--
--  Copyright (C) 2014-2022, AdaCore
--  SPDX-License-Identifier: Apache-2.0
--

with Ada.Containers.Vectors;
with Ada.Exceptions;
with Ada.Unchecked_Deallocation;

with Langkit_Support.Diagnostics; use Langkit_Support.Diagnostics;
with Langkit_Support.Packrat;
with Langkit_Support.Slocs;       use Langkit_Support.Slocs;

pragma Warnings (Off, "referenced");
with Langkit_Support.Symbols; use Langkit_Support.Symbols;
pragma Warnings (On, "referenced");

with Langkit_Support.Text;        use Langkit_Support.Text;

with Libadalang.Common;         use Libadalang.Common;
with Libadalang.Implementation; use Libadalang.Implementation;
use Libadalang.Implementation.Precomputed_Symbols;

pragma Warnings (Off, "referenced");
with Libadalang.Private_Converters; use Libadalang.Private_Converters;
pragma Warnings (On, "referenced");



package body Libadalang.Parsers is
   pragma Warnings (Off, "use clause");
   use all type Langkit_Support.Symbols.Symbol_Type;
   pragma Warnings (On, "use clause");

   --  Prepare packrat instantiations: one per enum type and onefor each kind
   --  of node (including lists). Likewise for bump ptr. allocators, except
   --  we need them only for non-abstract AST nodes.
   --
   --  In the Alloc instanciations, there are unchecked conversions to wrap
   --  System.Address values from a low-level allocator. All read/writes for
   --  the pointed values are made through values of the same access types
   --  (i.e. AST node access). Thus, strict aliasing issues should not arise
   --  for these.
   --
   --  See <https://gcc.gnu.org/onlinedocs/gnat_ugn/
   --       Optimization-and-Strict-Aliasing.html>.

   pragma Warnings (Off, "is not referenced");
   pragma Warnings (Off, "possible aliasing problem for type");
      package Bare_Ada_Node_Memos is new Langkit_Support.Packrat
        (Bare_Ada_Node, Token_Index);

      package Bare_Abort_Node_Memos is new Langkit_Support.Packrat
        (Bare_Abort_Node, Token_Index);

      package Bare_Abort_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Abort_Absent, Token_Index);

         
         subtype Subtype_For_Abort_Absent is
            Root_Node_Record (Ada_Abort_Absent);
         type Access_To_Subtype_For_Abort_Absent is access all Subtype_For_Abort_Absent;
         package Bare_Abort_Absent_Alloc is new Alloc
           (Subtype_For_Abort_Absent, Access_To_Subtype_For_Abort_Absent);

         function Allocate_Abort_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Abort_Absent;

         function Allocate_Abort_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Abort_Absent
         is
            Result      : constant Access_To_Subtype_For_Abort_Absent := Bare_Abort_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abort_Absent;
            return Bare_Abort_Absent (Result);
         end Allocate_Abort_Absent;

      package Bare_Abort_Present_Memos is new Langkit_Support.Packrat
        (Bare_Abort_Present, Token_Index);

         
         subtype Subtype_For_Abort_Present is
            Root_Node_Record (Ada_Abort_Present);
         type Access_To_Subtype_For_Abort_Present is access all Subtype_For_Abort_Present;
         package Bare_Abort_Present_Alloc is new Alloc
           (Subtype_For_Abort_Present, Access_To_Subtype_For_Abort_Present);

         function Allocate_Abort_Present
           (Pool : Bump_Ptr_Pool) return Bare_Abort_Present;

         function Allocate_Abort_Present
           (Pool : Bump_Ptr_Pool) return Bare_Abort_Present
         is
            Result      : constant Access_To_Subtype_For_Abort_Present := Bare_Abort_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abort_Present;
            return Bare_Abort_Present (Result);
         end Allocate_Abort_Present;

      package Bare_Abstract_Node_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_Node, Token_Index);

      package Bare_Abstract_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_Absent, Token_Index);

         
         subtype Subtype_For_Abstract_Absent is
            Root_Node_Record (Ada_Abstract_Absent);
         type Access_To_Subtype_For_Abstract_Absent is access all Subtype_For_Abstract_Absent;
         package Bare_Abstract_Absent_Alloc is new Alloc
           (Subtype_For_Abstract_Absent, Access_To_Subtype_For_Abstract_Absent);

         function Allocate_Abstract_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Absent;

         function Allocate_Abstract_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Absent
         is
            Result      : constant Access_To_Subtype_For_Abstract_Absent := Bare_Abstract_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_Absent;
            return Bare_Abstract_Absent (Result);
         end Allocate_Abstract_Absent;

      package Bare_Abstract_Present_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_Present, Token_Index);

         
         subtype Subtype_For_Abstract_Present is
            Root_Node_Record (Ada_Abstract_Present);
         type Access_To_Subtype_For_Abstract_Present is access all Subtype_For_Abstract_Present;
         package Bare_Abstract_Present_Alloc is new Alloc
           (Subtype_For_Abstract_Present, Access_To_Subtype_For_Abstract_Present);

         function Allocate_Abstract_Present
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Present;

         function Allocate_Abstract_Present
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Present
         is
            Result      : constant Access_To_Subtype_For_Abstract_Present := Bare_Abstract_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_Present;
            return Bare_Abstract_Present (Result);
         end Allocate_Abstract_Present;

      package Bare_Ada_List_Memos is new Langkit_Support.Packrat
        (Bare_Ada_List, Token_Index);

      package Bare_Ada_Node_List_Memos is new Langkit_Support.Packrat
        (Bare_Ada_Node_List, Token_Index);

         
         subtype Subtype_For_Ada_Node_List is
            Root_Node_Record (Ada_Ada_Node_List);
         type Access_To_Subtype_For_Ada_Node_List is access all Subtype_For_Ada_Node_List;
         package Bare_Ada_Node_List_Alloc is new Alloc
           (Subtype_For_Ada_Node_List, Access_To_Subtype_For_Ada_Node_List);

         function Allocate_Ada_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Ada_Node_List;

         function Allocate_Ada_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Ada_Node_List
         is
            Result      : constant Access_To_Subtype_For_Ada_Node_List := Bare_Ada_Node_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Ada_Node_List;
            return Bare_Ada_Node_List (Result);
         end Allocate_Ada_Node_List;

      package Bare_Abstract_State_Decl_List_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_State_Decl_List, Token_Index);

         
         subtype Subtype_For_Abstract_State_Decl_List is
            Root_Node_Record (Ada_Abstract_State_Decl_List);
         type Access_To_Subtype_For_Abstract_State_Decl_List is access all Subtype_For_Abstract_State_Decl_List;
         package Bare_Abstract_State_Decl_List_Alloc is new Alloc
           (Subtype_For_Abstract_State_Decl_List, Access_To_Subtype_For_Abstract_State_Decl_List);

         function Allocate_Abstract_State_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_State_Decl_List;

         function Allocate_Abstract_State_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_State_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Abstract_State_Decl_List := Bare_Abstract_State_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_State_Decl_List;
            return Bare_Abstract_State_Decl_List (Result);
         end Allocate_Abstract_State_Decl_List;

      package Bare_Alternatives_List_Memos is new Langkit_Support.Packrat
        (Bare_Alternatives_List, Token_Index);

         
         subtype Subtype_For_Alternatives_List is
            Root_Node_Record (Ada_Alternatives_List);
         type Access_To_Subtype_For_Alternatives_List is access all Subtype_For_Alternatives_List;
         package Bare_Alternatives_List_Alloc is new Alloc
           (Subtype_For_Alternatives_List, Access_To_Subtype_For_Alternatives_List);

         function Allocate_Alternatives_List
           (Pool : Bump_Ptr_Pool) return Bare_Alternatives_List;

         function Allocate_Alternatives_List
           (Pool : Bump_Ptr_Pool) return Bare_Alternatives_List
         is
            Result      : constant Access_To_Subtype_For_Alternatives_List := Bare_Alternatives_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Alternatives_List;
            return Bare_Alternatives_List (Result);
         end Allocate_Alternatives_List;

      package Bare_Constraint_List_Memos is new Langkit_Support.Packrat
        (Bare_Constraint_List, Token_Index);

         
         subtype Subtype_For_Constraint_List is
            Root_Node_Record (Ada_Constraint_List);
         type Access_To_Subtype_For_Constraint_List is access all Subtype_For_Constraint_List;
         package Bare_Constraint_List_Alloc is new Alloc
           (Subtype_For_Constraint_List, Access_To_Subtype_For_Constraint_List);

         function Allocate_Constraint_List
           (Pool : Bump_Ptr_Pool) return Bare_Constraint_List;

         function Allocate_Constraint_List
           (Pool : Bump_Ptr_Pool) return Bare_Constraint_List
         is
            Result      : constant Access_To_Subtype_For_Constraint_List := Bare_Constraint_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Constraint_List;
            return Bare_Constraint_List (Result);
         end Allocate_Constraint_List;

      package Bare_Decl_List_Memos is new Langkit_Support.Packrat
        (Bare_Decl_List, Token_Index);

         
         subtype Subtype_For_Decl_List is
            Root_Node_Record (Ada_Decl_List);
         type Access_To_Subtype_For_Decl_List is access all Subtype_For_Decl_List;
         package Bare_Decl_List_Alloc is new Alloc
           (Subtype_For_Decl_List, Access_To_Subtype_For_Decl_List);

         function Allocate_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Decl_List;

         function Allocate_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Decl_List := Bare_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Decl_List;
            return Bare_Decl_List (Result);
         end Allocate_Decl_List;

      package Bare_Stmt_List_Memos is new Langkit_Support.Packrat
        (Bare_Stmt_List, Token_Index);

         
         subtype Subtype_For_Stmt_List is
            Root_Node_Record (Ada_Stmt_List);
         type Access_To_Subtype_For_Stmt_List is access all Subtype_For_Stmt_List;
         package Bare_Stmt_List_Alloc is new Alloc
           (Subtype_For_Stmt_List, Access_To_Subtype_For_Stmt_List);

         function Allocate_Stmt_List
           (Pool : Bump_Ptr_Pool) return Bare_Stmt_List;

         function Allocate_Stmt_List
           (Pool : Bump_Ptr_Pool) return Bare_Stmt_List
         is
            Result      : constant Access_To_Subtype_For_Stmt_List := Bare_Stmt_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Stmt_List;
            return Bare_Stmt_List (Result);
         end Allocate_Stmt_List;

      package Bare_Aspect_Assoc_List_Memos is new Langkit_Support.Packrat
        (Bare_Aspect_Assoc_List, Token_Index);

         
         subtype Subtype_For_Aspect_Assoc_List is
            Root_Node_Record (Ada_Aspect_Assoc_List);
         type Access_To_Subtype_For_Aspect_Assoc_List is access all Subtype_For_Aspect_Assoc_List;
         package Bare_Aspect_Assoc_List_Alloc is new Alloc
           (Subtype_For_Aspect_Assoc_List, Access_To_Subtype_For_Aspect_Assoc_List);

         function Allocate_Aspect_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc_List;

         function Allocate_Aspect_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc_List
         is
            Result      : constant Access_To_Subtype_For_Aspect_Assoc_List := Bare_Aspect_Assoc_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aspect_Assoc_List;
            return Bare_Aspect_Assoc_List (Result);
         end Allocate_Aspect_Assoc_List;

      package Bare_Base_Assoc_List_Memos is new Langkit_Support.Packrat
        (Bare_Base_Assoc_List, Token_Index);

         
         subtype Subtype_For_Base_Assoc_List is
            Root_Node_Record (Ada_Base_Assoc_List);
         type Access_To_Subtype_For_Base_Assoc_List is access all Subtype_For_Base_Assoc_List;
         package Bare_Base_Assoc_List_Alloc is new Alloc
           (Subtype_For_Base_Assoc_List, Access_To_Subtype_For_Base_Assoc_List);

         function Allocate_Base_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Assoc_List;

         function Allocate_Base_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Assoc_List
         is
            Result      : constant Access_To_Subtype_For_Base_Assoc_List := Bare_Base_Assoc_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Base_Assoc_List;
            return Bare_Base_Assoc_List (Result);
         end Allocate_Base_Assoc_List;

      package Bare_Basic_Assoc_List_Memos is new Langkit_Support.Packrat
        (Bare_Basic_Assoc_List, Token_Index);

      package Bare_Assoc_List_Memos is new Langkit_Support.Packrat
        (Bare_Assoc_List, Token_Index);

         
         subtype Subtype_For_Assoc_List is
            Root_Node_Record (Ada_Assoc_List);
         type Access_To_Subtype_For_Assoc_List is access all Subtype_For_Assoc_List;
         package Bare_Assoc_List_Alloc is new Alloc
           (Subtype_For_Assoc_List, Access_To_Subtype_For_Assoc_List);

         function Allocate_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Assoc_List;

         function Allocate_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Assoc_List
         is
            Result      : constant Access_To_Subtype_For_Assoc_List := Bare_Assoc_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Assoc_List;
            return Bare_Assoc_List (Result);
         end Allocate_Assoc_List;

      package Bare_Basic_Decl_List_Memos is new Langkit_Support.Packrat
        (Bare_Basic_Decl_List, Token_Index);

         
         subtype Subtype_For_Basic_Decl_List is
            Root_Node_Record (Ada_Basic_Decl_List);
         type Access_To_Subtype_For_Basic_Decl_List is access all Subtype_For_Basic_Decl_List;
         package Bare_Basic_Decl_List_Alloc is new Alloc
           (Subtype_For_Basic_Decl_List, Access_To_Subtype_For_Basic_Decl_List);

         function Allocate_Basic_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Basic_Decl_List;

         function Allocate_Basic_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Basic_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Basic_Decl_List := Bare_Basic_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Basic_Decl_List;
            return Bare_Basic_Decl_List (Result);
         end Allocate_Basic_Decl_List;

      package Bare_Case_Expr_Alternative_List_Memos is new Langkit_Support.Packrat
        (Bare_Case_Expr_Alternative_List, Token_Index);

         
         subtype Subtype_For_Case_Expr_Alternative_List is
            Root_Node_Record (Ada_Case_Expr_Alternative_List);
         type Access_To_Subtype_For_Case_Expr_Alternative_List is access all Subtype_For_Case_Expr_Alternative_List;
         package Bare_Case_Expr_Alternative_List_Alloc is new Alloc
           (Subtype_For_Case_Expr_Alternative_List, Access_To_Subtype_For_Case_Expr_Alternative_List);

         function Allocate_Case_Expr_Alternative_List
           (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative_List;

         function Allocate_Case_Expr_Alternative_List
           (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative_List
         is
            Result      : constant Access_To_Subtype_For_Case_Expr_Alternative_List := Bare_Case_Expr_Alternative_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Case_Expr_Alternative_List;
            return Bare_Case_Expr_Alternative_List (Result);
         end Allocate_Case_Expr_Alternative_List;

      package Bare_Case_Stmt_Alternative_List_Memos is new Langkit_Support.Packrat
        (Bare_Case_Stmt_Alternative_List, Token_Index);

         
         subtype Subtype_For_Case_Stmt_Alternative_List is
            Root_Node_Record (Ada_Case_Stmt_Alternative_List);
         type Access_To_Subtype_For_Case_Stmt_Alternative_List is access all Subtype_For_Case_Stmt_Alternative_List;
         package Bare_Case_Stmt_Alternative_List_Alloc is new Alloc
           (Subtype_For_Case_Stmt_Alternative_List, Access_To_Subtype_For_Case_Stmt_Alternative_List);

         function Allocate_Case_Stmt_Alternative_List
           (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative_List;

         function Allocate_Case_Stmt_Alternative_List
           (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative_List
         is
            Result      : constant Access_To_Subtype_For_Case_Stmt_Alternative_List := Bare_Case_Stmt_Alternative_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Case_Stmt_Alternative_List;
            return Bare_Case_Stmt_Alternative_List (Result);
         end Allocate_Case_Stmt_Alternative_List;

      package Bare_Compilation_Unit_List_Memos is new Langkit_Support.Packrat
        (Bare_Compilation_Unit_List, Token_Index);

         
         subtype Subtype_For_Compilation_Unit_List is
            Root_Node_Record (Ada_Compilation_Unit_List);
         type Access_To_Subtype_For_Compilation_Unit_List is access all Subtype_For_Compilation_Unit_List;
         package Bare_Compilation_Unit_List_Alloc is new Alloc
           (Subtype_For_Compilation_Unit_List, Access_To_Subtype_For_Compilation_Unit_List);

         function Allocate_Compilation_Unit_List
           (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit_List;

         function Allocate_Compilation_Unit_List
           (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit_List
         is
            Result      : constant Access_To_Subtype_For_Compilation_Unit_List := Bare_Compilation_Unit_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Compilation_Unit_List;
            return Bare_Compilation_Unit_List (Result);
         end Allocate_Compilation_Unit_List;

      package Bare_Concat_Operand_List_Memos is new Langkit_Support.Packrat
        (Bare_Concat_Operand_List, Token_Index);

         
         subtype Subtype_For_Concat_Operand_List is
            Root_Node_Record (Ada_Concat_Operand_List);
         type Access_To_Subtype_For_Concat_Operand_List is access all Subtype_For_Concat_Operand_List;
         package Bare_Concat_Operand_List_Alloc is new Alloc
           (Subtype_For_Concat_Operand_List, Access_To_Subtype_For_Concat_Operand_List);

         function Allocate_Concat_Operand_List
           (Pool : Bump_Ptr_Pool) return Bare_Concat_Operand_List;

         function Allocate_Concat_Operand_List
           (Pool : Bump_Ptr_Pool) return Bare_Concat_Operand_List
         is
            Result      : constant Access_To_Subtype_For_Concat_Operand_List := Bare_Concat_Operand_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Concat_Operand_List;
            return Bare_Concat_Operand_List (Result);
         end Allocate_Concat_Operand_List;

      package Bare_Contract_Case_Assoc_List_Memos is new Langkit_Support.Packrat
        (Bare_Contract_Case_Assoc_List, Token_Index);

         
         subtype Subtype_For_Contract_Case_Assoc_List is
            Root_Node_Record (Ada_Contract_Case_Assoc_List);
         type Access_To_Subtype_For_Contract_Case_Assoc_List is access all Subtype_For_Contract_Case_Assoc_List;
         package Bare_Contract_Case_Assoc_List_Alloc is new Alloc
           (Subtype_For_Contract_Case_Assoc_List, Access_To_Subtype_For_Contract_Case_Assoc_List);

         function Allocate_Contract_Case_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc_List;

         function Allocate_Contract_Case_Assoc_List
           (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc_List
         is
            Result      : constant Access_To_Subtype_For_Contract_Case_Assoc_List := Bare_Contract_Case_Assoc_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Contract_Case_Assoc_List;
            return Bare_Contract_Case_Assoc_List (Result);
         end Allocate_Contract_Case_Assoc_List;

      package Bare_Defining_Name_List_Memos is new Langkit_Support.Packrat
        (Bare_Defining_Name_List, Token_Index);

         
         subtype Subtype_For_Defining_Name_List is
            Root_Node_Record (Ada_Defining_Name_List);
         type Access_To_Subtype_For_Defining_Name_List is access all Subtype_For_Defining_Name_List;
         package Bare_Defining_Name_List_Alloc is new Alloc
           (Subtype_For_Defining_Name_List, Access_To_Subtype_For_Defining_Name_List);

         function Allocate_Defining_Name_List
           (Pool : Bump_Ptr_Pool) return Bare_Defining_Name_List;

         function Allocate_Defining_Name_List
           (Pool : Bump_Ptr_Pool) return Bare_Defining_Name_List
         is
            Result      : constant Access_To_Subtype_For_Defining_Name_List := Bare_Defining_Name_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Defining_Name_List;
            return Bare_Defining_Name_List (Result);
         end Allocate_Defining_Name_List;

      package Bare_Discriminant_Spec_List_Memos is new Langkit_Support.Packrat
        (Bare_Discriminant_Spec_List, Token_Index);

         
         subtype Subtype_For_Discriminant_Spec_List is
            Root_Node_Record (Ada_Discriminant_Spec_List);
         type Access_To_Subtype_For_Discriminant_Spec_List is access all Subtype_For_Discriminant_Spec_List;
         package Bare_Discriminant_Spec_List_Alloc is new Alloc
           (Subtype_For_Discriminant_Spec_List, Access_To_Subtype_For_Discriminant_Spec_List);

         function Allocate_Discriminant_Spec_List
           (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec_List;

         function Allocate_Discriminant_Spec_List
           (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec_List
         is
            Result      : constant Access_To_Subtype_For_Discriminant_Spec_List := Bare_Discriminant_Spec_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Discriminant_Spec_List;
            return Bare_Discriminant_Spec_List (Result);
         end Allocate_Discriminant_Spec_List;

      package Bare_Elsif_Expr_Part_List_Memos is new Langkit_Support.Packrat
        (Bare_Elsif_Expr_Part_List, Token_Index);

         
         subtype Subtype_For_Elsif_Expr_Part_List is
            Root_Node_Record (Ada_Elsif_Expr_Part_List);
         type Access_To_Subtype_For_Elsif_Expr_Part_List is access all Subtype_For_Elsif_Expr_Part_List;
         package Bare_Elsif_Expr_Part_List_Alloc is new Alloc
           (Subtype_For_Elsif_Expr_Part_List, Access_To_Subtype_For_Elsif_Expr_Part_List);

         function Allocate_Elsif_Expr_Part_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part_List;

         function Allocate_Elsif_Expr_Part_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part_List
         is
            Result      : constant Access_To_Subtype_For_Elsif_Expr_Part_List := Bare_Elsif_Expr_Part_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Elsif_Expr_Part_List;
            return Bare_Elsif_Expr_Part_List (Result);
         end Allocate_Elsif_Expr_Part_List;

      package Bare_Elsif_Stmt_Part_List_Memos is new Langkit_Support.Packrat
        (Bare_Elsif_Stmt_Part_List, Token_Index);

         
         subtype Subtype_For_Elsif_Stmt_Part_List is
            Root_Node_Record (Ada_Elsif_Stmt_Part_List);
         type Access_To_Subtype_For_Elsif_Stmt_Part_List is access all Subtype_For_Elsif_Stmt_Part_List;
         package Bare_Elsif_Stmt_Part_List_Alloc is new Alloc
           (Subtype_For_Elsif_Stmt_Part_List, Access_To_Subtype_For_Elsif_Stmt_Part_List);

         function Allocate_Elsif_Stmt_Part_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part_List;

         function Allocate_Elsif_Stmt_Part_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part_List
         is
            Result      : constant Access_To_Subtype_For_Elsif_Stmt_Part_List := Bare_Elsif_Stmt_Part_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Elsif_Stmt_Part_List;
            return Bare_Elsif_Stmt_Part_List (Result);
         end Allocate_Elsif_Stmt_Part_List;

      package Bare_Enum_Literal_Decl_List_Memos is new Langkit_Support.Packrat
        (Bare_Enum_Literal_Decl_List, Token_Index);

         
         subtype Subtype_For_Enum_Literal_Decl_List is
            Root_Node_Record (Ada_Enum_Literal_Decl_List);
         type Access_To_Subtype_For_Enum_Literal_Decl_List is access all Subtype_For_Enum_Literal_Decl_List;
         package Bare_Enum_Literal_Decl_List_Alloc is new Alloc
           (Subtype_For_Enum_Literal_Decl_List, Access_To_Subtype_For_Enum_Literal_Decl_List);

         function Allocate_Enum_Literal_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl_List;

         function Allocate_Enum_Literal_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Literal_Decl_List := Bare_Enum_Literal_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Enum_Literal_Decl_List;
            return Bare_Enum_Literal_Decl_List (Result);
         end Allocate_Enum_Literal_Decl_List;

      package Bare_Expr_List_Memos is new Langkit_Support.Packrat
        (Bare_Expr_List, Token_Index);

      package Bare_Expr_Alternatives_List_Memos is new Langkit_Support.Packrat
        (Bare_Expr_Alternatives_List, Token_Index);

         
         subtype Subtype_For_Expr_Alternatives_List is
            Root_Node_Record (Ada_Expr_Alternatives_List);
         type Access_To_Subtype_For_Expr_Alternatives_List is access all Subtype_For_Expr_Alternatives_List;
         package Bare_Expr_Alternatives_List_Alloc is new Alloc
           (Subtype_For_Expr_Alternatives_List, Access_To_Subtype_For_Expr_Alternatives_List);

         function Allocate_Expr_Alternatives_List
           (Pool : Bump_Ptr_Pool) return Bare_Expr_Alternatives_List;

         function Allocate_Expr_Alternatives_List
           (Pool : Bump_Ptr_Pool) return Bare_Expr_Alternatives_List
         is
            Result      : constant Access_To_Subtype_For_Expr_Alternatives_List := Bare_Expr_Alternatives_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Expr_Alternatives_List;
            return Bare_Expr_Alternatives_List (Result);
         end Allocate_Expr_Alternatives_List;

      package Bare_Identifier_List_Memos is new Langkit_Support.Packrat
        (Bare_Identifier_List, Token_Index);

      package Bare_Discriminant_Choice_List_Memos is new Langkit_Support.Packrat
        (Bare_Discriminant_Choice_List, Token_Index);

         
         subtype Subtype_For_Discriminant_Choice_List is
            Root_Node_Record (Ada_Discriminant_Choice_List);
         type Access_To_Subtype_For_Discriminant_Choice_List is access all Subtype_For_Discriminant_Choice_List;
         package Bare_Discriminant_Choice_List_Alloc is new Alloc
           (Subtype_For_Discriminant_Choice_List, Access_To_Subtype_For_Discriminant_Choice_List);

         function Allocate_Discriminant_Choice_List
           (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Choice_List;

         function Allocate_Discriminant_Choice_List
           (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Choice_List
         is
            Result      : constant Access_To_Subtype_For_Discriminant_Choice_List := Bare_Discriminant_Choice_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Discriminant_Choice_List;
            return Bare_Discriminant_Choice_List (Result);
         end Allocate_Discriminant_Choice_List;

      package Bare_Name_List_Memos is new Langkit_Support.Packrat
        (Bare_Name_List, Token_Index);

         
         subtype Subtype_For_Name_List is
            Root_Node_Record (Ada_Name_List);
         type Access_To_Subtype_For_Name_List is access all Subtype_For_Name_List;
         package Bare_Name_List_Alloc is new Alloc
           (Subtype_For_Name_List, Access_To_Subtype_For_Name_List);

         function Allocate_Name_List
           (Pool : Bump_Ptr_Pool) return Bare_Name_List;

         function Allocate_Name_List
           (Pool : Bump_Ptr_Pool) return Bare_Name_List
         is
            Result      : constant Access_To_Subtype_For_Name_List := Bare_Name_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Name_List;
            return Bare_Name_List (Result);
         end Allocate_Name_List;

      package Bare_Parent_List_Memos is new Langkit_Support.Packrat
        (Bare_Parent_List, Token_Index);

         
         subtype Subtype_For_Parent_List is
            Root_Node_Record (Ada_Parent_List);
         type Access_To_Subtype_For_Parent_List is access all Subtype_For_Parent_List;
         package Bare_Parent_List_Alloc is new Alloc
           (Subtype_For_Parent_List, Access_To_Subtype_For_Parent_List);

         function Allocate_Parent_List
           (Pool : Bump_Ptr_Pool) return Bare_Parent_List;

         function Allocate_Parent_List
           (Pool : Bump_Ptr_Pool) return Bare_Parent_List
         is
            Result      : constant Access_To_Subtype_For_Parent_List := Bare_Parent_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Parent_List;
            return Bare_Parent_List (Result);
         end Allocate_Parent_List;

      package Bare_Param_Spec_List_Memos is new Langkit_Support.Packrat
        (Bare_Param_Spec_List, Token_Index);

         
         subtype Subtype_For_Param_Spec_List is
            Root_Node_Record (Ada_Param_Spec_List);
         type Access_To_Subtype_For_Param_Spec_List is access all Subtype_For_Param_Spec_List;
         package Bare_Param_Spec_List_Alloc is new Alloc
           (Subtype_For_Param_Spec_List, Access_To_Subtype_For_Param_Spec_List);

         function Allocate_Param_Spec_List
           (Pool : Bump_Ptr_Pool) return Bare_Param_Spec_List;

         function Allocate_Param_Spec_List
           (Pool : Bump_Ptr_Pool) return Bare_Param_Spec_List
         is
            Result      : constant Access_To_Subtype_For_Param_Spec_List := Bare_Param_Spec_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Param_Spec_List;
            return Bare_Param_Spec_List (Result);
         end Allocate_Param_Spec_List;

      package Bare_Pragma_Node_List_Memos is new Langkit_Support.Packrat
        (Bare_Pragma_Node_List, Token_Index);

         
         subtype Subtype_For_Pragma_Node_List is
            Root_Node_Record (Ada_Pragma_Node_List);
         type Access_To_Subtype_For_Pragma_Node_List is access all Subtype_For_Pragma_Node_List;
         package Bare_Pragma_Node_List_Alloc is new Alloc
           (Subtype_For_Pragma_Node_List, Access_To_Subtype_For_Pragma_Node_List);

         function Allocate_Pragma_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node_List;

         function Allocate_Pragma_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node_List
         is
            Result      : constant Access_To_Subtype_For_Pragma_Node_List := Bare_Pragma_Node_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pragma_Node_List;
            return Bare_Pragma_Node_List (Result);
         end Allocate_Pragma_Node_List;

      package Bare_Select_When_Part_List_Memos is new Langkit_Support.Packrat
        (Bare_Select_When_Part_List, Token_Index);

         
         subtype Subtype_For_Select_When_Part_List is
            Root_Node_Record (Ada_Select_When_Part_List);
         type Access_To_Subtype_For_Select_When_Part_List is access all Subtype_For_Select_When_Part_List;
         package Bare_Select_When_Part_List_Alloc is new Alloc
           (Subtype_For_Select_When_Part_List, Access_To_Subtype_For_Select_When_Part_List);

         function Allocate_Select_When_Part_List
           (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part_List;

         function Allocate_Select_When_Part_List
           (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part_List
         is
            Result      : constant Access_To_Subtype_For_Select_When_Part_List := Bare_Select_When_Part_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Select_When_Part_List;
            return Bare_Select_When_Part_List (Result);
         end Allocate_Select_When_Part_List;

      package Bare_Unconstrained_Array_Index_List_Memos is new Langkit_Support.Packrat
        (Bare_Unconstrained_Array_Index_List, Token_Index);

         
         subtype Subtype_For_Unconstrained_Array_Index_List is
            Root_Node_Record (Ada_Unconstrained_Array_Index_List);
         type Access_To_Subtype_For_Unconstrained_Array_Index_List is access all Subtype_For_Unconstrained_Array_Index_List;
         package Bare_Unconstrained_Array_Index_List_Alloc is new Alloc
           (Subtype_For_Unconstrained_Array_Index_List, Access_To_Subtype_For_Unconstrained_Array_Index_List);

         function Allocate_Unconstrained_Array_Index_List
           (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index_List;

         function Allocate_Unconstrained_Array_Index_List
           (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index_List
         is
            Result      : constant Access_To_Subtype_For_Unconstrained_Array_Index_List := Bare_Unconstrained_Array_Index_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Unconstrained_Array_Index_List;
            return Bare_Unconstrained_Array_Index_List (Result);
         end Allocate_Unconstrained_Array_Index_List;

      package Bare_Variant_List_Memos is new Langkit_Support.Packrat
        (Bare_Variant_List, Token_Index);

         
         subtype Subtype_For_Variant_List is
            Root_Node_Record (Ada_Variant_List);
         type Access_To_Subtype_For_Variant_List is access all Subtype_For_Variant_List;
         package Bare_Variant_List_Alloc is new Alloc
           (Subtype_For_Variant_List, Access_To_Subtype_For_Variant_List);

         function Allocate_Variant_List
           (Pool : Bump_Ptr_Pool) return Bare_Variant_List;

         function Allocate_Variant_List
           (Pool : Bump_Ptr_Pool) return Bare_Variant_List
         is
            Result      : constant Access_To_Subtype_For_Variant_List := Bare_Variant_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Variant_List;
            return Bare_Variant_List (Result);
         end Allocate_Variant_List;

      package Bare_Aliased_Node_Memos is new Langkit_Support.Packrat
        (Bare_Aliased_Node, Token_Index);

      package Bare_Aliased_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Aliased_Absent, Token_Index);

         
         subtype Subtype_For_Aliased_Absent is
            Root_Node_Record (Ada_Aliased_Absent);
         type Access_To_Subtype_For_Aliased_Absent is access all Subtype_For_Aliased_Absent;
         package Bare_Aliased_Absent_Alloc is new Alloc
           (Subtype_For_Aliased_Absent, Access_To_Subtype_For_Aliased_Absent);

         function Allocate_Aliased_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Aliased_Absent;

         function Allocate_Aliased_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Aliased_Absent
         is
            Result      : constant Access_To_Subtype_For_Aliased_Absent := Bare_Aliased_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aliased_Absent;
            return Bare_Aliased_Absent (Result);
         end Allocate_Aliased_Absent;

      package Bare_Aliased_Present_Memos is new Langkit_Support.Packrat
        (Bare_Aliased_Present, Token_Index);

         
         subtype Subtype_For_Aliased_Present is
            Root_Node_Record (Ada_Aliased_Present);
         type Access_To_Subtype_For_Aliased_Present is access all Subtype_For_Aliased_Present;
         package Bare_Aliased_Present_Alloc is new Alloc
           (Subtype_For_Aliased_Present, Access_To_Subtype_For_Aliased_Present);

         function Allocate_Aliased_Present
           (Pool : Bump_Ptr_Pool) return Bare_Aliased_Present;

         function Allocate_Aliased_Present
           (Pool : Bump_Ptr_Pool) return Bare_Aliased_Present
         is
            Result      : constant Access_To_Subtype_For_Aliased_Present := Bare_Aliased_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aliased_Present;
            return Bare_Aliased_Present (Result);
         end Allocate_Aliased_Present;

      package Bare_All_Node_Memos is new Langkit_Support.Packrat
        (Bare_All_Node, Token_Index);

      package Bare_All_Absent_Memos is new Langkit_Support.Packrat
        (Bare_All_Absent, Token_Index);

         
         subtype Subtype_For_All_Absent is
            Root_Node_Record (Ada_All_Absent);
         type Access_To_Subtype_For_All_Absent is access all Subtype_For_All_Absent;
         package Bare_All_Absent_Alloc is new Alloc
           (Subtype_For_All_Absent, Access_To_Subtype_For_All_Absent);

         function Allocate_All_Absent
           (Pool : Bump_Ptr_Pool) return Bare_All_Absent;

         function Allocate_All_Absent
           (Pool : Bump_Ptr_Pool) return Bare_All_Absent
         is
            Result      : constant Access_To_Subtype_For_All_Absent := Bare_All_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_All_Absent;
            return Bare_All_Absent (Result);
         end Allocate_All_Absent;

      package Bare_All_Present_Memos is new Langkit_Support.Packrat
        (Bare_All_Present, Token_Index);

         
         subtype Subtype_For_All_Present is
            Root_Node_Record (Ada_All_Present);
         type Access_To_Subtype_For_All_Present is access all Subtype_For_All_Present;
         package Bare_All_Present_Alloc is new Alloc
           (Subtype_For_All_Present, Access_To_Subtype_For_All_Present);

         function Allocate_All_Present
           (Pool : Bump_Ptr_Pool) return Bare_All_Present;

         function Allocate_All_Present
           (Pool : Bump_Ptr_Pool) return Bare_All_Present
         is
            Result      : constant Access_To_Subtype_For_All_Present := Bare_All_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_All_Present;
            return Bare_All_Present (Result);
         end Allocate_All_Present;

      package Bare_Array_Indices_Memos is new Langkit_Support.Packrat
        (Bare_Array_Indices, Token_Index);

      package Bare_Constrained_Array_Indices_Memos is new Langkit_Support.Packrat
        (Bare_Constrained_Array_Indices, Token_Index);

         
         subtype Subtype_For_Constrained_Array_Indices is
            Root_Node_Record (Ada_Constrained_Array_Indices);
         type Access_To_Subtype_For_Constrained_Array_Indices is access all Subtype_For_Constrained_Array_Indices;
         package Bare_Constrained_Array_Indices_Alloc is new Alloc
           (Subtype_For_Constrained_Array_Indices, Access_To_Subtype_For_Constrained_Array_Indices);

         function Allocate_Constrained_Array_Indices
           (Pool : Bump_Ptr_Pool) return Bare_Constrained_Array_Indices;

         function Allocate_Constrained_Array_Indices
           (Pool : Bump_Ptr_Pool) return Bare_Constrained_Array_Indices
         is
            Result      : constant Access_To_Subtype_For_Constrained_Array_Indices := Bare_Constrained_Array_Indices_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Constrained_Array_Indices;
            return Bare_Constrained_Array_Indices (Result);
         end Allocate_Constrained_Array_Indices;

      package Bare_Unconstrained_Array_Indices_Memos is new Langkit_Support.Packrat
        (Bare_Unconstrained_Array_Indices, Token_Index);

         
         subtype Subtype_For_Unconstrained_Array_Indices is
            Root_Node_Record (Ada_Unconstrained_Array_Indices);
         type Access_To_Subtype_For_Unconstrained_Array_Indices is access all Subtype_For_Unconstrained_Array_Indices;
         package Bare_Unconstrained_Array_Indices_Alloc is new Alloc
           (Subtype_For_Unconstrained_Array_Indices, Access_To_Subtype_For_Unconstrained_Array_Indices);

         function Allocate_Unconstrained_Array_Indices
           (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Indices;

         function Allocate_Unconstrained_Array_Indices
           (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Indices
         is
            Result      : constant Access_To_Subtype_For_Unconstrained_Array_Indices := Bare_Unconstrained_Array_Indices_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Unconstrained_Array_Indices;
            return Bare_Unconstrained_Array_Indices (Result);
         end Allocate_Unconstrained_Array_Indices;

      package Bare_Aspect_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Aspect_Assoc, Token_Index);

         
         subtype Subtype_For_Aspect_Assoc is
            Root_Node_Record (Ada_Aspect_Assoc);
         type Access_To_Subtype_For_Aspect_Assoc is access all Subtype_For_Aspect_Assoc;
         package Bare_Aspect_Assoc_Alloc is new Alloc
           (Subtype_For_Aspect_Assoc, Access_To_Subtype_For_Aspect_Assoc);

         function Allocate_Aspect_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc;

         function Allocate_Aspect_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc
         is
            Result      : constant Access_To_Subtype_For_Aspect_Assoc := Bare_Aspect_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aspect_Assoc;
            return Bare_Aspect_Assoc (Result);
         end Allocate_Aspect_Assoc;

      package Bare_Aspect_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Aspect_Clause, Token_Index);

      package Bare_At_Clause_Memos is new Langkit_Support.Packrat
        (Bare_At_Clause, Token_Index);

         
         subtype Subtype_For_At_Clause is
            Root_Node_Record (Ada_At_Clause);
         type Access_To_Subtype_For_At_Clause is access all Subtype_For_At_Clause;
         package Bare_At_Clause_Alloc is new Alloc
           (Subtype_For_At_Clause, Access_To_Subtype_For_At_Clause);

         function Allocate_At_Clause
           (Pool : Bump_Ptr_Pool) return Bare_At_Clause;

         function Allocate_At_Clause
           (Pool : Bump_Ptr_Pool) return Bare_At_Clause
         is
            Result      : constant Access_To_Subtype_For_At_Clause := Bare_At_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_At_Clause;
            return Bare_At_Clause (Result);
         end Allocate_At_Clause;

      package Bare_Attribute_Def_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Attribute_Def_Clause, Token_Index);

         
         subtype Subtype_For_Attribute_Def_Clause is
            Root_Node_Record (Ada_Attribute_Def_Clause);
         type Access_To_Subtype_For_Attribute_Def_Clause is access all Subtype_For_Attribute_Def_Clause;
         package Bare_Attribute_Def_Clause_Alloc is new Alloc
           (Subtype_For_Attribute_Def_Clause, Access_To_Subtype_For_Attribute_Def_Clause);

         function Allocate_Attribute_Def_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Attribute_Def_Clause;

         function Allocate_Attribute_Def_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Attribute_Def_Clause
         is
            Result      : constant Access_To_Subtype_For_Attribute_Def_Clause := Bare_Attribute_Def_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Attribute_Def_Clause;
            return Bare_Attribute_Def_Clause (Result);
         end Allocate_Attribute_Def_Clause;

      package Bare_Enum_Rep_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Enum_Rep_Clause, Token_Index);

         
         subtype Subtype_For_Enum_Rep_Clause is
            Root_Node_Record (Ada_Enum_Rep_Clause);
         type Access_To_Subtype_For_Enum_Rep_Clause is access all Subtype_For_Enum_Rep_Clause;
         package Bare_Enum_Rep_Clause_Alloc is new Alloc
           (Subtype_For_Enum_Rep_Clause, Access_To_Subtype_For_Enum_Rep_Clause);

         function Allocate_Enum_Rep_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Rep_Clause;

         function Allocate_Enum_Rep_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Rep_Clause
         is
            Result      : constant Access_To_Subtype_For_Enum_Rep_Clause := Bare_Enum_Rep_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Enum_Rep_Clause;
            return Bare_Enum_Rep_Clause (Result);
         end Allocate_Enum_Rep_Clause;

      package Bare_Record_Rep_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Record_Rep_Clause, Token_Index);

         
         subtype Subtype_For_Record_Rep_Clause is
            Root_Node_Record (Ada_Record_Rep_Clause);
         type Access_To_Subtype_For_Record_Rep_Clause is access all Subtype_For_Record_Rep_Clause;
         package Bare_Record_Rep_Clause_Alloc is new Alloc
           (Subtype_For_Record_Rep_Clause, Access_To_Subtype_For_Record_Rep_Clause);

         function Allocate_Record_Rep_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Record_Rep_Clause;

         function Allocate_Record_Rep_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Record_Rep_Clause
         is
            Result      : constant Access_To_Subtype_For_Record_Rep_Clause := Bare_Record_Rep_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Record_Rep_Clause;
            return Bare_Record_Rep_Clause (Result);
         end Allocate_Record_Rep_Clause;

      package Bare_Aspect_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Aspect_Spec, Token_Index);

         
         subtype Subtype_For_Aspect_Spec is
            Root_Node_Record (Ada_Aspect_Spec);
         type Access_To_Subtype_For_Aspect_Spec is access all Subtype_For_Aspect_Spec;
         package Bare_Aspect_Spec_Alloc is new Alloc
           (Subtype_For_Aspect_Spec, Access_To_Subtype_For_Aspect_Spec);

         function Allocate_Aspect_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Aspect_Spec;

         function Allocate_Aspect_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Aspect_Spec
         is
            Result      : constant Access_To_Subtype_For_Aspect_Spec := Bare_Aspect_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aspect_Spec;
            return Bare_Aspect_Spec (Result);
         end Allocate_Aspect_Spec;

      package Bare_Base_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Base_Assoc, Token_Index);

      package Bare_Contract_Case_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Contract_Case_Assoc, Token_Index);

         
         subtype Subtype_For_Contract_Case_Assoc is
            Root_Node_Record (Ada_Contract_Case_Assoc);
         type Access_To_Subtype_For_Contract_Case_Assoc is access all Subtype_For_Contract_Case_Assoc;
         package Bare_Contract_Case_Assoc_Alloc is new Alloc
           (Subtype_For_Contract_Case_Assoc, Access_To_Subtype_For_Contract_Case_Assoc);

         function Allocate_Contract_Case_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc;

         function Allocate_Contract_Case_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc
         is
            Result      : constant Access_To_Subtype_For_Contract_Case_Assoc := Bare_Contract_Case_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Contract_Case_Assoc;
            return Bare_Contract_Case_Assoc (Result);
         end Allocate_Contract_Case_Assoc;

      package Bare_Pragma_Argument_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Pragma_Argument_Assoc, Token_Index);

         
         subtype Subtype_For_Pragma_Argument_Assoc is
            Root_Node_Record (Ada_Pragma_Argument_Assoc);
         type Access_To_Subtype_For_Pragma_Argument_Assoc is access all Subtype_For_Pragma_Argument_Assoc;
         package Bare_Pragma_Argument_Assoc_Alloc is new Alloc
           (Subtype_For_Pragma_Argument_Assoc, Access_To_Subtype_For_Pragma_Argument_Assoc);

         function Allocate_Pragma_Argument_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Pragma_Argument_Assoc;

         function Allocate_Pragma_Argument_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Pragma_Argument_Assoc
         is
            Result      : constant Access_To_Subtype_For_Pragma_Argument_Assoc := Bare_Pragma_Argument_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pragma_Argument_Assoc;
            return Bare_Pragma_Argument_Assoc (Result);
         end Allocate_Pragma_Argument_Assoc;

      package Bare_Base_Formal_Param_Holder_Memos is new Langkit_Support.Packrat
        (Bare_Base_Formal_Param_Holder, Token_Index);

      package Bare_Base_Subp_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Base_Subp_Spec, Token_Index);

      package Bare_Entry_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Entry_Spec, Token_Index);

         
         subtype Subtype_For_Entry_Spec is
            Root_Node_Record (Ada_Entry_Spec);
         type Access_To_Subtype_For_Entry_Spec is access all Subtype_For_Entry_Spec;
         package Bare_Entry_Spec_Alloc is new Alloc
           (Subtype_For_Entry_Spec, Access_To_Subtype_For_Entry_Spec);

         function Allocate_Entry_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Spec;

         function Allocate_Entry_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Spec
         is
            Result      : constant Access_To_Subtype_For_Entry_Spec := Bare_Entry_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Entry_Spec;
            return Bare_Entry_Spec (Result);
         end Allocate_Entry_Spec;

      package Bare_Enum_Subp_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Enum_Subp_Spec, Token_Index);

         
         subtype Subtype_For_Enum_Subp_Spec is
            Root_Node_Record (Ada_Enum_Subp_Spec);
         type Access_To_Subtype_For_Enum_Subp_Spec is access all Subtype_For_Enum_Subp_Spec;
         package Bare_Enum_Subp_Spec_Alloc is new Alloc
           (Subtype_For_Enum_Subp_Spec, Access_To_Subtype_For_Enum_Subp_Spec);

         function Allocate_Enum_Subp_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Subp_Spec;

         function Allocate_Enum_Subp_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Subp_Spec
         is
            Result      : constant Access_To_Subtype_For_Enum_Subp_Spec := Bare_Enum_Subp_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Enum_Subp_Spec;
            return Bare_Enum_Subp_Spec (Result);
         end Allocate_Enum_Subp_Spec;

      package Bare_Subp_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Spec, Token_Index);

         
         subtype Subtype_For_Subp_Spec is
            Root_Node_Record (Ada_Subp_Spec);
         type Access_To_Subtype_For_Subp_Spec is access all Subtype_For_Subp_Spec;
         package Bare_Subp_Spec_Alloc is new Alloc
           (Subtype_For_Subp_Spec, Access_To_Subtype_For_Subp_Spec);

         function Allocate_Subp_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Spec;

         function Allocate_Subp_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Spec
         is
            Result      : constant Access_To_Subtype_For_Subp_Spec := Bare_Subp_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Spec;
            return Bare_Subp_Spec (Result);
         end Allocate_Subp_Spec;

      package Bare_Synthetic_Binary_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Binary_Spec, Token_Index);

         
         subtype Subtype_For_Synthetic_Binary_Spec is
            Root_Node_Record (Ada_Synthetic_Binary_Spec);
         type Access_To_Subtype_For_Synthetic_Binary_Spec is access all Subtype_For_Synthetic_Binary_Spec;
         package Bare_Synthetic_Binary_Spec_Alloc is new Alloc
           (Subtype_For_Synthetic_Binary_Spec, Access_To_Subtype_For_Synthetic_Binary_Spec);

         function Allocate_Synthetic_Binary_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Binary_Spec;

         function Allocate_Synthetic_Binary_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Binary_Spec
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Binary_Spec := Bare_Synthetic_Binary_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Binary_Spec;
            return Bare_Synthetic_Binary_Spec (Result);
         end Allocate_Synthetic_Binary_Spec;

      package Bare_Synthetic_Unary_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Unary_Spec, Token_Index);

         
         subtype Subtype_For_Synthetic_Unary_Spec is
            Root_Node_Record (Ada_Synthetic_Unary_Spec);
         type Access_To_Subtype_For_Synthetic_Unary_Spec is access all Subtype_For_Synthetic_Unary_Spec;
         package Bare_Synthetic_Unary_Spec_Alloc is new Alloc
           (Subtype_For_Synthetic_Unary_Spec, Access_To_Subtype_For_Synthetic_Unary_Spec);

         function Allocate_Synthetic_Unary_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Unary_Spec;

         function Allocate_Synthetic_Unary_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Unary_Spec
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Unary_Spec := Bare_Synthetic_Unary_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Unary_Spec;
            return Bare_Synthetic_Unary_Spec (Result);
         end Allocate_Synthetic_Unary_Spec;

      package Bare_Component_List_Memos is new Langkit_Support.Packrat
        (Bare_Component_List, Token_Index);

         
         subtype Subtype_For_Component_List is
            Root_Node_Record (Ada_Component_List);
         type Access_To_Subtype_For_Component_List is access all Subtype_For_Component_List;
         package Bare_Component_List_Alloc is new Alloc
           (Subtype_For_Component_List, Access_To_Subtype_For_Component_List);

         function Allocate_Component_List
           (Pool : Bump_Ptr_Pool) return Bare_Component_List;

         function Allocate_Component_List
           (Pool : Bump_Ptr_Pool) return Bare_Component_List
         is
            Result      : constant Access_To_Subtype_For_Component_List := Bare_Component_List_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Component_List;
            return Bare_Component_List (Result);
         end Allocate_Component_List;

      package Bare_Discriminant_Part_Memos is new Langkit_Support.Packrat
        (Bare_Discriminant_Part, Token_Index);

      package Bare_Known_Discriminant_Part_Memos is new Langkit_Support.Packrat
        (Bare_Known_Discriminant_Part, Token_Index);

         
         subtype Subtype_For_Known_Discriminant_Part is
            Root_Node_Record (Ada_Known_Discriminant_Part);
         type Access_To_Subtype_For_Known_Discriminant_Part is access all Subtype_For_Known_Discriminant_Part;
         package Bare_Known_Discriminant_Part_Alloc is new Alloc
           (Subtype_For_Known_Discriminant_Part, Access_To_Subtype_For_Known_Discriminant_Part);

         function Allocate_Known_Discriminant_Part
           (Pool : Bump_Ptr_Pool) return Bare_Known_Discriminant_Part;

         function Allocate_Known_Discriminant_Part
           (Pool : Bump_Ptr_Pool) return Bare_Known_Discriminant_Part
         is
            Result      : constant Access_To_Subtype_For_Known_Discriminant_Part := Bare_Known_Discriminant_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Known_Discriminant_Part;
            return Bare_Known_Discriminant_Part (Result);
         end Allocate_Known_Discriminant_Part;

      package Bare_Unknown_Discriminant_Part_Memos is new Langkit_Support.Packrat
        (Bare_Unknown_Discriminant_Part, Token_Index);

         
         subtype Subtype_For_Unknown_Discriminant_Part is
            Root_Node_Record (Ada_Unknown_Discriminant_Part);
         type Access_To_Subtype_For_Unknown_Discriminant_Part is access all Subtype_For_Unknown_Discriminant_Part;
         package Bare_Unknown_Discriminant_Part_Alloc is new Alloc
           (Subtype_For_Unknown_Discriminant_Part, Access_To_Subtype_For_Unknown_Discriminant_Part);

         function Allocate_Unknown_Discriminant_Part
           (Pool : Bump_Ptr_Pool) return Bare_Unknown_Discriminant_Part;

         function Allocate_Unknown_Discriminant_Part
           (Pool : Bump_Ptr_Pool) return Bare_Unknown_Discriminant_Part
         is
            Result      : constant Access_To_Subtype_For_Unknown_Discriminant_Part := Bare_Unknown_Discriminant_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Unknown_Discriminant_Part;
            return Bare_Unknown_Discriminant_Part (Result);
         end Allocate_Unknown_Discriminant_Part;

      package Bare_Entry_Completion_Formal_Params_Memos is new Langkit_Support.Packrat
        (Bare_Entry_Completion_Formal_Params, Token_Index);

         
         subtype Subtype_For_Entry_Completion_Formal_Params is
            Root_Node_Record (Ada_Entry_Completion_Formal_Params);
         type Access_To_Subtype_For_Entry_Completion_Formal_Params is access all Subtype_For_Entry_Completion_Formal_Params;
         package Bare_Entry_Completion_Formal_Params_Alloc is new Alloc
           (Subtype_For_Entry_Completion_Formal_Params, Access_To_Subtype_For_Entry_Completion_Formal_Params);

         function Allocate_Entry_Completion_Formal_Params
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Completion_Formal_Params;

         function Allocate_Entry_Completion_Formal_Params
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Completion_Formal_Params
         is
            Result      : constant Access_To_Subtype_For_Entry_Completion_Formal_Params := Bare_Entry_Completion_Formal_Params_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Entry_Completion_Formal_Params;
            return Bare_Entry_Completion_Formal_Params (Result);
         end Allocate_Entry_Completion_Formal_Params;

      package Bare_Generic_Formal_Part_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Formal_Part, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Part is
            Root_Node_Record (Ada_Generic_Formal_Part);
         type Access_To_Subtype_For_Generic_Formal_Part is access all Subtype_For_Generic_Formal_Part;
         package Bare_Generic_Formal_Part_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Part, Access_To_Subtype_For_Generic_Formal_Part);

         function Allocate_Generic_Formal_Part
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Part;

         function Allocate_Generic_Formal_Part
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Part
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Part := Bare_Generic_Formal_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Formal_Part;
            return Bare_Generic_Formal_Part (Result);
         end Allocate_Generic_Formal_Part;

      package Bare_Base_Record_Def_Memos is new Langkit_Support.Packrat
        (Bare_Base_Record_Def, Token_Index);

      package Bare_Null_Record_Def_Memos is new Langkit_Support.Packrat
        (Bare_Null_Record_Def, Token_Index);

         
         subtype Subtype_For_Null_Record_Def is
            Root_Node_Record (Ada_Null_Record_Def);
         type Access_To_Subtype_For_Null_Record_Def is access all Subtype_For_Null_Record_Def;
         package Bare_Null_Record_Def_Alloc is new Alloc
           (Subtype_For_Null_Record_Def, Access_To_Subtype_For_Null_Record_Def);

         function Allocate_Null_Record_Def
           (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Def;

         function Allocate_Null_Record_Def
           (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Def
         is
            Result      : constant Access_To_Subtype_For_Null_Record_Def := Bare_Null_Record_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Null_Record_Def;
            return Bare_Null_Record_Def (Result);
         end Allocate_Null_Record_Def;

      package Bare_Record_Def_Memos is new Langkit_Support.Packrat
        (Bare_Record_Def, Token_Index);

         
         subtype Subtype_For_Record_Def is
            Root_Node_Record (Ada_Record_Def);
         type Access_To_Subtype_For_Record_Def is access all Subtype_For_Record_Def;
         package Bare_Record_Def_Alloc is new Alloc
           (Subtype_For_Record_Def, Access_To_Subtype_For_Record_Def);

         function Allocate_Record_Def
           (Pool : Bump_Ptr_Pool) return Bare_Record_Def;

         function Allocate_Record_Def
           (Pool : Bump_Ptr_Pool) return Bare_Record_Def
         is
            Result      : constant Access_To_Subtype_For_Record_Def := Bare_Record_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Record_Def;
            return Bare_Record_Def (Result);
         end Allocate_Record_Def;

      package Bare_Basic_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Basic_Assoc, Token_Index);

      package Bare_Aggregate_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Aggregate_Assoc, Token_Index);

         
         subtype Subtype_For_Aggregate_Assoc is
            Root_Node_Record (Ada_Aggregate_Assoc);
         type Access_To_Subtype_For_Aggregate_Assoc is access all Subtype_For_Aggregate_Assoc;
         package Bare_Aggregate_Assoc_Alloc is new Alloc
           (Subtype_For_Aggregate_Assoc, Access_To_Subtype_For_Aggregate_Assoc);

         function Allocate_Aggregate_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Aggregate_Assoc;

         function Allocate_Aggregate_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Aggregate_Assoc
         is
            Result      : constant Access_To_Subtype_For_Aggregate_Assoc := Bare_Aggregate_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aggregate_Assoc;
            return Bare_Aggregate_Assoc (Result);
         end Allocate_Aggregate_Assoc;

      package Bare_Multi_Dim_Array_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Multi_Dim_Array_Assoc, Token_Index);

         
         subtype Subtype_For_Multi_Dim_Array_Assoc is
            Root_Node_Record (Ada_Multi_Dim_Array_Assoc);
         type Access_To_Subtype_For_Multi_Dim_Array_Assoc is access all Subtype_For_Multi_Dim_Array_Assoc;
         package Bare_Multi_Dim_Array_Assoc_Alloc is new Alloc
           (Subtype_For_Multi_Dim_Array_Assoc, Access_To_Subtype_For_Multi_Dim_Array_Assoc);

         function Allocate_Multi_Dim_Array_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Multi_Dim_Array_Assoc;

         function Allocate_Multi_Dim_Array_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Multi_Dim_Array_Assoc
         is
            Result      : constant Access_To_Subtype_For_Multi_Dim_Array_Assoc := Bare_Multi_Dim_Array_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Multi_Dim_Array_Assoc;
            return Bare_Multi_Dim_Array_Assoc (Result);
         end Allocate_Multi_Dim_Array_Assoc;

      package Bare_Composite_Constraint_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Composite_Constraint_Assoc, Token_Index);

         
         subtype Subtype_For_Composite_Constraint_Assoc is
            Root_Node_Record (Ada_Composite_Constraint_Assoc);
         type Access_To_Subtype_For_Composite_Constraint_Assoc is access all Subtype_For_Composite_Constraint_Assoc;
         package Bare_Composite_Constraint_Assoc_Alloc is new Alloc
           (Subtype_For_Composite_Constraint_Assoc, Access_To_Subtype_For_Composite_Constraint_Assoc);

         function Allocate_Composite_Constraint_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Composite_Constraint_Assoc;

         function Allocate_Composite_Constraint_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Composite_Constraint_Assoc
         is
            Result      : constant Access_To_Subtype_For_Composite_Constraint_Assoc := Bare_Composite_Constraint_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Composite_Constraint_Assoc;
            return Bare_Composite_Constraint_Assoc (Result);
         end Allocate_Composite_Constraint_Assoc;

      package Bare_Iterated_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Iterated_Assoc, Token_Index);

         
         subtype Subtype_For_Iterated_Assoc is
            Root_Node_Record (Ada_Iterated_Assoc);
         type Access_To_Subtype_For_Iterated_Assoc is access all Subtype_For_Iterated_Assoc;
         package Bare_Iterated_Assoc_Alloc is new Alloc
           (Subtype_For_Iterated_Assoc, Access_To_Subtype_For_Iterated_Assoc);

         function Allocate_Iterated_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Iterated_Assoc;

         function Allocate_Iterated_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Iterated_Assoc
         is
            Result      : constant Access_To_Subtype_For_Iterated_Assoc := Bare_Iterated_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Iterated_Assoc;
            return Bare_Iterated_Assoc (Result);
         end Allocate_Iterated_Assoc;

      package Bare_Param_Assoc_Memos is new Langkit_Support.Packrat
        (Bare_Param_Assoc, Token_Index);

         
         subtype Subtype_For_Param_Assoc is
            Root_Node_Record (Ada_Param_Assoc);
         type Access_To_Subtype_For_Param_Assoc is access all Subtype_For_Param_Assoc;
         package Bare_Param_Assoc_Alloc is new Alloc
           (Subtype_For_Param_Assoc, Access_To_Subtype_For_Param_Assoc);

         function Allocate_Param_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Param_Assoc;

         function Allocate_Param_Assoc
           (Pool : Bump_Ptr_Pool) return Bare_Param_Assoc
         is
            Result      : constant Access_To_Subtype_For_Param_Assoc := Bare_Param_Assoc_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Param_Assoc;
            return Bare_Param_Assoc (Result);
         end Allocate_Param_Assoc;

      package Bare_Basic_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Basic_Decl, Token_Index);

      package Bare_Abstract_State_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_State_Decl, Token_Index);

         
         subtype Subtype_For_Abstract_State_Decl is
            Root_Node_Record (Ada_Abstract_State_Decl);
         type Access_To_Subtype_For_Abstract_State_Decl is access all Subtype_For_Abstract_State_Decl;
         package Bare_Abstract_State_Decl_Alloc is new Alloc
           (Subtype_For_Abstract_State_Decl, Access_To_Subtype_For_Abstract_State_Decl);

         function Allocate_Abstract_State_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_State_Decl;

         function Allocate_Abstract_State_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_State_Decl
         is
            Result      : constant Access_To_Subtype_For_Abstract_State_Decl := Bare_Abstract_State_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_State_Decl;
            return Bare_Abstract_State_Decl (Result);
         end Allocate_Abstract_State_Decl;

      package Bare_Anonymous_Expr_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Anonymous_Expr_Decl, Token_Index);

         
         subtype Subtype_For_Anonymous_Expr_Decl is
            Root_Node_Record (Ada_Anonymous_Expr_Decl);
         type Access_To_Subtype_For_Anonymous_Expr_Decl is access all Subtype_For_Anonymous_Expr_Decl;
         package Bare_Anonymous_Expr_Decl_Alloc is new Alloc
           (Subtype_For_Anonymous_Expr_Decl, Access_To_Subtype_For_Anonymous_Expr_Decl);

         function Allocate_Anonymous_Expr_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Expr_Decl;

         function Allocate_Anonymous_Expr_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Expr_Decl
         is
            Result      : constant Access_To_Subtype_For_Anonymous_Expr_Decl := Bare_Anonymous_Expr_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Anonymous_Expr_Decl;
            return Bare_Anonymous_Expr_Decl (Result);
         end Allocate_Anonymous_Expr_Decl;

      package Bare_Base_Formal_Param_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Base_Formal_Param_Decl, Token_Index);

      package Bare_Component_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Component_Decl, Token_Index);

         
         subtype Subtype_For_Component_Decl is
            Root_Node_Record (Ada_Component_Decl);
         type Access_To_Subtype_For_Component_Decl is access all Subtype_For_Component_Decl;
         package Bare_Component_Decl_Alloc is new Alloc
           (Subtype_For_Component_Decl, Access_To_Subtype_For_Component_Decl);

         function Allocate_Component_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Component_Decl;

         function Allocate_Component_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Component_Decl
         is
            Result      : constant Access_To_Subtype_For_Component_Decl := Bare_Component_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Component_Decl;
            return Bare_Component_Decl (Result);
         end Allocate_Component_Decl;

      package Bare_Discriminant_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Discriminant_Spec, Token_Index);

         
         subtype Subtype_For_Discriminant_Spec is
            Root_Node_Record (Ada_Discriminant_Spec);
         type Access_To_Subtype_For_Discriminant_Spec is access all Subtype_For_Discriminant_Spec;
         package Bare_Discriminant_Spec_Alloc is new Alloc
           (Subtype_For_Discriminant_Spec, Access_To_Subtype_For_Discriminant_Spec);

         function Allocate_Discriminant_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec;

         function Allocate_Discriminant_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec
         is
            Result      : constant Access_To_Subtype_For_Discriminant_Spec := Bare_Discriminant_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Discriminant_Spec;
            return Bare_Discriminant_Spec (Result);
         end Allocate_Discriminant_Spec;

      package Bare_Generic_Formal_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Formal, Token_Index);

      package Bare_Generic_Formal_Obj_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Formal_Obj_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Obj_Decl is
            Root_Node_Record (Ada_Generic_Formal_Obj_Decl);
         type Access_To_Subtype_For_Generic_Formal_Obj_Decl is access all Subtype_For_Generic_Formal_Obj_Decl;
         package Bare_Generic_Formal_Obj_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Obj_Decl, Access_To_Subtype_For_Generic_Formal_Obj_Decl);

         function Allocate_Generic_Formal_Obj_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Obj_Decl;

         function Allocate_Generic_Formal_Obj_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Obj_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Obj_Decl := Bare_Generic_Formal_Obj_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Formal_Obj_Decl;
            return Bare_Generic_Formal_Obj_Decl (Result);
         end Allocate_Generic_Formal_Obj_Decl;

      package Bare_Generic_Formal_Package_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Formal_Package, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Package is
            Root_Node_Record (Ada_Generic_Formal_Package);
         type Access_To_Subtype_For_Generic_Formal_Package is access all Subtype_For_Generic_Formal_Package;
         package Bare_Generic_Formal_Package_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Package, Access_To_Subtype_For_Generic_Formal_Package);

         function Allocate_Generic_Formal_Package
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Package;

         function Allocate_Generic_Formal_Package
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Package
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Package := Bare_Generic_Formal_Package_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Formal_Package;
            return Bare_Generic_Formal_Package (Result);
         end Allocate_Generic_Formal_Package;

      package Bare_Generic_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Formal_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Subp_Decl is
            Root_Node_Record (Ada_Generic_Formal_Subp_Decl);
         type Access_To_Subtype_For_Generic_Formal_Subp_Decl is access all Subtype_For_Generic_Formal_Subp_Decl;
         package Bare_Generic_Formal_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Subp_Decl, Access_To_Subtype_For_Generic_Formal_Subp_Decl);

         function Allocate_Generic_Formal_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Subp_Decl;

         function Allocate_Generic_Formal_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Subp_Decl := Bare_Generic_Formal_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Formal_Subp_Decl;
            return Bare_Generic_Formal_Subp_Decl (Result);
         end Allocate_Generic_Formal_Subp_Decl;

      package Bare_Generic_Formal_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Formal_Type_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Type_Decl is
            Root_Node_Record (Ada_Generic_Formal_Type_Decl);
         type Access_To_Subtype_For_Generic_Formal_Type_Decl is access all Subtype_For_Generic_Formal_Type_Decl;
         package Bare_Generic_Formal_Type_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Type_Decl, Access_To_Subtype_For_Generic_Formal_Type_Decl);

         function Allocate_Generic_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Type_Decl;

         function Allocate_Generic_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Type_Decl := Bare_Generic_Formal_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Formal_Type_Decl;
            return Bare_Generic_Formal_Type_Decl (Result);
         end Allocate_Generic_Formal_Type_Decl;

      package Bare_Param_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Param_Spec, Token_Index);

         
         subtype Subtype_For_Param_Spec is
            Root_Node_Record (Ada_Param_Spec);
         type Access_To_Subtype_For_Param_Spec is access all Subtype_For_Param_Spec;
         package Bare_Param_Spec_Alloc is new Alloc
           (Subtype_For_Param_Spec, Access_To_Subtype_For_Param_Spec);

         function Allocate_Param_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Param_Spec;

         function Allocate_Param_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Param_Spec
         is
            Result      : constant Access_To_Subtype_For_Param_Spec := Bare_Param_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Param_Spec;
            return Bare_Param_Spec (Result);
         end Allocate_Param_Spec;

      package Bare_Synthetic_Formal_Param_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Formal_Param_Decl, Token_Index);

         
         subtype Subtype_For_Synthetic_Formal_Param_Decl is
            Root_Node_Record (Ada_Synthetic_Formal_Param_Decl);
         type Access_To_Subtype_For_Synthetic_Formal_Param_Decl is access all Subtype_For_Synthetic_Formal_Param_Decl;
         package Bare_Synthetic_Formal_Param_Decl_Alloc is new Alloc
           (Subtype_For_Synthetic_Formal_Param_Decl, Access_To_Subtype_For_Synthetic_Formal_Param_Decl);

         function Allocate_Synthetic_Formal_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Formal_Param_Decl;

         function Allocate_Synthetic_Formal_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Formal_Param_Decl
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Formal_Param_Decl := Bare_Synthetic_Formal_Param_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Formal_Param_Decl;
            return Bare_Synthetic_Formal_Param_Decl (Result);
         end Allocate_Synthetic_Formal_Param_Decl;

      package Bare_Base_Package_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Base_Package_Decl, Token_Index);

      package Bare_Generic_Package_Internal_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Package_Internal, Token_Index);

         
         subtype Subtype_For_Generic_Package_Internal is
            Root_Node_Record (Ada_Generic_Package_Internal);
         type Access_To_Subtype_For_Generic_Package_Internal is access all Subtype_For_Generic_Package_Internal;
         package Bare_Generic_Package_Internal_Alloc is new Alloc
           (Subtype_For_Generic_Package_Internal, Access_To_Subtype_For_Generic_Package_Internal);

         function Allocate_Generic_Package_Internal
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Internal;

         function Allocate_Generic_Package_Internal
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Internal
         is
            Result      : constant Access_To_Subtype_For_Generic_Package_Internal := Bare_Generic_Package_Internal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Package_Internal;
            return Bare_Generic_Package_Internal (Result);
         end Allocate_Generic_Package_Internal;

      package Bare_Package_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Package_Decl, Token_Index);

         
         subtype Subtype_For_Package_Decl is
            Root_Node_Record (Ada_Package_Decl);
         type Access_To_Subtype_For_Package_Decl is access all Subtype_For_Package_Decl;
         package Bare_Package_Decl_Alloc is new Alloc
           (Subtype_For_Package_Decl, Access_To_Subtype_For_Package_Decl);

         function Allocate_Package_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Package_Decl;

         function Allocate_Package_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Package_Decl
         is
            Result      : constant Access_To_Subtype_For_Package_Decl := Bare_Package_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Package_Decl;
            return Bare_Package_Decl (Result);
         end Allocate_Package_Decl;

      package Bare_Base_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Base_Type_Decl, Token_Index);

      package Bare_Base_Subtype_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Base_Subtype_Decl, Token_Index);

      package Bare_Discrete_Base_Subtype_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Discrete_Base_Subtype_Decl, Token_Index);

         
         subtype Subtype_For_Discrete_Base_Subtype_Decl is
            Root_Node_Record (Ada_Discrete_Base_Subtype_Decl);
         type Access_To_Subtype_For_Discrete_Base_Subtype_Decl is access all Subtype_For_Discrete_Base_Subtype_Decl;
         package Bare_Discrete_Base_Subtype_Decl_Alloc is new Alloc
           (Subtype_For_Discrete_Base_Subtype_Decl, Access_To_Subtype_For_Discrete_Base_Subtype_Decl);

         function Allocate_Discrete_Base_Subtype_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Discrete_Base_Subtype_Decl;

         function Allocate_Discrete_Base_Subtype_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Discrete_Base_Subtype_Decl
         is
            Result      : constant Access_To_Subtype_For_Discrete_Base_Subtype_Decl := Bare_Discrete_Base_Subtype_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Discrete_Base_Subtype_Decl;
            return Bare_Discrete_Base_Subtype_Decl (Result);
         end Allocate_Discrete_Base_Subtype_Decl;

      package Bare_Subtype_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Subtype_Decl, Token_Index);

         
         subtype Subtype_For_Subtype_Decl is
            Root_Node_Record (Ada_Subtype_Decl);
         type Access_To_Subtype_For_Subtype_Decl is access all Subtype_For_Subtype_Decl;
         package Bare_Subtype_Decl_Alloc is new Alloc
           (Subtype_For_Subtype_Decl, Access_To_Subtype_For_Subtype_Decl);

         function Allocate_Subtype_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Subtype_Decl;

         function Allocate_Subtype_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Subtype_Decl
         is
            Result      : constant Access_To_Subtype_For_Subtype_Decl := Bare_Subtype_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subtype_Decl;
            return Bare_Subtype_Decl (Result);
         end Allocate_Subtype_Decl;

      package Bare_Classwide_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Classwide_Type_Decl, Token_Index);

         
         subtype Subtype_For_Classwide_Type_Decl is
            Root_Node_Record (Ada_Classwide_Type_Decl);
         type Access_To_Subtype_For_Classwide_Type_Decl is access all Subtype_For_Classwide_Type_Decl;
         package Bare_Classwide_Type_Decl_Alloc is new Alloc
           (Subtype_For_Classwide_Type_Decl, Access_To_Subtype_For_Classwide_Type_Decl);

         function Allocate_Classwide_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Classwide_Type_Decl;

         function Allocate_Classwide_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Classwide_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Classwide_Type_Decl := Bare_Classwide_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Classwide_Type_Decl;
            return Bare_Classwide_Type_Decl (Result);
         end Allocate_Classwide_Type_Decl;

      package Bare_Incomplete_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Incomplete_Type_Decl, Token_Index);

         
         subtype Subtype_For_Incomplete_Type_Decl is
            Root_Node_Record (Ada_Incomplete_Type_Decl);
         type Access_To_Subtype_For_Incomplete_Type_Decl is access all Subtype_For_Incomplete_Type_Decl;
         package Bare_Incomplete_Type_Decl_Alloc is new Alloc
           (Subtype_For_Incomplete_Type_Decl, Access_To_Subtype_For_Incomplete_Type_Decl);

         function Allocate_Incomplete_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Type_Decl;

         function Allocate_Incomplete_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Incomplete_Type_Decl := Bare_Incomplete_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Incomplete_Type_Decl;
            return Bare_Incomplete_Type_Decl (Result);
         end Allocate_Incomplete_Type_Decl;

      package Bare_Incomplete_Formal_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Incomplete_Formal_Type_Decl, Token_Index);

         
         subtype Subtype_For_Incomplete_Formal_Type_Decl is
            Root_Node_Record (Ada_Incomplete_Formal_Type_Decl);
         type Access_To_Subtype_For_Incomplete_Formal_Type_Decl is access all Subtype_For_Incomplete_Formal_Type_Decl;
         package Bare_Incomplete_Formal_Type_Decl_Alloc is new Alloc
           (Subtype_For_Incomplete_Formal_Type_Decl, Access_To_Subtype_For_Incomplete_Formal_Type_Decl);

         function Allocate_Incomplete_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Formal_Type_Decl;

         function Allocate_Incomplete_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Formal_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Incomplete_Formal_Type_Decl := Bare_Incomplete_Formal_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Incomplete_Formal_Type_Decl;
            return Bare_Incomplete_Formal_Type_Decl (Result);
         end Allocate_Incomplete_Formal_Type_Decl;

      package Bare_Incomplete_Tagged_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Incomplete_Tagged_Type_Decl, Token_Index);

         
         subtype Subtype_For_Incomplete_Tagged_Type_Decl is
            Root_Node_Record (Ada_Incomplete_Tagged_Type_Decl);
         type Access_To_Subtype_For_Incomplete_Tagged_Type_Decl is access all Subtype_For_Incomplete_Tagged_Type_Decl;
         package Bare_Incomplete_Tagged_Type_Decl_Alloc is new Alloc
           (Subtype_For_Incomplete_Tagged_Type_Decl, Access_To_Subtype_For_Incomplete_Tagged_Type_Decl);

         function Allocate_Incomplete_Tagged_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Tagged_Type_Decl;

         function Allocate_Incomplete_Tagged_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Tagged_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Incomplete_Tagged_Type_Decl := Bare_Incomplete_Tagged_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Incomplete_Tagged_Type_Decl;
            return Bare_Incomplete_Tagged_Type_Decl (Result);
         end Allocate_Incomplete_Tagged_Type_Decl;

      package Bare_Protected_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Type_Decl, Token_Index);

         
         subtype Subtype_For_Protected_Type_Decl is
            Root_Node_Record (Ada_Protected_Type_Decl);
         type Access_To_Subtype_For_Protected_Type_Decl is access all Subtype_For_Protected_Type_Decl;
         package Bare_Protected_Type_Decl_Alloc is new Alloc
           (Subtype_For_Protected_Type_Decl, Access_To_Subtype_For_Protected_Type_Decl);

         function Allocate_Protected_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Type_Decl;

         function Allocate_Protected_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Protected_Type_Decl := Bare_Protected_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Protected_Type_Decl;
            return Bare_Protected_Type_Decl (Result);
         end Allocate_Protected_Type_Decl;

      package Bare_Task_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Task_Type_Decl, Token_Index);

         
         subtype Subtype_For_Task_Type_Decl is
            Root_Node_Record (Ada_Task_Type_Decl);
         type Access_To_Subtype_For_Task_Type_Decl is access all Subtype_For_Task_Type_Decl;
         package Bare_Task_Type_Decl_Alloc is new Alloc
           (Subtype_For_Task_Type_Decl, Access_To_Subtype_For_Task_Type_Decl);

         function Allocate_Task_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Task_Type_Decl;

         function Allocate_Task_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Task_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Task_Type_Decl := Bare_Task_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Task_Type_Decl;
            return Bare_Task_Type_Decl (Result);
         end Allocate_Task_Type_Decl;

      package Bare_Single_Task_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Single_Task_Type_Decl, Token_Index);

         
         subtype Subtype_For_Single_Task_Type_Decl is
            Root_Node_Record (Ada_Single_Task_Type_Decl);
         type Access_To_Subtype_For_Single_Task_Type_Decl is access all Subtype_For_Single_Task_Type_Decl;
         package Bare_Single_Task_Type_Decl_Alloc is new Alloc
           (Subtype_For_Single_Task_Type_Decl, Access_To_Subtype_For_Single_Task_Type_Decl);

         function Allocate_Single_Task_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Type_Decl;

         function Allocate_Single_Task_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Single_Task_Type_Decl := Bare_Single_Task_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Single_Task_Type_Decl;
            return Bare_Single_Task_Type_Decl (Result);
         end Allocate_Single_Task_Type_Decl;

      package Bare_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Type_Decl, Token_Index);

      package Bare_Anonymous_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Anonymous_Type_Decl, Token_Index);

         
         subtype Subtype_For_Anonymous_Type_Decl is
            Root_Node_Record (Ada_Anonymous_Type_Decl);
         type Access_To_Subtype_For_Anonymous_Type_Decl is access all Subtype_For_Anonymous_Type_Decl;
         package Bare_Anonymous_Type_Decl_Alloc is new Alloc
           (Subtype_For_Anonymous_Type_Decl, Access_To_Subtype_For_Anonymous_Type_Decl);

         function Allocate_Anonymous_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Decl;

         function Allocate_Anonymous_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Anonymous_Type_Decl := Bare_Anonymous_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Anonymous_Type_Decl;
            return Bare_Anonymous_Type_Decl (Result);
         end Allocate_Anonymous_Type_Decl;

      package Bare_Synth_Anonymous_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Synth_Anonymous_Type_Decl, Token_Index);

         
         subtype Subtype_For_Synth_Anonymous_Type_Decl is
            Root_Node_Record (Ada_Synth_Anonymous_Type_Decl);
         type Access_To_Subtype_For_Synth_Anonymous_Type_Decl is access all Subtype_For_Synth_Anonymous_Type_Decl;
         package Bare_Synth_Anonymous_Type_Decl_Alloc is new Alloc
           (Subtype_For_Synth_Anonymous_Type_Decl, Access_To_Subtype_For_Synth_Anonymous_Type_Decl);

         function Allocate_Synth_Anonymous_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Anonymous_Type_Decl;

         function Allocate_Synth_Anonymous_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Anonymous_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Synth_Anonymous_Type_Decl := Bare_Synth_Anonymous_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synth_Anonymous_Type_Decl;
            return Bare_Synth_Anonymous_Type_Decl (Result);
         end Allocate_Synth_Anonymous_Type_Decl;

      package Bare_Concrete_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Concrete_Type_Decl, Token_Index);

         
         subtype Subtype_For_Concrete_Type_Decl is
            Root_Node_Record (Ada_Concrete_Type_Decl);
         type Access_To_Subtype_For_Concrete_Type_Decl is access all Subtype_For_Concrete_Type_Decl;
         package Bare_Concrete_Type_Decl_Alloc is new Alloc
           (Subtype_For_Concrete_Type_Decl, Access_To_Subtype_For_Concrete_Type_Decl);

         function Allocate_Concrete_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Concrete_Type_Decl;

         function Allocate_Concrete_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Concrete_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Concrete_Type_Decl := Bare_Concrete_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Concrete_Type_Decl;
            return Bare_Concrete_Type_Decl (Result);
         end Allocate_Concrete_Type_Decl;

      package Bare_Formal_Type_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Formal_Type_Decl, Token_Index);

         
         subtype Subtype_For_Formal_Type_Decl is
            Root_Node_Record (Ada_Formal_Type_Decl);
         type Access_To_Subtype_For_Formal_Type_Decl is access all Subtype_For_Formal_Type_Decl;
         package Bare_Formal_Type_Decl_Alloc is new Alloc
           (Subtype_For_Formal_Type_Decl, Access_To_Subtype_For_Formal_Type_Decl);

         function Allocate_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Formal_Type_Decl;

         function Allocate_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Formal_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Formal_Type_Decl := Bare_Formal_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Formal_Type_Decl;
            return Bare_Formal_Type_Decl (Result);
         end Allocate_Formal_Type_Decl;

      package Bare_Basic_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Basic_Subp_Decl, Token_Index);

      package Bare_Classic_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Classic_Subp_Decl, Token_Index);

      package Bare_Abstract_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Abstract_Subp_Decl is
            Root_Node_Record (Ada_Abstract_Subp_Decl);
         type Access_To_Subtype_For_Abstract_Subp_Decl is access all Subtype_For_Abstract_Subp_Decl;
         package Bare_Abstract_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Abstract_Subp_Decl, Access_To_Subtype_For_Abstract_Subp_Decl);

         function Allocate_Abstract_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Subp_Decl;

         function Allocate_Abstract_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Abstract_Subp_Decl := Bare_Abstract_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_Subp_Decl;
            return Bare_Abstract_Subp_Decl (Result);
         end Allocate_Abstract_Subp_Decl;

      package Bare_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Formal_Subp_Decl, Token_Index);

      package Bare_Abstract_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_Formal_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Abstract_Formal_Subp_Decl is
            Root_Node_Record (Ada_Abstract_Formal_Subp_Decl);
         type Access_To_Subtype_For_Abstract_Formal_Subp_Decl is access all Subtype_For_Abstract_Formal_Subp_Decl;
         package Bare_Abstract_Formal_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Abstract_Formal_Subp_Decl, Access_To_Subtype_For_Abstract_Formal_Subp_Decl);

         function Allocate_Abstract_Formal_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Formal_Subp_Decl;

         function Allocate_Abstract_Formal_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_Formal_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Abstract_Formal_Subp_Decl := Bare_Abstract_Formal_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_Formal_Subp_Decl;
            return Bare_Abstract_Formal_Subp_Decl (Result);
         end Allocate_Abstract_Formal_Subp_Decl;

      package Bare_Concrete_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Concrete_Formal_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Concrete_Formal_Subp_Decl is
            Root_Node_Record (Ada_Concrete_Formal_Subp_Decl);
         type Access_To_Subtype_For_Concrete_Formal_Subp_Decl is access all Subtype_For_Concrete_Formal_Subp_Decl;
         package Bare_Concrete_Formal_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Concrete_Formal_Subp_Decl, Access_To_Subtype_For_Concrete_Formal_Subp_Decl);

         function Allocate_Concrete_Formal_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Concrete_Formal_Subp_Decl;

         function Allocate_Concrete_Formal_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Concrete_Formal_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Concrete_Formal_Subp_Decl := Bare_Concrete_Formal_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Concrete_Formal_Subp_Decl;
            return Bare_Concrete_Formal_Subp_Decl (Result);
         end Allocate_Concrete_Formal_Subp_Decl;

      package Bare_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Subp_Decl is
            Root_Node_Record (Ada_Subp_Decl);
         type Access_To_Subtype_For_Subp_Decl is access all Subtype_For_Subp_Decl;
         package Bare_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Subp_Decl, Access_To_Subtype_For_Subp_Decl);

         function Allocate_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Decl;

         function Allocate_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Subp_Decl := Bare_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Decl;
            return Bare_Subp_Decl (Result);
         end Allocate_Subp_Decl;

      package Bare_Entry_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Entry_Decl, Token_Index);

         
         subtype Subtype_For_Entry_Decl is
            Root_Node_Record (Ada_Entry_Decl);
         type Access_To_Subtype_For_Entry_Decl is access all Subtype_For_Entry_Decl;
         package Bare_Entry_Decl_Alloc is new Alloc
           (Subtype_For_Entry_Decl, Access_To_Subtype_For_Entry_Decl);

         function Allocate_Entry_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Decl;

         function Allocate_Entry_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Decl
         is
            Result      : constant Access_To_Subtype_For_Entry_Decl := Bare_Entry_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Entry_Decl;
            return Bare_Entry_Decl (Result);
         end Allocate_Entry_Decl;

      package Bare_Enum_Literal_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Enum_Literal_Decl, Token_Index);

         
         subtype Subtype_For_Enum_Literal_Decl is
            Root_Node_Record (Ada_Enum_Literal_Decl);
         type Access_To_Subtype_For_Enum_Literal_Decl is access all Subtype_For_Enum_Literal_Decl;
         package Bare_Enum_Literal_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Literal_Decl, Access_To_Subtype_For_Enum_Literal_Decl);

         function Allocate_Enum_Literal_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl;

         function Allocate_Enum_Literal_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Literal_Decl := Bare_Enum_Literal_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Enum_Literal_Decl;
            return Bare_Enum_Literal_Decl (Result);
         end Allocate_Enum_Literal_Decl;

      package Bare_Synthetic_Char_Enum_Lit_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Char_Enum_Lit, Token_Index);

         
         subtype Subtype_For_Synthetic_Char_Enum_Lit is
            Root_Node_Record (Ada_Synthetic_Char_Enum_Lit);
         type Access_To_Subtype_For_Synthetic_Char_Enum_Lit is access all Subtype_For_Synthetic_Char_Enum_Lit;
         package Bare_Synthetic_Char_Enum_Lit_Alloc is new Alloc
           (Subtype_For_Synthetic_Char_Enum_Lit, Access_To_Subtype_For_Synthetic_Char_Enum_Lit);

         function Allocate_Synthetic_Char_Enum_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Char_Enum_Lit;

         function Allocate_Synthetic_Char_Enum_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Char_Enum_Lit
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Char_Enum_Lit := Bare_Synthetic_Char_Enum_Lit_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Char_Enum_Lit;
            return Bare_Synthetic_Char_Enum_Lit (Result);
         end Allocate_Synthetic_Char_Enum_Lit;

      package Bare_Generic_Subp_Internal_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Subp_Internal, Token_Index);

         
         subtype Subtype_For_Generic_Subp_Internal is
            Root_Node_Record (Ada_Generic_Subp_Internal);
         type Access_To_Subtype_For_Generic_Subp_Internal is access all Subtype_For_Generic_Subp_Internal;
         package Bare_Generic_Subp_Internal_Alloc is new Alloc
           (Subtype_For_Generic_Subp_Internal, Access_To_Subtype_For_Generic_Subp_Internal);

         function Allocate_Generic_Subp_Internal
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Internal;

         function Allocate_Generic_Subp_Internal
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Internal
         is
            Result      : constant Access_To_Subtype_For_Generic_Subp_Internal := Bare_Generic_Subp_Internal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Subp_Internal;
            return Bare_Generic_Subp_Internal (Result);
         end Allocate_Generic_Subp_Internal;

      package Bare_Synthetic_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Synthetic_Subp_Decl is
            Root_Node_Record (Ada_Synthetic_Subp_Decl);
         type Access_To_Subtype_For_Synthetic_Subp_Decl is access all Subtype_For_Synthetic_Subp_Decl;
         package Bare_Synthetic_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Synthetic_Subp_Decl, Access_To_Subtype_For_Synthetic_Subp_Decl);

         function Allocate_Synthetic_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Subp_Decl;

         function Allocate_Synthetic_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Subp_Decl := Bare_Synthetic_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Subp_Decl;
            return Bare_Synthetic_Subp_Decl (Result);
         end Allocate_Synthetic_Subp_Decl;

      package Bare_Body_Node_Memos is new Langkit_Support.Packrat
        (Bare_Body_Node, Token_Index);

      package Bare_Base_Subp_Body_Memos is new Langkit_Support.Packrat
        (Bare_Base_Subp_Body, Token_Index);

      package Bare_Expr_Function_Memos is new Langkit_Support.Packrat
        (Bare_Expr_Function, Token_Index);

         
         subtype Subtype_For_Expr_Function is
            Root_Node_Record (Ada_Expr_Function);
         type Access_To_Subtype_For_Expr_Function is access all Subtype_For_Expr_Function;
         package Bare_Expr_Function_Alloc is new Alloc
           (Subtype_For_Expr_Function, Access_To_Subtype_For_Expr_Function);

         function Allocate_Expr_Function
           (Pool : Bump_Ptr_Pool) return Bare_Expr_Function;

         function Allocate_Expr_Function
           (Pool : Bump_Ptr_Pool) return Bare_Expr_Function
         is
            Result      : constant Access_To_Subtype_For_Expr_Function := Bare_Expr_Function_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Expr_Function;
            return Bare_Expr_Function (Result);
         end Allocate_Expr_Function;

      package Bare_Null_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Null_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Null_Subp_Decl is
            Root_Node_Record (Ada_Null_Subp_Decl);
         type Access_To_Subtype_For_Null_Subp_Decl is access all Subtype_For_Null_Subp_Decl;
         package Bare_Null_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Null_Subp_Decl, Access_To_Subtype_For_Null_Subp_Decl);

         function Allocate_Null_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Null_Subp_Decl;

         function Allocate_Null_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Null_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Null_Subp_Decl := Bare_Null_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Null_Subp_Decl;
            return Bare_Null_Subp_Decl (Result);
         end Allocate_Null_Subp_Decl;

      package Bare_Subp_Body_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Body, Token_Index);

         
         subtype Subtype_For_Subp_Body is
            Root_Node_Record (Ada_Subp_Body);
         type Access_To_Subtype_For_Subp_Body is access all Subtype_For_Subp_Body;
         package Bare_Subp_Body_Alloc is new Alloc
           (Subtype_For_Subp_Body, Access_To_Subtype_For_Subp_Body);

         function Allocate_Subp_Body
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Body;

         function Allocate_Subp_Body
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Body
         is
            Result      : constant Access_To_Subtype_For_Subp_Body := Bare_Subp_Body_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Body;
            return Bare_Subp_Body (Result);
         end Allocate_Subp_Body;

      package Bare_Subp_Renaming_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Renaming_Decl, Token_Index);

         
         subtype Subtype_For_Subp_Renaming_Decl is
            Root_Node_Record (Ada_Subp_Renaming_Decl);
         type Access_To_Subtype_For_Subp_Renaming_Decl is access all Subtype_For_Subp_Renaming_Decl;
         package Bare_Subp_Renaming_Decl_Alloc is new Alloc
           (Subtype_For_Subp_Renaming_Decl, Access_To_Subtype_For_Subp_Renaming_Decl);

         function Allocate_Subp_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Renaming_Decl;

         function Allocate_Subp_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Renaming_Decl
         is
            Result      : constant Access_To_Subtype_For_Subp_Renaming_Decl := Bare_Subp_Renaming_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Renaming_Decl;
            return Bare_Subp_Renaming_Decl (Result);
         end Allocate_Subp_Renaming_Decl;

      package Bare_Body_Stub_Memos is new Langkit_Support.Packrat
        (Bare_Body_Stub, Token_Index);

      package Bare_Package_Body_Stub_Memos is new Langkit_Support.Packrat
        (Bare_Package_Body_Stub, Token_Index);

         
         subtype Subtype_For_Package_Body_Stub is
            Root_Node_Record (Ada_Package_Body_Stub);
         type Access_To_Subtype_For_Package_Body_Stub is access all Subtype_For_Package_Body_Stub;
         package Bare_Package_Body_Stub_Alloc is new Alloc
           (Subtype_For_Package_Body_Stub, Access_To_Subtype_For_Package_Body_Stub);

         function Allocate_Package_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Package_Body_Stub;

         function Allocate_Package_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Package_Body_Stub
         is
            Result      : constant Access_To_Subtype_For_Package_Body_Stub := Bare_Package_Body_Stub_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Package_Body_Stub;
            return Bare_Package_Body_Stub (Result);
         end Allocate_Package_Body_Stub;

      package Bare_Protected_Body_Stub_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Body_Stub, Token_Index);

         
         subtype Subtype_For_Protected_Body_Stub is
            Root_Node_Record (Ada_Protected_Body_Stub);
         type Access_To_Subtype_For_Protected_Body_Stub is access all Subtype_For_Protected_Body_Stub;
         package Bare_Protected_Body_Stub_Alloc is new Alloc
           (Subtype_For_Protected_Body_Stub, Access_To_Subtype_For_Protected_Body_Stub);

         function Allocate_Protected_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Body_Stub;

         function Allocate_Protected_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Body_Stub
         is
            Result      : constant Access_To_Subtype_For_Protected_Body_Stub := Bare_Protected_Body_Stub_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Protected_Body_Stub;
            return Bare_Protected_Body_Stub (Result);
         end Allocate_Protected_Body_Stub;

      package Bare_Subp_Body_Stub_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Body_Stub, Token_Index);

         
         subtype Subtype_For_Subp_Body_Stub is
            Root_Node_Record (Ada_Subp_Body_Stub);
         type Access_To_Subtype_For_Subp_Body_Stub is access all Subtype_For_Subp_Body_Stub;
         package Bare_Subp_Body_Stub_Alloc is new Alloc
           (Subtype_For_Subp_Body_Stub, Access_To_Subtype_For_Subp_Body_Stub);

         function Allocate_Subp_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Body_Stub;

         function Allocate_Subp_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Body_Stub
         is
            Result      : constant Access_To_Subtype_For_Subp_Body_Stub := Bare_Subp_Body_Stub_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Body_Stub;
            return Bare_Subp_Body_Stub (Result);
         end Allocate_Subp_Body_Stub;

      package Bare_Task_Body_Stub_Memos is new Langkit_Support.Packrat
        (Bare_Task_Body_Stub, Token_Index);

         
         subtype Subtype_For_Task_Body_Stub is
            Root_Node_Record (Ada_Task_Body_Stub);
         type Access_To_Subtype_For_Task_Body_Stub is access all Subtype_For_Task_Body_Stub;
         package Bare_Task_Body_Stub_Alloc is new Alloc
           (Subtype_For_Task_Body_Stub, Access_To_Subtype_For_Task_Body_Stub);

         function Allocate_Task_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Task_Body_Stub;

         function Allocate_Task_Body_Stub
           (Pool : Bump_Ptr_Pool) return Bare_Task_Body_Stub
         is
            Result      : constant Access_To_Subtype_For_Task_Body_Stub := Bare_Task_Body_Stub_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Task_Body_Stub;
            return Bare_Task_Body_Stub (Result);
         end Allocate_Task_Body_Stub;

      package Bare_Entry_Body_Memos is new Langkit_Support.Packrat
        (Bare_Entry_Body, Token_Index);

         
         subtype Subtype_For_Entry_Body is
            Root_Node_Record (Ada_Entry_Body);
         type Access_To_Subtype_For_Entry_Body is access all Subtype_For_Entry_Body;
         package Bare_Entry_Body_Alloc is new Alloc
           (Subtype_For_Entry_Body, Access_To_Subtype_For_Entry_Body);

         function Allocate_Entry_Body
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Body;

         function Allocate_Entry_Body
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Body
         is
            Result      : constant Access_To_Subtype_For_Entry_Body := Bare_Entry_Body_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Entry_Body;
            return Bare_Entry_Body (Result);
         end Allocate_Entry_Body;

      package Bare_Package_Body_Memos is new Langkit_Support.Packrat
        (Bare_Package_Body, Token_Index);

         
         subtype Subtype_For_Package_Body is
            Root_Node_Record (Ada_Package_Body);
         type Access_To_Subtype_For_Package_Body is access all Subtype_For_Package_Body;
         package Bare_Package_Body_Alloc is new Alloc
           (Subtype_For_Package_Body, Access_To_Subtype_For_Package_Body);

         function Allocate_Package_Body
           (Pool : Bump_Ptr_Pool) return Bare_Package_Body;

         function Allocate_Package_Body
           (Pool : Bump_Ptr_Pool) return Bare_Package_Body
         is
            Result      : constant Access_To_Subtype_For_Package_Body := Bare_Package_Body_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Package_Body;
            return Bare_Package_Body (Result);
         end Allocate_Package_Body;

      package Bare_Protected_Body_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Body, Token_Index);

         
         subtype Subtype_For_Protected_Body is
            Root_Node_Record (Ada_Protected_Body);
         type Access_To_Subtype_For_Protected_Body is access all Subtype_For_Protected_Body;
         package Bare_Protected_Body_Alloc is new Alloc
           (Subtype_For_Protected_Body, Access_To_Subtype_For_Protected_Body);

         function Allocate_Protected_Body
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Body;

         function Allocate_Protected_Body
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Body
         is
            Result      : constant Access_To_Subtype_For_Protected_Body := Bare_Protected_Body_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Protected_Body;
            return Bare_Protected_Body (Result);
         end Allocate_Protected_Body;

      package Bare_Task_Body_Memos is new Langkit_Support.Packrat
        (Bare_Task_Body, Token_Index);

         
         subtype Subtype_For_Task_Body is
            Root_Node_Record (Ada_Task_Body);
         type Access_To_Subtype_For_Task_Body is access all Subtype_For_Task_Body;
         package Bare_Task_Body_Alloc is new Alloc
           (Subtype_For_Task_Body, Access_To_Subtype_For_Task_Body);

         function Allocate_Task_Body
           (Pool : Bump_Ptr_Pool) return Bare_Task_Body;

         function Allocate_Task_Body
           (Pool : Bump_Ptr_Pool) return Bare_Task_Body
         is
            Result      : constant Access_To_Subtype_For_Task_Body := Bare_Task_Body_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Task_Body;
            return Bare_Task_Body (Result);
         end Allocate_Task_Body;

      package Bare_Entry_Index_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Entry_Index_Spec, Token_Index);

         
         subtype Subtype_For_Entry_Index_Spec is
            Root_Node_Record (Ada_Entry_Index_Spec);
         type Access_To_Subtype_For_Entry_Index_Spec is access all Subtype_For_Entry_Index_Spec;
         package Bare_Entry_Index_Spec_Alloc is new Alloc
           (Subtype_For_Entry_Index_Spec, Access_To_Subtype_For_Entry_Index_Spec);

         function Allocate_Entry_Index_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Index_Spec;

         function Allocate_Entry_Index_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Entry_Index_Spec
         is
            Result      : constant Access_To_Subtype_For_Entry_Index_Spec := Bare_Entry_Index_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Entry_Index_Spec;
            return Bare_Entry_Index_Spec (Result);
         end Allocate_Entry_Index_Spec;

      package Bare_Error_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Error_Decl, Token_Index);

         
         subtype Subtype_For_Error_Decl is
            Root_Node_Record (Ada_Error_Decl);
         type Access_To_Subtype_For_Error_Decl is access all Subtype_For_Error_Decl;
         package Bare_Error_Decl_Alloc is new Alloc
           (Subtype_For_Error_Decl, Access_To_Subtype_For_Error_Decl);

         function Allocate_Error_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Error_Decl;

         function Allocate_Error_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Error_Decl
         is
            Result      : constant Access_To_Subtype_For_Error_Decl := Bare_Error_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Error_Decl;
            return Bare_Error_Decl (Result);
         end Allocate_Error_Decl;

      package Bare_Exception_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Exception_Decl, Token_Index);

         
         subtype Subtype_For_Exception_Decl is
            Root_Node_Record (Ada_Exception_Decl);
         type Access_To_Subtype_For_Exception_Decl is access all Subtype_For_Exception_Decl;
         package Bare_Exception_Decl_Alloc is new Alloc
           (Subtype_For_Exception_Decl, Access_To_Subtype_For_Exception_Decl);

         function Allocate_Exception_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Exception_Decl;

         function Allocate_Exception_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Exception_Decl
         is
            Result      : constant Access_To_Subtype_For_Exception_Decl := Bare_Exception_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Exception_Decl;
            return Bare_Exception_Decl (Result);
         end Allocate_Exception_Decl;

      package Bare_Exception_Handler_Memos is new Langkit_Support.Packrat
        (Bare_Exception_Handler, Token_Index);

         
         subtype Subtype_For_Exception_Handler is
            Root_Node_Record (Ada_Exception_Handler);
         type Access_To_Subtype_For_Exception_Handler is access all Subtype_For_Exception_Handler;
         package Bare_Exception_Handler_Alloc is new Alloc
           (Subtype_For_Exception_Handler, Access_To_Subtype_For_Exception_Handler);

         function Allocate_Exception_Handler
           (Pool : Bump_Ptr_Pool) return Bare_Exception_Handler;

         function Allocate_Exception_Handler
           (Pool : Bump_Ptr_Pool) return Bare_Exception_Handler
         is
            Result      : constant Access_To_Subtype_For_Exception_Handler := Bare_Exception_Handler_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Exception_Handler;
            return Bare_Exception_Handler (Result);
         end Allocate_Exception_Handler;

      package Bare_For_Loop_Var_Decl_Memos is new Langkit_Support.Packrat
        (Bare_For_Loop_Var_Decl, Token_Index);

         
         subtype Subtype_For_For_Loop_Var_Decl is
            Root_Node_Record (Ada_For_Loop_Var_Decl);
         type Access_To_Subtype_For_For_Loop_Var_Decl is access all Subtype_For_For_Loop_Var_Decl;
         package Bare_For_Loop_Var_Decl_Alloc is new Alloc
           (Subtype_For_For_Loop_Var_Decl, Access_To_Subtype_For_For_Loop_Var_Decl);

         function Allocate_For_Loop_Var_Decl
           (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Var_Decl;

         function Allocate_For_Loop_Var_Decl
           (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Var_Decl
         is
            Result      : constant Access_To_Subtype_For_For_Loop_Var_Decl := Bare_For_Loop_Var_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_For_Loop_Var_Decl;
            return Bare_For_Loop_Var_Decl (Result);
         end Allocate_For_Loop_Var_Decl;

      package Bare_Generic_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Decl, Token_Index);

      package Bare_Generic_Package_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Package_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Package_Decl is
            Root_Node_Record (Ada_Generic_Package_Decl);
         type Access_To_Subtype_For_Generic_Package_Decl is access all Subtype_For_Generic_Package_Decl;
         package Bare_Generic_Package_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Package_Decl, Access_To_Subtype_For_Generic_Package_Decl);

         function Allocate_Generic_Package_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Decl;

         function Allocate_Generic_Package_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Package_Decl := Bare_Generic_Package_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Package_Decl;
            return Bare_Generic_Package_Decl (Result);
         end Allocate_Generic_Package_Decl;

      package Bare_Generic_Subp_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Subp_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Subp_Decl is
            Root_Node_Record (Ada_Generic_Subp_Decl);
         type Access_To_Subtype_For_Generic_Subp_Decl is access all Subtype_For_Generic_Subp_Decl;
         package Bare_Generic_Subp_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Subp_Decl, Access_To_Subtype_For_Generic_Subp_Decl);

         function Allocate_Generic_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Decl;

         function Allocate_Generic_Subp_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Subp_Decl := Bare_Generic_Subp_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Subp_Decl;
            return Bare_Generic_Subp_Decl (Result);
         end Allocate_Generic_Subp_Decl;

      package Bare_Generic_Instantiation_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Instantiation, Token_Index);

      package Bare_Generic_Package_Instantiation_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Package_Instantiation, Token_Index);

         
         subtype Subtype_For_Generic_Package_Instantiation is
            Root_Node_Record (Ada_Generic_Package_Instantiation);
         type Access_To_Subtype_For_Generic_Package_Instantiation is access all Subtype_For_Generic_Package_Instantiation;
         package Bare_Generic_Package_Instantiation_Alloc is new Alloc
           (Subtype_For_Generic_Package_Instantiation, Access_To_Subtype_For_Generic_Package_Instantiation);

         function Allocate_Generic_Package_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Instantiation;

         function Allocate_Generic_Package_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Instantiation
         is
            Result      : constant Access_To_Subtype_For_Generic_Package_Instantiation := Bare_Generic_Package_Instantiation_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Package_Instantiation;
            return Bare_Generic_Package_Instantiation (Result);
         end Allocate_Generic_Package_Instantiation;

      package Bare_Generic_Subp_Instantiation_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Subp_Instantiation, Token_Index);

         
         subtype Subtype_For_Generic_Subp_Instantiation is
            Root_Node_Record (Ada_Generic_Subp_Instantiation);
         type Access_To_Subtype_For_Generic_Subp_Instantiation is access all Subtype_For_Generic_Subp_Instantiation;
         package Bare_Generic_Subp_Instantiation_Alloc is new Alloc
           (Subtype_For_Generic_Subp_Instantiation, Access_To_Subtype_For_Generic_Subp_Instantiation);

         function Allocate_Generic_Subp_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Instantiation;

         function Allocate_Generic_Subp_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Instantiation
         is
            Result      : constant Access_To_Subtype_For_Generic_Subp_Instantiation := Bare_Generic_Subp_Instantiation_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Subp_Instantiation;
            return Bare_Generic_Subp_Instantiation (Result);
         end Allocate_Generic_Subp_Instantiation;

      package Bare_Generic_Renaming_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Renaming_Decl, Token_Index);

      package Bare_Generic_Package_Renaming_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Package_Renaming_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Package_Renaming_Decl is
            Root_Node_Record (Ada_Generic_Package_Renaming_Decl);
         type Access_To_Subtype_For_Generic_Package_Renaming_Decl is access all Subtype_For_Generic_Package_Renaming_Decl;
         package Bare_Generic_Package_Renaming_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Package_Renaming_Decl, Access_To_Subtype_For_Generic_Package_Renaming_Decl);

         function Allocate_Generic_Package_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Renaming_Decl;

         function Allocate_Generic_Package_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Renaming_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Package_Renaming_Decl := Bare_Generic_Package_Renaming_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Package_Renaming_Decl;
            return Bare_Generic_Package_Renaming_Decl (Result);
         end Allocate_Generic_Package_Renaming_Decl;

      package Bare_Generic_Subp_Renaming_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Generic_Subp_Renaming_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Subp_Renaming_Decl is
            Root_Node_Record (Ada_Generic_Subp_Renaming_Decl);
         type Access_To_Subtype_For_Generic_Subp_Renaming_Decl is access all Subtype_For_Generic_Subp_Renaming_Decl;
         package Bare_Generic_Subp_Renaming_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Subp_Renaming_Decl, Access_To_Subtype_For_Generic_Subp_Renaming_Decl);

         function Allocate_Generic_Subp_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Renaming_Decl;

         function Allocate_Generic_Subp_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Renaming_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Subp_Renaming_Decl := Bare_Generic_Subp_Renaming_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Generic_Subp_Renaming_Decl;
            return Bare_Generic_Subp_Renaming_Decl (Result);
         end Allocate_Generic_Subp_Renaming_Decl;

      package Bare_Label_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Label_Decl, Token_Index);

         
         subtype Subtype_For_Label_Decl is
            Root_Node_Record (Ada_Label_Decl);
         type Access_To_Subtype_For_Label_Decl is access all Subtype_For_Label_Decl;
         package Bare_Label_Decl_Alloc is new Alloc
           (Subtype_For_Label_Decl, Access_To_Subtype_For_Label_Decl);

         function Allocate_Label_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Label_Decl;

         function Allocate_Label_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Label_Decl
         is
            Result      : constant Access_To_Subtype_For_Label_Decl := Bare_Label_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Label_Decl;
            return Bare_Label_Decl (Result);
         end Allocate_Label_Decl;

      package Bare_Named_Stmt_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Named_Stmt_Decl, Token_Index);

         
         subtype Subtype_For_Named_Stmt_Decl is
            Root_Node_Record (Ada_Named_Stmt_Decl);
         type Access_To_Subtype_For_Named_Stmt_Decl is access all Subtype_For_Named_Stmt_Decl;
         package Bare_Named_Stmt_Decl_Alloc is new Alloc
           (Subtype_For_Named_Stmt_Decl, Access_To_Subtype_For_Named_Stmt_Decl);

         function Allocate_Named_Stmt_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt_Decl;

         function Allocate_Named_Stmt_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt_Decl
         is
            Result      : constant Access_To_Subtype_For_Named_Stmt_Decl := Bare_Named_Stmt_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Named_Stmt_Decl;
            return Bare_Named_Stmt_Decl (Result);
         end Allocate_Named_Stmt_Decl;

      package Bare_Number_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Number_Decl, Token_Index);

         
         subtype Subtype_For_Number_Decl is
            Root_Node_Record (Ada_Number_Decl);
         type Access_To_Subtype_For_Number_Decl is access all Subtype_For_Number_Decl;
         package Bare_Number_Decl_Alloc is new Alloc
           (Subtype_For_Number_Decl, Access_To_Subtype_For_Number_Decl);

         function Allocate_Number_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Number_Decl;

         function Allocate_Number_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Number_Decl
         is
            Result      : constant Access_To_Subtype_For_Number_Decl := Bare_Number_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Number_Decl;
            return Bare_Number_Decl (Result);
         end Allocate_Number_Decl;

      package Bare_Object_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Object_Decl, Token_Index);

         
         subtype Subtype_For_Object_Decl is
            Root_Node_Record (Ada_Object_Decl);
         type Access_To_Subtype_For_Object_Decl is access all Subtype_For_Object_Decl;
         package Bare_Object_Decl_Alloc is new Alloc
           (Subtype_For_Object_Decl, Access_To_Subtype_For_Object_Decl);

         function Allocate_Object_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Object_Decl;

         function Allocate_Object_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Object_Decl
         is
            Result      : constant Access_To_Subtype_For_Object_Decl := Bare_Object_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Object_Decl;
            return Bare_Object_Decl (Result);
         end Allocate_Object_Decl;

      package Bare_Extended_Return_Stmt_Object_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Extended_Return_Stmt_Object_Decl, Token_Index);

         
         subtype Subtype_For_Extended_Return_Stmt_Object_Decl is
            Root_Node_Record (Ada_Extended_Return_Stmt_Object_Decl);
         type Access_To_Subtype_For_Extended_Return_Stmt_Object_Decl is access all Subtype_For_Extended_Return_Stmt_Object_Decl;
         package Bare_Extended_Return_Stmt_Object_Decl_Alloc is new Alloc
           (Subtype_For_Extended_Return_Stmt_Object_Decl, Access_To_Subtype_For_Extended_Return_Stmt_Object_Decl);

         function Allocate_Extended_Return_Stmt_Object_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt_Object_Decl;

         function Allocate_Extended_Return_Stmt_Object_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt_Object_Decl
         is
            Result      : constant Access_To_Subtype_For_Extended_Return_Stmt_Object_Decl := Bare_Extended_Return_Stmt_Object_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Extended_Return_Stmt_Object_Decl;
            return Bare_Extended_Return_Stmt_Object_Decl (Result);
         end Allocate_Extended_Return_Stmt_Object_Decl;

      package Bare_No_Type_Object_Renaming_Decl_Memos is new Langkit_Support.Packrat
        (Bare_No_Type_Object_Renaming_Decl, Token_Index);

         
         subtype Subtype_For_No_Type_Object_Renaming_Decl is
            Root_Node_Record (Ada_No_Type_Object_Renaming_Decl);
         type Access_To_Subtype_For_No_Type_Object_Renaming_Decl is access all Subtype_For_No_Type_Object_Renaming_Decl;
         package Bare_No_Type_Object_Renaming_Decl_Alloc is new Alloc
           (Subtype_For_No_Type_Object_Renaming_Decl, Access_To_Subtype_For_No_Type_Object_Renaming_Decl);

         function Allocate_No_Type_Object_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_No_Type_Object_Renaming_Decl;

         function Allocate_No_Type_Object_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_No_Type_Object_Renaming_Decl
         is
            Result      : constant Access_To_Subtype_For_No_Type_Object_Renaming_Decl := Bare_No_Type_Object_Renaming_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_No_Type_Object_Renaming_Decl;
            return Bare_No_Type_Object_Renaming_Decl (Result);
         end Allocate_No_Type_Object_Renaming_Decl;

      package Bare_Package_Renaming_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Package_Renaming_Decl, Token_Index);

         
         subtype Subtype_For_Package_Renaming_Decl is
            Root_Node_Record (Ada_Package_Renaming_Decl);
         type Access_To_Subtype_For_Package_Renaming_Decl is access all Subtype_For_Package_Renaming_Decl;
         package Bare_Package_Renaming_Decl_Alloc is new Alloc
           (Subtype_For_Package_Renaming_Decl, Access_To_Subtype_For_Package_Renaming_Decl);

         function Allocate_Package_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Package_Renaming_Decl;

         function Allocate_Package_Renaming_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Package_Renaming_Decl
         is
            Result      : constant Access_To_Subtype_For_Package_Renaming_Decl := Bare_Package_Renaming_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Package_Renaming_Decl;
            return Bare_Package_Renaming_Decl (Result);
         end Allocate_Package_Renaming_Decl;

      package Bare_Single_Protected_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Single_Protected_Decl, Token_Index);

         
         subtype Subtype_For_Single_Protected_Decl is
            Root_Node_Record (Ada_Single_Protected_Decl);
         type Access_To_Subtype_For_Single_Protected_Decl is access all Subtype_For_Single_Protected_Decl;
         package Bare_Single_Protected_Decl_Alloc is new Alloc
           (Subtype_For_Single_Protected_Decl, Access_To_Subtype_For_Single_Protected_Decl);

         function Allocate_Single_Protected_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Single_Protected_Decl;

         function Allocate_Single_Protected_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Single_Protected_Decl
         is
            Result      : constant Access_To_Subtype_For_Single_Protected_Decl := Bare_Single_Protected_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Single_Protected_Decl;
            return Bare_Single_Protected_Decl (Result);
         end Allocate_Single_Protected_Decl;

      package Bare_Single_Task_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Single_Task_Decl, Token_Index);

         
         subtype Subtype_For_Single_Task_Decl is
            Root_Node_Record (Ada_Single_Task_Decl);
         type Access_To_Subtype_For_Single_Task_Decl is access all Subtype_For_Single_Task_Decl;
         package Bare_Single_Task_Decl_Alloc is new Alloc
           (Subtype_For_Single_Task_Decl, Access_To_Subtype_For_Single_Task_Decl);

         function Allocate_Single_Task_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Decl;

         function Allocate_Single_Task_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Decl
         is
            Result      : constant Access_To_Subtype_For_Single_Task_Decl := Bare_Single_Task_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Single_Task_Decl;
            return Bare_Single_Task_Decl (Result);
         end Allocate_Single_Task_Decl;

      package Bare_Case_Stmt_Alternative_Memos is new Langkit_Support.Packrat
        (Bare_Case_Stmt_Alternative, Token_Index);

         
         subtype Subtype_For_Case_Stmt_Alternative is
            Root_Node_Record (Ada_Case_Stmt_Alternative);
         type Access_To_Subtype_For_Case_Stmt_Alternative is access all Subtype_For_Case_Stmt_Alternative;
         package Bare_Case_Stmt_Alternative_Alloc is new Alloc
           (Subtype_For_Case_Stmt_Alternative, Access_To_Subtype_For_Case_Stmt_Alternative);

         function Allocate_Case_Stmt_Alternative
           (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative;

         function Allocate_Case_Stmt_Alternative
           (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative
         is
            Result      : constant Access_To_Subtype_For_Case_Stmt_Alternative := Bare_Case_Stmt_Alternative_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Case_Stmt_Alternative;
            return Bare_Case_Stmt_Alternative (Result);
         end Allocate_Case_Stmt_Alternative;

      package Bare_Compilation_Unit_Memos is new Langkit_Support.Packrat
        (Bare_Compilation_Unit, Token_Index);

         
         subtype Subtype_For_Compilation_Unit is
            Root_Node_Record (Ada_Compilation_Unit);
         type Access_To_Subtype_For_Compilation_Unit is access all Subtype_For_Compilation_Unit;
         package Bare_Compilation_Unit_Alloc is new Alloc
           (Subtype_For_Compilation_Unit, Access_To_Subtype_For_Compilation_Unit);

         function Allocate_Compilation_Unit
           (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit;

         function Allocate_Compilation_Unit
           (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit
         is
            Result      : constant Access_To_Subtype_For_Compilation_Unit := Bare_Compilation_Unit_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Compilation_Unit;
            return Bare_Compilation_Unit (Result);
         end Allocate_Compilation_Unit;

      package Bare_Component_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Component_Clause, Token_Index);

         
         subtype Subtype_For_Component_Clause is
            Root_Node_Record (Ada_Component_Clause);
         type Access_To_Subtype_For_Component_Clause is access all Subtype_For_Component_Clause;
         package Bare_Component_Clause_Alloc is new Alloc
           (Subtype_For_Component_Clause, Access_To_Subtype_For_Component_Clause);

         function Allocate_Component_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Component_Clause;

         function Allocate_Component_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Component_Clause
         is
            Result      : constant Access_To_Subtype_For_Component_Clause := Bare_Component_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Component_Clause;
            return Bare_Component_Clause (Result);
         end Allocate_Component_Clause;

      package Bare_Component_Def_Memos is new Langkit_Support.Packrat
        (Bare_Component_Def, Token_Index);

         
         subtype Subtype_For_Component_Def is
            Root_Node_Record (Ada_Component_Def);
         type Access_To_Subtype_For_Component_Def is access all Subtype_For_Component_Def;
         package Bare_Component_Def_Alloc is new Alloc
           (Subtype_For_Component_Def, Access_To_Subtype_For_Component_Def);

         function Allocate_Component_Def
           (Pool : Bump_Ptr_Pool) return Bare_Component_Def;

         function Allocate_Component_Def
           (Pool : Bump_Ptr_Pool) return Bare_Component_Def
         is
            Result      : constant Access_To_Subtype_For_Component_Def := Bare_Component_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Component_Def;
            return Bare_Component_Def (Result);
         end Allocate_Component_Def;

      package Bare_Constant_Node_Memos is new Langkit_Support.Packrat
        (Bare_Constant_Node, Token_Index);

      package Bare_Constant_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Constant_Absent, Token_Index);

         
         subtype Subtype_For_Constant_Absent is
            Root_Node_Record (Ada_Constant_Absent);
         type Access_To_Subtype_For_Constant_Absent is access all Subtype_For_Constant_Absent;
         package Bare_Constant_Absent_Alloc is new Alloc
           (Subtype_For_Constant_Absent, Access_To_Subtype_For_Constant_Absent);

         function Allocate_Constant_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Constant_Absent;

         function Allocate_Constant_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Constant_Absent
         is
            Result      : constant Access_To_Subtype_For_Constant_Absent := Bare_Constant_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Constant_Absent;
            return Bare_Constant_Absent (Result);
         end Allocate_Constant_Absent;

      package Bare_Constant_Present_Memos is new Langkit_Support.Packrat
        (Bare_Constant_Present, Token_Index);

         
         subtype Subtype_For_Constant_Present is
            Root_Node_Record (Ada_Constant_Present);
         type Access_To_Subtype_For_Constant_Present is access all Subtype_For_Constant_Present;
         package Bare_Constant_Present_Alloc is new Alloc
           (Subtype_For_Constant_Present, Access_To_Subtype_For_Constant_Present);

         function Allocate_Constant_Present
           (Pool : Bump_Ptr_Pool) return Bare_Constant_Present;

         function Allocate_Constant_Present
           (Pool : Bump_Ptr_Pool) return Bare_Constant_Present
         is
            Result      : constant Access_To_Subtype_For_Constant_Present := Bare_Constant_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Constant_Present;
            return Bare_Constant_Present (Result);
         end Allocate_Constant_Present;

      package Bare_Constraint_Memos is new Langkit_Support.Packrat
        (Bare_Constraint, Token_Index);

      package Bare_Composite_Constraint_Memos is new Langkit_Support.Packrat
        (Bare_Composite_Constraint, Token_Index);

         
         subtype Subtype_For_Composite_Constraint is
            Root_Node_Record (Ada_Composite_Constraint);
         type Access_To_Subtype_For_Composite_Constraint is access all Subtype_For_Composite_Constraint;
         package Bare_Composite_Constraint_Alloc is new Alloc
           (Subtype_For_Composite_Constraint, Access_To_Subtype_For_Composite_Constraint);

         function Allocate_Composite_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Composite_Constraint;

         function Allocate_Composite_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Composite_Constraint
         is
            Result      : constant Access_To_Subtype_For_Composite_Constraint := Bare_Composite_Constraint_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Composite_Constraint;
            return Bare_Composite_Constraint (Result);
         end Allocate_Composite_Constraint;

      package Bare_Delta_Constraint_Memos is new Langkit_Support.Packrat
        (Bare_Delta_Constraint, Token_Index);

         
         subtype Subtype_For_Delta_Constraint is
            Root_Node_Record (Ada_Delta_Constraint);
         type Access_To_Subtype_For_Delta_Constraint is access all Subtype_For_Delta_Constraint;
         package Bare_Delta_Constraint_Alloc is new Alloc
           (Subtype_For_Delta_Constraint, Access_To_Subtype_For_Delta_Constraint);

         function Allocate_Delta_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Delta_Constraint;

         function Allocate_Delta_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Delta_Constraint
         is
            Result      : constant Access_To_Subtype_For_Delta_Constraint := Bare_Delta_Constraint_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Delta_Constraint;
            return Bare_Delta_Constraint (Result);
         end Allocate_Delta_Constraint;

      package Bare_Digits_Constraint_Memos is new Langkit_Support.Packrat
        (Bare_Digits_Constraint, Token_Index);

         
         subtype Subtype_For_Digits_Constraint is
            Root_Node_Record (Ada_Digits_Constraint);
         type Access_To_Subtype_For_Digits_Constraint is access all Subtype_For_Digits_Constraint;
         package Bare_Digits_Constraint_Alloc is new Alloc
           (Subtype_For_Digits_Constraint, Access_To_Subtype_For_Digits_Constraint);

         function Allocate_Digits_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Digits_Constraint;

         function Allocate_Digits_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Digits_Constraint
         is
            Result      : constant Access_To_Subtype_For_Digits_Constraint := Bare_Digits_Constraint_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Digits_Constraint;
            return Bare_Digits_Constraint (Result);
         end Allocate_Digits_Constraint;

      package Bare_Range_Constraint_Memos is new Langkit_Support.Packrat
        (Bare_Range_Constraint, Token_Index);

         
         subtype Subtype_For_Range_Constraint is
            Root_Node_Record (Ada_Range_Constraint);
         type Access_To_Subtype_For_Range_Constraint is access all Subtype_For_Range_Constraint;
         package Bare_Range_Constraint_Alloc is new Alloc
           (Subtype_For_Range_Constraint, Access_To_Subtype_For_Range_Constraint);

         function Allocate_Range_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Range_Constraint;

         function Allocate_Range_Constraint
           (Pool : Bump_Ptr_Pool) return Bare_Range_Constraint
         is
            Result      : constant Access_To_Subtype_For_Range_Constraint := Bare_Range_Constraint_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Range_Constraint;
            return Bare_Range_Constraint (Result);
         end Allocate_Range_Constraint;

      package Bare_Declarative_Part_Memos is new Langkit_Support.Packrat
        (Bare_Declarative_Part, Token_Index);

         
         subtype Subtype_For_Declarative_Part is
            Root_Node_Record (Ada_Declarative_Part);
         type Access_To_Subtype_For_Declarative_Part is access all Subtype_For_Declarative_Part;
         package Bare_Declarative_Part_Alloc is new Alloc
           (Subtype_For_Declarative_Part, Access_To_Subtype_For_Declarative_Part);

         function Allocate_Declarative_Part
           (Pool : Bump_Ptr_Pool) return Bare_Declarative_Part;

         function Allocate_Declarative_Part
           (Pool : Bump_Ptr_Pool) return Bare_Declarative_Part
         is
            Result      : constant Access_To_Subtype_For_Declarative_Part := Bare_Declarative_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Declarative_Part;
            return Bare_Declarative_Part (Result);
         end Allocate_Declarative_Part;

      package Bare_Private_Part_Memos is new Langkit_Support.Packrat
        (Bare_Private_Part, Token_Index);

         
         subtype Subtype_For_Private_Part is
            Root_Node_Record (Ada_Private_Part);
         type Access_To_Subtype_For_Private_Part is access all Subtype_For_Private_Part;
         package Bare_Private_Part_Alloc is new Alloc
           (Subtype_For_Private_Part, Access_To_Subtype_For_Private_Part);

         function Allocate_Private_Part
           (Pool : Bump_Ptr_Pool) return Bare_Private_Part;

         function Allocate_Private_Part
           (Pool : Bump_Ptr_Pool) return Bare_Private_Part
         is
            Result      : constant Access_To_Subtype_For_Private_Part := Bare_Private_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Private_Part;
            return Bare_Private_Part (Result);
         end Allocate_Private_Part;

      package Bare_Public_Part_Memos is new Langkit_Support.Packrat
        (Bare_Public_Part, Token_Index);

         
         subtype Subtype_For_Public_Part is
            Root_Node_Record (Ada_Public_Part);
         type Access_To_Subtype_For_Public_Part is access all Subtype_For_Public_Part;
         package Bare_Public_Part_Alloc is new Alloc
           (Subtype_For_Public_Part, Access_To_Subtype_For_Public_Part);

         function Allocate_Public_Part
           (Pool : Bump_Ptr_Pool) return Bare_Public_Part;

         function Allocate_Public_Part
           (Pool : Bump_Ptr_Pool) return Bare_Public_Part
         is
            Result      : constant Access_To_Subtype_For_Public_Part := Bare_Public_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Public_Part;
            return Bare_Public_Part (Result);
         end Allocate_Public_Part;

      package Bare_Elsif_Expr_Part_Memos is new Langkit_Support.Packrat
        (Bare_Elsif_Expr_Part, Token_Index);

         
         subtype Subtype_For_Elsif_Expr_Part is
            Root_Node_Record (Ada_Elsif_Expr_Part);
         type Access_To_Subtype_For_Elsif_Expr_Part is access all Subtype_For_Elsif_Expr_Part;
         package Bare_Elsif_Expr_Part_Alloc is new Alloc
           (Subtype_For_Elsif_Expr_Part, Access_To_Subtype_For_Elsif_Expr_Part);

         function Allocate_Elsif_Expr_Part
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part;

         function Allocate_Elsif_Expr_Part
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part
         is
            Result      : constant Access_To_Subtype_For_Elsif_Expr_Part := Bare_Elsif_Expr_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Elsif_Expr_Part;
            return Bare_Elsif_Expr_Part (Result);
         end Allocate_Elsif_Expr_Part;

      package Bare_Elsif_Stmt_Part_Memos is new Langkit_Support.Packrat
        (Bare_Elsif_Stmt_Part, Token_Index);

         
         subtype Subtype_For_Elsif_Stmt_Part is
            Root_Node_Record (Ada_Elsif_Stmt_Part);
         type Access_To_Subtype_For_Elsif_Stmt_Part is access all Subtype_For_Elsif_Stmt_Part;
         package Bare_Elsif_Stmt_Part_Alloc is new Alloc
           (Subtype_For_Elsif_Stmt_Part, Access_To_Subtype_For_Elsif_Stmt_Part);

         function Allocate_Elsif_Stmt_Part
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part;

         function Allocate_Elsif_Stmt_Part
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part
         is
            Result      : constant Access_To_Subtype_For_Elsif_Stmt_Part := Bare_Elsif_Stmt_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Elsif_Stmt_Part;
            return Bare_Elsif_Stmt_Part (Result);
         end Allocate_Elsif_Stmt_Part;

      package Bare_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Expr, Token_Index);

      package Bare_Abstract_State_Decl_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Abstract_State_Decl_Expr, Token_Index);

         
         subtype Subtype_For_Abstract_State_Decl_Expr is
            Root_Node_Record (Ada_Abstract_State_Decl_Expr);
         type Access_To_Subtype_For_Abstract_State_Decl_Expr is access all Subtype_For_Abstract_State_Decl_Expr;
         package Bare_Abstract_State_Decl_Expr_Alloc is new Alloc
           (Subtype_For_Abstract_State_Decl_Expr, Access_To_Subtype_For_Abstract_State_Decl_Expr);

         function Allocate_Abstract_State_Decl_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_State_Decl_Expr;

         function Allocate_Abstract_State_Decl_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Abstract_State_Decl_Expr
         is
            Result      : constant Access_To_Subtype_For_Abstract_State_Decl_Expr := Bare_Abstract_State_Decl_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abstract_State_Decl_Expr;
            return Bare_Abstract_State_Decl_Expr (Result);
         end Allocate_Abstract_State_Decl_Expr;

      package Bare_Allocator_Memos is new Langkit_Support.Packrat
        (Bare_Allocator, Token_Index);

         
         subtype Subtype_For_Allocator is
            Root_Node_Record (Ada_Allocator);
         type Access_To_Subtype_For_Allocator is access all Subtype_For_Allocator;
         package Bare_Allocator_Alloc is new Alloc
           (Subtype_For_Allocator, Access_To_Subtype_For_Allocator);

         function Allocate_Allocator
           (Pool : Bump_Ptr_Pool) return Bare_Allocator;

         function Allocate_Allocator
           (Pool : Bump_Ptr_Pool) return Bare_Allocator
         is
            Result      : constant Access_To_Subtype_For_Allocator := Bare_Allocator_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Allocator;
            return Bare_Allocator (Result);
         end Allocate_Allocator;

      package Bare_Base_Aggregate_Memos is new Langkit_Support.Packrat
        (Bare_Base_Aggregate, Token_Index);

      package Bare_Aggregate_Memos is new Langkit_Support.Packrat
        (Bare_Aggregate, Token_Index);

         
         subtype Subtype_For_Aggregate is
            Root_Node_Record (Ada_Aggregate);
         type Access_To_Subtype_For_Aggregate is access all Subtype_For_Aggregate;
         package Bare_Aggregate_Alloc is new Alloc
           (Subtype_For_Aggregate, Access_To_Subtype_For_Aggregate);

         function Allocate_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Aggregate;

         function Allocate_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Aggregate
         is
            Result      : constant Access_To_Subtype_For_Aggregate := Bare_Aggregate_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Aggregate;
            return Bare_Aggregate (Result);
         end Allocate_Aggregate;

      package Bare_Bracket_Aggregate_Memos is new Langkit_Support.Packrat
        (Bare_Bracket_Aggregate, Token_Index);

         
         subtype Subtype_For_Bracket_Aggregate is
            Root_Node_Record (Ada_Bracket_Aggregate);
         type Access_To_Subtype_For_Bracket_Aggregate is access all Subtype_For_Bracket_Aggregate;
         package Bare_Bracket_Aggregate_Alloc is new Alloc
           (Subtype_For_Bracket_Aggregate, Access_To_Subtype_For_Bracket_Aggregate);

         function Allocate_Bracket_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Bracket_Aggregate;

         function Allocate_Bracket_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Bracket_Aggregate
         is
            Result      : constant Access_To_Subtype_For_Bracket_Aggregate := Bare_Bracket_Aggregate_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Bracket_Aggregate;
            return Bare_Bracket_Aggregate (Result);
         end Allocate_Bracket_Aggregate;

      package Bare_Delta_Aggregate_Memos is new Langkit_Support.Packrat
        (Bare_Delta_Aggregate, Token_Index);

         
         subtype Subtype_For_Delta_Aggregate is
            Root_Node_Record (Ada_Delta_Aggregate);
         type Access_To_Subtype_For_Delta_Aggregate is access all Subtype_For_Delta_Aggregate;
         package Bare_Delta_Aggregate_Alloc is new Alloc
           (Subtype_For_Delta_Aggregate, Access_To_Subtype_For_Delta_Aggregate);

         function Allocate_Delta_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Delta_Aggregate;

         function Allocate_Delta_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Delta_Aggregate
         is
            Result      : constant Access_To_Subtype_For_Delta_Aggregate := Bare_Delta_Aggregate_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Delta_Aggregate;
            return Bare_Delta_Aggregate (Result);
         end Allocate_Delta_Aggregate;

      package Bare_Bracket_Delta_Aggregate_Memos is new Langkit_Support.Packrat
        (Bare_Bracket_Delta_Aggregate, Token_Index);

         
         subtype Subtype_For_Bracket_Delta_Aggregate is
            Root_Node_Record (Ada_Bracket_Delta_Aggregate);
         type Access_To_Subtype_For_Bracket_Delta_Aggregate is access all Subtype_For_Bracket_Delta_Aggregate;
         package Bare_Bracket_Delta_Aggregate_Alloc is new Alloc
           (Subtype_For_Bracket_Delta_Aggregate, Access_To_Subtype_For_Bracket_Delta_Aggregate);

         function Allocate_Bracket_Delta_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Bracket_Delta_Aggregate;

         function Allocate_Bracket_Delta_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Bracket_Delta_Aggregate
         is
            Result      : constant Access_To_Subtype_For_Bracket_Delta_Aggregate := Bare_Bracket_Delta_Aggregate_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Bracket_Delta_Aggregate;
            return Bare_Bracket_Delta_Aggregate (Result);
         end Allocate_Bracket_Delta_Aggregate;

      package Bare_Null_Record_Aggregate_Memos is new Langkit_Support.Packrat
        (Bare_Null_Record_Aggregate, Token_Index);

         
         subtype Subtype_For_Null_Record_Aggregate is
            Root_Node_Record (Ada_Null_Record_Aggregate);
         type Access_To_Subtype_For_Null_Record_Aggregate is access all Subtype_For_Null_Record_Aggregate;
         package Bare_Null_Record_Aggregate_Alloc is new Alloc
           (Subtype_For_Null_Record_Aggregate, Access_To_Subtype_For_Null_Record_Aggregate);

         function Allocate_Null_Record_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Aggregate;

         function Allocate_Null_Record_Aggregate
           (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Aggregate
         is
            Result      : constant Access_To_Subtype_For_Null_Record_Aggregate := Bare_Null_Record_Aggregate_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Null_Record_Aggregate;
            return Bare_Null_Record_Aggregate (Result);
         end Allocate_Null_Record_Aggregate;

      package Bare_Bin_Op_Memos is new Langkit_Support.Packrat
        (Bare_Bin_Op, Token_Index);

         
         subtype Subtype_For_Bin_Op is
            Root_Node_Record (Ada_Bin_Op);
         type Access_To_Subtype_For_Bin_Op is access all Subtype_For_Bin_Op;
         package Bare_Bin_Op_Alloc is new Alloc
           (Subtype_For_Bin_Op, Access_To_Subtype_For_Bin_Op);

         function Allocate_Bin_Op
           (Pool : Bump_Ptr_Pool) return Bare_Bin_Op;

         function Allocate_Bin_Op
           (Pool : Bump_Ptr_Pool) return Bare_Bin_Op
         is
            Result      : constant Access_To_Subtype_For_Bin_Op := Bare_Bin_Op_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Bin_Op;
            return Bare_Bin_Op (Result);
         end Allocate_Bin_Op;

      package Bare_Relation_Op_Memos is new Langkit_Support.Packrat
        (Bare_Relation_Op, Token_Index);

         
         subtype Subtype_For_Relation_Op is
            Root_Node_Record (Ada_Relation_Op);
         type Access_To_Subtype_For_Relation_Op is access all Subtype_For_Relation_Op;
         package Bare_Relation_Op_Alloc is new Alloc
           (Subtype_For_Relation_Op, Access_To_Subtype_For_Relation_Op);

         function Allocate_Relation_Op
           (Pool : Bump_Ptr_Pool) return Bare_Relation_Op;

         function Allocate_Relation_Op
           (Pool : Bump_Ptr_Pool) return Bare_Relation_Op
         is
            Result      : constant Access_To_Subtype_For_Relation_Op := Bare_Relation_Op_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Relation_Op;
            return Bare_Relation_Op (Result);
         end Allocate_Relation_Op;

      package Bare_Box_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Box_Expr, Token_Index);

         
         subtype Subtype_For_Box_Expr is
            Root_Node_Record (Ada_Box_Expr);
         type Access_To_Subtype_For_Box_Expr is access all Subtype_For_Box_Expr;
         package Bare_Box_Expr_Alloc is new Alloc
           (Subtype_For_Box_Expr, Access_To_Subtype_For_Box_Expr);

         function Allocate_Box_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Box_Expr;

         function Allocate_Box_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Box_Expr
         is
            Result      : constant Access_To_Subtype_For_Box_Expr := Bare_Box_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Box_Expr;
            return Bare_Box_Expr (Result);
         end Allocate_Box_Expr;

      package Bare_Case_Expr_Alternative_Memos is new Langkit_Support.Packrat
        (Bare_Case_Expr_Alternative, Token_Index);

         
         subtype Subtype_For_Case_Expr_Alternative is
            Root_Node_Record (Ada_Case_Expr_Alternative);
         type Access_To_Subtype_For_Case_Expr_Alternative is access all Subtype_For_Case_Expr_Alternative;
         package Bare_Case_Expr_Alternative_Alloc is new Alloc
           (Subtype_For_Case_Expr_Alternative, Access_To_Subtype_For_Case_Expr_Alternative);

         function Allocate_Case_Expr_Alternative
           (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative;

         function Allocate_Case_Expr_Alternative
           (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative
         is
            Result      : constant Access_To_Subtype_For_Case_Expr_Alternative := Bare_Case_Expr_Alternative_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Case_Expr_Alternative;
            return Bare_Case_Expr_Alternative (Result);
         end Allocate_Case_Expr_Alternative;

      package Bare_Concat_Op_Memos is new Langkit_Support.Packrat
        (Bare_Concat_Op, Token_Index);

         
         subtype Subtype_For_Concat_Op is
            Root_Node_Record (Ada_Concat_Op);
         type Access_To_Subtype_For_Concat_Op is access all Subtype_For_Concat_Op;
         package Bare_Concat_Op_Alloc is new Alloc
           (Subtype_For_Concat_Op, Access_To_Subtype_For_Concat_Op);

         function Allocate_Concat_Op
           (Pool : Bump_Ptr_Pool) return Bare_Concat_Op;

         function Allocate_Concat_Op
           (Pool : Bump_Ptr_Pool) return Bare_Concat_Op
         is
            Result      : constant Access_To_Subtype_For_Concat_Op := Bare_Concat_Op_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Concat_Op;
            return Bare_Concat_Op (Result);
         end Allocate_Concat_Op;

      package Bare_Concat_Operand_Memos is new Langkit_Support.Packrat
        (Bare_Concat_Operand, Token_Index);

         
         subtype Subtype_For_Concat_Operand is
            Root_Node_Record (Ada_Concat_Operand);
         type Access_To_Subtype_For_Concat_Operand is access all Subtype_For_Concat_Operand;
         package Bare_Concat_Operand_Alloc is new Alloc
           (Subtype_For_Concat_Operand, Access_To_Subtype_For_Concat_Operand);

         function Allocate_Concat_Operand
           (Pool : Bump_Ptr_Pool) return Bare_Concat_Operand;

         function Allocate_Concat_Operand
           (Pool : Bump_Ptr_Pool) return Bare_Concat_Operand
         is
            Result      : constant Access_To_Subtype_For_Concat_Operand := Bare_Concat_Operand_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Concat_Operand;
            return Bare_Concat_Operand (Result);
         end Allocate_Concat_Operand;

      package Bare_Cond_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Cond_Expr, Token_Index);

      package Bare_Case_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Case_Expr, Token_Index);

         
         subtype Subtype_For_Case_Expr is
            Root_Node_Record (Ada_Case_Expr);
         type Access_To_Subtype_For_Case_Expr is access all Subtype_For_Case_Expr;
         package Bare_Case_Expr_Alloc is new Alloc
           (Subtype_For_Case_Expr, Access_To_Subtype_For_Case_Expr);

         function Allocate_Case_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Case_Expr;

         function Allocate_Case_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Case_Expr
         is
            Result      : constant Access_To_Subtype_For_Case_Expr := Bare_Case_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Case_Expr;
            return Bare_Case_Expr (Result);
         end Allocate_Case_Expr;

      package Bare_If_Expr_Memos is new Langkit_Support.Packrat
        (Bare_If_Expr, Token_Index);

         
         subtype Subtype_For_If_Expr is
            Root_Node_Record (Ada_If_Expr);
         type Access_To_Subtype_For_If_Expr is access all Subtype_For_If_Expr;
         package Bare_If_Expr_Alloc is new Alloc
           (Subtype_For_If_Expr, Access_To_Subtype_For_If_Expr);

         function Allocate_If_Expr
           (Pool : Bump_Ptr_Pool) return Bare_If_Expr;

         function Allocate_If_Expr
           (Pool : Bump_Ptr_Pool) return Bare_If_Expr
         is
            Result      : constant Access_To_Subtype_For_If_Expr := Bare_If_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_If_Expr;
            return Bare_If_Expr (Result);
         end Allocate_If_Expr;

      package Bare_Contract_Cases_Memos is new Langkit_Support.Packrat
        (Bare_Contract_Cases, Token_Index);

         
         subtype Subtype_For_Contract_Cases is
            Root_Node_Record (Ada_Contract_Cases);
         type Access_To_Subtype_For_Contract_Cases is access all Subtype_For_Contract_Cases;
         package Bare_Contract_Cases_Alloc is new Alloc
           (Subtype_For_Contract_Cases, Access_To_Subtype_For_Contract_Cases);

         function Allocate_Contract_Cases
           (Pool : Bump_Ptr_Pool) return Bare_Contract_Cases;

         function Allocate_Contract_Cases
           (Pool : Bump_Ptr_Pool) return Bare_Contract_Cases
         is
            Result      : constant Access_To_Subtype_For_Contract_Cases := Bare_Contract_Cases_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Contract_Cases;
            return Bare_Contract_Cases (Result);
         end Allocate_Contract_Cases;

      package Bare_Decl_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Decl_Expr, Token_Index);

         
         subtype Subtype_For_Decl_Expr is
            Root_Node_Record (Ada_Decl_Expr);
         type Access_To_Subtype_For_Decl_Expr is access all Subtype_For_Decl_Expr;
         package Bare_Decl_Expr_Alloc is new Alloc
           (Subtype_For_Decl_Expr, Access_To_Subtype_For_Decl_Expr);

         function Allocate_Decl_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Expr;

         function Allocate_Decl_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Expr
         is
            Result      : constant Access_To_Subtype_For_Decl_Expr := Bare_Decl_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Decl_Expr;
            return Bare_Decl_Expr (Result);
         end Allocate_Decl_Expr;

      package Bare_Membership_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Membership_Expr, Token_Index);

         
         subtype Subtype_For_Membership_Expr is
            Root_Node_Record (Ada_Membership_Expr);
         type Access_To_Subtype_For_Membership_Expr is access all Subtype_For_Membership_Expr;
         package Bare_Membership_Expr_Alloc is new Alloc
           (Subtype_For_Membership_Expr, Access_To_Subtype_For_Membership_Expr);

         function Allocate_Membership_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Membership_Expr;

         function Allocate_Membership_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Membership_Expr
         is
            Result      : constant Access_To_Subtype_For_Membership_Expr := Bare_Membership_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Membership_Expr;
            return Bare_Membership_Expr (Result);
         end Allocate_Membership_Expr;

      package Bare_Name_Memos is new Langkit_Support.Packrat
        (Bare_Name, Token_Index);

      package Bare_Attribute_Ref_Memos is new Langkit_Support.Packrat
        (Bare_Attribute_Ref, Token_Index);

         
         subtype Subtype_For_Attribute_Ref is
            Root_Node_Record (Ada_Attribute_Ref);
         type Access_To_Subtype_For_Attribute_Ref is access all Subtype_For_Attribute_Ref;
         package Bare_Attribute_Ref_Alloc is new Alloc
           (Subtype_For_Attribute_Ref, Access_To_Subtype_For_Attribute_Ref);

         function Allocate_Attribute_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Attribute_Ref;

         function Allocate_Attribute_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Attribute_Ref
         is
            Result      : constant Access_To_Subtype_For_Attribute_Ref := Bare_Attribute_Ref_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Attribute_Ref;
            return Bare_Attribute_Ref (Result);
         end Allocate_Attribute_Ref;

      package Bare_Call_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Call_Expr, Token_Index);

         
         subtype Subtype_For_Call_Expr is
            Root_Node_Record (Ada_Call_Expr);
         type Access_To_Subtype_For_Call_Expr is access all Subtype_For_Call_Expr;
         package Bare_Call_Expr_Alloc is new Alloc
           (Subtype_For_Call_Expr, Access_To_Subtype_For_Call_Expr);

         function Allocate_Call_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr;

         function Allocate_Call_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr
         is
            Result      : constant Access_To_Subtype_For_Call_Expr := Bare_Call_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Call_Expr;
            return Bare_Call_Expr (Result);
         end Allocate_Call_Expr;

      package Bare_Defining_Name_Memos is new Langkit_Support.Packrat
        (Bare_Defining_Name, Token_Index);

         
         subtype Subtype_For_Defining_Name is
            Root_Node_Record (Ada_Defining_Name);
         type Access_To_Subtype_For_Defining_Name is access all Subtype_For_Defining_Name;
         package Bare_Defining_Name_Alloc is new Alloc
           (Subtype_For_Defining_Name, Access_To_Subtype_For_Defining_Name);

         function Allocate_Defining_Name
           (Pool : Bump_Ptr_Pool) return Bare_Defining_Name;

         function Allocate_Defining_Name
           (Pool : Bump_Ptr_Pool) return Bare_Defining_Name
         is
            Result      : constant Access_To_Subtype_For_Defining_Name := Bare_Defining_Name_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Defining_Name;
            return Bare_Defining_Name (Result);
         end Allocate_Defining_Name;

      package Bare_Synthetic_Defining_Name_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Defining_Name, Token_Index);

         
         subtype Subtype_For_Synthetic_Defining_Name is
            Root_Node_Record (Ada_Synthetic_Defining_Name);
         type Access_To_Subtype_For_Synthetic_Defining_Name is access all Subtype_For_Synthetic_Defining_Name;
         package Bare_Synthetic_Defining_Name_Alloc is new Alloc
           (Subtype_For_Synthetic_Defining_Name, Access_To_Subtype_For_Synthetic_Defining_Name);

         function Allocate_Synthetic_Defining_Name
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Defining_Name;

         function Allocate_Synthetic_Defining_Name
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Defining_Name
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Defining_Name := Bare_Synthetic_Defining_Name_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Defining_Name;
            return Bare_Synthetic_Defining_Name (Result);
         end Allocate_Synthetic_Defining_Name;

      package Bare_Discrete_Subtype_Name_Memos is new Langkit_Support.Packrat
        (Bare_Discrete_Subtype_Name, Token_Index);

         
         subtype Subtype_For_Discrete_Subtype_Name is
            Root_Node_Record (Ada_Discrete_Subtype_Name);
         type Access_To_Subtype_For_Discrete_Subtype_Name is access all Subtype_For_Discrete_Subtype_Name;
         package Bare_Discrete_Subtype_Name_Alloc is new Alloc
           (Subtype_For_Discrete_Subtype_Name, Access_To_Subtype_For_Discrete_Subtype_Name);

         function Allocate_Discrete_Subtype_Name
           (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Name;

         function Allocate_Discrete_Subtype_Name
           (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Name
         is
            Result      : constant Access_To_Subtype_For_Discrete_Subtype_Name := Bare_Discrete_Subtype_Name_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Discrete_Subtype_Name;
            return Bare_Discrete_Subtype_Name (Result);
         end Allocate_Discrete_Subtype_Name;

      package Bare_Dotted_Name_Memos is new Langkit_Support.Packrat
        (Bare_Dotted_Name, Token_Index);

         
         subtype Subtype_For_Dotted_Name is
            Root_Node_Record (Ada_Dotted_Name);
         type Access_To_Subtype_For_Dotted_Name is access all Subtype_For_Dotted_Name;
         package Bare_Dotted_Name_Alloc is new Alloc
           (Subtype_For_Dotted_Name, Access_To_Subtype_For_Dotted_Name);

         function Allocate_Dotted_Name
           (Pool : Bump_Ptr_Pool) return Bare_Dotted_Name;

         function Allocate_Dotted_Name
           (Pool : Bump_Ptr_Pool) return Bare_Dotted_Name
         is
            Result      : constant Access_To_Subtype_For_Dotted_Name := Bare_Dotted_Name_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Dotted_Name;
            return Bare_Dotted_Name (Result);
         end Allocate_Dotted_Name;

      package Bare_End_Name_Memos is new Langkit_Support.Packrat
        (Bare_End_Name, Token_Index);

         
         subtype Subtype_For_End_Name is
            Root_Node_Record (Ada_End_Name);
         type Access_To_Subtype_For_End_Name is access all Subtype_For_End_Name;
         package Bare_End_Name_Alloc is new Alloc
           (Subtype_For_End_Name, Access_To_Subtype_For_End_Name);

         function Allocate_End_Name
           (Pool : Bump_Ptr_Pool) return Bare_End_Name;

         function Allocate_End_Name
           (Pool : Bump_Ptr_Pool) return Bare_End_Name
         is
            Result      : constant Access_To_Subtype_For_End_Name := Bare_End_Name_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_End_Name;
            return Bare_End_Name (Result);
         end Allocate_End_Name;

      package Bare_Explicit_Deref_Memos is new Langkit_Support.Packrat
        (Bare_Explicit_Deref, Token_Index);

         
         subtype Subtype_For_Explicit_Deref is
            Root_Node_Record (Ada_Explicit_Deref);
         type Access_To_Subtype_For_Explicit_Deref is access all Subtype_For_Explicit_Deref;
         package Bare_Explicit_Deref_Alloc is new Alloc
           (Subtype_For_Explicit_Deref, Access_To_Subtype_For_Explicit_Deref);

         function Allocate_Explicit_Deref
           (Pool : Bump_Ptr_Pool) return Bare_Explicit_Deref;

         function Allocate_Explicit_Deref
           (Pool : Bump_Ptr_Pool) return Bare_Explicit_Deref
         is
            Result      : constant Access_To_Subtype_For_Explicit_Deref := Bare_Explicit_Deref_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Explicit_Deref;
            return Bare_Explicit_Deref (Result);
         end Allocate_Explicit_Deref;

      package Bare_Qual_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Qual_Expr, Token_Index);

         
         subtype Subtype_For_Qual_Expr is
            Root_Node_Record (Ada_Qual_Expr);
         type Access_To_Subtype_For_Qual_Expr is access all Subtype_For_Qual_Expr;
         package Bare_Qual_Expr_Alloc is new Alloc
           (Subtype_For_Qual_Expr, Access_To_Subtype_For_Qual_Expr);

         function Allocate_Qual_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Qual_Expr;

         function Allocate_Qual_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Qual_Expr
         is
            Result      : constant Access_To_Subtype_For_Qual_Expr := Bare_Qual_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Qual_Expr;
            return Bare_Qual_Expr (Result);
         end Allocate_Qual_Expr;

      package Bare_Reduce_Attribute_Ref_Memos is new Langkit_Support.Packrat
        (Bare_Reduce_Attribute_Ref, Token_Index);

         
         subtype Subtype_For_Reduce_Attribute_Ref is
            Root_Node_Record (Ada_Reduce_Attribute_Ref);
         type Access_To_Subtype_For_Reduce_Attribute_Ref is access all Subtype_For_Reduce_Attribute_Ref;
         package Bare_Reduce_Attribute_Ref_Alloc is new Alloc
           (Subtype_For_Reduce_Attribute_Ref, Access_To_Subtype_For_Reduce_Attribute_Ref);

         function Allocate_Reduce_Attribute_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Reduce_Attribute_Ref;

         function Allocate_Reduce_Attribute_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Reduce_Attribute_Ref
         is
            Result      : constant Access_To_Subtype_For_Reduce_Attribute_Ref := Bare_Reduce_Attribute_Ref_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Reduce_Attribute_Ref;
            return Bare_Reduce_Attribute_Ref (Result);
         end Allocate_Reduce_Attribute_Ref;

      package Bare_Single_Tok_Node_Memos is new Langkit_Support.Packrat
        (Bare_Single_Tok_Node, Token_Index);

      package Bare_Base_Id_Memos is new Langkit_Support.Packrat
        (Bare_Base_Id, Token_Index);

      package Bare_Char_Literal_Memos is new Langkit_Support.Packrat
        (Bare_Char_Literal, Token_Index);

         
         subtype Subtype_For_Char_Literal is
            Root_Node_Record (Ada_Char_Literal);
         type Access_To_Subtype_For_Char_Literal is access all Subtype_For_Char_Literal;
         package Bare_Char_Literal_Alloc is new Alloc
           (Subtype_For_Char_Literal, Access_To_Subtype_For_Char_Literal);

         function Allocate_Char_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Char_Literal;

         function Allocate_Char_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Char_Literal
         is
            Result      : constant Access_To_Subtype_For_Char_Literal := Bare_Char_Literal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Char_Literal;
            return Bare_Char_Literal (Result);
         end Allocate_Char_Literal;

      package Bare_Identifier_Memos is new Langkit_Support.Packrat
        (Bare_Identifier, Token_Index);

         
         subtype Subtype_For_Identifier is
            Root_Node_Record (Ada_Identifier);
         type Access_To_Subtype_For_Identifier is access all Subtype_For_Identifier;
         package Bare_Identifier_Alloc is new Alloc
           (Subtype_For_Identifier, Access_To_Subtype_For_Identifier);

         function Allocate_Identifier
           (Pool : Bump_Ptr_Pool) return Bare_Identifier;

         function Allocate_Identifier
           (Pool : Bump_Ptr_Pool) return Bare_Identifier
         is
            Result      : constant Access_To_Subtype_For_Identifier := Bare_Identifier_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Identifier;
            return Bare_Identifier (Result);
         end Allocate_Identifier;

      package Bare_Op_Memos is new Langkit_Support.Packrat
        (Bare_Op, Token_Index);

      package Bare_Op_Abs_Memos is new Langkit_Support.Packrat
        (Bare_Op_Abs, Token_Index);

         
         subtype Subtype_For_Op_Abs is
            Root_Node_Record (Ada_Op_Abs);
         type Access_To_Subtype_For_Op_Abs is access all Subtype_For_Op_Abs;
         package Bare_Op_Abs_Alloc is new Alloc
           (Subtype_For_Op_Abs, Access_To_Subtype_For_Op_Abs);

         function Allocate_Op_Abs
           (Pool : Bump_Ptr_Pool) return Bare_Op_Abs;

         function Allocate_Op_Abs
           (Pool : Bump_Ptr_Pool) return Bare_Op_Abs
         is
            Result      : constant Access_To_Subtype_For_Op_Abs := Bare_Op_Abs_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Abs;
            return Bare_Op_Abs (Result);
         end Allocate_Op_Abs;

      package Bare_Op_And_Memos is new Langkit_Support.Packrat
        (Bare_Op_And, Token_Index);

         
         subtype Subtype_For_Op_And is
            Root_Node_Record (Ada_Op_And);
         type Access_To_Subtype_For_Op_And is access all Subtype_For_Op_And;
         package Bare_Op_And_Alloc is new Alloc
           (Subtype_For_Op_And, Access_To_Subtype_For_Op_And);

         function Allocate_Op_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_And;

         function Allocate_Op_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_And
         is
            Result      : constant Access_To_Subtype_For_Op_And := Bare_Op_And_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_And;
            return Bare_Op_And (Result);
         end Allocate_Op_And;

      package Bare_Op_And_Then_Memos is new Langkit_Support.Packrat
        (Bare_Op_And_Then, Token_Index);

         
         subtype Subtype_For_Op_And_Then is
            Root_Node_Record (Ada_Op_And_Then);
         type Access_To_Subtype_For_Op_And_Then is access all Subtype_For_Op_And_Then;
         package Bare_Op_And_Then_Alloc is new Alloc
           (Subtype_For_Op_And_Then, Access_To_Subtype_For_Op_And_Then);

         function Allocate_Op_And_Then
           (Pool : Bump_Ptr_Pool) return Bare_Op_And_Then;

         function Allocate_Op_And_Then
           (Pool : Bump_Ptr_Pool) return Bare_Op_And_Then
         is
            Result      : constant Access_To_Subtype_For_Op_And_Then := Bare_Op_And_Then_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_And_Then;
            return Bare_Op_And_Then (Result);
         end Allocate_Op_And_Then;

      package Bare_Op_Concat_Memos is new Langkit_Support.Packrat
        (Bare_Op_Concat, Token_Index);

         
         subtype Subtype_For_Op_Concat is
            Root_Node_Record (Ada_Op_Concat);
         type Access_To_Subtype_For_Op_Concat is access all Subtype_For_Op_Concat;
         package Bare_Op_Concat_Alloc is new Alloc
           (Subtype_For_Op_Concat, Access_To_Subtype_For_Op_Concat);

         function Allocate_Op_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Op_Concat;

         function Allocate_Op_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Op_Concat
         is
            Result      : constant Access_To_Subtype_For_Op_Concat := Bare_Op_Concat_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Concat;
            return Bare_Op_Concat (Result);
         end Allocate_Op_Concat;

      package Bare_Op_Div_Memos is new Langkit_Support.Packrat
        (Bare_Op_Div, Token_Index);

         
         subtype Subtype_For_Op_Div is
            Root_Node_Record (Ada_Op_Div);
         type Access_To_Subtype_For_Op_Div is access all Subtype_For_Op_Div;
         package Bare_Op_Div_Alloc is new Alloc
           (Subtype_For_Op_Div, Access_To_Subtype_For_Op_Div);

         function Allocate_Op_Div
           (Pool : Bump_Ptr_Pool) return Bare_Op_Div;

         function Allocate_Op_Div
           (Pool : Bump_Ptr_Pool) return Bare_Op_Div
         is
            Result      : constant Access_To_Subtype_For_Op_Div := Bare_Op_Div_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Div;
            return Bare_Op_Div (Result);
         end Allocate_Op_Div;

      package Bare_Op_Double_Dot_Memos is new Langkit_Support.Packrat
        (Bare_Op_Double_Dot, Token_Index);

         
         subtype Subtype_For_Op_Double_Dot is
            Root_Node_Record (Ada_Op_Double_Dot);
         type Access_To_Subtype_For_Op_Double_Dot is access all Subtype_For_Op_Double_Dot;
         package Bare_Op_Double_Dot_Alloc is new Alloc
           (Subtype_For_Op_Double_Dot, Access_To_Subtype_For_Op_Double_Dot);

         function Allocate_Op_Double_Dot
           (Pool : Bump_Ptr_Pool) return Bare_Op_Double_Dot;

         function Allocate_Op_Double_Dot
           (Pool : Bump_Ptr_Pool) return Bare_Op_Double_Dot
         is
            Result      : constant Access_To_Subtype_For_Op_Double_Dot := Bare_Op_Double_Dot_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Double_Dot;
            return Bare_Op_Double_Dot (Result);
         end Allocate_Op_Double_Dot;

      package Bare_Op_Eq_Memos is new Langkit_Support.Packrat
        (Bare_Op_Eq, Token_Index);

         
         subtype Subtype_For_Op_Eq is
            Root_Node_Record (Ada_Op_Eq);
         type Access_To_Subtype_For_Op_Eq is access all Subtype_For_Op_Eq;
         package Bare_Op_Eq_Alloc is new Alloc
           (Subtype_For_Op_Eq, Access_To_Subtype_For_Op_Eq);

         function Allocate_Op_Eq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Eq;

         function Allocate_Op_Eq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Eq
         is
            Result      : constant Access_To_Subtype_For_Op_Eq := Bare_Op_Eq_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Eq;
            return Bare_Op_Eq (Result);
         end Allocate_Op_Eq;

      package Bare_Op_Gt_Memos is new Langkit_Support.Packrat
        (Bare_Op_Gt, Token_Index);

         
         subtype Subtype_For_Op_Gt is
            Root_Node_Record (Ada_Op_Gt);
         type Access_To_Subtype_For_Op_Gt is access all Subtype_For_Op_Gt;
         package Bare_Op_Gt_Alloc is new Alloc
           (Subtype_For_Op_Gt, Access_To_Subtype_For_Op_Gt);

         function Allocate_Op_Gt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gt;

         function Allocate_Op_Gt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gt
         is
            Result      : constant Access_To_Subtype_For_Op_Gt := Bare_Op_Gt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Gt;
            return Bare_Op_Gt (Result);
         end Allocate_Op_Gt;

      package Bare_Op_Gte_Memos is new Langkit_Support.Packrat
        (Bare_Op_Gte, Token_Index);

         
         subtype Subtype_For_Op_Gte is
            Root_Node_Record (Ada_Op_Gte);
         type Access_To_Subtype_For_Op_Gte is access all Subtype_For_Op_Gte;
         package Bare_Op_Gte_Alloc is new Alloc
           (Subtype_For_Op_Gte, Access_To_Subtype_For_Op_Gte);

         function Allocate_Op_Gte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gte;

         function Allocate_Op_Gte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gte
         is
            Result      : constant Access_To_Subtype_For_Op_Gte := Bare_Op_Gte_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Gte;
            return Bare_Op_Gte (Result);
         end Allocate_Op_Gte;

      package Bare_Op_In_Memos is new Langkit_Support.Packrat
        (Bare_Op_In, Token_Index);

         
         subtype Subtype_For_Op_In is
            Root_Node_Record (Ada_Op_In);
         type Access_To_Subtype_For_Op_In is access all Subtype_For_Op_In;
         package Bare_Op_In_Alloc is new Alloc
           (Subtype_For_Op_In, Access_To_Subtype_For_Op_In);

         function Allocate_Op_In
           (Pool : Bump_Ptr_Pool) return Bare_Op_In;

         function Allocate_Op_In
           (Pool : Bump_Ptr_Pool) return Bare_Op_In
         is
            Result      : constant Access_To_Subtype_For_Op_In := Bare_Op_In_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_In;
            return Bare_Op_In (Result);
         end Allocate_Op_In;

      package Bare_Op_Lt_Memos is new Langkit_Support.Packrat
        (Bare_Op_Lt, Token_Index);

         
         subtype Subtype_For_Op_Lt is
            Root_Node_Record (Ada_Op_Lt);
         type Access_To_Subtype_For_Op_Lt is access all Subtype_For_Op_Lt;
         package Bare_Op_Lt_Alloc is new Alloc
           (Subtype_For_Op_Lt, Access_To_Subtype_For_Op_Lt);

         function Allocate_Op_Lt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lt;

         function Allocate_Op_Lt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lt
         is
            Result      : constant Access_To_Subtype_For_Op_Lt := Bare_Op_Lt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Lt;
            return Bare_Op_Lt (Result);
         end Allocate_Op_Lt;

      package Bare_Op_Lte_Memos is new Langkit_Support.Packrat
        (Bare_Op_Lte, Token_Index);

         
         subtype Subtype_For_Op_Lte is
            Root_Node_Record (Ada_Op_Lte);
         type Access_To_Subtype_For_Op_Lte is access all Subtype_For_Op_Lte;
         package Bare_Op_Lte_Alloc is new Alloc
           (Subtype_For_Op_Lte, Access_To_Subtype_For_Op_Lte);

         function Allocate_Op_Lte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lte;

         function Allocate_Op_Lte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lte
         is
            Result      : constant Access_To_Subtype_For_Op_Lte := Bare_Op_Lte_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Lte;
            return Bare_Op_Lte (Result);
         end Allocate_Op_Lte;

      package Bare_Op_Minus_Memos is new Langkit_Support.Packrat
        (Bare_Op_Minus, Token_Index);

         
         subtype Subtype_For_Op_Minus is
            Root_Node_Record (Ada_Op_Minus);
         type Access_To_Subtype_For_Op_Minus is access all Subtype_For_Op_Minus;
         package Bare_Op_Minus_Alloc is new Alloc
           (Subtype_For_Op_Minus, Access_To_Subtype_For_Op_Minus);

         function Allocate_Op_Minus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Minus;

         function Allocate_Op_Minus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Minus
         is
            Result      : constant Access_To_Subtype_For_Op_Minus := Bare_Op_Minus_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Minus;
            return Bare_Op_Minus (Result);
         end Allocate_Op_Minus;

      package Bare_Op_Mod_Memos is new Langkit_Support.Packrat
        (Bare_Op_Mod, Token_Index);

         
         subtype Subtype_For_Op_Mod is
            Root_Node_Record (Ada_Op_Mod);
         type Access_To_Subtype_For_Op_Mod is access all Subtype_For_Op_Mod;
         package Bare_Op_Mod_Alloc is new Alloc
           (Subtype_For_Op_Mod, Access_To_Subtype_For_Op_Mod);

         function Allocate_Op_Mod
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mod;

         function Allocate_Op_Mod
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mod
         is
            Result      : constant Access_To_Subtype_For_Op_Mod := Bare_Op_Mod_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Mod;
            return Bare_Op_Mod (Result);
         end Allocate_Op_Mod;

      package Bare_Op_Mult_Memos is new Langkit_Support.Packrat
        (Bare_Op_Mult, Token_Index);

         
         subtype Subtype_For_Op_Mult is
            Root_Node_Record (Ada_Op_Mult);
         type Access_To_Subtype_For_Op_Mult is access all Subtype_For_Op_Mult;
         package Bare_Op_Mult_Alloc is new Alloc
           (Subtype_For_Op_Mult, Access_To_Subtype_For_Op_Mult);

         function Allocate_Op_Mult
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mult;

         function Allocate_Op_Mult
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mult
         is
            Result      : constant Access_To_Subtype_For_Op_Mult := Bare_Op_Mult_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Mult;
            return Bare_Op_Mult (Result);
         end Allocate_Op_Mult;

      package Bare_Op_Neq_Memos is new Langkit_Support.Packrat
        (Bare_Op_Neq, Token_Index);

         
         subtype Subtype_For_Op_Neq is
            Root_Node_Record (Ada_Op_Neq);
         type Access_To_Subtype_For_Op_Neq is access all Subtype_For_Op_Neq;
         package Bare_Op_Neq_Alloc is new Alloc
           (Subtype_For_Op_Neq, Access_To_Subtype_For_Op_Neq);

         function Allocate_Op_Neq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Neq;

         function Allocate_Op_Neq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Neq
         is
            Result      : constant Access_To_Subtype_For_Op_Neq := Bare_Op_Neq_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Neq;
            return Bare_Op_Neq (Result);
         end Allocate_Op_Neq;

      package Bare_Op_Not_Memos is new Langkit_Support.Packrat
        (Bare_Op_Not, Token_Index);

         
         subtype Subtype_For_Op_Not is
            Root_Node_Record (Ada_Op_Not);
         type Access_To_Subtype_For_Op_Not is access all Subtype_For_Op_Not;
         package Bare_Op_Not_Alloc is new Alloc
           (Subtype_For_Op_Not, Access_To_Subtype_For_Op_Not);

         function Allocate_Op_Not
           (Pool : Bump_Ptr_Pool) return Bare_Op_Not;

         function Allocate_Op_Not
           (Pool : Bump_Ptr_Pool) return Bare_Op_Not
         is
            Result      : constant Access_To_Subtype_For_Op_Not := Bare_Op_Not_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Not;
            return Bare_Op_Not (Result);
         end Allocate_Op_Not;

      package Bare_Op_Not_In_Memos is new Langkit_Support.Packrat
        (Bare_Op_Not_In, Token_Index);

         
         subtype Subtype_For_Op_Not_In is
            Root_Node_Record (Ada_Op_Not_In);
         type Access_To_Subtype_For_Op_Not_In is access all Subtype_For_Op_Not_In;
         package Bare_Op_Not_In_Alloc is new Alloc
           (Subtype_For_Op_Not_In, Access_To_Subtype_For_Op_Not_In);

         function Allocate_Op_Not_In
           (Pool : Bump_Ptr_Pool) return Bare_Op_Not_In;

         function Allocate_Op_Not_In
           (Pool : Bump_Ptr_Pool) return Bare_Op_Not_In
         is
            Result      : constant Access_To_Subtype_For_Op_Not_In := Bare_Op_Not_In_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Not_In;
            return Bare_Op_Not_In (Result);
         end Allocate_Op_Not_In;

      package Bare_Op_Or_Memos is new Langkit_Support.Packrat
        (Bare_Op_Or, Token_Index);

         
         subtype Subtype_For_Op_Or is
            Root_Node_Record (Ada_Op_Or);
         type Access_To_Subtype_For_Op_Or is access all Subtype_For_Op_Or;
         package Bare_Op_Or_Alloc is new Alloc
           (Subtype_For_Op_Or, Access_To_Subtype_For_Op_Or);

         function Allocate_Op_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or;

         function Allocate_Op_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or
         is
            Result      : constant Access_To_Subtype_For_Op_Or := Bare_Op_Or_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Or;
            return Bare_Op_Or (Result);
         end Allocate_Op_Or;

      package Bare_Op_Or_Else_Memos is new Langkit_Support.Packrat
        (Bare_Op_Or_Else, Token_Index);

         
         subtype Subtype_For_Op_Or_Else is
            Root_Node_Record (Ada_Op_Or_Else);
         type Access_To_Subtype_For_Op_Or_Else is access all Subtype_For_Op_Or_Else;
         package Bare_Op_Or_Else_Alloc is new Alloc
           (Subtype_For_Op_Or_Else, Access_To_Subtype_For_Op_Or_Else);

         function Allocate_Op_Or_Else
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Else;

         function Allocate_Op_Or_Else
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Else
         is
            Result      : constant Access_To_Subtype_For_Op_Or_Else := Bare_Op_Or_Else_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Or_Else;
            return Bare_Op_Or_Else (Result);
         end Allocate_Op_Or_Else;

      package Bare_Op_Plus_Memos is new Langkit_Support.Packrat
        (Bare_Op_Plus, Token_Index);

         
         subtype Subtype_For_Op_Plus is
            Root_Node_Record (Ada_Op_Plus);
         type Access_To_Subtype_For_Op_Plus is access all Subtype_For_Op_Plus;
         package Bare_Op_Plus_Alloc is new Alloc
           (Subtype_For_Op_Plus, Access_To_Subtype_For_Op_Plus);

         function Allocate_Op_Plus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Plus;

         function Allocate_Op_Plus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Plus
         is
            Result      : constant Access_To_Subtype_For_Op_Plus := Bare_Op_Plus_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Plus;
            return Bare_Op_Plus (Result);
         end Allocate_Op_Plus;

      package Bare_Op_Pow_Memos is new Langkit_Support.Packrat
        (Bare_Op_Pow, Token_Index);

         
         subtype Subtype_For_Op_Pow is
            Root_Node_Record (Ada_Op_Pow);
         type Access_To_Subtype_For_Op_Pow is access all Subtype_For_Op_Pow;
         package Bare_Op_Pow_Alloc is new Alloc
           (Subtype_For_Op_Pow, Access_To_Subtype_For_Op_Pow);

         function Allocate_Op_Pow
           (Pool : Bump_Ptr_Pool) return Bare_Op_Pow;

         function Allocate_Op_Pow
           (Pool : Bump_Ptr_Pool) return Bare_Op_Pow
         is
            Result      : constant Access_To_Subtype_For_Op_Pow := Bare_Op_Pow_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Pow;
            return Bare_Op_Pow (Result);
         end Allocate_Op_Pow;

      package Bare_Op_Rem_Memos is new Langkit_Support.Packrat
        (Bare_Op_Rem, Token_Index);

         
         subtype Subtype_For_Op_Rem is
            Root_Node_Record (Ada_Op_Rem);
         type Access_To_Subtype_For_Op_Rem is access all Subtype_For_Op_Rem;
         package Bare_Op_Rem_Alloc is new Alloc
           (Subtype_For_Op_Rem, Access_To_Subtype_For_Op_Rem);

         function Allocate_Op_Rem
           (Pool : Bump_Ptr_Pool) return Bare_Op_Rem;

         function Allocate_Op_Rem
           (Pool : Bump_Ptr_Pool) return Bare_Op_Rem
         is
            Result      : constant Access_To_Subtype_For_Op_Rem := Bare_Op_Rem_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Rem;
            return Bare_Op_Rem (Result);
         end Allocate_Op_Rem;

      package Bare_Op_Xor_Memos is new Langkit_Support.Packrat
        (Bare_Op_Xor, Token_Index);

         
         subtype Subtype_For_Op_Xor is
            Root_Node_Record (Ada_Op_Xor);
         type Access_To_Subtype_For_Op_Xor is access all Subtype_For_Op_Xor;
         package Bare_Op_Xor_Alloc is new Alloc
           (Subtype_For_Op_Xor, Access_To_Subtype_For_Op_Xor);

         function Allocate_Op_Xor
           (Pool : Bump_Ptr_Pool) return Bare_Op_Xor;

         function Allocate_Op_Xor
           (Pool : Bump_Ptr_Pool) return Bare_Op_Xor
         is
            Result      : constant Access_To_Subtype_For_Op_Xor := Bare_Op_Xor_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Op_Xor;
            return Bare_Op_Xor (Result);
         end Allocate_Op_Xor;

      package Bare_String_Literal_Memos is new Langkit_Support.Packrat
        (Bare_String_Literal, Token_Index);

         
         subtype Subtype_For_String_Literal is
            Root_Node_Record (Ada_String_Literal);
         type Access_To_Subtype_For_String_Literal is access all Subtype_For_String_Literal;
         package Bare_String_Literal_Alloc is new Alloc
           (Subtype_For_String_Literal, Access_To_Subtype_For_String_Literal);

         function Allocate_String_Literal
           (Pool : Bump_Ptr_Pool) return Bare_String_Literal;

         function Allocate_String_Literal
           (Pool : Bump_Ptr_Pool) return Bare_String_Literal
         is
            Result      : constant Access_To_Subtype_For_String_Literal := Bare_String_Literal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_String_Literal;
            return Bare_String_Literal (Result);
         end Allocate_String_Literal;

      package Bare_Null_Literal_Memos is new Langkit_Support.Packrat
        (Bare_Null_Literal, Token_Index);

         
         subtype Subtype_For_Null_Literal is
            Root_Node_Record (Ada_Null_Literal);
         type Access_To_Subtype_For_Null_Literal is access all Subtype_For_Null_Literal;
         package Bare_Null_Literal_Alloc is new Alloc
           (Subtype_For_Null_Literal, Access_To_Subtype_For_Null_Literal);

         function Allocate_Null_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Null_Literal;

         function Allocate_Null_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Null_Literal
         is
            Result      : constant Access_To_Subtype_For_Null_Literal := Bare_Null_Literal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Null_Literal;
            return Bare_Null_Literal (Result);
         end Allocate_Null_Literal;

      package Bare_Num_Literal_Memos is new Langkit_Support.Packrat
        (Bare_Num_Literal, Token_Index);

      package Bare_Int_Literal_Memos is new Langkit_Support.Packrat
        (Bare_Int_Literal, Token_Index);

         
         subtype Subtype_For_Int_Literal is
            Root_Node_Record (Ada_Int_Literal);
         type Access_To_Subtype_For_Int_Literal is access all Subtype_For_Int_Literal;
         package Bare_Int_Literal_Alloc is new Alloc
           (Subtype_For_Int_Literal, Access_To_Subtype_For_Int_Literal);

         function Allocate_Int_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Int_Literal;

         function Allocate_Int_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Int_Literal
         is
            Result      : constant Access_To_Subtype_For_Int_Literal := Bare_Int_Literal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Int_Literal;
            return Bare_Int_Literal (Result);
         end Allocate_Int_Literal;

      package Bare_Real_Literal_Memos is new Langkit_Support.Packrat
        (Bare_Real_Literal, Token_Index);

         
         subtype Subtype_For_Real_Literal is
            Root_Node_Record (Ada_Real_Literal);
         type Access_To_Subtype_For_Real_Literal is access all Subtype_For_Real_Literal;
         package Bare_Real_Literal_Alloc is new Alloc
           (Subtype_For_Real_Literal, Access_To_Subtype_For_Real_Literal);

         function Allocate_Real_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Real_Literal;

         function Allocate_Real_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Real_Literal
         is
            Result      : constant Access_To_Subtype_For_Real_Literal := Bare_Real_Literal_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Real_Literal;
            return Bare_Real_Literal (Result);
         end Allocate_Real_Literal;

      package Bare_Synthetic_Identifier_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Identifier, Token_Index);

         
         subtype Subtype_For_Synthetic_Identifier is
            Root_Node_Record (Ada_Synthetic_Identifier);
         type Access_To_Subtype_For_Synthetic_Identifier is access all Subtype_For_Synthetic_Identifier;
         package Bare_Synthetic_Identifier_Alloc is new Alloc
           (Subtype_For_Synthetic_Identifier, Access_To_Subtype_For_Synthetic_Identifier);

         function Allocate_Synthetic_Identifier
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Identifier;

         function Allocate_Synthetic_Identifier
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Identifier
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Identifier := Bare_Synthetic_Identifier_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Identifier;
            return Bare_Synthetic_Identifier (Result);
         end Allocate_Synthetic_Identifier;

      package Bare_Target_Name_Memos is new Langkit_Support.Packrat
        (Bare_Target_Name, Token_Index);

         
         subtype Subtype_For_Target_Name is
            Root_Node_Record (Ada_Target_Name);
         type Access_To_Subtype_For_Target_Name is access all Subtype_For_Target_Name;
         package Bare_Target_Name_Alloc is new Alloc
           (Subtype_For_Target_Name, Access_To_Subtype_For_Target_Name);

         function Allocate_Target_Name
           (Pool : Bump_Ptr_Pool) return Bare_Target_Name;

         function Allocate_Target_Name
           (Pool : Bump_Ptr_Pool) return Bare_Target_Name
         is
            Result      : constant Access_To_Subtype_For_Target_Name := Bare_Target_Name_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Target_Name;
            return Bare_Target_Name (Result);
         end Allocate_Target_Name;

      package Bare_Update_Attribute_Ref_Memos is new Langkit_Support.Packrat
        (Bare_Update_Attribute_Ref, Token_Index);

         
         subtype Subtype_For_Update_Attribute_Ref is
            Root_Node_Record (Ada_Update_Attribute_Ref);
         type Access_To_Subtype_For_Update_Attribute_Ref is access all Subtype_For_Update_Attribute_Ref;
         package Bare_Update_Attribute_Ref_Alloc is new Alloc
           (Subtype_For_Update_Attribute_Ref, Access_To_Subtype_For_Update_Attribute_Ref);

         function Allocate_Update_Attribute_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Update_Attribute_Ref;

         function Allocate_Update_Attribute_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Update_Attribute_Ref
         is
            Result      : constant Access_To_Subtype_For_Update_Attribute_Ref := Bare_Update_Attribute_Ref_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Update_Attribute_Ref;
            return Bare_Update_Attribute_Ref (Result);
         end Allocate_Update_Attribute_Ref;

      package Bare_Paren_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Paren_Expr, Token_Index);

         
         subtype Subtype_For_Paren_Expr is
            Root_Node_Record (Ada_Paren_Expr);
         type Access_To_Subtype_For_Paren_Expr is access all Subtype_For_Paren_Expr;
         package Bare_Paren_Expr_Alloc is new Alloc
           (Subtype_For_Paren_Expr, Access_To_Subtype_For_Paren_Expr);

         function Allocate_Paren_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr;

         function Allocate_Paren_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr
         is
            Result      : constant Access_To_Subtype_For_Paren_Expr := Bare_Paren_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Paren_Expr;
            return Bare_Paren_Expr (Result);
         end Allocate_Paren_Expr;

      package Bare_Quantified_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Quantified_Expr, Token_Index);

         
         subtype Subtype_For_Quantified_Expr is
            Root_Node_Record (Ada_Quantified_Expr);
         type Access_To_Subtype_For_Quantified_Expr is access all Subtype_For_Quantified_Expr;
         package Bare_Quantified_Expr_Alloc is new Alloc
           (Subtype_For_Quantified_Expr, Access_To_Subtype_For_Quantified_Expr);

         function Allocate_Quantified_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Quantified_Expr;

         function Allocate_Quantified_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Quantified_Expr
         is
            Result      : constant Access_To_Subtype_For_Quantified_Expr := Bare_Quantified_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Quantified_Expr;
            return Bare_Quantified_Expr (Result);
         end Allocate_Quantified_Expr;

      package Bare_Raise_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Raise_Expr, Token_Index);

         
         subtype Subtype_For_Raise_Expr is
            Root_Node_Record (Ada_Raise_Expr);
         type Access_To_Subtype_For_Raise_Expr is access all Subtype_For_Raise_Expr;
         package Bare_Raise_Expr_Alloc is new Alloc
           (Subtype_For_Raise_Expr, Access_To_Subtype_For_Raise_Expr);

         function Allocate_Raise_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr;

         function Allocate_Raise_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr
         is
            Result      : constant Access_To_Subtype_For_Raise_Expr := Bare_Raise_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Raise_Expr;
            return Bare_Raise_Expr (Result);
         end Allocate_Raise_Expr;

      package Bare_Un_Op_Memos is new Langkit_Support.Packrat
        (Bare_Un_Op, Token_Index);

         
         subtype Subtype_For_Un_Op is
            Root_Node_Record (Ada_Un_Op);
         type Access_To_Subtype_For_Un_Op is access all Subtype_For_Un_Op;
         package Bare_Un_Op_Alloc is new Alloc
           (Subtype_For_Un_Op, Access_To_Subtype_For_Un_Op);

         function Allocate_Un_Op
           (Pool : Bump_Ptr_Pool) return Bare_Un_Op;

         function Allocate_Un_Op
           (Pool : Bump_Ptr_Pool) return Bare_Un_Op
         is
            Result      : constant Access_To_Subtype_For_Un_Op := Bare_Un_Op_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Un_Op;
            return Bare_Un_Op (Result);
         end Allocate_Un_Op;

      package Bare_Handled_Stmts_Memos is new Langkit_Support.Packrat
        (Bare_Handled_Stmts, Token_Index);

         
         subtype Subtype_For_Handled_Stmts is
            Root_Node_Record (Ada_Handled_Stmts);
         type Access_To_Subtype_For_Handled_Stmts is access all Subtype_For_Handled_Stmts;
         package Bare_Handled_Stmts_Alloc is new Alloc
           (Subtype_For_Handled_Stmts, Access_To_Subtype_For_Handled_Stmts);

         function Allocate_Handled_Stmts
           (Pool : Bump_Ptr_Pool) return Bare_Handled_Stmts;

         function Allocate_Handled_Stmts
           (Pool : Bump_Ptr_Pool) return Bare_Handled_Stmts
         is
            Result      : constant Access_To_Subtype_For_Handled_Stmts := Bare_Handled_Stmts_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Handled_Stmts;
            return Bare_Handled_Stmts (Result);
         end Allocate_Handled_Stmts;

      package Bare_Interface_Kind_Memos is new Langkit_Support.Packrat
        (Bare_Interface_Kind, Token_Index);

      package Bare_Interface_Kind_Limited_Memos is new Langkit_Support.Packrat
        (Bare_Interface_Kind_Limited, Token_Index);

         
         subtype Subtype_For_Interface_Kind_Limited is
            Root_Node_Record (Ada_Interface_Kind_Limited);
         type Access_To_Subtype_For_Interface_Kind_Limited is access all Subtype_For_Interface_Kind_Limited;
         package Bare_Interface_Kind_Limited_Alloc is new Alloc
           (Subtype_For_Interface_Kind_Limited, Access_To_Subtype_For_Interface_Kind_Limited);

         function Allocate_Interface_Kind_Limited
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Limited;

         function Allocate_Interface_Kind_Limited
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Limited
         is
            Result      : constant Access_To_Subtype_For_Interface_Kind_Limited := Bare_Interface_Kind_Limited_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Interface_Kind_Limited;
            return Bare_Interface_Kind_Limited (Result);
         end Allocate_Interface_Kind_Limited;

      package Bare_Interface_Kind_Protected_Memos is new Langkit_Support.Packrat
        (Bare_Interface_Kind_Protected, Token_Index);

         
         subtype Subtype_For_Interface_Kind_Protected is
            Root_Node_Record (Ada_Interface_Kind_Protected);
         type Access_To_Subtype_For_Interface_Kind_Protected is access all Subtype_For_Interface_Kind_Protected;
         package Bare_Interface_Kind_Protected_Alloc is new Alloc
           (Subtype_For_Interface_Kind_Protected, Access_To_Subtype_For_Interface_Kind_Protected);

         function Allocate_Interface_Kind_Protected
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Protected;

         function Allocate_Interface_Kind_Protected
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Protected
         is
            Result      : constant Access_To_Subtype_For_Interface_Kind_Protected := Bare_Interface_Kind_Protected_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Interface_Kind_Protected;
            return Bare_Interface_Kind_Protected (Result);
         end Allocate_Interface_Kind_Protected;

      package Bare_Interface_Kind_Synchronized_Memos is new Langkit_Support.Packrat
        (Bare_Interface_Kind_Synchronized, Token_Index);

         
         subtype Subtype_For_Interface_Kind_Synchronized is
            Root_Node_Record (Ada_Interface_Kind_Synchronized);
         type Access_To_Subtype_For_Interface_Kind_Synchronized is access all Subtype_For_Interface_Kind_Synchronized;
         package Bare_Interface_Kind_Synchronized_Alloc is new Alloc
           (Subtype_For_Interface_Kind_Synchronized, Access_To_Subtype_For_Interface_Kind_Synchronized);

         function Allocate_Interface_Kind_Synchronized
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Synchronized;

         function Allocate_Interface_Kind_Synchronized
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Synchronized
         is
            Result      : constant Access_To_Subtype_For_Interface_Kind_Synchronized := Bare_Interface_Kind_Synchronized_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Interface_Kind_Synchronized;
            return Bare_Interface_Kind_Synchronized (Result);
         end Allocate_Interface_Kind_Synchronized;

      package Bare_Interface_Kind_Task_Memos is new Langkit_Support.Packrat
        (Bare_Interface_Kind_Task, Token_Index);

         
         subtype Subtype_For_Interface_Kind_Task is
            Root_Node_Record (Ada_Interface_Kind_Task);
         type Access_To_Subtype_For_Interface_Kind_Task is access all Subtype_For_Interface_Kind_Task;
         package Bare_Interface_Kind_Task_Alloc is new Alloc
           (Subtype_For_Interface_Kind_Task, Access_To_Subtype_For_Interface_Kind_Task);

         function Allocate_Interface_Kind_Task
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Task;

         function Allocate_Interface_Kind_Task
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Task
         is
            Result      : constant Access_To_Subtype_For_Interface_Kind_Task := Bare_Interface_Kind_Task_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Interface_Kind_Task;
            return Bare_Interface_Kind_Task (Result);
         end Allocate_Interface_Kind_Task;

      package Bare_Iter_Type_Memos is new Langkit_Support.Packrat
        (Bare_Iter_Type, Token_Index);

      package Bare_Iter_Type_In_Memos is new Langkit_Support.Packrat
        (Bare_Iter_Type_In, Token_Index);

         
         subtype Subtype_For_Iter_Type_In is
            Root_Node_Record (Ada_Iter_Type_In);
         type Access_To_Subtype_For_Iter_Type_In is access all Subtype_For_Iter_Type_In;
         package Bare_Iter_Type_In_Alloc is new Alloc
           (Subtype_For_Iter_Type_In, Access_To_Subtype_For_Iter_Type_In);

         function Allocate_Iter_Type_In
           (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_In;

         function Allocate_Iter_Type_In
           (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_In
         is
            Result      : constant Access_To_Subtype_For_Iter_Type_In := Bare_Iter_Type_In_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Iter_Type_In;
            return Bare_Iter_Type_In (Result);
         end Allocate_Iter_Type_In;

      package Bare_Iter_Type_Of_Memos is new Langkit_Support.Packrat
        (Bare_Iter_Type_Of, Token_Index);

         
         subtype Subtype_For_Iter_Type_Of is
            Root_Node_Record (Ada_Iter_Type_Of);
         type Access_To_Subtype_For_Iter_Type_Of is access all Subtype_For_Iter_Type_Of;
         package Bare_Iter_Type_Of_Alloc is new Alloc
           (Subtype_For_Iter_Type_Of, Access_To_Subtype_For_Iter_Type_Of);

         function Allocate_Iter_Type_Of
           (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_Of;

         function Allocate_Iter_Type_Of
           (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_Of
         is
            Result      : constant Access_To_Subtype_For_Iter_Type_Of := Bare_Iter_Type_Of_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Iter_Type_Of;
            return Bare_Iter_Type_Of (Result);
         end Allocate_Iter_Type_Of;

      package Bare_Library_Item_Memos is new Langkit_Support.Packrat
        (Bare_Library_Item, Token_Index);

         
         subtype Subtype_For_Library_Item is
            Root_Node_Record (Ada_Library_Item);
         type Access_To_Subtype_For_Library_Item is access all Subtype_For_Library_Item;
         package Bare_Library_Item_Alloc is new Alloc
           (Subtype_For_Library_Item, Access_To_Subtype_For_Library_Item);

         function Allocate_Library_Item
           (Pool : Bump_Ptr_Pool) return Bare_Library_Item;

         function Allocate_Library_Item
           (Pool : Bump_Ptr_Pool) return Bare_Library_Item
         is
            Result      : constant Access_To_Subtype_For_Library_Item := Bare_Library_Item_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Library_Item;
            return Bare_Library_Item (Result);
         end Allocate_Library_Item;

      package Bare_Limited_Node_Memos is new Langkit_Support.Packrat
        (Bare_Limited_Node, Token_Index);

      package Bare_Limited_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Limited_Absent, Token_Index);

         
         subtype Subtype_For_Limited_Absent is
            Root_Node_Record (Ada_Limited_Absent);
         type Access_To_Subtype_For_Limited_Absent is access all Subtype_For_Limited_Absent;
         package Bare_Limited_Absent_Alloc is new Alloc
           (Subtype_For_Limited_Absent, Access_To_Subtype_For_Limited_Absent);

         function Allocate_Limited_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Limited_Absent;

         function Allocate_Limited_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Limited_Absent
         is
            Result      : constant Access_To_Subtype_For_Limited_Absent := Bare_Limited_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Limited_Absent;
            return Bare_Limited_Absent (Result);
         end Allocate_Limited_Absent;

      package Bare_Limited_Present_Memos is new Langkit_Support.Packrat
        (Bare_Limited_Present, Token_Index);

         
         subtype Subtype_For_Limited_Present is
            Root_Node_Record (Ada_Limited_Present);
         type Access_To_Subtype_For_Limited_Present is access all Subtype_For_Limited_Present;
         package Bare_Limited_Present_Alloc is new Alloc
           (Subtype_For_Limited_Present, Access_To_Subtype_For_Limited_Present);

         function Allocate_Limited_Present
           (Pool : Bump_Ptr_Pool) return Bare_Limited_Present;

         function Allocate_Limited_Present
           (Pool : Bump_Ptr_Pool) return Bare_Limited_Present
         is
            Result      : constant Access_To_Subtype_For_Limited_Present := Bare_Limited_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Limited_Present;
            return Bare_Limited_Present (Result);
         end Allocate_Limited_Present;

      package Bare_Loop_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Loop_Spec, Token_Index);

      package Bare_For_Loop_Spec_Memos is new Langkit_Support.Packrat
        (Bare_For_Loop_Spec, Token_Index);

         
         subtype Subtype_For_For_Loop_Spec is
            Root_Node_Record (Ada_For_Loop_Spec);
         type Access_To_Subtype_For_For_Loop_Spec is access all Subtype_For_For_Loop_Spec;
         package Bare_For_Loop_Spec_Alloc is new Alloc
           (Subtype_For_For_Loop_Spec, Access_To_Subtype_For_For_Loop_Spec);

         function Allocate_For_Loop_Spec
           (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Spec;

         function Allocate_For_Loop_Spec
           (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Spec
         is
            Result      : constant Access_To_Subtype_For_For_Loop_Spec := Bare_For_Loop_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_For_Loop_Spec;
            return Bare_For_Loop_Spec (Result);
         end Allocate_For_Loop_Spec;

      package Bare_While_Loop_Spec_Memos is new Langkit_Support.Packrat
        (Bare_While_Loop_Spec, Token_Index);

         
         subtype Subtype_For_While_Loop_Spec is
            Root_Node_Record (Ada_While_Loop_Spec);
         type Access_To_Subtype_For_While_Loop_Spec is access all Subtype_For_While_Loop_Spec;
         package Bare_While_Loop_Spec_Alloc is new Alloc
           (Subtype_For_While_Loop_Spec, Access_To_Subtype_For_While_Loop_Spec);

         function Allocate_While_Loop_Spec
           (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Spec;

         function Allocate_While_Loop_Spec
           (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Spec
         is
            Result      : constant Access_To_Subtype_For_While_Loop_Spec := Bare_While_Loop_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_While_Loop_Spec;
            return Bare_While_Loop_Spec (Result);
         end Allocate_While_Loop_Spec;

      package Bare_Mode_Memos is new Langkit_Support.Packrat
        (Bare_Mode, Token_Index);

      package Bare_Mode_Default_Memos is new Langkit_Support.Packrat
        (Bare_Mode_Default, Token_Index);

         
         subtype Subtype_For_Mode_Default is
            Root_Node_Record (Ada_Mode_Default);
         type Access_To_Subtype_For_Mode_Default is access all Subtype_For_Mode_Default;
         package Bare_Mode_Default_Alloc is new Alloc
           (Subtype_For_Mode_Default, Access_To_Subtype_For_Mode_Default);

         function Allocate_Mode_Default
           (Pool : Bump_Ptr_Pool) return Bare_Mode_Default;

         function Allocate_Mode_Default
           (Pool : Bump_Ptr_Pool) return Bare_Mode_Default
         is
            Result      : constant Access_To_Subtype_For_Mode_Default := Bare_Mode_Default_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Mode_Default;
            return Bare_Mode_Default (Result);
         end Allocate_Mode_Default;

      package Bare_Mode_In_Memos is new Langkit_Support.Packrat
        (Bare_Mode_In, Token_Index);

         
         subtype Subtype_For_Mode_In is
            Root_Node_Record (Ada_Mode_In);
         type Access_To_Subtype_For_Mode_In is access all Subtype_For_Mode_In;
         package Bare_Mode_In_Alloc is new Alloc
           (Subtype_For_Mode_In, Access_To_Subtype_For_Mode_In);

         function Allocate_Mode_In
           (Pool : Bump_Ptr_Pool) return Bare_Mode_In;

         function Allocate_Mode_In
           (Pool : Bump_Ptr_Pool) return Bare_Mode_In
         is
            Result      : constant Access_To_Subtype_For_Mode_In := Bare_Mode_In_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Mode_In;
            return Bare_Mode_In (Result);
         end Allocate_Mode_In;

      package Bare_Mode_In_Out_Memos is new Langkit_Support.Packrat
        (Bare_Mode_In_Out, Token_Index);

         
         subtype Subtype_For_Mode_In_Out is
            Root_Node_Record (Ada_Mode_In_Out);
         type Access_To_Subtype_For_Mode_In_Out is access all Subtype_For_Mode_In_Out;
         package Bare_Mode_In_Out_Alloc is new Alloc
           (Subtype_For_Mode_In_Out, Access_To_Subtype_For_Mode_In_Out);

         function Allocate_Mode_In_Out
           (Pool : Bump_Ptr_Pool) return Bare_Mode_In_Out;

         function Allocate_Mode_In_Out
           (Pool : Bump_Ptr_Pool) return Bare_Mode_In_Out
         is
            Result      : constant Access_To_Subtype_For_Mode_In_Out := Bare_Mode_In_Out_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Mode_In_Out;
            return Bare_Mode_In_Out (Result);
         end Allocate_Mode_In_Out;

      package Bare_Mode_Out_Memos is new Langkit_Support.Packrat
        (Bare_Mode_Out, Token_Index);

         
         subtype Subtype_For_Mode_Out is
            Root_Node_Record (Ada_Mode_Out);
         type Access_To_Subtype_For_Mode_Out is access all Subtype_For_Mode_Out;
         package Bare_Mode_Out_Alloc is new Alloc
           (Subtype_For_Mode_Out, Access_To_Subtype_For_Mode_Out);

         function Allocate_Mode_Out
           (Pool : Bump_Ptr_Pool) return Bare_Mode_Out;

         function Allocate_Mode_Out
           (Pool : Bump_Ptr_Pool) return Bare_Mode_Out
         is
            Result      : constant Access_To_Subtype_For_Mode_Out := Bare_Mode_Out_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Mode_Out;
            return Bare_Mode_Out (Result);
         end Allocate_Mode_Out;

      package Bare_Multi_Abstract_State_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Multi_Abstract_State_Decl, Token_Index);

         
         subtype Subtype_For_Multi_Abstract_State_Decl is
            Root_Node_Record (Ada_Multi_Abstract_State_Decl);
         type Access_To_Subtype_For_Multi_Abstract_State_Decl is access all Subtype_For_Multi_Abstract_State_Decl;
         package Bare_Multi_Abstract_State_Decl_Alloc is new Alloc
           (Subtype_For_Multi_Abstract_State_Decl, Access_To_Subtype_For_Multi_Abstract_State_Decl);

         function Allocate_Multi_Abstract_State_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Multi_Abstract_State_Decl;

         function Allocate_Multi_Abstract_State_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Multi_Abstract_State_Decl
         is
            Result      : constant Access_To_Subtype_For_Multi_Abstract_State_Decl := Bare_Multi_Abstract_State_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Multi_Abstract_State_Decl;
            return Bare_Multi_Abstract_State_Decl (Result);
         end Allocate_Multi_Abstract_State_Decl;

      package Bare_Not_Null_Memos is new Langkit_Support.Packrat
        (Bare_Not_Null, Token_Index);

      package Bare_Not_Null_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Not_Null_Absent, Token_Index);

         
         subtype Subtype_For_Not_Null_Absent is
            Root_Node_Record (Ada_Not_Null_Absent);
         type Access_To_Subtype_For_Not_Null_Absent is access all Subtype_For_Not_Null_Absent;
         package Bare_Not_Null_Absent_Alloc is new Alloc
           (Subtype_For_Not_Null_Absent, Access_To_Subtype_For_Not_Null_Absent);

         function Allocate_Not_Null_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Absent;

         function Allocate_Not_Null_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Absent
         is
            Result      : constant Access_To_Subtype_For_Not_Null_Absent := Bare_Not_Null_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Not_Null_Absent;
            return Bare_Not_Null_Absent (Result);
         end Allocate_Not_Null_Absent;

      package Bare_Not_Null_Present_Memos is new Langkit_Support.Packrat
        (Bare_Not_Null_Present, Token_Index);

         
         subtype Subtype_For_Not_Null_Present is
            Root_Node_Record (Ada_Not_Null_Present);
         type Access_To_Subtype_For_Not_Null_Present is access all Subtype_For_Not_Null_Present;
         package Bare_Not_Null_Present_Alloc is new Alloc
           (Subtype_For_Not_Null_Present, Access_To_Subtype_For_Not_Null_Present);

         function Allocate_Not_Null_Present
           (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Present;

         function Allocate_Not_Null_Present
           (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Present
         is
            Result      : constant Access_To_Subtype_For_Not_Null_Present := Bare_Not_Null_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Not_Null_Present;
            return Bare_Not_Null_Present (Result);
         end Allocate_Not_Null_Present;

      package Bare_Null_Component_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Null_Component_Decl, Token_Index);

         
         subtype Subtype_For_Null_Component_Decl is
            Root_Node_Record (Ada_Null_Component_Decl);
         type Access_To_Subtype_For_Null_Component_Decl is access all Subtype_For_Null_Component_Decl;
         package Bare_Null_Component_Decl_Alloc is new Alloc
           (Subtype_For_Null_Component_Decl, Access_To_Subtype_For_Null_Component_Decl);

         function Allocate_Null_Component_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Null_Component_Decl;

         function Allocate_Null_Component_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Null_Component_Decl
         is
            Result      : constant Access_To_Subtype_For_Null_Component_Decl := Bare_Null_Component_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Null_Component_Decl;
            return Bare_Null_Component_Decl (Result);
         end Allocate_Null_Component_Decl;

      package Bare_Others_Designator_Memos is new Langkit_Support.Packrat
        (Bare_Others_Designator, Token_Index);

         
         subtype Subtype_For_Others_Designator is
            Root_Node_Record (Ada_Others_Designator);
         type Access_To_Subtype_For_Others_Designator is access all Subtype_For_Others_Designator;
         package Bare_Others_Designator_Alloc is new Alloc
           (Subtype_For_Others_Designator, Access_To_Subtype_For_Others_Designator);

         function Allocate_Others_Designator
           (Pool : Bump_Ptr_Pool) return Bare_Others_Designator;

         function Allocate_Others_Designator
           (Pool : Bump_Ptr_Pool) return Bare_Others_Designator
         is
            Result      : constant Access_To_Subtype_For_Others_Designator := Bare_Others_Designator_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Others_Designator;
            return Bare_Others_Designator (Result);
         end Allocate_Others_Designator;

      package Bare_Overriding_Node_Memos is new Langkit_Support.Packrat
        (Bare_Overriding_Node, Token_Index);

      package Bare_Overriding_Not_Overriding_Memos is new Langkit_Support.Packrat
        (Bare_Overriding_Not_Overriding, Token_Index);

         
         subtype Subtype_For_Overriding_Not_Overriding is
            Root_Node_Record (Ada_Overriding_Not_Overriding);
         type Access_To_Subtype_For_Overriding_Not_Overriding is access all Subtype_For_Overriding_Not_Overriding;
         package Bare_Overriding_Not_Overriding_Alloc is new Alloc
           (Subtype_For_Overriding_Not_Overriding, Access_To_Subtype_For_Overriding_Not_Overriding);

         function Allocate_Overriding_Not_Overriding
           (Pool : Bump_Ptr_Pool) return Bare_Overriding_Not_Overriding;

         function Allocate_Overriding_Not_Overriding
           (Pool : Bump_Ptr_Pool) return Bare_Overriding_Not_Overriding
         is
            Result      : constant Access_To_Subtype_For_Overriding_Not_Overriding := Bare_Overriding_Not_Overriding_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Overriding_Not_Overriding;
            return Bare_Overriding_Not_Overriding (Result);
         end Allocate_Overriding_Not_Overriding;

      package Bare_Overriding_Overriding_Memos is new Langkit_Support.Packrat
        (Bare_Overriding_Overriding, Token_Index);

         
         subtype Subtype_For_Overriding_Overriding is
            Root_Node_Record (Ada_Overriding_Overriding);
         type Access_To_Subtype_For_Overriding_Overriding is access all Subtype_For_Overriding_Overriding;
         package Bare_Overriding_Overriding_Alloc is new Alloc
           (Subtype_For_Overriding_Overriding, Access_To_Subtype_For_Overriding_Overriding);

         function Allocate_Overriding_Overriding
           (Pool : Bump_Ptr_Pool) return Bare_Overriding_Overriding;

         function Allocate_Overriding_Overriding
           (Pool : Bump_Ptr_Pool) return Bare_Overriding_Overriding
         is
            Result      : constant Access_To_Subtype_For_Overriding_Overriding := Bare_Overriding_Overriding_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Overriding_Overriding;
            return Bare_Overriding_Overriding (Result);
         end Allocate_Overriding_Overriding;

      package Bare_Overriding_Unspecified_Memos is new Langkit_Support.Packrat
        (Bare_Overriding_Unspecified, Token_Index);

         
         subtype Subtype_For_Overriding_Unspecified is
            Root_Node_Record (Ada_Overriding_Unspecified);
         type Access_To_Subtype_For_Overriding_Unspecified is access all Subtype_For_Overriding_Unspecified;
         package Bare_Overriding_Unspecified_Alloc is new Alloc
           (Subtype_For_Overriding_Unspecified, Access_To_Subtype_For_Overriding_Unspecified);

         function Allocate_Overriding_Unspecified
           (Pool : Bump_Ptr_Pool) return Bare_Overriding_Unspecified;

         function Allocate_Overriding_Unspecified
           (Pool : Bump_Ptr_Pool) return Bare_Overriding_Unspecified
         is
            Result      : constant Access_To_Subtype_For_Overriding_Unspecified := Bare_Overriding_Unspecified_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Overriding_Unspecified;
            return Bare_Overriding_Unspecified (Result);
         end Allocate_Overriding_Unspecified;

      package Bare_Params_Memos is new Langkit_Support.Packrat
        (Bare_Params, Token_Index);

         
         subtype Subtype_For_Params is
            Root_Node_Record (Ada_Params);
         type Access_To_Subtype_For_Params is access all Subtype_For_Params;
         package Bare_Params_Alloc is new Alloc
           (Subtype_For_Params, Access_To_Subtype_For_Params);

         function Allocate_Params
           (Pool : Bump_Ptr_Pool) return Bare_Params;

         function Allocate_Params
           (Pool : Bump_Ptr_Pool) return Bare_Params
         is
            Result      : constant Access_To_Subtype_For_Params := Bare_Params_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Params;
            return Bare_Params (Result);
         end Allocate_Params;

      package Bare_Paren_Abstract_State_Decl_Memos is new Langkit_Support.Packrat
        (Bare_Paren_Abstract_State_Decl, Token_Index);

         
         subtype Subtype_For_Paren_Abstract_State_Decl is
            Root_Node_Record (Ada_Paren_Abstract_State_Decl);
         type Access_To_Subtype_For_Paren_Abstract_State_Decl is access all Subtype_For_Paren_Abstract_State_Decl;
         package Bare_Paren_Abstract_State_Decl_Alloc is new Alloc
           (Subtype_For_Paren_Abstract_State_Decl, Access_To_Subtype_For_Paren_Abstract_State_Decl);

         function Allocate_Paren_Abstract_State_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Abstract_State_Decl;

         function Allocate_Paren_Abstract_State_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Abstract_State_Decl
         is
            Result      : constant Access_To_Subtype_For_Paren_Abstract_State_Decl := Bare_Paren_Abstract_State_Decl_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Paren_Abstract_State_Decl;
            return Bare_Paren_Abstract_State_Decl (Result);
         end Allocate_Paren_Abstract_State_Decl;

      package Bare_Pp_Directive_Memos is new Langkit_Support.Packrat
        (Bare_Pp_Directive, Token_Index);

      package Bare_Pp_Else_Directive_Memos is new Langkit_Support.Packrat
        (Bare_Pp_Else_Directive, Token_Index);

         
         subtype Subtype_For_Pp_Else_Directive is
            Root_Node_Record (Ada_Pp_Else_Directive);
         type Access_To_Subtype_For_Pp_Else_Directive is access all Subtype_For_Pp_Else_Directive;
         package Bare_Pp_Else_Directive_Alloc is new Alloc
           (Subtype_For_Pp_Else_Directive, Access_To_Subtype_For_Pp_Else_Directive);

         function Allocate_Pp_Else_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_Else_Directive;

         function Allocate_Pp_Else_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_Else_Directive
         is
            Result      : constant Access_To_Subtype_For_Pp_Else_Directive := Bare_Pp_Else_Directive_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pp_Else_Directive;
            return Bare_Pp_Else_Directive (Result);
         end Allocate_Pp_Else_Directive;

      package Bare_Pp_Elsif_Directive_Memos is new Langkit_Support.Packrat
        (Bare_Pp_Elsif_Directive, Token_Index);

         
         subtype Subtype_For_Pp_Elsif_Directive is
            Root_Node_Record (Ada_Pp_Elsif_Directive);
         type Access_To_Subtype_For_Pp_Elsif_Directive is access all Subtype_For_Pp_Elsif_Directive;
         package Bare_Pp_Elsif_Directive_Alloc is new Alloc
           (Subtype_For_Pp_Elsif_Directive, Access_To_Subtype_For_Pp_Elsif_Directive);

         function Allocate_Pp_Elsif_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_Elsif_Directive;

         function Allocate_Pp_Elsif_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_Elsif_Directive
         is
            Result      : constant Access_To_Subtype_For_Pp_Elsif_Directive := Bare_Pp_Elsif_Directive_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pp_Elsif_Directive;
            return Bare_Pp_Elsif_Directive (Result);
         end Allocate_Pp_Elsif_Directive;

      package Bare_Pp_End_If_Directive_Memos is new Langkit_Support.Packrat
        (Bare_Pp_End_If_Directive, Token_Index);

         
         subtype Subtype_For_Pp_End_If_Directive is
            Root_Node_Record (Ada_Pp_End_If_Directive);
         type Access_To_Subtype_For_Pp_End_If_Directive is access all Subtype_For_Pp_End_If_Directive;
         package Bare_Pp_End_If_Directive_Alloc is new Alloc
           (Subtype_For_Pp_End_If_Directive, Access_To_Subtype_For_Pp_End_If_Directive);

         function Allocate_Pp_End_If_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_End_If_Directive;

         function Allocate_Pp_End_If_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_End_If_Directive
         is
            Result      : constant Access_To_Subtype_For_Pp_End_If_Directive := Bare_Pp_End_If_Directive_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pp_End_If_Directive;
            return Bare_Pp_End_If_Directive (Result);
         end Allocate_Pp_End_If_Directive;

      package Bare_Pp_If_Directive_Memos is new Langkit_Support.Packrat
        (Bare_Pp_If_Directive, Token_Index);

         
         subtype Subtype_For_Pp_If_Directive is
            Root_Node_Record (Ada_Pp_If_Directive);
         type Access_To_Subtype_For_Pp_If_Directive is access all Subtype_For_Pp_If_Directive;
         package Bare_Pp_If_Directive_Alloc is new Alloc
           (Subtype_For_Pp_If_Directive, Access_To_Subtype_For_Pp_If_Directive);

         function Allocate_Pp_If_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_If_Directive;

         function Allocate_Pp_If_Directive
           (Pool : Bump_Ptr_Pool) return Bare_Pp_If_Directive
         is
            Result      : constant Access_To_Subtype_For_Pp_If_Directive := Bare_Pp_If_Directive_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pp_If_Directive;
            return Bare_Pp_If_Directive (Result);
         end Allocate_Pp_If_Directive;

      package Bare_Pp_Then_Kw_Memos is new Langkit_Support.Packrat
        (Bare_Pp_Then_Kw, Token_Index);

         
         subtype Subtype_For_Pp_Then_Kw is
            Root_Node_Record (Ada_Pp_Then_Kw);
         type Access_To_Subtype_For_Pp_Then_Kw is access all Subtype_For_Pp_Then_Kw;
         package Bare_Pp_Then_Kw_Alloc is new Alloc
           (Subtype_For_Pp_Then_Kw, Access_To_Subtype_For_Pp_Then_Kw);

         function Allocate_Pp_Then_Kw
           (Pool : Bump_Ptr_Pool) return Bare_Pp_Then_Kw;

         function Allocate_Pp_Then_Kw
           (Pool : Bump_Ptr_Pool) return Bare_Pp_Then_Kw
         is
            Result      : constant Access_To_Subtype_For_Pp_Then_Kw := Bare_Pp_Then_Kw_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pp_Then_Kw;
            return Bare_Pp_Then_Kw (Result);
         end Allocate_Pp_Then_Kw;

      package Bare_Pragma_Node_Memos is new Langkit_Support.Packrat
        (Bare_Pragma_Node, Token_Index);

         
         subtype Subtype_For_Pragma_Node is
            Root_Node_Record (Ada_Pragma_Node);
         type Access_To_Subtype_For_Pragma_Node is access all Subtype_For_Pragma_Node;
         package Bare_Pragma_Node_Alloc is new Alloc
           (Subtype_For_Pragma_Node, Access_To_Subtype_For_Pragma_Node);

         function Allocate_Pragma_Node
           (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node;

         function Allocate_Pragma_Node
           (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node
         is
            Result      : constant Access_To_Subtype_For_Pragma_Node := Bare_Pragma_Node_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Pragma_Node;
            return Bare_Pragma_Node (Result);
         end Allocate_Pragma_Node;

      package Bare_Private_Node_Memos is new Langkit_Support.Packrat
        (Bare_Private_Node, Token_Index);

      package Bare_Private_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Private_Absent, Token_Index);

         
         subtype Subtype_For_Private_Absent is
            Root_Node_Record (Ada_Private_Absent);
         type Access_To_Subtype_For_Private_Absent is access all Subtype_For_Private_Absent;
         package Bare_Private_Absent_Alloc is new Alloc
           (Subtype_For_Private_Absent, Access_To_Subtype_For_Private_Absent);

         function Allocate_Private_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Private_Absent;

         function Allocate_Private_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Private_Absent
         is
            Result      : constant Access_To_Subtype_For_Private_Absent := Bare_Private_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Private_Absent;
            return Bare_Private_Absent (Result);
         end Allocate_Private_Absent;

      package Bare_Private_Present_Memos is new Langkit_Support.Packrat
        (Bare_Private_Present, Token_Index);

         
         subtype Subtype_For_Private_Present is
            Root_Node_Record (Ada_Private_Present);
         type Access_To_Subtype_For_Private_Present is access all Subtype_For_Private_Present;
         package Bare_Private_Present_Alloc is new Alloc
           (Subtype_For_Private_Present, Access_To_Subtype_For_Private_Present);

         function Allocate_Private_Present
           (Pool : Bump_Ptr_Pool) return Bare_Private_Present;

         function Allocate_Private_Present
           (Pool : Bump_Ptr_Pool) return Bare_Private_Present
         is
            Result      : constant Access_To_Subtype_For_Private_Present := Bare_Private_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Private_Present;
            return Bare_Private_Present (Result);
         end Allocate_Private_Present;

      package Bare_Protected_Def_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Def, Token_Index);

         
         subtype Subtype_For_Protected_Def is
            Root_Node_Record (Ada_Protected_Def);
         type Access_To_Subtype_For_Protected_Def is access all Subtype_For_Protected_Def;
         package Bare_Protected_Def_Alloc is new Alloc
           (Subtype_For_Protected_Def, Access_To_Subtype_For_Protected_Def);

         function Allocate_Protected_Def
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Def;

         function Allocate_Protected_Def
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Def
         is
            Result      : constant Access_To_Subtype_For_Protected_Def := Bare_Protected_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Protected_Def;
            return Bare_Protected_Def (Result);
         end Allocate_Protected_Def;

      package Bare_Protected_Node_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Node, Token_Index);

      package Bare_Protected_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Absent, Token_Index);

         
         subtype Subtype_For_Protected_Absent is
            Root_Node_Record (Ada_Protected_Absent);
         type Access_To_Subtype_For_Protected_Absent is access all Subtype_For_Protected_Absent;
         package Bare_Protected_Absent_Alloc is new Alloc
           (Subtype_For_Protected_Absent, Access_To_Subtype_For_Protected_Absent);

         function Allocate_Protected_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Absent;

         function Allocate_Protected_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Absent
         is
            Result      : constant Access_To_Subtype_For_Protected_Absent := Bare_Protected_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Protected_Absent;
            return Bare_Protected_Absent (Result);
         end Allocate_Protected_Absent;

      package Bare_Protected_Present_Memos is new Langkit_Support.Packrat
        (Bare_Protected_Present, Token_Index);

         
         subtype Subtype_For_Protected_Present is
            Root_Node_Record (Ada_Protected_Present);
         type Access_To_Subtype_For_Protected_Present is access all Subtype_For_Protected_Present;
         package Bare_Protected_Present_Alloc is new Alloc
           (Subtype_For_Protected_Present, Access_To_Subtype_For_Protected_Present);

         function Allocate_Protected_Present
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Present;

         function Allocate_Protected_Present
           (Pool : Bump_Ptr_Pool) return Bare_Protected_Present
         is
            Result      : constant Access_To_Subtype_For_Protected_Present := Bare_Protected_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Protected_Present;
            return Bare_Protected_Present (Result);
         end Allocate_Protected_Present;

      package Bare_Quantifier_Memos is new Langkit_Support.Packrat
        (Bare_Quantifier, Token_Index);

      package Bare_Quantifier_All_Memos is new Langkit_Support.Packrat
        (Bare_Quantifier_All, Token_Index);

         
         subtype Subtype_For_Quantifier_All is
            Root_Node_Record (Ada_Quantifier_All);
         type Access_To_Subtype_For_Quantifier_All is access all Subtype_For_Quantifier_All;
         package Bare_Quantifier_All_Alloc is new Alloc
           (Subtype_For_Quantifier_All, Access_To_Subtype_For_Quantifier_All);

         function Allocate_Quantifier_All
           (Pool : Bump_Ptr_Pool) return Bare_Quantifier_All;

         function Allocate_Quantifier_All
           (Pool : Bump_Ptr_Pool) return Bare_Quantifier_All
         is
            Result      : constant Access_To_Subtype_For_Quantifier_All := Bare_Quantifier_All_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Quantifier_All;
            return Bare_Quantifier_All (Result);
         end Allocate_Quantifier_All;

      package Bare_Quantifier_Some_Memos is new Langkit_Support.Packrat
        (Bare_Quantifier_Some, Token_Index);

         
         subtype Subtype_For_Quantifier_Some is
            Root_Node_Record (Ada_Quantifier_Some);
         type Access_To_Subtype_For_Quantifier_Some is access all Subtype_For_Quantifier_Some;
         package Bare_Quantifier_Some_Alloc is new Alloc
           (Subtype_For_Quantifier_Some, Access_To_Subtype_For_Quantifier_Some);

         function Allocate_Quantifier_Some
           (Pool : Bump_Ptr_Pool) return Bare_Quantifier_Some;

         function Allocate_Quantifier_Some
           (Pool : Bump_Ptr_Pool) return Bare_Quantifier_Some
         is
            Result      : constant Access_To_Subtype_For_Quantifier_Some := Bare_Quantifier_Some_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Quantifier_Some;
            return Bare_Quantifier_Some (Result);
         end Allocate_Quantifier_Some;

      package Bare_Range_Spec_Memos is new Langkit_Support.Packrat
        (Bare_Range_Spec, Token_Index);

         
         subtype Subtype_For_Range_Spec is
            Root_Node_Record (Ada_Range_Spec);
         type Access_To_Subtype_For_Range_Spec is access all Subtype_For_Range_Spec;
         package Bare_Range_Spec_Alloc is new Alloc
           (Subtype_For_Range_Spec, Access_To_Subtype_For_Range_Spec);

         function Allocate_Range_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Range_Spec;

         function Allocate_Range_Spec
           (Pool : Bump_Ptr_Pool) return Bare_Range_Spec
         is
            Result      : constant Access_To_Subtype_For_Range_Spec := Bare_Range_Spec_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Range_Spec;
            return Bare_Range_Spec (Result);
         end Allocate_Range_Spec;

      package Bare_Renaming_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Renaming_Clause, Token_Index);

         
         subtype Subtype_For_Renaming_Clause is
            Root_Node_Record (Ada_Renaming_Clause);
         type Access_To_Subtype_For_Renaming_Clause is access all Subtype_For_Renaming_Clause;
         package Bare_Renaming_Clause_Alloc is new Alloc
           (Subtype_For_Renaming_Clause, Access_To_Subtype_For_Renaming_Clause);

         function Allocate_Renaming_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Renaming_Clause;

         function Allocate_Renaming_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Renaming_Clause
         is
            Result      : constant Access_To_Subtype_For_Renaming_Clause := Bare_Renaming_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Renaming_Clause;
            return Bare_Renaming_Clause (Result);
         end Allocate_Renaming_Clause;

      package Bare_Synthetic_Renaming_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Renaming_Clause, Token_Index);

         
         subtype Subtype_For_Synthetic_Renaming_Clause is
            Root_Node_Record (Ada_Synthetic_Renaming_Clause);
         type Access_To_Subtype_For_Synthetic_Renaming_Clause is access all Subtype_For_Synthetic_Renaming_Clause;
         package Bare_Synthetic_Renaming_Clause_Alloc is new Alloc
           (Subtype_For_Synthetic_Renaming_Clause, Access_To_Subtype_For_Synthetic_Renaming_Clause);

         function Allocate_Synthetic_Renaming_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Renaming_Clause;

         function Allocate_Synthetic_Renaming_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Renaming_Clause
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Renaming_Clause := Bare_Synthetic_Renaming_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Renaming_Clause;
            return Bare_Synthetic_Renaming_Clause (Result);
         end Allocate_Synthetic_Renaming_Clause;

      package Bare_Reverse_Node_Memos is new Langkit_Support.Packrat
        (Bare_Reverse_Node, Token_Index);

      package Bare_Reverse_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Reverse_Absent, Token_Index);

         
         subtype Subtype_For_Reverse_Absent is
            Root_Node_Record (Ada_Reverse_Absent);
         type Access_To_Subtype_For_Reverse_Absent is access all Subtype_For_Reverse_Absent;
         package Bare_Reverse_Absent_Alloc is new Alloc
           (Subtype_For_Reverse_Absent, Access_To_Subtype_For_Reverse_Absent);

         function Allocate_Reverse_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Reverse_Absent;

         function Allocate_Reverse_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Reverse_Absent
         is
            Result      : constant Access_To_Subtype_For_Reverse_Absent := Bare_Reverse_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Reverse_Absent;
            return Bare_Reverse_Absent (Result);
         end Allocate_Reverse_Absent;

      package Bare_Reverse_Present_Memos is new Langkit_Support.Packrat
        (Bare_Reverse_Present, Token_Index);

         
         subtype Subtype_For_Reverse_Present is
            Root_Node_Record (Ada_Reverse_Present);
         type Access_To_Subtype_For_Reverse_Present is access all Subtype_For_Reverse_Present;
         package Bare_Reverse_Present_Alloc is new Alloc
           (Subtype_For_Reverse_Present, Access_To_Subtype_For_Reverse_Present);

         function Allocate_Reverse_Present
           (Pool : Bump_Ptr_Pool) return Bare_Reverse_Present;

         function Allocate_Reverse_Present
           (Pool : Bump_Ptr_Pool) return Bare_Reverse_Present
         is
            Result      : constant Access_To_Subtype_For_Reverse_Present := Bare_Reverse_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Reverse_Present;
            return Bare_Reverse_Present (Result);
         end Allocate_Reverse_Present;

      package Bare_Select_When_Part_Memos is new Langkit_Support.Packrat
        (Bare_Select_When_Part, Token_Index);

         
         subtype Subtype_For_Select_When_Part is
            Root_Node_Record (Ada_Select_When_Part);
         type Access_To_Subtype_For_Select_When_Part is access all Subtype_For_Select_When_Part;
         package Bare_Select_When_Part_Alloc is new Alloc
           (Subtype_For_Select_When_Part, Access_To_Subtype_For_Select_When_Part);

         function Allocate_Select_When_Part
           (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part;

         function Allocate_Select_When_Part
           (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part
         is
            Result      : constant Access_To_Subtype_For_Select_When_Part := Bare_Select_When_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Select_When_Part;
            return Bare_Select_When_Part (Result);
         end Allocate_Select_When_Part;

      package Bare_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Stmt, Token_Index);

      package Bare_Composite_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Composite_Stmt, Token_Index);

      package Bare_Accept_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Accept_Stmt, Token_Index);

         
         subtype Subtype_For_Accept_Stmt is
            Root_Node_Record (Ada_Accept_Stmt);
         type Access_To_Subtype_For_Accept_Stmt is access all Subtype_For_Accept_Stmt;
         package Bare_Accept_Stmt_Alloc is new Alloc
           (Subtype_For_Accept_Stmt, Access_To_Subtype_For_Accept_Stmt);

         function Allocate_Accept_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt;

         function Allocate_Accept_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt
         is
            Result      : constant Access_To_Subtype_For_Accept_Stmt := Bare_Accept_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Accept_Stmt;
            return Bare_Accept_Stmt (Result);
         end Allocate_Accept_Stmt;

      package Bare_Accept_Stmt_With_Stmts_Memos is new Langkit_Support.Packrat
        (Bare_Accept_Stmt_With_Stmts, Token_Index);

         
         subtype Subtype_For_Accept_Stmt_With_Stmts is
            Root_Node_Record (Ada_Accept_Stmt_With_Stmts);
         type Access_To_Subtype_For_Accept_Stmt_With_Stmts is access all Subtype_For_Accept_Stmt_With_Stmts;
         package Bare_Accept_Stmt_With_Stmts_Alloc is new Alloc
           (Subtype_For_Accept_Stmt_With_Stmts, Access_To_Subtype_For_Accept_Stmt_With_Stmts);

         function Allocate_Accept_Stmt_With_Stmts
           (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt_With_Stmts;

         function Allocate_Accept_Stmt_With_Stmts
           (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt_With_Stmts
         is
            Result      : constant Access_To_Subtype_For_Accept_Stmt_With_Stmts := Bare_Accept_Stmt_With_Stmts_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Accept_Stmt_With_Stmts;
            return Bare_Accept_Stmt_With_Stmts (Result);
         end Allocate_Accept_Stmt_With_Stmts;

      package Bare_Base_Loop_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Base_Loop_Stmt, Token_Index);

      package Bare_For_Loop_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_For_Loop_Stmt, Token_Index);

         
         subtype Subtype_For_For_Loop_Stmt is
            Root_Node_Record (Ada_For_Loop_Stmt);
         type Access_To_Subtype_For_For_Loop_Stmt is access all Subtype_For_For_Loop_Stmt;
         package Bare_For_Loop_Stmt_Alloc is new Alloc
           (Subtype_For_For_Loop_Stmt, Access_To_Subtype_For_For_Loop_Stmt);

         function Allocate_For_Loop_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Stmt;

         function Allocate_For_Loop_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Stmt
         is
            Result      : constant Access_To_Subtype_For_For_Loop_Stmt := Bare_For_Loop_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_For_Loop_Stmt;
            return Bare_For_Loop_Stmt (Result);
         end Allocate_For_Loop_Stmt;

      package Bare_Loop_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Loop_Stmt, Token_Index);

         
         subtype Subtype_For_Loop_Stmt is
            Root_Node_Record (Ada_Loop_Stmt);
         type Access_To_Subtype_For_Loop_Stmt is access all Subtype_For_Loop_Stmt;
         package Bare_Loop_Stmt_Alloc is new Alloc
           (Subtype_For_Loop_Stmt, Access_To_Subtype_For_Loop_Stmt);

         function Allocate_Loop_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Loop_Stmt;

         function Allocate_Loop_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Loop_Stmt
         is
            Result      : constant Access_To_Subtype_For_Loop_Stmt := Bare_Loop_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Loop_Stmt;
            return Bare_Loop_Stmt (Result);
         end Allocate_Loop_Stmt;

      package Bare_While_Loop_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_While_Loop_Stmt, Token_Index);

         
         subtype Subtype_For_While_Loop_Stmt is
            Root_Node_Record (Ada_While_Loop_Stmt);
         type Access_To_Subtype_For_While_Loop_Stmt is access all Subtype_For_While_Loop_Stmt;
         package Bare_While_Loop_Stmt_Alloc is new Alloc
           (Subtype_For_While_Loop_Stmt, Access_To_Subtype_For_While_Loop_Stmt);

         function Allocate_While_Loop_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Stmt;

         function Allocate_While_Loop_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Stmt
         is
            Result      : constant Access_To_Subtype_For_While_Loop_Stmt := Bare_While_Loop_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_While_Loop_Stmt;
            return Bare_While_Loop_Stmt (Result);
         end Allocate_While_Loop_Stmt;

      package Bare_Block_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Block_Stmt, Token_Index);

      package Bare_Begin_Block_Memos is new Langkit_Support.Packrat
        (Bare_Begin_Block, Token_Index);

         
         subtype Subtype_For_Begin_Block is
            Root_Node_Record (Ada_Begin_Block);
         type Access_To_Subtype_For_Begin_Block is access all Subtype_For_Begin_Block;
         package Bare_Begin_Block_Alloc is new Alloc
           (Subtype_For_Begin_Block, Access_To_Subtype_For_Begin_Block);

         function Allocate_Begin_Block
           (Pool : Bump_Ptr_Pool) return Bare_Begin_Block;

         function Allocate_Begin_Block
           (Pool : Bump_Ptr_Pool) return Bare_Begin_Block
         is
            Result      : constant Access_To_Subtype_For_Begin_Block := Bare_Begin_Block_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Begin_Block;
            return Bare_Begin_Block (Result);
         end Allocate_Begin_Block;

      package Bare_Decl_Block_Memos is new Langkit_Support.Packrat
        (Bare_Decl_Block, Token_Index);

         
         subtype Subtype_For_Decl_Block is
            Root_Node_Record (Ada_Decl_Block);
         type Access_To_Subtype_For_Decl_Block is access all Subtype_For_Decl_Block;
         package Bare_Decl_Block_Alloc is new Alloc
           (Subtype_For_Decl_Block, Access_To_Subtype_For_Decl_Block);

         function Allocate_Decl_Block
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Block;

         function Allocate_Decl_Block
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Block
         is
            Result      : constant Access_To_Subtype_For_Decl_Block := Bare_Decl_Block_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Decl_Block;
            return Bare_Decl_Block (Result);
         end Allocate_Decl_Block;

      package Bare_Case_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Case_Stmt, Token_Index);

         
         subtype Subtype_For_Case_Stmt is
            Root_Node_Record (Ada_Case_Stmt);
         type Access_To_Subtype_For_Case_Stmt is access all Subtype_For_Case_Stmt;
         package Bare_Case_Stmt_Alloc is new Alloc
           (Subtype_For_Case_Stmt, Access_To_Subtype_For_Case_Stmt);

         function Allocate_Case_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt;

         function Allocate_Case_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt
         is
            Result      : constant Access_To_Subtype_For_Case_Stmt := Bare_Case_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Case_Stmt;
            return Bare_Case_Stmt (Result);
         end Allocate_Case_Stmt;

      package Bare_Extended_Return_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Extended_Return_Stmt, Token_Index);

         
         subtype Subtype_For_Extended_Return_Stmt is
            Root_Node_Record (Ada_Extended_Return_Stmt);
         type Access_To_Subtype_For_Extended_Return_Stmt is access all Subtype_For_Extended_Return_Stmt;
         package Bare_Extended_Return_Stmt_Alloc is new Alloc
           (Subtype_For_Extended_Return_Stmt, Access_To_Subtype_For_Extended_Return_Stmt);

         function Allocate_Extended_Return_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt;

         function Allocate_Extended_Return_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt
         is
            Result      : constant Access_To_Subtype_For_Extended_Return_Stmt := Bare_Extended_Return_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Extended_Return_Stmt;
            return Bare_Extended_Return_Stmt (Result);
         end Allocate_Extended_Return_Stmt;

      package Bare_If_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_If_Stmt, Token_Index);

         
         subtype Subtype_For_If_Stmt is
            Root_Node_Record (Ada_If_Stmt);
         type Access_To_Subtype_For_If_Stmt is access all Subtype_For_If_Stmt;
         package Bare_If_Stmt_Alloc is new Alloc
           (Subtype_For_If_Stmt, Access_To_Subtype_For_If_Stmt);

         function Allocate_If_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_If_Stmt;

         function Allocate_If_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_If_Stmt
         is
            Result      : constant Access_To_Subtype_For_If_Stmt := Bare_If_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_If_Stmt;
            return Bare_If_Stmt (Result);
         end Allocate_If_Stmt;

      package Bare_Named_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Named_Stmt, Token_Index);

         
         subtype Subtype_For_Named_Stmt is
            Root_Node_Record (Ada_Named_Stmt);
         type Access_To_Subtype_For_Named_Stmt is access all Subtype_For_Named_Stmt;
         package Bare_Named_Stmt_Alloc is new Alloc
           (Subtype_For_Named_Stmt, Access_To_Subtype_For_Named_Stmt);

         function Allocate_Named_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt;

         function Allocate_Named_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt
         is
            Result      : constant Access_To_Subtype_For_Named_Stmt := Bare_Named_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Named_Stmt;
            return Bare_Named_Stmt (Result);
         end Allocate_Named_Stmt;

      package Bare_Select_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Select_Stmt, Token_Index);

         
         subtype Subtype_For_Select_Stmt is
            Root_Node_Record (Ada_Select_Stmt);
         type Access_To_Subtype_For_Select_Stmt is access all Subtype_For_Select_Stmt;
         package Bare_Select_Stmt_Alloc is new Alloc
           (Subtype_For_Select_Stmt, Access_To_Subtype_For_Select_Stmt);

         function Allocate_Select_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Select_Stmt;

         function Allocate_Select_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Select_Stmt
         is
            Result      : constant Access_To_Subtype_For_Select_Stmt := Bare_Select_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Select_Stmt;
            return Bare_Select_Stmt (Result);
         end Allocate_Select_Stmt;

      package Bare_Error_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Error_Stmt, Token_Index);

         
         subtype Subtype_For_Error_Stmt is
            Root_Node_Record (Ada_Error_Stmt);
         type Access_To_Subtype_For_Error_Stmt is access all Subtype_For_Error_Stmt;
         package Bare_Error_Stmt_Alloc is new Alloc
           (Subtype_For_Error_Stmt, Access_To_Subtype_For_Error_Stmt);

         function Allocate_Error_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Error_Stmt;

         function Allocate_Error_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Error_Stmt
         is
            Result      : constant Access_To_Subtype_For_Error_Stmt := Bare_Error_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Error_Stmt;
            return Bare_Error_Stmt (Result);
         end Allocate_Error_Stmt;

      package Bare_Simple_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Simple_Stmt, Token_Index);

      package Bare_Abort_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Abort_Stmt, Token_Index);

         
         subtype Subtype_For_Abort_Stmt is
            Root_Node_Record (Ada_Abort_Stmt);
         type Access_To_Subtype_For_Abort_Stmt is access all Subtype_For_Abort_Stmt;
         package Bare_Abort_Stmt_Alloc is new Alloc
           (Subtype_For_Abort_Stmt, Access_To_Subtype_For_Abort_Stmt);

         function Allocate_Abort_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Abort_Stmt;

         function Allocate_Abort_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Abort_Stmt
         is
            Result      : constant Access_To_Subtype_For_Abort_Stmt := Bare_Abort_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Abort_Stmt;
            return Bare_Abort_Stmt (Result);
         end Allocate_Abort_Stmt;

      package Bare_Assign_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Assign_Stmt, Token_Index);

         
         subtype Subtype_For_Assign_Stmt is
            Root_Node_Record (Ada_Assign_Stmt);
         type Access_To_Subtype_For_Assign_Stmt is access all Subtype_For_Assign_Stmt;
         package Bare_Assign_Stmt_Alloc is new Alloc
           (Subtype_For_Assign_Stmt, Access_To_Subtype_For_Assign_Stmt);

         function Allocate_Assign_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Assign_Stmt;

         function Allocate_Assign_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Assign_Stmt
         is
            Result      : constant Access_To_Subtype_For_Assign_Stmt := Bare_Assign_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Assign_Stmt;
            return Bare_Assign_Stmt (Result);
         end Allocate_Assign_Stmt;

      package Bare_Call_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Call_Stmt, Token_Index);

         
         subtype Subtype_For_Call_Stmt is
            Root_Node_Record (Ada_Call_Stmt);
         type Access_To_Subtype_For_Call_Stmt is access all Subtype_For_Call_Stmt;
         package Bare_Call_Stmt_Alloc is new Alloc
           (Subtype_For_Call_Stmt, Access_To_Subtype_For_Call_Stmt);

         function Allocate_Call_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Call_Stmt;

         function Allocate_Call_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Call_Stmt
         is
            Result      : constant Access_To_Subtype_For_Call_Stmt := Bare_Call_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Call_Stmt;
            return Bare_Call_Stmt (Result);
         end Allocate_Call_Stmt;

      package Bare_Delay_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Delay_Stmt, Token_Index);

         
         subtype Subtype_For_Delay_Stmt is
            Root_Node_Record (Ada_Delay_Stmt);
         type Access_To_Subtype_For_Delay_Stmt is access all Subtype_For_Delay_Stmt;
         package Bare_Delay_Stmt_Alloc is new Alloc
           (Subtype_For_Delay_Stmt, Access_To_Subtype_For_Delay_Stmt);

         function Allocate_Delay_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Delay_Stmt;

         function Allocate_Delay_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Delay_Stmt
         is
            Result      : constant Access_To_Subtype_For_Delay_Stmt := Bare_Delay_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Delay_Stmt;
            return Bare_Delay_Stmt (Result);
         end Allocate_Delay_Stmt;

      package Bare_Exit_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Exit_Stmt, Token_Index);

         
         subtype Subtype_For_Exit_Stmt is
            Root_Node_Record (Ada_Exit_Stmt);
         type Access_To_Subtype_For_Exit_Stmt is access all Subtype_For_Exit_Stmt;
         package Bare_Exit_Stmt_Alloc is new Alloc
           (Subtype_For_Exit_Stmt, Access_To_Subtype_For_Exit_Stmt);

         function Allocate_Exit_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Exit_Stmt;

         function Allocate_Exit_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Exit_Stmt
         is
            Result      : constant Access_To_Subtype_For_Exit_Stmt := Bare_Exit_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Exit_Stmt;
            return Bare_Exit_Stmt (Result);
         end Allocate_Exit_Stmt;

      package Bare_Goto_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Goto_Stmt, Token_Index);

         
         subtype Subtype_For_Goto_Stmt is
            Root_Node_Record (Ada_Goto_Stmt);
         type Access_To_Subtype_For_Goto_Stmt is access all Subtype_For_Goto_Stmt;
         package Bare_Goto_Stmt_Alloc is new Alloc
           (Subtype_For_Goto_Stmt, Access_To_Subtype_For_Goto_Stmt);

         function Allocate_Goto_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Goto_Stmt;

         function Allocate_Goto_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Goto_Stmt
         is
            Result      : constant Access_To_Subtype_For_Goto_Stmt := Bare_Goto_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Goto_Stmt;
            return Bare_Goto_Stmt (Result);
         end Allocate_Goto_Stmt;

      package Bare_Label_Memos is new Langkit_Support.Packrat
        (Bare_Label, Token_Index);

         
         subtype Subtype_For_Label is
            Root_Node_Record (Ada_Label);
         type Access_To_Subtype_For_Label is access all Subtype_For_Label;
         package Bare_Label_Alloc is new Alloc
           (Subtype_For_Label, Access_To_Subtype_For_Label);

         function Allocate_Label
           (Pool : Bump_Ptr_Pool) return Bare_Label;

         function Allocate_Label
           (Pool : Bump_Ptr_Pool) return Bare_Label
         is
            Result      : constant Access_To_Subtype_For_Label := Bare_Label_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Label;
            return Bare_Label (Result);
         end Allocate_Label;

      package Bare_Null_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Null_Stmt, Token_Index);

         
         subtype Subtype_For_Null_Stmt is
            Root_Node_Record (Ada_Null_Stmt);
         type Access_To_Subtype_For_Null_Stmt is access all Subtype_For_Null_Stmt;
         package Bare_Null_Stmt_Alloc is new Alloc
           (Subtype_For_Null_Stmt, Access_To_Subtype_For_Null_Stmt);

         function Allocate_Null_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Null_Stmt;

         function Allocate_Null_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Null_Stmt
         is
            Result      : constant Access_To_Subtype_For_Null_Stmt := Bare_Null_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Null_Stmt;
            return Bare_Null_Stmt (Result);
         end Allocate_Null_Stmt;

      package Bare_Raise_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Raise_Stmt, Token_Index);

         
         subtype Subtype_For_Raise_Stmt is
            Root_Node_Record (Ada_Raise_Stmt);
         type Access_To_Subtype_For_Raise_Stmt is access all Subtype_For_Raise_Stmt;
         package Bare_Raise_Stmt_Alloc is new Alloc
           (Subtype_For_Raise_Stmt, Access_To_Subtype_For_Raise_Stmt);

         function Allocate_Raise_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Stmt;

         function Allocate_Raise_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Stmt
         is
            Result      : constant Access_To_Subtype_For_Raise_Stmt := Bare_Raise_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Raise_Stmt;
            return Bare_Raise_Stmt (Result);
         end Allocate_Raise_Stmt;

      package Bare_Requeue_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Requeue_Stmt, Token_Index);

         
         subtype Subtype_For_Requeue_Stmt is
            Root_Node_Record (Ada_Requeue_Stmt);
         type Access_To_Subtype_For_Requeue_Stmt is access all Subtype_For_Requeue_Stmt;
         package Bare_Requeue_Stmt_Alloc is new Alloc
           (Subtype_For_Requeue_Stmt, Access_To_Subtype_For_Requeue_Stmt);

         function Allocate_Requeue_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Requeue_Stmt;

         function Allocate_Requeue_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Requeue_Stmt
         is
            Result      : constant Access_To_Subtype_For_Requeue_Stmt := Bare_Requeue_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Requeue_Stmt;
            return Bare_Requeue_Stmt (Result);
         end Allocate_Requeue_Stmt;

      package Bare_Return_Stmt_Memos is new Langkit_Support.Packrat
        (Bare_Return_Stmt, Token_Index);

         
         subtype Subtype_For_Return_Stmt is
            Root_Node_Record (Ada_Return_Stmt);
         type Access_To_Subtype_For_Return_Stmt is access all Subtype_For_Return_Stmt;
         package Bare_Return_Stmt_Alloc is new Alloc
           (Subtype_For_Return_Stmt, Access_To_Subtype_For_Return_Stmt);

         function Allocate_Return_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Return_Stmt;

         function Allocate_Return_Stmt
           (Pool : Bump_Ptr_Pool) return Bare_Return_Stmt
         is
            Result      : constant Access_To_Subtype_For_Return_Stmt := Bare_Return_Stmt_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Return_Stmt;
            return Bare_Return_Stmt (Result);
         end Allocate_Return_Stmt;

      package Bare_Terminate_Alternative_Memos is new Langkit_Support.Packrat
        (Bare_Terminate_Alternative, Token_Index);

         
         subtype Subtype_For_Terminate_Alternative is
            Root_Node_Record (Ada_Terminate_Alternative);
         type Access_To_Subtype_For_Terminate_Alternative is access all Subtype_For_Terminate_Alternative;
         package Bare_Terminate_Alternative_Alloc is new Alloc
           (Subtype_For_Terminate_Alternative, Access_To_Subtype_For_Terminate_Alternative);

         function Allocate_Terminate_Alternative
           (Pool : Bump_Ptr_Pool) return Bare_Terminate_Alternative;

         function Allocate_Terminate_Alternative
           (Pool : Bump_Ptr_Pool) return Bare_Terminate_Alternative
         is
            Result      : constant Access_To_Subtype_For_Terminate_Alternative := Bare_Terminate_Alternative_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Terminate_Alternative;
            return Bare_Terminate_Alternative (Result);
         end Allocate_Terminate_Alternative;

      package Bare_Subp_Kind_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Kind, Token_Index);

      package Bare_Subp_Kind_Function_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Kind_Function, Token_Index);

         
         subtype Subtype_For_Subp_Kind_Function is
            Root_Node_Record (Ada_Subp_Kind_Function);
         type Access_To_Subtype_For_Subp_Kind_Function is access all Subtype_For_Subp_Kind_Function;
         package Bare_Subp_Kind_Function_Alloc is new Alloc
           (Subtype_For_Subp_Kind_Function, Access_To_Subtype_For_Subp_Kind_Function);

         function Allocate_Subp_Kind_Function
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Function;

         function Allocate_Subp_Kind_Function
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Function
         is
            Result      : constant Access_To_Subtype_For_Subp_Kind_Function := Bare_Subp_Kind_Function_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Kind_Function;
            return Bare_Subp_Kind_Function (Result);
         end Allocate_Subp_Kind_Function;

      package Bare_Subp_Kind_Procedure_Memos is new Langkit_Support.Packrat
        (Bare_Subp_Kind_Procedure, Token_Index);

         
         subtype Subtype_For_Subp_Kind_Procedure is
            Root_Node_Record (Ada_Subp_Kind_Procedure);
         type Access_To_Subtype_For_Subp_Kind_Procedure is access all Subtype_For_Subp_Kind_Procedure;
         package Bare_Subp_Kind_Procedure_Alloc is new Alloc
           (Subtype_For_Subp_Kind_Procedure, Access_To_Subtype_For_Subp_Kind_Procedure);

         function Allocate_Subp_Kind_Procedure
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Procedure;

         function Allocate_Subp_Kind_Procedure
           (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Procedure
         is
            Result      : constant Access_To_Subtype_For_Subp_Kind_Procedure := Bare_Subp_Kind_Procedure_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subp_Kind_Procedure;
            return Bare_Subp_Kind_Procedure (Result);
         end Allocate_Subp_Kind_Procedure;

      package Bare_Subunit_Memos is new Langkit_Support.Packrat
        (Bare_Subunit, Token_Index);

         
         subtype Subtype_For_Subunit is
            Root_Node_Record (Ada_Subunit);
         type Access_To_Subtype_For_Subunit is access all Subtype_For_Subunit;
         package Bare_Subunit_Alloc is new Alloc
           (Subtype_For_Subunit, Access_To_Subtype_For_Subunit);

         function Allocate_Subunit
           (Pool : Bump_Ptr_Pool) return Bare_Subunit;

         function Allocate_Subunit
           (Pool : Bump_Ptr_Pool) return Bare_Subunit
         is
            Result      : constant Access_To_Subtype_For_Subunit := Bare_Subunit_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subunit;
            return Bare_Subunit (Result);
         end Allocate_Subunit;

      package Bare_Synchronized_Node_Memos is new Langkit_Support.Packrat
        (Bare_Synchronized_Node, Token_Index);

      package Bare_Synchronized_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Synchronized_Absent, Token_Index);

         
         subtype Subtype_For_Synchronized_Absent is
            Root_Node_Record (Ada_Synchronized_Absent);
         type Access_To_Subtype_For_Synchronized_Absent is access all Subtype_For_Synchronized_Absent;
         package Bare_Synchronized_Absent_Alloc is new Alloc
           (Subtype_For_Synchronized_Absent, Access_To_Subtype_For_Synchronized_Absent);

         function Allocate_Synchronized_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Absent;

         function Allocate_Synchronized_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Absent
         is
            Result      : constant Access_To_Subtype_For_Synchronized_Absent := Bare_Synchronized_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synchronized_Absent;
            return Bare_Synchronized_Absent (Result);
         end Allocate_Synchronized_Absent;

      package Bare_Synchronized_Present_Memos is new Langkit_Support.Packrat
        (Bare_Synchronized_Present, Token_Index);

         
         subtype Subtype_For_Synchronized_Present is
            Root_Node_Record (Ada_Synchronized_Present);
         type Access_To_Subtype_For_Synchronized_Present is access all Subtype_For_Synchronized_Present;
         package Bare_Synchronized_Present_Alloc is new Alloc
           (Subtype_For_Synchronized_Present, Access_To_Subtype_For_Synchronized_Present);

         function Allocate_Synchronized_Present
           (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Present;

         function Allocate_Synchronized_Present
           (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Present
         is
            Result      : constant Access_To_Subtype_For_Synchronized_Present := Bare_Synchronized_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synchronized_Present;
            return Bare_Synchronized_Present (Result);
         end Allocate_Synchronized_Present;

      package Bare_Tagged_Node_Memos is new Langkit_Support.Packrat
        (Bare_Tagged_Node, Token_Index);

      package Bare_Tagged_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Tagged_Absent, Token_Index);

         
         subtype Subtype_For_Tagged_Absent is
            Root_Node_Record (Ada_Tagged_Absent);
         type Access_To_Subtype_For_Tagged_Absent is access all Subtype_For_Tagged_Absent;
         package Bare_Tagged_Absent_Alloc is new Alloc
           (Subtype_For_Tagged_Absent, Access_To_Subtype_For_Tagged_Absent);

         function Allocate_Tagged_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Tagged_Absent;

         function Allocate_Tagged_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Tagged_Absent
         is
            Result      : constant Access_To_Subtype_For_Tagged_Absent := Bare_Tagged_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Tagged_Absent;
            return Bare_Tagged_Absent (Result);
         end Allocate_Tagged_Absent;

      package Bare_Tagged_Present_Memos is new Langkit_Support.Packrat
        (Bare_Tagged_Present, Token_Index);

         
         subtype Subtype_For_Tagged_Present is
            Root_Node_Record (Ada_Tagged_Present);
         type Access_To_Subtype_For_Tagged_Present is access all Subtype_For_Tagged_Present;
         package Bare_Tagged_Present_Alloc is new Alloc
           (Subtype_For_Tagged_Present, Access_To_Subtype_For_Tagged_Present);

         function Allocate_Tagged_Present
           (Pool : Bump_Ptr_Pool) return Bare_Tagged_Present;

         function Allocate_Tagged_Present
           (Pool : Bump_Ptr_Pool) return Bare_Tagged_Present
         is
            Result      : constant Access_To_Subtype_For_Tagged_Present := Bare_Tagged_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Tagged_Present;
            return Bare_Tagged_Present (Result);
         end Allocate_Tagged_Present;

      package Bare_Task_Def_Memos is new Langkit_Support.Packrat
        (Bare_Task_Def, Token_Index);

         
         subtype Subtype_For_Task_Def is
            Root_Node_Record (Ada_Task_Def);
         type Access_To_Subtype_For_Task_Def is access all Subtype_For_Task_Def;
         package Bare_Task_Def_Alloc is new Alloc
           (Subtype_For_Task_Def, Access_To_Subtype_For_Task_Def);

         function Allocate_Task_Def
           (Pool : Bump_Ptr_Pool) return Bare_Task_Def;

         function Allocate_Task_Def
           (Pool : Bump_Ptr_Pool) return Bare_Task_Def
         is
            Result      : constant Access_To_Subtype_For_Task_Def := Bare_Task_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Task_Def;
            return Bare_Task_Def (Result);
         end Allocate_Task_Def;

      package Bare_Type_Attributes_Repository_Memos is new Langkit_Support.Packrat
        (Bare_Type_Attributes_Repository, Token_Index);

         
         subtype Subtype_For_Type_Attributes_Repository is
            Root_Node_Record (Ada_Type_Attributes_Repository);
         type Access_To_Subtype_For_Type_Attributes_Repository is access all Subtype_For_Type_Attributes_Repository;
         package Bare_Type_Attributes_Repository_Alloc is new Alloc
           (Subtype_For_Type_Attributes_Repository, Access_To_Subtype_For_Type_Attributes_Repository);

         function Allocate_Type_Attributes_Repository
           (Pool : Bump_Ptr_Pool) return Bare_Type_Attributes_Repository;

         function Allocate_Type_Attributes_Repository
           (Pool : Bump_Ptr_Pool) return Bare_Type_Attributes_Repository
         is
            Result      : constant Access_To_Subtype_For_Type_Attributes_Repository := Bare_Type_Attributes_Repository_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Type_Attributes_Repository;
            return Bare_Type_Attributes_Repository (Result);
         end Allocate_Type_Attributes_Repository;

      package Bare_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Type_Def, Token_Index);

      package Bare_Access_Def_Memos is new Langkit_Support.Packrat
        (Bare_Access_Def, Token_Index);

      package Bare_Access_To_Subp_Def_Memos is new Langkit_Support.Packrat
        (Bare_Access_To_Subp_Def, Token_Index);

         
         subtype Subtype_For_Access_To_Subp_Def is
            Root_Node_Record (Ada_Access_To_Subp_Def);
         type Access_To_Subtype_For_Access_To_Subp_Def is access all Subtype_For_Access_To_Subp_Def;
         package Bare_Access_To_Subp_Def_Alloc is new Alloc
           (Subtype_For_Access_To_Subp_Def, Access_To_Subtype_For_Access_To_Subp_Def);

         function Allocate_Access_To_Subp_Def
           (Pool : Bump_Ptr_Pool) return Bare_Access_To_Subp_Def;

         function Allocate_Access_To_Subp_Def
           (Pool : Bump_Ptr_Pool) return Bare_Access_To_Subp_Def
         is
            Result      : constant Access_To_Subtype_For_Access_To_Subp_Def := Bare_Access_To_Subp_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Access_To_Subp_Def;
            return Bare_Access_To_Subp_Def (Result);
         end Allocate_Access_To_Subp_Def;

      package Bare_Base_Type_Access_Def_Memos is new Langkit_Support.Packrat
        (Bare_Base_Type_Access_Def, Token_Index);

      package Bare_Anonymous_Type_Access_Def_Memos is new Langkit_Support.Packrat
        (Bare_Anonymous_Type_Access_Def, Token_Index);

         
         subtype Subtype_For_Anonymous_Type_Access_Def is
            Root_Node_Record (Ada_Anonymous_Type_Access_Def);
         type Access_To_Subtype_For_Anonymous_Type_Access_Def is access all Subtype_For_Anonymous_Type_Access_Def;
         package Bare_Anonymous_Type_Access_Def_Alloc is new Alloc
           (Subtype_For_Anonymous_Type_Access_Def, Access_To_Subtype_For_Anonymous_Type_Access_Def);

         function Allocate_Anonymous_Type_Access_Def
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Access_Def;

         function Allocate_Anonymous_Type_Access_Def
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Access_Def
         is
            Result      : constant Access_To_Subtype_For_Anonymous_Type_Access_Def := Bare_Anonymous_Type_Access_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Anonymous_Type_Access_Def;
            return Bare_Anonymous_Type_Access_Def (Result);
         end Allocate_Anonymous_Type_Access_Def;

      package Bare_Type_Access_Def_Memos is new Langkit_Support.Packrat
        (Bare_Type_Access_Def, Token_Index);

         
         subtype Subtype_For_Type_Access_Def is
            Root_Node_Record (Ada_Type_Access_Def);
         type Access_To_Subtype_For_Type_Access_Def is access all Subtype_For_Type_Access_Def;
         package Bare_Type_Access_Def_Alloc is new Alloc
           (Subtype_For_Type_Access_Def, Access_To_Subtype_For_Type_Access_Def);

         function Allocate_Type_Access_Def
           (Pool : Bump_Ptr_Pool) return Bare_Type_Access_Def;

         function Allocate_Type_Access_Def
           (Pool : Bump_Ptr_Pool) return Bare_Type_Access_Def
         is
            Result      : constant Access_To_Subtype_For_Type_Access_Def := Bare_Type_Access_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Type_Access_Def;
            return Bare_Type_Access_Def (Result);
         end Allocate_Type_Access_Def;

      package Bare_Array_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Array_Type_Def, Token_Index);

         
         subtype Subtype_For_Array_Type_Def is
            Root_Node_Record (Ada_Array_Type_Def);
         type Access_To_Subtype_For_Array_Type_Def is access all Subtype_For_Array_Type_Def;
         package Bare_Array_Type_Def_Alloc is new Alloc
           (Subtype_For_Array_Type_Def, Access_To_Subtype_For_Array_Type_Def);

         function Allocate_Array_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Array_Type_Def;

         function Allocate_Array_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Array_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Array_Type_Def := Bare_Array_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Array_Type_Def;
            return Bare_Array_Type_Def (Result);
         end Allocate_Array_Type_Def;

      package Bare_Derived_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Derived_Type_Def, Token_Index);

         
         subtype Subtype_For_Derived_Type_Def is
            Root_Node_Record (Ada_Derived_Type_Def);
         type Access_To_Subtype_For_Derived_Type_Def is access all Subtype_For_Derived_Type_Def;
         package Bare_Derived_Type_Def_Alloc is new Alloc
           (Subtype_For_Derived_Type_Def, Access_To_Subtype_For_Derived_Type_Def);

         function Allocate_Derived_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Derived_Type_Def;

         function Allocate_Derived_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Derived_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Derived_Type_Def := Bare_Derived_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Derived_Type_Def;
            return Bare_Derived_Type_Def (Result);
         end Allocate_Derived_Type_Def;

      package Bare_Enum_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Enum_Type_Def, Token_Index);

         
         subtype Subtype_For_Enum_Type_Def is
            Root_Node_Record (Ada_Enum_Type_Def);
         type Access_To_Subtype_For_Enum_Type_Def is access all Subtype_For_Enum_Type_Def;
         package Bare_Enum_Type_Def_Alloc is new Alloc
           (Subtype_For_Enum_Type_Def, Access_To_Subtype_For_Enum_Type_Def);

         function Allocate_Enum_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Def;

         function Allocate_Enum_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Enum_Type_Def := Bare_Enum_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Enum_Type_Def;
            return Bare_Enum_Type_Def (Result);
         end Allocate_Enum_Type_Def;

      package Bare_Formal_Discrete_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Formal_Discrete_Type_Def, Token_Index);

         
         subtype Subtype_For_Formal_Discrete_Type_Def is
            Root_Node_Record (Ada_Formal_Discrete_Type_Def);
         type Access_To_Subtype_For_Formal_Discrete_Type_Def is access all Subtype_For_Formal_Discrete_Type_Def;
         package Bare_Formal_Discrete_Type_Def_Alloc is new Alloc
           (Subtype_For_Formal_Discrete_Type_Def, Access_To_Subtype_For_Formal_Discrete_Type_Def);

         function Allocate_Formal_Discrete_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Formal_Discrete_Type_Def;

         function Allocate_Formal_Discrete_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Formal_Discrete_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Formal_Discrete_Type_Def := Bare_Formal_Discrete_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Formal_Discrete_Type_Def;
            return Bare_Formal_Discrete_Type_Def (Result);
         end Allocate_Formal_Discrete_Type_Def;

      package Bare_Interface_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Interface_Type_Def, Token_Index);

         
         subtype Subtype_For_Interface_Type_Def is
            Root_Node_Record (Ada_Interface_Type_Def);
         type Access_To_Subtype_For_Interface_Type_Def is access all Subtype_For_Interface_Type_Def;
         package Bare_Interface_Type_Def_Alloc is new Alloc
           (Subtype_For_Interface_Type_Def, Access_To_Subtype_For_Interface_Type_Def);

         function Allocate_Interface_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Type_Def;

         function Allocate_Interface_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Interface_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Interface_Type_Def := Bare_Interface_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Interface_Type_Def;
            return Bare_Interface_Type_Def (Result);
         end Allocate_Interface_Type_Def;

      package Bare_Mod_Int_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Mod_Int_Type_Def, Token_Index);

         
         subtype Subtype_For_Mod_Int_Type_Def is
            Root_Node_Record (Ada_Mod_Int_Type_Def);
         type Access_To_Subtype_For_Mod_Int_Type_Def is access all Subtype_For_Mod_Int_Type_Def;
         package Bare_Mod_Int_Type_Def_Alloc is new Alloc
           (Subtype_For_Mod_Int_Type_Def, Access_To_Subtype_For_Mod_Int_Type_Def);

         function Allocate_Mod_Int_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Mod_Int_Type_Def;

         function Allocate_Mod_Int_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Mod_Int_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Mod_Int_Type_Def := Bare_Mod_Int_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Mod_Int_Type_Def;
            return Bare_Mod_Int_Type_Def (Result);
         end Allocate_Mod_Int_Type_Def;

      package Bare_Private_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Private_Type_Def, Token_Index);

         
         subtype Subtype_For_Private_Type_Def is
            Root_Node_Record (Ada_Private_Type_Def);
         type Access_To_Subtype_For_Private_Type_Def is access all Subtype_For_Private_Type_Def;
         package Bare_Private_Type_Def_Alloc is new Alloc
           (Subtype_For_Private_Type_Def, Access_To_Subtype_For_Private_Type_Def);

         function Allocate_Private_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Private_Type_Def;

         function Allocate_Private_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Private_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Private_Type_Def := Bare_Private_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Private_Type_Def;
            return Bare_Private_Type_Def (Result);
         end Allocate_Private_Type_Def;

      package Bare_Real_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Real_Type_Def, Token_Index);

      package Bare_Decimal_Fixed_Point_Def_Memos is new Langkit_Support.Packrat
        (Bare_Decimal_Fixed_Point_Def, Token_Index);

         
         subtype Subtype_For_Decimal_Fixed_Point_Def is
            Root_Node_Record (Ada_Decimal_Fixed_Point_Def);
         type Access_To_Subtype_For_Decimal_Fixed_Point_Def is access all Subtype_For_Decimal_Fixed_Point_Def;
         package Bare_Decimal_Fixed_Point_Def_Alloc is new Alloc
           (Subtype_For_Decimal_Fixed_Point_Def, Access_To_Subtype_For_Decimal_Fixed_Point_Def);

         function Allocate_Decimal_Fixed_Point_Def
           (Pool : Bump_Ptr_Pool) return Bare_Decimal_Fixed_Point_Def;

         function Allocate_Decimal_Fixed_Point_Def
           (Pool : Bump_Ptr_Pool) return Bare_Decimal_Fixed_Point_Def
         is
            Result      : constant Access_To_Subtype_For_Decimal_Fixed_Point_Def := Bare_Decimal_Fixed_Point_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Decimal_Fixed_Point_Def;
            return Bare_Decimal_Fixed_Point_Def (Result);
         end Allocate_Decimal_Fixed_Point_Def;

      package Bare_Floating_Point_Def_Memos is new Langkit_Support.Packrat
        (Bare_Floating_Point_Def, Token_Index);

         
         subtype Subtype_For_Floating_Point_Def is
            Root_Node_Record (Ada_Floating_Point_Def);
         type Access_To_Subtype_For_Floating_Point_Def is access all Subtype_For_Floating_Point_Def;
         package Bare_Floating_Point_Def_Alloc is new Alloc
           (Subtype_For_Floating_Point_Def, Access_To_Subtype_For_Floating_Point_Def);

         function Allocate_Floating_Point_Def
           (Pool : Bump_Ptr_Pool) return Bare_Floating_Point_Def;

         function Allocate_Floating_Point_Def
           (Pool : Bump_Ptr_Pool) return Bare_Floating_Point_Def
         is
            Result      : constant Access_To_Subtype_For_Floating_Point_Def := Bare_Floating_Point_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Floating_Point_Def;
            return Bare_Floating_Point_Def (Result);
         end Allocate_Floating_Point_Def;

      package Bare_Ordinary_Fixed_Point_Def_Memos is new Langkit_Support.Packrat
        (Bare_Ordinary_Fixed_Point_Def, Token_Index);

         
         subtype Subtype_For_Ordinary_Fixed_Point_Def is
            Root_Node_Record (Ada_Ordinary_Fixed_Point_Def);
         type Access_To_Subtype_For_Ordinary_Fixed_Point_Def is access all Subtype_For_Ordinary_Fixed_Point_Def;
         package Bare_Ordinary_Fixed_Point_Def_Alloc is new Alloc
           (Subtype_For_Ordinary_Fixed_Point_Def, Access_To_Subtype_For_Ordinary_Fixed_Point_Def);

         function Allocate_Ordinary_Fixed_Point_Def
           (Pool : Bump_Ptr_Pool) return Bare_Ordinary_Fixed_Point_Def;

         function Allocate_Ordinary_Fixed_Point_Def
           (Pool : Bump_Ptr_Pool) return Bare_Ordinary_Fixed_Point_Def
         is
            Result      : constant Access_To_Subtype_For_Ordinary_Fixed_Point_Def := Bare_Ordinary_Fixed_Point_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Ordinary_Fixed_Point_Def;
            return Bare_Ordinary_Fixed_Point_Def (Result);
         end Allocate_Ordinary_Fixed_Point_Def;

      package Bare_Record_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Record_Type_Def, Token_Index);

         
         subtype Subtype_For_Record_Type_Def is
            Root_Node_Record (Ada_Record_Type_Def);
         type Access_To_Subtype_For_Record_Type_Def is access all Subtype_For_Record_Type_Def;
         package Bare_Record_Type_Def_Alloc is new Alloc
           (Subtype_For_Record_Type_Def, Access_To_Subtype_For_Record_Type_Def);

         function Allocate_Record_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Record_Type_Def;

         function Allocate_Record_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Record_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Record_Type_Def := Bare_Record_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Record_Type_Def;
            return Bare_Record_Type_Def (Result);
         end Allocate_Record_Type_Def;

      package Bare_Signed_Int_Type_Def_Memos is new Langkit_Support.Packrat
        (Bare_Signed_Int_Type_Def, Token_Index);

         
         subtype Subtype_For_Signed_Int_Type_Def is
            Root_Node_Record (Ada_Signed_Int_Type_Def);
         type Access_To_Subtype_For_Signed_Int_Type_Def is access all Subtype_For_Signed_Int_Type_Def;
         package Bare_Signed_Int_Type_Def_Alloc is new Alloc
           (Subtype_For_Signed_Int_Type_Def, Access_To_Subtype_For_Signed_Int_Type_Def);

         function Allocate_Signed_Int_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Signed_Int_Type_Def;

         function Allocate_Signed_Int_Type_Def
           (Pool : Bump_Ptr_Pool) return Bare_Signed_Int_Type_Def
         is
            Result      : constant Access_To_Subtype_For_Signed_Int_Type_Def := Bare_Signed_Int_Type_Def_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Signed_Int_Type_Def;
            return Bare_Signed_Int_Type_Def (Result);
         end Allocate_Signed_Int_Type_Def;

      package Bare_Type_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Type_Expr, Token_Index);

      package Bare_Anonymous_Type_Memos is new Langkit_Support.Packrat
        (Bare_Anonymous_Type, Token_Index);

         
         subtype Subtype_For_Anonymous_Type is
            Root_Node_Record (Ada_Anonymous_Type);
         type Access_To_Subtype_For_Anonymous_Type is access all Subtype_For_Anonymous_Type;
         package Bare_Anonymous_Type_Alloc is new Alloc
           (Subtype_For_Anonymous_Type, Access_To_Subtype_For_Anonymous_Type);

         function Allocate_Anonymous_Type
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type;

         function Allocate_Anonymous_Type
           (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type
         is
            Result      : constant Access_To_Subtype_For_Anonymous_Type := Bare_Anonymous_Type_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Anonymous_Type;
            return Bare_Anonymous_Type (Result);
         end Allocate_Anonymous_Type;

      package Bare_Enum_Lit_Synth_Type_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Enum_Lit_Synth_Type_Expr, Token_Index);

         
         subtype Subtype_For_Enum_Lit_Synth_Type_Expr is
            Root_Node_Record (Ada_Enum_Lit_Synth_Type_Expr);
         type Access_To_Subtype_For_Enum_Lit_Synth_Type_Expr is access all Subtype_For_Enum_Lit_Synth_Type_Expr;
         package Bare_Enum_Lit_Synth_Type_Expr_Alloc is new Alloc
           (Subtype_For_Enum_Lit_Synth_Type_Expr, Access_To_Subtype_For_Enum_Lit_Synth_Type_Expr);

         function Allocate_Enum_Lit_Synth_Type_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Synth_Type_Expr;

         function Allocate_Enum_Lit_Synth_Type_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Synth_Type_Expr
         is
            Result      : constant Access_To_Subtype_For_Enum_Lit_Synth_Type_Expr := Bare_Enum_Lit_Synth_Type_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Enum_Lit_Synth_Type_Expr;
            return Bare_Enum_Lit_Synth_Type_Expr (Result);
         end Allocate_Enum_Lit_Synth_Type_Expr;

      package Bare_Subtype_Indication_Memos is new Langkit_Support.Packrat
        (Bare_Subtype_Indication, Token_Index);

         
         subtype Subtype_For_Subtype_Indication is
            Root_Node_Record (Ada_Subtype_Indication);
         type Access_To_Subtype_For_Subtype_Indication is access all Subtype_For_Subtype_Indication;
         package Bare_Subtype_Indication_Alloc is new Alloc
           (Subtype_For_Subtype_Indication, Access_To_Subtype_For_Subtype_Indication);

         function Allocate_Subtype_Indication
           (Pool : Bump_Ptr_Pool) return Bare_Subtype_Indication;

         function Allocate_Subtype_Indication
           (Pool : Bump_Ptr_Pool) return Bare_Subtype_Indication
         is
            Result      : constant Access_To_Subtype_For_Subtype_Indication := Bare_Subtype_Indication_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Subtype_Indication;
            return Bare_Subtype_Indication (Result);
         end Allocate_Subtype_Indication;

      package Bare_Constrained_Subtype_Indication_Memos is new Langkit_Support.Packrat
        (Bare_Constrained_Subtype_Indication, Token_Index);

         
         subtype Subtype_For_Constrained_Subtype_Indication is
            Root_Node_Record (Ada_Constrained_Subtype_Indication);
         type Access_To_Subtype_For_Constrained_Subtype_Indication is access all Subtype_For_Constrained_Subtype_Indication;
         package Bare_Constrained_Subtype_Indication_Alloc is new Alloc
           (Subtype_For_Constrained_Subtype_Indication, Access_To_Subtype_For_Constrained_Subtype_Indication);

         function Allocate_Constrained_Subtype_Indication
           (Pool : Bump_Ptr_Pool) return Bare_Constrained_Subtype_Indication;

         function Allocate_Constrained_Subtype_Indication
           (Pool : Bump_Ptr_Pool) return Bare_Constrained_Subtype_Indication
         is
            Result      : constant Access_To_Subtype_For_Constrained_Subtype_Indication := Bare_Constrained_Subtype_Indication_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Constrained_Subtype_Indication;
            return Bare_Constrained_Subtype_Indication (Result);
         end Allocate_Constrained_Subtype_Indication;

      package Bare_Discrete_Subtype_Indication_Memos is new Langkit_Support.Packrat
        (Bare_Discrete_Subtype_Indication, Token_Index);

         
         subtype Subtype_For_Discrete_Subtype_Indication is
            Root_Node_Record (Ada_Discrete_Subtype_Indication);
         type Access_To_Subtype_For_Discrete_Subtype_Indication is access all Subtype_For_Discrete_Subtype_Indication;
         package Bare_Discrete_Subtype_Indication_Alloc is new Alloc
           (Subtype_For_Discrete_Subtype_Indication, Access_To_Subtype_For_Discrete_Subtype_Indication);

         function Allocate_Discrete_Subtype_Indication
           (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Indication;

         function Allocate_Discrete_Subtype_Indication
           (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Indication
         is
            Result      : constant Access_To_Subtype_For_Discrete_Subtype_Indication := Bare_Discrete_Subtype_Indication_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Discrete_Subtype_Indication;
            return Bare_Discrete_Subtype_Indication (Result);
         end Allocate_Discrete_Subtype_Indication;

      package Bare_Synthetic_Type_Expr_Memos is new Langkit_Support.Packrat
        (Bare_Synthetic_Type_Expr, Token_Index);

         
         subtype Subtype_For_Synthetic_Type_Expr is
            Root_Node_Record (Ada_Synthetic_Type_Expr);
         type Access_To_Subtype_For_Synthetic_Type_Expr is access all Subtype_For_Synthetic_Type_Expr;
         package Bare_Synthetic_Type_Expr_Alloc is new Alloc
           (Subtype_For_Synthetic_Type_Expr, Access_To_Subtype_For_Synthetic_Type_Expr);

         function Allocate_Synthetic_Type_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Type_Expr;

         function Allocate_Synthetic_Type_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Type_Expr
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Type_Expr := Bare_Synthetic_Type_Expr_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Synthetic_Type_Expr;
            return Bare_Synthetic_Type_Expr (Result);
         end Allocate_Synthetic_Type_Expr;

      package Bare_Unconstrained_Array_Index_Memos is new Langkit_Support.Packrat
        (Bare_Unconstrained_Array_Index, Token_Index);

         
         subtype Subtype_For_Unconstrained_Array_Index is
            Root_Node_Record (Ada_Unconstrained_Array_Index);
         type Access_To_Subtype_For_Unconstrained_Array_Index is access all Subtype_For_Unconstrained_Array_Index;
         package Bare_Unconstrained_Array_Index_Alloc is new Alloc
           (Subtype_For_Unconstrained_Array_Index, Access_To_Subtype_For_Unconstrained_Array_Index);

         function Allocate_Unconstrained_Array_Index
           (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index;

         function Allocate_Unconstrained_Array_Index
           (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index
         is
            Result      : constant Access_To_Subtype_For_Unconstrained_Array_Index := Bare_Unconstrained_Array_Index_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Unconstrained_Array_Index;
            return Bare_Unconstrained_Array_Index (Result);
         end Allocate_Unconstrained_Array_Index;

      package Bare_Until_Node_Memos is new Langkit_Support.Packrat
        (Bare_Until_Node, Token_Index);

      package Bare_Until_Absent_Memos is new Langkit_Support.Packrat
        (Bare_Until_Absent, Token_Index);

         
         subtype Subtype_For_Until_Absent is
            Root_Node_Record (Ada_Until_Absent);
         type Access_To_Subtype_For_Until_Absent is access all Subtype_For_Until_Absent;
         package Bare_Until_Absent_Alloc is new Alloc
           (Subtype_For_Until_Absent, Access_To_Subtype_For_Until_Absent);

         function Allocate_Until_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Until_Absent;

         function Allocate_Until_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Until_Absent
         is
            Result      : constant Access_To_Subtype_For_Until_Absent := Bare_Until_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Until_Absent;
            return Bare_Until_Absent (Result);
         end Allocate_Until_Absent;

      package Bare_Until_Present_Memos is new Langkit_Support.Packrat
        (Bare_Until_Present, Token_Index);

         
         subtype Subtype_For_Until_Present is
            Root_Node_Record (Ada_Until_Present);
         type Access_To_Subtype_For_Until_Present is access all Subtype_For_Until_Present;
         package Bare_Until_Present_Alloc is new Alloc
           (Subtype_For_Until_Present, Access_To_Subtype_For_Until_Present);

         function Allocate_Until_Present
           (Pool : Bump_Ptr_Pool) return Bare_Until_Present;

         function Allocate_Until_Present
           (Pool : Bump_Ptr_Pool) return Bare_Until_Present
         is
            Result      : constant Access_To_Subtype_For_Until_Present := Bare_Until_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Until_Present;
            return Bare_Until_Present (Result);
         end Allocate_Until_Present;

      package Bare_Use_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Use_Clause, Token_Index);

      package Bare_Use_Package_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Use_Package_Clause, Token_Index);

         
         subtype Subtype_For_Use_Package_Clause is
            Root_Node_Record (Ada_Use_Package_Clause);
         type Access_To_Subtype_For_Use_Package_Clause is access all Subtype_For_Use_Package_Clause;
         package Bare_Use_Package_Clause_Alloc is new Alloc
           (Subtype_For_Use_Package_Clause, Access_To_Subtype_For_Use_Package_Clause);

         function Allocate_Use_Package_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Use_Package_Clause;

         function Allocate_Use_Package_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Use_Package_Clause
         is
            Result      : constant Access_To_Subtype_For_Use_Package_Clause := Bare_Use_Package_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Use_Package_Clause;
            return Bare_Use_Package_Clause (Result);
         end Allocate_Use_Package_Clause;

      package Bare_Use_Type_Clause_Memos is new Langkit_Support.Packrat
        (Bare_Use_Type_Clause, Token_Index);

         
         subtype Subtype_For_Use_Type_Clause is
            Root_Node_Record (Ada_Use_Type_Clause);
         type Access_To_Subtype_For_Use_Type_Clause is access all Subtype_For_Use_Type_Clause;
         package Bare_Use_Type_Clause_Alloc is new Alloc
           (Subtype_For_Use_Type_Clause, Access_To_Subtype_For_Use_Type_Clause);

         function Allocate_Use_Type_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Use_Type_Clause;

         function Allocate_Use_Type_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Use_Type_Clause
         is
            Result      : constant Access_To_Subtype_For_Use_Type_Clause := Bare_Use_Type_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Use_Type_Clause;
            return Bare_Use_Type_Clause (Result);
         end Allocate_Use_Type_Clause;

      package Bare_Value_Sequence_Memos is new Langkit_Support.Packrat
        (Bare_Value_Sequence, Token_Index);

         
         subtype Subtype_For_Value_Sequence is
            Root_Node_Record (Ada_Value_Sequence);
         type Access_To_Subtype_For_Value_Sequence is access all Subtype_For_Value_Sequence;
         package Bare_Value_Sequence_Alloc is new Alloc
           (Subtype_For_Value_Sequence, Access_To_Subtype_For_Value_Sequence);

         function Allocate_Value_Sequence
           (Pool : Bump_Ptr_Pool) return Bare_Value_Sequence;

         function Allocate_Value_Sequence
           (Pool : Bump_Ptr_Pool) return Bare_Value_Sequence
         is
            Result      : constant Access_To_Subtype_For_Value_Sequence := Bare_Value_Sequence_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Value_Sequence;
            return Bare_Value_Sequence (Result);
         end Allocate_Value_Sequence;

      package Bare_Variant_Memos is new Langkit_Support.Packrat
        (Bare_Variant, Token_Index);

         
         subtype Subtype_For_Variant is
            Root_Node_Record (Ada_Variant);
         type Access_To_Subtype_For_Variant is access all Subtype_For_Variant;
         package Bare_Variant_Alloc is new Alloc
           (Subtype_For_Variant, Access_To_Subtype_For_Variant);

         function Allocate_Variant
           (Pool : Bump_Ptr_Pool) return Bare_Variant;

         function Allocate_Variant
           (Pool : Bump_Ptr_Pool) return Bare_Variant
         is
            Result      : constant Access_To_Subtype_For_Variant := Bare_Variant_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Variant;
            return Bare_Variant (Result);
         end Allocate_Variant;

      package Bare_Variant_Part_Memos is new Langkit_Support.Packrat
        (Bare_Variant_Part, Token_Index);

         
         subtype Subtype_For_Variant_Part is
            Root_Node_Record (Ada_Variant_Part);
         type Access_To_Subtype_For_Variant_Part is access all Subtype_For_Variant_Part;
         package Bare_Variant_Part_Alloc is new Alloc
           (Subtype_For_Variant_Part, Access_To_Subtype_For_Variant_Part);

         function Allocate_Variant_Part
           (Pool : Bump_Ptr_Pool) return Bare_Variant_Part;

         function Allocate_Variant_Part
           (Pool : Bump_Ptr_Pool) return Bare_Variant_Part
         is
            Result      : constant Access_To_Subtype_For_Variant_Part := Bare_Variant_Part_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_Variant_Part;
            return Bare_Variant_Part (Result);
         end Allocate_Variant_Part;

      package Bare_With_Clause_Memos is new Langkit_Support.Packrat
        (Bare_With_Clause, Token_Index);

         
         subtype Subtype_For_With_Clause is
            Root_Node_Record (Ada_With_Clause);
         type Access_To_Subtype_For_With_Clause is access all Subtype_For_With_Clause;
         package Bare_With_Clause_Alloc is new Alloc
           (Subtype_For_With_Clause, Access_To_Subtype_For_With_Clause);

         function Allocate_With_Clause
           (Pool : Bump_Ptr_Pool) return Bare_With_Clause;

         function Allocate_With_Clause
           (Pool : Bump_Ptr_Pool) return Bare_With_Clause
         is
            Result      : constant Access_To_Subtype_For_With_Clause := Bare_With_Clause_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_With_Clause;
            return Bare_With_Clause (Result);
         end Allocate_With_Clause;

      package Bare_With_Private_Memos is new Langkit_Support.Packrat
        (Bare_With_Private, Token_Index);

      package Bare_With_Private_Absent_Memos is new Langkit_Support.Packrat
        (Bare_With_Private_Absent, Token_Index);

         
         subtype Subtype_For_With_Private_Absent is
            Root_Node_Record (Ada_With_Private_Absent);
         type Access_To_Subtype_For_With_Private_Absent is access all Subtype_For_With_Private_Absent;
         package Bare_With_Private_Absent_Alloc is new Alloc
           (Subtype_For_With_Private_Absent, Access_To_Subtype_For_With_Private_Absent);

         function Allocate_With_Private_Absent
           (Pool : Bump_Ptr_Pool) return Bare_With_Private_Absent;

         function Allocate_With_Private_Absent
           (Pool : Bump_Ptr_Pool) return Bare_With_Private_Absent
         is
            Result      : constant Access_To_Subtype_For_With_Private_Absent := Bare_With_Private_Absent_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_With_Private_Absent;
            return Bare_With_Private_Absent (Result);
         end Allocate_With_Private_Absent;

      package Bare_With_Private_Present_Memos is new Langkit_Support.Packrat
        (Bare_With_Private_Present, Token_Index);

         
         subtype Subtype_For_With_Private_Present is
            Root_Node_Record (Ada_With_Private_Present);
         type Access_To_Subtype_For_With_Private_Present is access all Subtype_For_With_Private_Present;
         package Bare_With_Private_Present_Alloc is new Alloc
           (Subtype_For_With_Private_Present, Access_To_Subtype_For_With_Private_Present);

         function Allocate_With_Private_Present
           (Pool : Bump_Ptr_Pool) return Bare_With_Private_Present;

         function Allocate_With_Private_Present
           (Pool : Bump_Ptr_Pool) return Bare_With_Private_Present
         is
            Result      : constant Access_To_Subtype_For_With_Private_Present := Bare_With_Private_Present_Alloc.Alloc (Pool);
            Result_Kind : Ada_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Ada_With_Private_Present;
            return Bare_With_Private_Present (Result);
         end Allocate_With_Private_Present;

   pragma Warnings (On, "possible aliasing problem for type");
   pragma Warnings (On, "is not referenced");

   type Dontskip_Parser_Function is access function
     (Parser : in out Parser_Type;
      Pos    : Token_Index) return Bare_Ada_Node;

   package Dont_Skip_Fn_Vectors
   is new Ada.Containers.Vectors (Natural, Dontskip_Parser_Function);

   type Free_Parse_List_Record;
   type Free_Parse_List is access all Free_Parse_List_Record;
   --  Cache of temporary lists of AST nodes used in List parsers

   type Free_Parse_List_Record is record
      Nodes : Bare_Ada_Node_Vectors.Vector;
      Next  : Free_Parse_List;
   end record;

   type Parser_Private_Part_Type is record
      Parse_Lists : Free_Parse_List;

      
      Abort_Stmt_Transform_Parse0_Memo : Bare_Abort_Stmt_Memos.Memo_Type;
      
      Abstract_State_Decl_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Abstract_Subp_Decl_Transform_Parse0_Memo : Bare_Abstract_Subp_Decl_Memos.Memo_Type;
      
      Accept_Stmt_Or_Parse0_Memo : Bare_Accept_Stmt_Memos.Memo_Type;
      
      Access_Def_Or_Parse0_Memo : Bare_Access_Def_Memos.Memo_Type;
      
      Aggregate_Assoc_Or_Parse1_Memo : Bare_Basic_Assoc_Memos.Memo_Type;
      
      Aggregate_Or_Parse0_Memo : Bare_Base_Aggregate_Memos.Memo_Type;
      
      Allocator_Transform_Parse0_Memo : Bare_Allocator_Memos.Memo_Type;
      
      Anonymous_Type_Decl_Transform_Parse0_Memo : Bare_Anonymous_Type_Decl_Memos.Memo_Type;
      
      Anonymous_Type_Transform_Parse0_Memo : Bare_Anonymous_Type_Memos.Memo_Type;
      
      Array_Type_Def_Transform_Parse2_Memo : Bare_Array_Type_Def_Memos.Memo_Type;
      
      Aspect_Assoc_Or_Parse2_Memo : Bare_Aspect_Assoc_Memos.Memo_Type;
      
      Aspect_Clause_Or_Parse1_Memo : Bare_Aspect_Clause_Memos.Memo_Type;
      
      Aspect_Spec_Opt_Parse0_Memo : Bare_Aspect_Spec_Memos.Memo_Type;
      
      Assignment_Stmt_Transform_Parse0_Memo : Bare_Assign_Stmt_Memos.Memo_Type;
      
      Attr_Suffix_List_Parse0_Memo : Bare_Assoc_List_Memos.Memo_Type;
      
      Basic_Decl_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Basic_Decls_List_Parse0_Memo : Bare_Ada_Node_List_Memos.Memo_Type;
      
      Block_Stmt_Or_Parse0_Memo : Bare_Composite_Stmt_Memos.Memo_Type;
      
      Body_Or_Parse0_Memo : Bare_Body_Node_Memos.Memo_Type;
      
      Body_Stub_Or_Parse0_Memo : Bare_Body_Stub_Memos.Memo_Type;
      
      Boolean_Op_Or_Parse0_Memo : Bare_Op_Memos.Memo_Type;
      
      Box_Expr_Transform_Parse0_Memo : Bare_Box_Expr_Memos.Memo_Type;
      
      Bracket_Aggregate_Or_Parse0_Memo : Bare_Base_Aggregate_Memos.Memo_Type;
      
      Call_Stmt_Transform_Parse0_Memo : Bare_Call_Stmt_Memos.Memo_Type;
      
      Call_Suffix_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Case_Alt_Transform_Parse0_Memo : Bare_Case_Stmt_Alternative_Memos.Memo_Type;
      
      Case_Expr_Alt_Transform_Parse0_Memo : Bare_Case_Expr_Alternative_Memos.Memo_Type;
      
      Case_Expr_Transform_Parse0_Memo : Bare_Case_Expr_Memos.Memo_Type;
      
      Case_Stmt_Transform_Parse0_Memo : Bare_Case_Stmt_Memos.Memo_Type;
      
      Char_Literal_Transform_Parse0_Memo : Bare_Char_Literal_Memos.Memo_Type;
      
      Choice_List_List_Parse0_Memo : Bare_Alternatives_List_Memos.Memo_Type;
      
      Choice_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Compilation_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Compilation_Unit_Transform_Parse0_Memo : Bare_Compilation_Unit_Memos.Memo_Type;
      
      Component_Clause_Transform_Parse0_Memo : Bare_Component_Clause_Memos.Memo_Type;
      
      Component_Decl_Transform_Parse0_Memo : Bare_Component_Decl_Memos.Memo_Type;
      
      Component_Def_Transform_Parse0_Memo : Bare_Component_Def_Memos.Memo_Type;
      
      Component_Item_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Component_List_Transform_Parse0_Memo : Bare_Component_List_Memos.Memo_Type;
      
      Composite_Constraint_Assoc_Transform_Parse0_Memo : Bare_Composite_Constraint_Assoc_Memos.Memo_Type;
      
      Composite_Constraint_Transform_Parse0_Memo : Bare_Composite_Constraint_Memos.Memo_Type;
      
      Compound_Stmt_Or_Parse0_Memo : Bare_Composite_Stmt_Memos.Memo_Type;
      
      Conditional_Expr_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Constrained_Subtype_Indication_Transform_Parse0_Memo : Bare_Constrained_Subtype_Indication_Memos.Memo_Type;
      
      Constraint_List_List_Parse0_Memo : Bare_Constraint_List_Memos.Memo_Type;
      
      Constraint_Or_Parse0_Memo : Bare_Constraint_Memos.Memo_Type;
      
      Context_Item_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Contract_Case_Assoc_Transform_Parse0_Memo : Bare_Contract_Case_Assoc_Memos.Memo_Type;
      
      Contract_Cases_Expr_Transform_Parse0_Memo : Bare_Contract_Cases_Memos.Memo_Type;
      
      Dec_Literal_Transform_Parse0_Memo : Bare_Real_Literal_Memos.Memo_Type;
      
      Decimal_Fixed_Point_Def_Transform_Parse0_Memo : Bare_Decimal_Fixed_Point_Def_Memos.Memo_Type;
      
      Decl_Part_Transform_Parse0_Memo : Bare_Declarative_Part_Memos.Memo_Type;
      
      Declare_Expr_Transform_Parse0_Memo : Bare_Decl_Expr_Memos.Memo_Type;
      
      Defining_Id_List_List_Parse0_Memo : Bare_Defining_Name_List_Memos.Memo_Type;
      
      Defining_Id_Transform_Parse0_Memo : Bare_Defining_Name_Memos.Memo_Type;
      
      Defining_Name_Transform_Parse0_Memo : Bare_Defining_Name_Memos.Memo_Type;
      
      Delay_Stmt_Transform_Parse0_Memo : Bare_Delay_Stmt_Memos.Memo_Type;
      
      Delta_Constraint_Transform_Parse0_Memo : Bare_Delta_Constraint_Memos.Memo_Type;
      
      Derived_Type_Def_Transform_Parse0_Memo : Bare_Derived_Type_Def_Memos.Memo_Type;
      
      Digits_Constraint_Transform_Parse0_Memo : Bare_Digits_Constraint_Memos.Memo_Type;
      
      Direct_Name_Or_Parse0_Memo : Bare_Base_Id_Memos.Memo_Type;
      
      Direct_Name_Or_Target_Name_Or_Parse0_Memo : Bare_Name_Memos.Memo_Type;
      
      Discr_Spec_List_List_Parse0_Memo : Bare_Discriminant_Spec_List_Memos.Memo_Type;
      
      Discrete_Range_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Discrete_Subtype_Definition_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Discrete_Subtype_Indication_Transform_Parse0_Memo : Bare_Discrete_Subtype_Indication_Memos.Memo_Type;
      
      Discriminant_Part_Or_Parse0_Memo : Bare_Discriminant_Part_Memos.Memo_Type;
      
      Discriminant_Spec_Transform_Parse0_Memo : Bare_Discriminant_Spec_Memos.Memo_Type;
      
      Dontskip_Case_Alt0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Elsif_Part0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Exception_Handler0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Generic_Decl0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Generic_Decl1_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Handled_Stmts0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_If_Stmt0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_If_Stmt1_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Iloop_Stmt0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Iloop_Stmt1_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Iloop_Stmt2_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Package_Body0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Package_Decl0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Package_Decl1_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Protected_Body0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Recov_Decl_Part0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Select_Stmt0_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Select_Stmt1_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Dontskip_Select_Stmt2_Extract_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Elsif_Part_Transform_Parse0_Memo : Bare_Elsif_Stmt_Part_Memos.Memo_Type;
      
      Entry_Body_Transform_Parse3_Memo : Bare_Entry_Body_Memos.Memo_Type;
      
      Entry_Decl_Transform_Parse1_Memo : Bare_Entry_Decl_Memos.Memo_Type;
      
      Enum_Literal_Decl_Transform_Parse1_Memo : Bare_Enum_Literal_Decl_Memos.Memo_Type;
      
      Enum_Type_Def_Transform_Parse0_Memo : Bare_Enum_Type_Def_Memos.Memo_Type;
      
      Exception_Decl_Transform_Parse0_Memo : Bare_Exception_Decl_Memos.Memo_Type;
      
      Exception_Handler_Transform_Parse0_Memo : Bare_Exception_Handler_Memos.Memo_Type;
      
      Exit_Stmt_Transform_Parse0_Memo : Bare_Exit_Stmt_Memos.Memo_Type;
      
      Expr_Fn_Transform_Parse0_Memo : Bare_Expr_Function_Memos.Memo_Type;
      
      Expr_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Ext_Ret_Stmt_Object_Decl_Transform_Parse0_Memo : Bare_Extended_Return_Stmt_Object_Decl_Memos.Memo_Type;
      
      Ext_Return_Stmt_Transform_Parse0_Memo : Bare_Extended_Return_Stmt_Memos.Memo_Type;
      
      Factor_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Floating_Point_Def_Transform_Parse0_Memo : Bare_Floating_Point_Def_Memos.Memo_Type;
      
      For_Loop_Param_Spec_Transform_Parse3_Memo : Bare_For_Loop_Spec_Memos.Memo_Type;
      
      Formal_Discrete_Type_Def_Transform_Parse0_Memo : Bare_Formal_Discrete_Type_Def_Memos.Memo_Type;
      
      Formal_Subp_Decl_Or_Parse2_Memo : Bare_Formal_Subp_Decl_Memos.Memo_Type;
      
      Formal_Type_Decl_Or_Parse1_Memo : Bare_Base_Type_Decl_Memos.Memo_Type;
      
      Generic_Decl_Or_Parse0_Memo : Bare_Generic_Decl_Memos.Memo_Type;
      
      Generic_Formal_Decl_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Generic_Formal_Part_Transform_Parse0_Memo : Bare_Generic_Formal_Part_Memos.Memo_Type;
      
      Generic_Instantiation_Or_Parse1_Memo : Bare_Generic_Instantiation_Memos.Memo_Type;
      
      Generic_Renaming_Decl_Or_Parse1_Memo : Bare_Generic_Renaming_Decl_Memos.Memo_Type;
      
      Goto_Stmt_Transform_Parse0_Memo : Bare_Goto_Stmt_Memos.Memo_Type;
      
      Handled_Stmts_Transform_Parse0_Memo : Bare_Handled_Stmts_Memos.Memo_Type;
      
      Iblock_Stmt_Or_Parse0_Memo : Bare_Block_Stmt_Memos.Memo_Type;
      
      Identifier_Transform_Parse0_Memo : Bare_Identifier_Memos.Memo_Type;
      
      If_Expr_Transform_Parse1_Memo : Bare_If_Expr_Memos.Memo_Type;
      
      If_Stmt_Transform_Parse0_Memo : Bare_If_Stmt_Memos.Memo_Type;
      
      Iloop_Stmt_Or_Parse0_Memo : Bare_Base_Loop_Stmt_Memos.Memo_Type;
      
      Incomplete_Type_Decl_Or_Parse0_Memo : Bare_Incomplete_Type_Decl_Memos.Memo_Type;
      
      Int_Literal_Transform_Parse0_Memo : Bare_Int_Literal_Memos.Memo_Type;
      
      Interface_Type_Def_Transform_Parse4_Memo : Bare_Interface_Type_Def_Memos.Memo_Type;
      
      Iterated_Assoc_Transform_Parse0_Memo : Bare_Iterated_Assoc_Memos.Memo_Type;
      
      Label_Transform_Parse1_Memo : Bare_Label_Memos.Memo_Type;
      
      Library_Item_Transform_Parse1_Memo : Bare_Library_Item_Memos.Memo_Type;
      
      Library_Unit_Body_Or_Parse0_Memo : Bare_Body_Node_Memos.Memo_Type;
      
      Library_Unit_Renaming_Decl_Or_Parse0_Memo : Bare_Basic_Decl_Memos.Memo_Type;
      
      Loop_Stmt_Or_Parse0_Memo : Bare_Composite_Stmt_Memos.Memo_Type;
      
      Membership_Choice_List_List_Parse0_Memo : Bare_Expr_Alternatives_List_Memos.Memo_Type;
      
      Membership_Choice_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Mod_Int_Type_Def_Transform_Parse0_Memo : Bare_Mod_Int_Type_Def_Memos.Memo_Type;
      
      Mode_Or_Parse0_Memo : Bare_Mode_Memos.Memo_Type;
      
      Multi_Abstract_State_Decl_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Multidim_Array_Assoc_Transform_Parse0_Memo : Bare_Multi_Dim_Array_Assoc_Memos.Memo_Type;
      
      Name_Or_Parse2_Memo : Bare_Name_Memos.Memo_Type;
      
      No_Type_Object_Renaming_Decl_Transform_Parse0_Memo : Bare_No_Type_Object_Renaming_Decl_Memos.Memo_Type;
      
      Null_Literal_Transform_Parse0_Memo : Bare_Null_Literal_Memos.Memo_Type;
      
      Null_Stmt_Transform_Parse0_Memo : Bare_Null_Stmt_Memos.Memo_Type;
      
      Null_Subp_Decl_Transform_Parse0_Memo : Bare_Null_Subp_Decl_Memos.Memo_Type;
      
      Num_Literal_Or_Parse0_Memo : Bare_Num_Literal_Memos.Memo_Type;
      
      Number_Decl_Transform_Parse0_Memo : Bare_Number_Decl_Memos.Memo_Type;
      
      Object_Decl_Or_Parse0_Memo : Bare_Basic_Decl_Memos.Memo_Type;
      
      Ordinary_Fixed_Point_Def_Transform_Parse0_Memo : Bare_Ordinary_Fixed_Point_Def_Memos.Memo_Type;
      
      Others_Designator_Transform_Parse0_Memo : Bare_Others_Designator_Memos.Memo_Type;
      
      Overriding_Indicator_Or_Parse0_Memo : Bare_Overriding_Node_Memos.Memo_Type;
      
      Package_Body_Stub_Transform_Parse0_Memo : Bare_Package_Body_Stub_Memos.Memo_Type;
      
      Package_Body_Transform_Parse1_Memo : Bare_Package_Body_Memos.Memo_Type;
      
      Package_Decl_Transform_Parse3_Memo : Bare_Package_Decl_Memos.Memo_Type;
      
      Package_Renaming_Decl_Transform_Parse0_Memo : Bare_Package_Renaming_Decl_Memos.Memo_Type;
      
      Param_Assoc_Transform_Parse0_Memo : Bare_Param_Assoc_Memos.Memo_Type;
      
      Param_Spec_Transform_Parse0_Memo : Bare_Param_Spec_Memos.Memo_Type;
      
      Param_Specs_Transform_Parse0_Memo : Bare_Params_Memos.Memo_Type;
      
      Paren_Expr_Transform_Parse0_Memo : Bare_Paren_Expr_Memos.Memo_Type;
      
      Parent_List_List_Parse0_Memo : Bare_Parent_List_Memos.Memo_Type;
      
      Pp_Directive_Or_Parse0_Memo : Bare_Pp_Directive_Memos.Memo_Type;
      
      Pp_Expr_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Pp_Term_Or_Parse2_Memo : Bare_Expr_Memos.Memo_Type;
      
      Pp_Then_Opt_Parse0_Memo : Bare_Pp_Then_Kw_Memos.Memo_Type;
      
      Pragma_Argument_Transform_Parse1_Memo : Bare_Pragma_Argument_Assoc_Memos.Memo_Type;
      
      Pragma_Transform_Parse0_Memo : Bare_Pragma_Node_Memos.Memo_Type;
      
      Primary_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Protected_Body_Stub_Transform_Parse0_Memo : Bare_Protected_Body_Stub_Memos.Memo_Type;
      
      Protected_Body_Transform_Parse1_Memo : Bare_Protected_Body_Memos.Memo_Type;
      
      Protected_Decl_Transform_Parse0_Memo : Bare_Single_Protected_Decl_Memos.Memo_Type;
      
      Protected_Def_Transform_Parse3_Memo : Bare_Protected_Def_Memos.Memo_Type;
      
      Protected_El_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Protected_Op_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Protected_Type_Decl_Transform_Parse0_Memo : Bare_Protected_Type_Decl_Memos.Memo_Type;
      
      Qual_Name_Internal_Or_Parse0_Memo : Bare_Name_Memos.Memo_Type;
      
      Qualified_Name_Transform_Parse0_Memo : Bare_Qual_Expr_Memos.Memo_Type;
      
      Quantified_Expr_Transform_Parse2_Memo : Bare_Quantified_Expr_Memos.Memo_Type;
      
      Raise_Expr_Or_Parse0_Memo : Bare_Raise_Expr_Memos.Memo_Type;
      
      Raise_Stmt_Or_Parse0_Memo : Bare_Raise_Stmt_Memos.Memo_Type;
      
      Range_Constraint_Transform_Parse1_Memo : Bare_Range_Constraint_Memos.Memo_Type;
      
      Range_Spec_Transform_Parse0_Memo : Bare_Range_Spec_Memos.Memo_Type;
      
      Real_Type_Def_Or_Parse0_Memo : Bare_Real_Type_Def_Memos.Memo_Type;
      
      Record_Def_Or_Parse0_Memo : Bare_Base_Record_Def_Memos.Memo_Type;
      
      Record_Type_Def_Transform_Parse0_Memo : Bare_Record_Type_Def_Memos.Memo_Type;
      
      Recov_Decl_Part_Dont_Skip_Parse0_Memo : Bare_Declarative_Part_Memos.Memo_Type;
      
      Regular_Aggregate_Or_Parse0_Memo : Bare_Base_Aggregate_Memos.Memo_Type;
      
      Rel_Op_Or_Parse0_Memo : Bare_Op_Memos.Memo_Type;
      
      Relation_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Renaming_Clause_Transform_Parse0_Memo : Bare_Renaming_Clause_Memos.Memo_Type;
      
      Requeue_Stmt_Transform_Parse0_Memo : Bare_Requeue_Stmt_Memos.Memo_Type;
      
      Return_Stmt_Transform_Parse0_Memo : Bare_Return_Stmt_Memos.Memo_Type;
      
      Select_Stmt_Transform_Parse1_Memo : Bare_Select_Stmt_Memos.Memo_Type;
      
      Sexpr_Or_Box_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Signed_Int_Type_Def_Transform_Parse0_Memo : Bare_Signed_Int_Type_Def_Memos.Memo_Type;
      
      Simple_Expr_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Simple_Stmt_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Simple_Subp_Decl_Transform_Parse0_Memo : Bare_Subp_Decl_Memos.Memo_Type;
      
      Single_Task_Decl_Transform_Parse1_Memo : Bare_Single_Task_Decl_Memos.Memo_Type;
      
      Static_Name_Or_Parse0_Memo : Bare_Name_Memos.Memo_Type;
      
      Stmt_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Stmts_List_Parse0_Memo : Bare_Stmt_List_Memos.Memo_Type;
      
      String_Literal_Transform_Parse0_Memo : Bare_String_Literal_Memos.Memo_Type;
      
      Sub_Object_Decl_Transform_Parse0_Memo : Bare_Object_Decl_Memos.Memo_Type;
      
      Subp_Body_Stub_Transform_Parse0_Memo : Bare_Subp_Body_Stub_Memos.Memo_Type;
      
      Subp_Body_Transform_Parse1_Memo : Bare_Subp_Body_Memos.Memo_Type;
      
      Subp_Decl_Or_Parse0_Memo : Bare_Basic_Decl_Memos.Memo_Type;
      
      Subp_Renaming_Decl_Transform_Parse0_Memo : Bare_Subp_Renaming_Decl_Memos.Memo_Type;
      
      Subp_Spec_Transform_Parse2_Memo : Bare_Subp_Spec_Memos.Memo_Type;
      
      Subtype_Decl_Transform_Parse0_Memo : Bare_Subtype_Decl_Memos.Memo_Type;
      
      Subtype_Indication_Transform_Parse0_Memo : Bare_Subtype_Indication_Memos.Memo_Type;
      
      Subtype_Name_Or_Parse0_Memo : Bare_Name_Memos.Memo_Type;
      
      Subunit_Transform_Parse0_Memo : Bare_Subunit_Memos.Memo_Type;
      
      Target_Name_Transform_Parse0_Memo : Bare_Target_Name_Memos.Memo_Type;
      
      Task_Body_Stub_Transform_Parse0_Memo : Bare_Task_Body_Stub_Memos.Memo_Type;
      
      Task_Body_Transform_Parse1_Memo : Bare_Task_Body_Memos.Memo_Type;
      
      Task_Def_Transform_Parse3_Memo : Bare_Task_Def_Memos.Memo_Type;
      
      Task_Item_Or_Parse0_Memo : Bare_Ada_Node_Memos.Memo_Type;
      
      Task_Type_Decl_Transform_Parse0_Memo : Bare_Task_Type_Decl_Memos.Memo_Type;
      
      Term_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Terminate_Alternative_Transform_Parse0_Memo : Bare_Terminate_Alternative_Memos.Memo_Type;
      
      Type_Decl_Or_Parse1_Memo : Bare_Base_Type_Decl_Memos.Memo_Type;
      
      Type_Def_Or_Parse0_Memo : Bare_Type_Def_Memos.Memo_Type;
      
      Type_Expr_Or_Parse0_Memo : Bare_Type_Expr_Memos.Memo_Type;
      
      Unconstrained_Index_Transform_Parse0_Memo : Bare_Unconstrained_Array_Index_Memos.Memo_Type;
      
      Unop_Term_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Update_Attr_Aggregate_Or_Parse0_Memo : Bare_Base_Aggregate_Memos.Memo_Type;
      
      Update_Attr_Content_List_Parse0_Memo : Bare_Assoc_List_Memos.Memo_Type;
      
      Use_Clause_Or_Parse0_Memo : Bare_Use_Clause_Memos.Memo_Type;
      
      Use_Package_Clause_Transform_Parse0_Memo : Bare_Use_Package_Clause_Memos.Memo_Type;
      
      Use_Type_Clause_Transform_Parse0_Memo : Bare_Use_Type_Clause_Memos.Memo_Type;
      
      Value_Sequence_Transform_Parse0_Memo : Bare_Value_Sequence_Memos.Memo_Type;
      
      Variant_Part_Transform_Parse0_Memo : Bare_Variant_Part_Memos.Memo_Type;
      
      Variant_Transform_Parse0_Memo : Bare_Variant_Memos.Memo_Type;
      
      While_Loop_Spec_Transform_Parse0_Memo : Bare_While_Loop_Spec_Memos.Memo_Type;
      
      With_Clause_Transform_Parse0_Memo : Bare_With_Clause_Memos.Memo_Type;

      Dont_Skip : Dont_Skip_Fn_Vectors.Vector;
   end record;

   
function Abort_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Abort_Stmt;

   
function Abstract_State_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Abstract_Subp_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Abstract_Subp_Decl;

   
function Accept_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Accept_Stmt;

   
function Access_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Access_Def;

   
function Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate;

   
function Aggregate_Assoc_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Assoc;

   
function Allocator_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Allocator;

   
function Anonymous_Type_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Anonymous_Type;

   
function Anonymous_Type_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Anonymous_Type_Decl;

   
function Array_Type_Def_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Array_Type_Def;

   
function Aspect_Assoc_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Aspect_Assoc;

   
function Aspect_Clause_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Aspect_Clause;

   
function Aspect_Spec_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Aspect_Spec;

   
function Assignment_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Assign_Stmt;

   
function Attr_Suffix_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Assoc_List;

   
function Basic_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Basic_Decls_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node_List;

   
function Block_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Stmt;

   
function Body_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Body_Node;

   
function Body_Stub_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Body_Stub;

   
function Boolean_Op_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Op;

   
function Box_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Box_Expr;

   
function Bracket_Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate;

   
function Call_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Call_Stmt;

   
function Call_Suffix_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Case_Alt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Stmt_Alternative;

   
function Case_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Expr;

   
function Case_Expr_Alt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Expr_Alternative;

   
function Case_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Stmt;

   
function Char_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Char_Literal;

   
function Choice_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Choice_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Alternatives_List;

   
function Compilation_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Compilation_Unit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Compilation_Unit;

   
function Component_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_Clause;

   
function Component_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_Decl;

   
function Component_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_Def;

   
function Component_Item_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Component_List_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_List;

   
function Composite_Constraint_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Constraint;

   
function Composite_Constraint_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Constraint_Assoc;

   
function Compound_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Stmt;

   
function Conditional_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Constrained_Subtype_Indication_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Constrained_Subtype_Indication;

   
function Constraint_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Constraint;

   
function Constraint_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Constraint_List;

   
function Context_Item_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Contract_Case_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Contract_Case_Assoc;

   
function Contract_Cases_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Contract_Cases;

   
function Dec_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Real_Literal;

   
function Decimal_Fixed_Point_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decimal_Fixed_Point_Def;

   
function Decl_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Declarative_Part;

   
function Declare_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Expr;

   
function Defining_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Defining_Name;

   
function Defining_Id_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Defining_Name_List;

   
function Defining_Name_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Defining_Name;

   
function Delay_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Delay_Stmt;

   
function Delta_Constraint_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Delta_Constraint;

   
function Derived_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Derived_Type_Def;

   
function Digits_Constraint_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Digits_Constraint;

   
function Direct_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Id;

   
function Direct_Name_Or_Target_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name;

   
function Discr_Spec_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discriminant_Spec_List;

   
function Discrete_Range_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Discrete_Subtype_Definition_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Discrete_Subtype_Indication_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discrete_Subtype_Indication;

   
function Discriminant_Part_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discriminant_Part;

   
function Discriminant_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discriminant_Spec;

   
function Dontskip_Case_Alt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Elsif_Part0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Exception_Handler0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Generic_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Generic_Decl1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Handled_Stmts0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_If_Stmt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_If_Stmt1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Iloop_Stmt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Iloop_Stmt1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Iloop_Stmt2_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Package_Body0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Package_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Package_Decl1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Protected_Body0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Recov_Decl_Part0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Select_Stmt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Select_Stmt1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Dontskip_Select_Stmt2_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Elsif_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Elsif_Stmt_Part;

   
function Entry_Body_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Entry_Body;

   
function Entry_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Entry_Decl;

   
function Enum_Literal_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Literal_Decl;

   
function Enum_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Type_Def;

   
function Exception_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Exception_Decl;

   
function Exception_Handler_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Exception_Handler;

   
function Exit_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Exit_Stmt;

   
function Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Expr_Fn_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr_Function;

   
function Ext_Ret_Stmt_Object_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Extended_Return_Stmt_Object_Decl;

   
function Ext_Return_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Extended_Return_Stmt;

   
function Factor_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Floating_Point_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Floating_Point_Def;

   
function For_Loop_Param_Spec_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_For_Loop_Spec;

   
function Formal_Discrete_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Formal_Discrete_Type_Def;

   
function Formal_Subp_Decl_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Formal_Subp_Decl;

   
function Formal_Type_Decl_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Type_Decl;

   
function Generic_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Decl;

   
function Generic_Formal_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Generic_Formal_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Formal_Part;

   
function Generic_Instantiation_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Instantiation;

   
function Generic_Renaming_Decl_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Renaming_Decl;

   
function Goto_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Goto_Stmt;

   
function Handled_Stmts_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Handled_Stmts;

   
function Iblock_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_Stmt;

   
function Identifier_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Identifier;

   
function If_Expr_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Expr;

   
function If_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Stmt;

   
function Iloop_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Loop_Stmt;

   
function Incomplete_Type_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Incomplete_Type_Decl;

   
function Int_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Int_Literal;

   
function Interface_Type_Def_Transform_Parse4
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Interface_Type_Def;

   
function Iterated_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Iterated_Assoc;

   
function Label_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Label;

   
function Library_Item_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Library_Item;

   
function Library_Unit_Body_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Body_Node;

   
function Library_Unit_Renaming_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Decl;

   
function Loop_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Stmt;

   
function Membership_Choice_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Membership_Choice_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr_Alternatives_List;

   
function Mod_Int_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Mod_Int_Type_Def;

   
function Mode_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Mode;

   
function Multi_Abstract_State_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Multidim_Array_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Multi_Dim_Array_Assoc;

   
function Name_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name;

   
function No_Type_Object_Renaming_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_No_Type_Object_Renaming_Decl;

   
function Null_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Literal;

   
function Null_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Stmt;

   
function Null_Subp_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Subp_Decl;

   
function Num_Literal_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Num_Literal;

   
function Number_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Number_Decl;

   
function Object_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Decl;

   
function Ordinary_Fixed_Point_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ordinary_Fixed_Point_Def;

   
function Others_Designator_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Others_Designator;

   
function Overriding_Indicator_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Overriding_Node;

   
function Package_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Body;

   
function Package_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Body_Stub;

   
function Package_Decl_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Decl;

   
function Package_Renaming_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Renaming_Decl;

   
function Param_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param_Assoc;

   
function Param_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param_Spec;

   
function Param_Specs_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Params;

   
function Paren_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Paren_Expr;

   
function Parent_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Parent_List;

   
function Pp_Directive_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pp_Directive;

   
function Pp_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Pp_Term_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Pp_Then_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pp_Then_Kw;

   
function Pragma_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pragma_Node;

   
function Pragma_Argument_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pragma_Argument_Assoc;

   
function Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Protected_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Body;

   
function Protected_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Body_Stub;

   
function Protected_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Single_Protected_Decl;

   
function Protected_Def_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Def;

   
function Protected_El_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Protected_Op_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Protected_Type_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Type_Decl;

   
function Qual_Name_Internal_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name;

   
function Qualified_Name_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Qual_Expr;

   
function Quantified_Expr_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Quantified_Expr;

   
function Raise_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Expr;

   
function Raise_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Stmt;

   
function Range_Constraint_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Range_Constraint;

   
function Range_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Range_Spec;

   
function Real_Type_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Real_Type_Def;

   
function Record_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Record_Def;

   
function Record_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Record_Type_Def;

   
function Recov_Decl_Part_Dont_Skip_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Declarative_Part;

   
function Regular_Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate;

   
function Rel_Op_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Op;

   
function Relation_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Renaming_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Renaming_Clause;

   
function Requeue_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Requeue_Stmt;

   
function Return_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Return_Stmt;

   
function Select_Stmt_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Select_Stmt;

   
function Sexpr_Or_Box_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Signed_Int_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Signed_Int_Type_Def;

   
function Simple_Expr_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Simple_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Simple_Subp_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Decl;

   
function Single_Task_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Single_Task_Decl;

   
function Static_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name;

   
function Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Stmts_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Stmt_List;

   
function String_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Literal;

   
function Sub_Object_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Object_Decl;

   
function Subp_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Body;

   
function Subp_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Body_Stub;

   
function Subp_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Decl;

   
function Subp_Renaming_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Renaming_Decl;

   
function Subp_Spec_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Spec;

   
function Subtype_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subtype_Decl;

   
function Subtype_Indication_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subtype_Indication;

   
function Subtype_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name;

   
function Subunit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subunit;

   
function Target_Name_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Target_Name;

   
function Task_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Body;

   
function Task_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Body_Stub;

   
function Task_Def_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Def;

   
function Task_Item_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node;

   
function Task_Type_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Type_Decl;

   
function Term_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Terminate_Alternative_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Terminate_Alternative;

   
function Type_Decl_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Type_Decl;

   
function Type_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Def;

   
function Type_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Expr;

   
function Unconstrained_Index_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Unconstrained_Array_Index;

   
function Unop_Term_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Update_Attr_Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate;

   
function Update_Attr_Content_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Assoc_List;

   
function Use_Clause_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Use_Clause;

   
function Use_Package_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Use_Package_Clause;

   
function Use_Type_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Use_Type_Clause;

   
function Value_Sequence_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Value_Sequence;

   
function Variant_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Variant;

   
function Variant_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Variant_Part;

   
function While_Loop_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_While_Loop_Spec;

   
function With_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_With_Clause;


   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True);
   --  Helper for the user parsing function, to be called after a low-level
   --  parsing function. Check_Complete has the same semantics as in Parse. If
   --  the parsing failed (Parser.Current_Pos = No_Token_Index), append
   --  corresponding diagnostics to Parser.Diagnostics, do nothing instead.

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type);
   --  Add a diagnostic for the last fail position of the parser

   pragma Warnings (Off, "is not referenced");

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List;
   --  Get a free parse list, or allocate one if there is no free parse list in
   --  Parser. When done with the result, the caller must invoke
   --  Release_Parse_List.

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List);
   --  Release a parse list, putting it in Parsers' free list. Set List to
   --  null.

   procedure Initialize_List
     (Self   : Bare_Ada_List;
      Parser : Parser_Type;
      Count  : Natural);
   --  Helper for parsers, to initialize the list of children in a freshly
   --  allocated list node.

   pragma Warnings (On, "is not referenced");

   procedure Enter_Call (Parser : Parser_Type; Call_Depth : access Natural);
   procedure Exit_Call (Parser : Parser_Type; Call_Depth : Natural);
   --  Shortcuts to forward Parser's context to the eponym procedures in
   --  the Implementation package.

   ---------------------
   -- Initialize_List --
   ---------------------

   procedure Initialize_List
     (Self   : Bare_Ada_List;
      Parser : Parser_Type;
      Count  : Natural) is
   begin
      Self.Count := Count;
      Self.Nodes := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, 0);
   end Initialize_List;

   -----------------
   -- Init_Parser --
   -----------------

   procedure Init_Parser
     (Input       : Internal_Lexer_Input;
      With_Trivia : Boolean;
      Unit        : access Implementation.Analysis_Unit_Type;
      TDH         : Token_Data_Handler_Access;
      Parser      : in out Parser_Type)
   is
      --  Never try to use file readers for internal units: these are generally
      --  not actual source files, and file readers, which are external users
      --  of the generated library, have no reason to be aware of them.

      FR : constant Internal_File_Reader_Access :=
        (if Unit.Is_Internal
         then null
         else Unit.Context.File_Reader);
   begin
      Reset (Parser);
      Extract_Tokens (Input, With_Trivia, FR, TDH.all, Parser.Diagnostics);
      Parser.Unit := Unit;
      Parser.TDH := TDH;
   end Init_Parser;

   ------------------------------
   -- Add_Last_Fail_Diagnostic --
   ------------------------------

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type)
   is
      Last_Token : Stored_Token_Data renames
         Get_Token (Parser.TDH.all, Parser.Last_Fail.Pos);
      D : constant Diagnostic :=
        (if Parser.Last_Fail.Kind = Token_Fail then
          Create (Sloc_Range (Parser.TDH.all, Last_Token), To_Text
            ("Expected "
             & Token_Error_Image (Parser.Last_Fail.Expected_Token_Id)
             & ", got "
             & Token_Error_Image (Parser.Last_Fail.Found_Token_Id)))
         else
           Create (Sloc_Range (Parser.TDH.all, Last_Token),
                   To_Text (Parser.Last_Fail.Custom_Message.all)));
   begin
      Parser.Diagnostics.Append (D);
   end Add_Last_Fail_Diagnostic;

   ---------------------------
   -- Process_Parsing_Error --
   ---------------------------

   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True) is
   begin

      if Parser.Current_Pos = No_Token_Index then
         Add_Last_Fail_Diagnostic (Parser);
      elsif Check_Complete
        and then Parser.Current_Pos /= Last_Token (Parser.TDH.all)
      then
         --  If the fail pos is the current position of the parser or after,
         --  it means that the longest parse is the correct result, and that we
         --  have some garbage afterwards.
         if Parser.Current_Pos >= Parser.Last_Fail.Pos then
            declare
               First_Garbage_Token : Stored_Token_Data renames
                  Get_Token (Parser.TDH.all, Parser.Current_Pos);
            begin
               Append
                 (Parser.Diagnostics,
                  Sloc_Range (Parser.TDH.all, First_Garbage_Token),
                  To_Text
                    ("End of input expected, got """
                     & Token_Kind_Name
                         (To_Token_Kind (First_Garbage_Token.Kind))
                     & """"));
            end;

         --  Else, the last fail pos is further down the line, and we want to
         --  have the diagnostic of what exactly failed.
         else
            Add_Last_Fail_Diagnostic (Parser);
         end if;
      end if;

   end Process_Parsing_Error;

   -----------
   -- Parse --
   -----------

   function Parse
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True;
      Rule           : Grammar_Rule) return Parsed_Node
   is
      Result : Bare_Ada_Node;
   begin
      case Rule is
         when Parent_List_Rule =>
            Result := Parent_List_List_Parse0
              (Parser, First_Token_Index);
         when Protected_Type_Decl_Rule =>
            Result := Protected_Type_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Protected_Op_Rule =>
            Result := Protected_Op_Or_Parse0
              (Parser, First_Token_Index);
         when Protected_El_Rule =>
            Result := Protected_El_Or_Parse0
              (Parser, First_Token_Index);
         when Protected_Def_Rule =>
            Result := Protected_Def_Transform_Parse3
              (Parser, First_Token_Index);
         when Protected_Decl_Rule =>
            Result := Protected_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Task_Item_Rule =>
            Result := Task_Item_Or_Parse0
              (Parser, First_Token_Index);
         when Task_Def_Rule =>
            Result := Task_Def_Transform_Parse3
              (Parser, First_Token_Index);
         when Task_Type_Decl_Rule =>
            Result := Task_Type_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Subtype_Decl_Rule =>
            Result := Subtype_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Interface_Type_Def_Rule =>
            Result := Interface_Type_Def_Transform_Parse4
              (Parser, First_Token_Index);
         when Unconstrained_Index_Rule =>
            Result := Unconstrained_Index_Transform_Parse0
              (Parser, First_Token_Index);
         when Array_Type_Def_Rule =>
            Result := Array_Type_Def_Transform_Parse2
              (Parser, First_Token_Index);
         when Discrete_Subtype_Definition_Rule =>
            Result := Discrete_Subtype_Definition_Or_Parse0
              (Parser, First_Token_Index);
         when Constraint_List_Rule =>
            Result := Constraint_List_List_Parse0
              (Parser, First_Token_Index);
         when Signed_Int_Type_Def_Rule =>
            Result := Signed_Int_Type_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Mod_Int_Type_Def_Rule =>
            Result := Mod_Int_Type_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Derived_Type_Def_Rule =>
            Result := Derived_Type_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Composite_Constraint_Assoc_Rule =>
            Result := Composite_Constraint_Assoc_Transform_Parse0
              (Parser, First_Token_Index);
         when Composite_Constraint_Rule =>
            Result := Composite_Constraint_Transform_Parse0
              (Parser, First_Token_Index);
         when Digits_Constraint_Rule =>
            Result := Digits_Constraint_Transform_Parse0
              (Parser, First_Token_Index);
         when Delta_Constraint_Rule =>
            Result := Delta_Constraint_Transform_Parse0
              (Parser, First_Token_Index);
         when Range_Constraint_Rule =>
            Result := Range_Constraint_Transform_Parse1
              (Parser, First_Token_Index);
         when Constraint_Rule =>
            Result := Constraint_Or_Parse0
              (Parser, First_Token_Index);
         when Discriminant_Spec_Rule =>
            Result := Discriminant_Spec_Transform_Parse0
              (Parser, First_Token_Index);
         when Discr_Spec_List_Rule =>
            Result := Discr_Spec_List_List_Parse0
              (Parser, First_Token_Index);
         when Discriminant_Part_Rule =>
            Result := Discriminant_Part_Or_Parse0
              (Parser, First_Token_Index);
         when Enum_Literal_Decl_Rule =>
            Result := Enum_Literal_Decl_Transform_Parse1
              (Parser, First_Token_Index);
         when Formal_Discrete_Type_Def_Rule =>
            Result := Formal_Discrete_Type_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Record_Def_Rule =>
            Result := Record_Def_Or_Parse0
              (Parser, First_Token_Index);
         when Range_Spec_Rule =>
            Result := Range_Spec_Transform_Parse0
              (Parser, First_Token_Index);
         when Real_Type_Def_Rule =>
            Result := Real_Type_Def_Or_Parse0
              (Parser, First_Token_Index);
         when Sexpr_Or_Box_Rule =>
            Result := Sexpr_Or_Box_Or_Parse0
              (Parser, First_Token_Index);
         when Ordinary_Fixed_Point_Def_Rule =>
            Result := Ordinary_Fixed_Point_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Decimal_Fixed_Point_Def_Rule =>
            Result := Decimal_Fixed_Point_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Floating_Point_Def_Rule =>
            Result := Floating_Point_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Record_Type_Def_Rule =>
            Result := Record_Type_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Access_Def_Rule =>
            Result := Access_Def_Or_Parse0
              (Parser, First_Token_Index);
         when Enum_Type_Def_Rule =>
            Result := Enum_Type_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Def_Rule =>
            Result := Type_Def_Or_Parse0
              (Parser, First_Token_Index);
         when Variant_Rule =>
            Result := Variant_Transform_Parse0
              (Parser, First_Token_Index);
         when Anonymous_Type_Decl_Rule =>
            Result := Anonymous_Type_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Incomplete_Type_Decl_Rule =>
            Result := Incomplete_Type_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Type_Decl_Rule =>
            Result := Type_Decl_Or_Parse1
              (Parser, First_Token_Index);
         when Variant_Part_Rule =>
            Result := Variant_Part_Transform_Parse0
              (Parser, First_Token_Index);
         when Component_Def_Rule =>
            Result := Component_Def_Transform_Parse0
              (Parser, First_Token_Index);
         when Component_Item_Rule =>
            Result := Component_Item_Or_Parse0
              (Parser, First_Token_Index);
         when Component_Decl_Rule =>
            Result := Component_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Component_List_Rule =>
            Result := Component_List_Transform_Parse0
              (Parser, First_Token_Index);
         when Generic_Decl_Rule =>
            Result := Generic_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Generic_Formal_Part_Rule =>
            Result := Generic_Formal_Part_Transform_Parse0
              (Parser, First_Token_Index);
         when Generic_Formal_Decl_Rule =>
            Result := Generic_Formal_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Formal_Type_Decl_Rule =>
            Result := Formal_Type_Decl_Or_Parse1
              (Parser, First_Token_Index);
         when Formal_Subp_Decl_Rule =>
            Result := Formal_Subp_Decl_Or_Parse2
              (Parser, First_Token_Index);
         when Renaming_Clause_Rule =>
            Result := Renaming_Clause_Transform_Parse0
              (Parser, First_Token_Index);
         when Generic_Renaming_Decl_Rule =>
            Result := Generic_Renaming_Decl_Or_Parse1
              (Parser, First_Token_Index);
         when Generic_Instantiation_Rule =>
            Result := Generic_Instantiation_Or_Parse1
              (Parser, First_Token_Index);
         when Exception_Decl_Rule =>
            Result := Exception_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Basic_Decls_Rule =>
            Result := Basic_Decls_List_Parse0
              (Parser, First_Token_Index);
         when Package_Renaming_Decl_Rule =>
            Result := Package_Renaming_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Package_Decl_Rule =>
            Result := Package_Decl_Transform_Parse3
              (Parser, First_Token_Index);
         when Basic_Decl_Rule =>
            Result := Basic_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Object_Decl_Rule =>
            Result := Object_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Sub_Object_Decl_Rule =>
            Result := Sub_Object_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when No_Type_Object_Renaming_Decl_Rule =>
            Result := No_Type_Object_Renaming_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Ext_Ret_Stmt_Object_Decl_Rule =>
            Result := Ext_Ret_Stmt_Object_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Defining_Id_List_Rule =>
            Result := Defining_Id_List_List_Parse0
              (Parser, First_Token_Index);
         when Number_Decl_Rule =>
            Result := Number_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Contract_Case_Assoc_Rule =>
            Result := Contract_Case_Assoc_Transform_Parse0
              (Parser, First_Token_Index);
         when Contract_Cases_Expr_Rule =>
            Result := Contract_Cases_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Abstract_State_Decl_Rule =>
            Result := Abstract_State_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Multi_Abstract_State_Decl_Rule =>
            Result := Multi_Abstract_State_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Aspect_Assoc_Rule =>
            Result := Aspect_Assoc_Or_Parse2
              (Parser, First_Token_Index);
         when Aspect_Spec_Rule =>
            Result := Aspect_Spec_Opt_Parse0
              (Parser, First_Token_Index);
         when Single_Task_Decl_Rule =>
            Result := Single_Task_Decl_Transform_Parse1
              (Parser, First_Token_Index);
         when Overriding_Indicator_Rule =>
            Result := Overriding_Indicator_Or_Parse0
              (Parser, First_Token_Index);
         when Entry_Decl_Rule =>
            Result := Entry_Decl_Transform_Parse1
              (Parser, First_Token_Index);
         when Component_Clause_Rule =>
            Result := Component_Clause_Transform_Parse0
              (Parser, First_Token_Index);
         when Aspect_Clause_Rule =>
            Result := Aspect_Clause_Or_Parse1
              (Parser, First_Token_Index);
         when Param_Spec_Rule =>
            Result := Param_Spec_Transform_Parse0
              (Parser, First_Token_Index);
         when Param_Specs_Rule =>
            Result := Param_Specs_Transform_Parse0
              (Parser, First_Token_Index);
         when Subp_Spec_Rule =>
            Result := Subp_Spec_Transform_Parse2
              (Parser, First_Token_Index);
         when Expr_Fn_Rule =>
            Result := Expr_Fn_Transform_Parse0
              (Parser, First_Token_Index);
         when Null_Subp_Decl_Rule =>
            Result := Null_Subp_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Abstract_Subp_Decl_Rule =>
            Result := Abstract_Subp_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Subp_Renaming_Decl_Rule =>
            Result := Subp_Renaming_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Simple_Subp_Decl_Rule =>
            Result := Simple_Subp_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Subp_Decl_Rule =>
            Result := Subp_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when With_Clause_Rule =>
            Result := With_Clause_Transform_Parse0
              (Parser, First_Token_Index);
         when Context_Item_Rule =>
            Result := Context_Item_Or_Parse0
              (Parser, First_Token_Index);
         when Use_Clause_Rule =>
            Result := Use_Clause_Or_Parse0
              (Parser, First_Token_Index);
         when Use_Package_Clause_Rule =>
            Result := Use_Package_Clause_Transform_Parse0
              (Parser, First_Token_Index);
         when Use_Type_Clause_Rule =>
            Result := Use_Type_Clause_Transform_Parse0
              (Parser, First_Token_Index);
         when Subtype_Indication_Rule =>
            Result := Subtype_Indication_Transform_Parse0
              (Parser, First_Token_Index);
         when Discrete_Subtype_Indication_Rule =>
            Result := Discrete_Subtype_Indication_Transform_Parse0
              (Parser, First_Token_Index);
         when Constrained_Subtype_Indication_Rule =>
            Result := Constrained_Subtype_Indication_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Expr_Rule =>
            Result := Type_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Anonymous_Type_Rule =>
            Result := Anonymous_Type_Transform_Parse0
              (Parser, First_Token_Index);
         when Mode_Rule =>
            Result := Mode_Or_Parse0
              (Parser, First_Token_Index);
         when Pragma_Argument_Rule =>
            Result := Pragma_Argument_Transform_Parse1
              (Parser, First_Token_Index);
         when Pragma_Rule =>
            Result := Pragma_Transform_Parse0
              (Parser, First_Token_Index);
         when Subunit_Rule =>
            Result := Subunit_Transform_Parse0
              (Parser, First_Token_Index);
         when Library_Unit_Body_Rule =>
            Result := Library_Unit_Body_Or_Parse0
              (Parser, First_Token_Index);
         when Library_Unit_Renaming_Decl_Rule =>
            Result := Library_Unit_Renaming_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Library_Item_Rule =>
            Result := Library_Item_Transform_Parse1
              (Parser, First_Token_Index);
         when Compilation_Unit_Rule =>
            Result := Compilation_Unit_Transform_Parse0
              (Parser, First_Token_Index);
         when Compilation_Rule =>
            Result := Compilation_Or_Parse0
              (Parser, First_Token_Index);
         when Decl_Part_Rule =>
            Result := Decl_Part_Transform_Parse0
              (Parser, First_Token_Index);
         when Entry_Body_Rule =>
            Result := Entry_Body_Transform_Parse3
              (Parser, First_Token_Index);
         when Protected_Body_Rule =>
            Result := Protected_Body_Transform_Parse1
              (Parser, First_Token_Index);
         when Protected_Body_Stub_Rule =>
            Result := Protected_Body_Stub_Transform_Parse0
              (Parser, First_Token_Index);
         when Task_Body_Rule =>
            Result := Task_Body_Transform_Parse1
              (Parser, First_Token_Index);
         when Task_Body_Stub_Rule =>
            Result := Task_Body_Stub_Transform_Parse0
              (Parser, First_Token_Index);
         when Package_Body_Stub_Rule =>
            Result := Package_Body_Stub_Transform_Parse0
              (Parser, First_Token_Index);
         when Package_Body_Rule =>
            Result := Package_Body_Transform_Parse1
              (Parser, First_Token_Index);
         when Terminate_Alternative_Rule =>
            Result := Terminate_Alternative_Transform_Parse0
              (Parser, First_Token_Index);
         when Select_Stmt_Rule =>
            Result := Select_Stmt_Transform_Parse1
              (Parser, First_Token_Index);
         when Accept_Stmt_Rule =>
            Result := Accept_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Case_Alt_Rule =>
            Result := Case_Alt_Transform_Parse0
              (Parser, First_Token_Index);
         when Case_Stmt_Rule =>
            Result := Case_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Ext_Return_Stmt_Rule =>
            Result := Ext_Return_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Iblock_Stmt_Rule =>
            Result := Iblock_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Block_Stmt_Rule =>
            Result := Block_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when While_Loop_Spec_Rule =>
            Result := While_Loop_Spec_Transform_Parse0
              (Parser, First_Token_Index);
         when Iloop_Stmt_Rule =>
            Result := Iloop_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Loop_Stmt_Rule =>
            Result := Loop_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Compound_Stmt_Rule =>
            Result := Compound_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Elsif_Part_Rule =>
            Result := Elsif_Part_Transform_Parse0
              (Parser, First_Token_Index);
         when If_Stmt_Rule =>
            Result := If_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Raise_Stmt_Rule =>
            Result := Raise_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Delay_Stmt_Rule =>
            Result := Delay_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Abort_Stmt_Rule =>
            Result := Abort_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Body_Rule =>
            Result := Body_Or_Parse0
              (Parser, First_Token_Index);
         when Body_Stub_Rule =>
            Result := Body_Stub_Or_Parse0
              (Parser, First_Token_Index);
         when Subp_Body_Stub_Rule =>
            Result := Subp_Body_Stub_Transform_Parse0
              (Parser, First_Token_Index);
         when Recov_Decl_Part_Rule =>
            Result := Recov_Decl_Part_Dont_Skip_Parse0
              (Parser, First_Token_Index);
         when Subp_Body_Rule =>
            Result := Subp_Body_Transform_Parse1
              (Parser, First_Token_Index);
         when Handled_Stmts_Rule =>
            Result := Handled_Stmts_Transform_Parse0
              (Parser, First_Token_Index);
         when Exception_Handler_Rule =>
            Result := Exception_Handler_Transform_Parse0
              (Parser, First_Token_Index);
         when Stmts_Rule =>
            Result := Stmts_List_Parse0
              (Parser, First_Token_Index);
         when Label_Rule =>
            Result := Label_Transform_Parse1
              (Parser, First_Token_Index);
         when Stmt_Rule =>
            Result := Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Call_Stmt_Rule =>
            Result := Call_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Simple_Stmt_Rule =>
            Result := Simple_Stmt_Or_Parse0
              (Parser, First_Token_Index);
         when Null_Stmt_Rule =>
            Result := Null_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Assignment_Stmt_Rule =>
            Result := Assignment_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Goto_Stmt_Rule =>
            Result := Goto_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Exit_Stmt_Rule =>
            Result := Exit_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Return_Stmt_Rule =>
            Result := Return_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Requeue_Stmt_Rule =>
            Result := Requeue_Stmt_Transform_Parse0
              (Parser, First_Token_Index);
         when Identifier_Rule =>
            Result := Identifier_Transform_Parse0
              (Parser, First_Token_Index);
         when Char_Literal_Rule =>
            Result := Char_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when String_Literal_Rule =>
            Result := String_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Defining_Id_Rule =>
            Result := Defining_Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Dec_Literal_Rule =>
            Result := Dec_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Int_Literal_Rule =>
            Result := Int_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Num_Literal_Rule =>
            Result := Num_Literal_Or_Parse0
              (Parser, First_Token_Index);
         when Null_Literal_Rule =>
            Result := Null_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Allocator_Rule =>
            Result := Allocator_Transform_Parse0
              (Parser, First_Token_Index);
         when For_Loop_Param_Spec_Rule =>
            Result := For_Loop_Param_Spec_Transform_Parse3
              (Parser, First_Token_Index);
         when Quantified_Expr_Rule =>
            Result := Quantified_Expr_Transform_Parse2
              (Parser, First_Token_Index);
         when Case_Expr_Rule =>
            Result := Case_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Case_Expr_Alt_Rule =>
            Result := Case_Expr_Alt_Transform_Parse0
              (Parser, First_Token_Index);
         when Raise_Expr_Rule =>
            Result := Raise_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when If_Expr_Rule =>
            Result := If_Expr_Transform_Parse1
              (Parser, First_Token_Index);
         when Conditional_Expr_Rule =>
            Result := Conditional_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Box_Expr_Rule =>
            Result := Box_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Others_Designator_Rule =>
            Result := Others_Designator_Transform_Parse0
              (Parser, First_Token_Index);
         when Iterated_Assoc_Rule =>
            Result := Iterated_Assoc_Transform_Parse0
              (Parser, First_Token_Index);
         when Aggregate_Assoc_Rule =>
            Result := Aggregate_Assoc_Or_Parse1
              (Parser, First_Token_Index);
         when Regular_Aggregate_Rule =>
            Result := Regular_Aggregate_Or_Parse0
              (Parser, First_Token_Index);
         when Bracket_Aggregate_Rule =>
            Result := Bracket_Aggregate_Or_Parse0
              (Parser, First_Token_Index);
         when Aggregate_Rule =>
            Result := Aggregate_Or_Parse0
              (Parser, First_Token_Index);
         when Direct_Name_Rule =>
            Result := Direct_Name_Or_Parse0
              (Parser, First_Token_Index);
         when Param_Assoc_Rule =>
            Result := Param_Assoc_Transform_Parse0
              (Parser, First_Token_Index);
         when Call_Suffix_Rule =>
            Result := Call_Suffix_Or_Parse0
              (Parser, First_Token_Index);
         when Attr_Suffix_Rule =>
            Result := Attr_Suffix_List_Parse0
              (Parser, First_Token_Index);
         when Qualified_Name_Rule =>
            Result := Qualified_Name_Transform_Parse0
              (Parser, First_Token_Index);
         when Qual_Name_Internal_Rule =>
            Result := Qual_Name_Internal_Or_Parse0
              (Parser, First_Token_Index);
         when Value_Sequence_Rule =>
            Result := Value_Sequence_Transform_Parse0
              (Parser, First_Token_Index);
         when Name_Rule =>
            Result := Name_Or_Parse2
              (Parser, First_Token_Index);
         when Defining_Name_Rule =>
            Result := Defining_Name_Transform_Parse0
              (Parser, First_Token_Index);
         when Direct_Name_Or_Target_Name_Rule =>
            Result := Direct_Name_Or_Target_Name_Or_Parse0
              (Parser, First_Token_Index);
         when Target_Name_Rule =>
            Result := Target_Name_Transform_Parse0
              (Parser, First_Token_Index);
         when Update_Attr_Aggregate_Rule =>
            Result := Update_Attr_Aggregate_Or_Parse0
              (Parser, First_Token_Index);
         when Update_Attr_Content_Rule =>
            Result := Update_Attr_Content_List_Parse0
              (Parser, First_Token_Index);
         when Multidim_Array_Assoc_Rule =>
            Result := Multidim_Array_Assoc_Transform_Parse0
              (Parser, First_Token_Index);
         when Subtype_Name_Rule =>
            Result := Subtype_Name_Or_Parse0
              (Parser, First_Token_Index);
         when Static_Name_Rule =>
            Result := Static_Name_Or_Parse0
              (Parser, First_Token_Index);
         when Primary_Rule =>
            Result := Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Paren_Expr_Rule =>
            Result := Paren_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Declare_Expr_Rule =>
            Result := Declare_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Factor_Rule =>
            Result := Factor_Or_Parse1
              (Parser, First_Token_Index);
         when Term_Rule =>
            Result := Term_Or_Parse1
              (Parser, First_Token_Index);
         when Unop_Term_Rule =>
            Result := Unop_Term_Or_Parse1
              (Parser, First_Token_Index);
         when Simple_Expr_Rule =>
            Result := Simple_Expr_Or_Parse1
              (Parser, First_Token_Index);
         when Boolean_Op_Rule =>
            Result := Boolean_Op_Or_Parse0
              (Parser, First_Token_Index);
         when Discrete_Range_Rule =>
            Result := Discrete_Range_Or_Parse0
              (Parser, First_Token_Index);
         when Choice_Rule =>
            Result := Choice_Or_Parse0
              (Parser, First_Token_Index);
         when Choice_List_Rule =>
            Result := Choice_List_List_Parse0
              (Parser, First_Token_Index);
         when Rel_Op_Rule =>
            Result := Rel_Op_Or_Parse0
              (Parser, First_Token_Index);
         when Membership_Choice_Rule =>
            Result := Membership_Choice_Or_Parse0
              (Parser, First_Token_Index);
         when Membership_Choice_List_Rule =>
            Result := Membership_Choice_List_List_Parse0
              (Parser, First_Token_Index);
         when Relation_Rule =>
            Result := Relation_Or_Parse1
              (Parser, First_Token_Index);
         when Expr_Rule =>
            Result := Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Pp_Directive_Rule =>
            Result := Pp_Directive_Or_Parse0
              (Parser, First_Token_Index);
         when Pp_Then_Rule =>
            Result := Pp_Then_Opt_Parse0
              (Parser, First_Token_Index);
         when Pp_Expr_Rule =>
            Result := Pp_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Pp_Term_Rule =>
            Result := Pp_Term_Or_Parse2
              (Parser, First_Token_Index);
      end case;
      Process_Parsing_Error (Parser, Check_Complete);
      Set_Parents (Result, null);
      return Parsed_Node (Result);
   exception
      when Exc : Precondition_Failure | Property_Error =>
         Append
           (Parser.Diagnostics,
            No_Source_Location_Range,
            To_Text ("Error during parsing: "
                     & Ada.Exceptions.Exception_Message (Exc)));
         return Parsed_Node (No_Bare_Ada_Node);
   end Parse;

   


function Abort_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Abort_Stmt
is
   use Bare_Abort_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos0 :
            Token_Index
               := No_Token_Index;
      Token_Pos0 :
            Token_Index
               := No_Token_Index;
      Token_Res0 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos0 :
            Token_Index
               := No_Token_Index;
      Tmp_List0 :
            Free_Parse_List;
      Defer_Pos0 :
            Token_Index
               := No_Token_Index;
      Defer_Res0 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos1 :
            Token_Index
               := No_Token_Index;
      Token_Res1 :
            Token_Index
               := No_Token_Index;
      List_Pos0 :
            Token_Index
               := No_Token_Index;
      List_Res0 :
            Bare_Name_List
               := No_Bare_Ada_Node;
      Token_Pos2 :
            Token_Index
               := No_Token_Index;
      Token_Res2 :
            Token_Index
               := No_Token_Index;
      Transform_Res0 :
            Bare_Abort_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags0 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Abort_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res0 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res0;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags0 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos0 := Pos;



--  Start tok_code

Token_Res0 := Row_Pos0;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res0));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Abort)
   then
       Token_Pos0 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos0 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos0,
             Expected_Token_Id => Ada_Abort,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos0 := Row_Pos0 + 1;
   end if;
end;

--  End tok_code




if Token_Pos0 /= No_Token_Index then

   Row_Pos0 := Token_Pos0;

else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;

end if;


--  Start list_code

    List_Pos0 := No_Token_Index;



Lst_Cpos0 := Row_Pos0;
Tmp_List0 := Get_Parse_List (Parser);

loop
   
Defer_Res0 :=
   Name_Or_Parse2 (Parser, Lst_Cpos0);
Defer_Pos0 := Parser.Current_Pos;


   exit when Defer_Pos0 = No_Token_Index;

   List_Pos0 := Defer_Pos0;
   Lst_Cpos0 := List_Pos0;

   Tmp_List0.Nodes.Append (Defer_Res0);

      
--  Start tok_code

Token_Res1 := Lst_Cpos0;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res1));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos1 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos0 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos0,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos1 := Lst_Cpos0 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos1 /= No_Token_Index then
          Lst_Cpos0 := Token_Pos1;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List0.Nodes.Length;
begin
   List_Res0 :=
      Allocate_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos0;
      Token_End := (if Lst_Cpos0 = Row_Pos0
                    then Row_Pos0
                    else Lst_Cpos0 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos0, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res0,
      Kind              => Ada_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res0,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List0.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res0.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List0);

--  End list_code




if List_Pos0 /= No_Token_Index then

   Row_Pos0 := List_Pos0;

else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res2 := Row_Pos0;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res2));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos2 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos0 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos0,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos2 := Row_Pos0 + 1;
   end if;
end;

--  End tok_code


if Token_Pos2 = No_Token_Index then

         
   Token_Res2 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos0)),
                To_Text ("Missing ';'"));

       
   Token_Pos2 := Row_Pos0;



end if;

--  End opt_code




if Token_Pos2 /= No_Token_Index then

   Row_Pos0 := Token_Pos2;

else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row0_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos0 /= No_Token_Index then

   Transform_Res0 := Allocate_Abort_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res0,
      Kind => Ada_Abort_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos0 = Pos
                            then No_Token_Index
                            else Row_Pos0 - 1));

      Initialize_Fields_For_Abort_Stmt
        (Self => Transform_Res0, Abort_Stmt_F_Names => List_Res0);

         if List_Res0 /= null and then Is_Incomplete (List_Res0) then
            Transform_Res0.Last_Attempted_Child := 0;
         elsif List_Res0 /= null and then not Is_Ghost (List_Res0) then
            Transform_Res0.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos0 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags0);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Abort_Stmt_Transform_Parse0_Memo,
      Row_Pos0 /= No_Token_Index,
      Transform_Res0,
      Pos,
      Row_Pos0);


   Parser.Current_Pos := Row_Pos0;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res0;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Abort_Stmt_Transform_Parse0;

   


function Abstract_State_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos1 :
            Token_Index
               := No_Token_Index;
      Defer_Pos1 :
            Token_Index
               := No_Token_Index;
      Defer_Res1 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos2 :
            Token_Index
               := No_Token_Index;
      Defer_Res2 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Transform_Res1 :
            Bare_Abstract_State_Decl
               := No_Bare_Ada_Node;
      Transform_Diags1 :
            Ada.Containers.Count_Type;
      Row_Pos2 :
            Token_Index
               := No_Token_Index;
      Token_Pos3 :
            Token_Index
               := No_Token_Index;
      Token_Res3 :
            Token_Index
               := No_Token_Index;
      Defer_Pos3 :
            Token_Index
               := No_Token_Index;
      Defer_Res3 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos4 :
            Token_Index
               := No_Token_Index;
      Token_Res4 :
            Token_Index
               := No_Token_Index;
      Transform_Res2 :
            Bare_Paren_Abstract_State_Decl
               := No_Bare_Ada_Node;
      Transform_Diags2 :
            Ada.Containers.Count_Type;
      Or_Pos0 :
            Token_Index
               := No_Token_Index;
      Or_Res0 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Abstract_State_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res0 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res0;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos0 := No_Token_Index;
Or_Res0 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags1 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos1 := Pos;



Defer_Res1 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos1);
Defer_Pos1 := Parser.Current_Pos;




if Defer_Pos1 /= No_Token_Index then

   Row_Pos1 := Defer_Pos1;

else
   Row_Pos1 := No_Token_Index;
   goto Exit_Row1_0;

end if;


Defer_Res2 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos1);
Defer_Pos2 := Parser.Current_Pos;




if Defer_Pos2 /= No_Token_Index then

   Row_Pos1 := Defer_Pos2;

else
   Row_Pos1 := No_Token_Index;
   goto Exit_Row1_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row1_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos1 /= No_Token_Index then

   Transform_Res1 := Allocate_Abstract_State_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res1,
      Kind => Ada_Abstract_State_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos1 = Pos
                            then No_Token_Index
                            else Row_Pos1 - 1));

      Initialize_Fields_For_Abstract_State_Decl
        (Self => Transform_Res1, Abstract_State_Decl_F_Name => Defer_Res1, Abstract_State_Decl_F_Aspects => Defer_Res2);

         if Defer_Res1 /= null and then Is_Incomplete (Defer_Res1) then
            Transform_Res1.Last_Attempted_Child := 0;
         elsif Defer_Res1 /= null and then not Is_Ghost (Defer_Res1) then
            Transform_Res1.Last_Attempted_Child := -1;
         end if;
         if Defer_Res2 /= null and then Is_Incomplete (Defer_Res2) then
            Transform_Res1.Last_Attempted_Child := 0;
         elsif Defer_Res2 /= null and then not Is_Ghost (Defer_Res2) then
            Transform_Res1.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos1 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags1);
end if;

--  End transform_code

    if Row_Pos1 /= No_Token_Index then
        Or_Pos0 := Row_Pos1;
        Or_Res0 := Transform_Res1;
        goto Exit_Or0;
    end if;
    
--  Start transform_code

Transform_Diags2 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos2 := Pos;



--  Start tok_code

Token_Res3 := Row_Pos2;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res3));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos3 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos2 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos2,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos3 := Row_Pos2 + 1;
   end if;
end;

--  End tok_code




if Token_Pos3 /= No_Token_Index then

   Row_Pos2 := Token_Pos3;

else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;

end if;


Defer_Res3 :=
   Abstract_State_Decl_Or_Parse0 (Parser, Row_Pos2);
Defer_Pos3 := Parser.Current_Pos;




if Defer_Pos3 /= No_Token_Index then

   Row_Pos2 := Defer_Pos3;

else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;

end if;


--  Start tok_code

Token_Res4 := Row_Pos2;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res4));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos4 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos2 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos2,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos4 := Row_Pos2 + 1;
   end if;
end;

--  End tok_code




if Token_Pos4 /= No_Token_Index then

   Row_Pos2 := Token_Pos4;

else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row2_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos2 /= No_Token_Index then

   Transform_Res2 := Allocate_Paren_Abstract_State_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res2,
      Kind => Ada_Paren_Abstract_State_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos2 = Pos
                            then No_Token_Index
                            else Row_Pos2 - 1));

      Initialize_Fields_For_Paren_Abstract_State_Decl
        (Self => Transform_Res2, Paren_Abstract_State_Decl_F_Decl => Defer_Res3);

         if Defer_Res3 /= null and then Is_Incomplete (Defer_Res3) then
            Transform_Res2.Last_Attempted_Child := 0;
         elsif Defer_Res3 /= null and then not Is_Ghost (Defer_Res3) then
            Transform_Res2.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos2 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags2);
end if;

--  End transform_code

    if Row_Pos2 /= No_Token_Index then
        Or_Pos0 := Row_Pos2;
        Or_Res0 := Transform_Res2;
        goto Exit_Or0;
    end if;
<<Exit_Or0>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Abstract_State_Decl_Or_Parse0_Memo,
      Or_Pos0 /= No_Token_Index,
      Or_Res0,
      Pos,
      Or_Pos0);


   Parser.Current_Pos := Or_Pos0;

   Exit_Call (Parser, Call_Depth);
   return Or_Res0;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Abstract_State_Decl_Or_Parse0;

   


function Abstract_Subp_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Abstract_Subp_Decl
is
   use Bare_Abstract_Subp_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos3 :
            Token_Index
               := No_Token_Index;
      Defer_Pos4 :
            Token_Index
               := No_Token_Index;
      Defer_Res4 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos5 :
            Token_Index
               := No_Token_Index;
      Defer_Res5 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Token_Pos5 :
            Token_Index
               := No_Token_Index;
      Token_Res5 :
            Token_Index
               := No_Token_Index;
      Token_Pos6 :
            Token_Index
               := No_Token_Index;
      Token_Res6 :
            Token_Index
               := No_Token_Index;
      Defer_Pos6 :
            Token_Index
               := No_Token_Index;
      Defer_Res6 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos7 :
            Token_Index
               := No_Token_Index;
      Token_Res7 :
            Token_Index
               := No_Token_Index;
      Transform_Res3 :
            Bare_Abstract_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags3 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Abstract_Subp_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res3 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags3 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos3 := Pos;



Defer_Res4 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos3);
Defer_Pos4 := Parser.Current_Pos;




if Defer_Pos4 /= No_Token_Index then

   Row_Pos3 := Defer_Pos4;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;


Defer_Res5 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos3);
Defer_Pos5 := Parser.Current_Pos;




if Defer_Pos5 /= No_Token_Index then

   Row_Pos3 := Defer_Pos5;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;


--  Start tok_code

Token_Res5 := Row_Pos3;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res5));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos5 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos3 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos3,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos5 := Row_Pos3 + 1;
   end if;
end;

--  End tok_code




if Token_Pos5 /= No_Token_Index then

   Row_Pos3 := Token_Pos5;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;


--  Start tok_code

Token_Res6 := Row_Pos3;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res6));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos6 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos3 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos3,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos6 := Row_Pos3 + 1;
   end if;
end;

--  End tok_code




if Token_Pos6 /= No_Token_Index then

   Row_Pos3 := Token_Pos6;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;


Defer_Res6 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos3);
Defer_Pos6 := Parser.Current_Pos;




if Defer_Pos6 /= No_Token_Index then

   Row_Pos3 := Defer_Pos6;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res7 := Row_Pos3;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res7));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos7 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos3 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos3,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos7 := Row_Pos3 + 1;
   end if;
end;

--  End tok_code


if Token_Pos7 = No_Token_Index then

         
   Token_Res7 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos3)),
                To_Text ("Missing ';'"));

       
   Token_Pos7 := Row_Pos3;



end if;

--  End opt_code




if Token_Pos7 /= No_Token_Index then

   Row_Pos3 := Token_Pos7;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row3_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos3 /= No_Token_Index then

   Transform_Res3 := Allocate_Abstract_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res3,
      Kind => Ada_Abstract_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos3 = Pos
                            then No_Token_Index
                            else Row_Pos3 - 1));

      Initialize_Fields_For_Abstract_Subp_Decl
        (Self => Transform_Res3, Classic_Subp_Decl_F_Overriding => Defer_Res4, Classic_Subp_Decl_F_Subp_Spec => Defer_Res5, Abstract_Subp_Decl_F_Aspects => Defer_Res6);

         if Defer_Res4 /= null and then Is_Incomplete (Defer_Res4) then
            Transform_Res3.Last_Attempted_Child := 0;
         elsif Defer_Res4 /= null and then not Is_Ghost (Defer_Res4) then
            Transform_Res3.Last_Attempted_Child := -1;
         end if;
         if Defer_Res5 /= null and then Is_Incomplete (Defer_Res5) then
            Transform_Res3.Last_Attempted_Child := 0;
         elsif Defer_Res5 /= null and then not Is_Ghost (Defer_Res5) then
            Transform_Res3.Last_Attempted_Child := -1;
         end if;
         if Defer_Res6 /= null and then Is_Incomplete (Defer_Res6) then
            Transform_Res3.Last_Attempted_Child := 0;
         elsif Defer_Res6 /= null and then not Is_Ghost (Defer_Res6) then
            Transform_Res3.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos3 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags3);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Abstract_Subp_Decl_Transform_Parse0_Memo,
      Row_Pos3 /= No_Token_Index,
      Transform_Res3,
      Pos,
      Row_Pos3);


   Parser.Current_Pos := Row_Pos3;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res3;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Abstract_Subp_Decl_Transform_Parse0;

   


function Accept_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Accept_Stmt
is
   use Bare_Accept_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos4 :
            Token_Index
               := No_Token_Index;
      Token_Pos8 :
            Token_Index
               := No_Token_Index;
      Token_Res8 :
            Token_Index
               := No_Token_Index;
      Defer_Pos7 :
            Token_Index
               := No_Token_Index;
      Defer_Res7 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Row_Pos5 :
            Token_Index
               := No_Token_Index;
      Token_Pos9 :
            Token_Index
               := No_Token_Index;
      Token_Res9 :
            Token_Index
               := No_Token_Index;
      Defer_Pos8 :
            Token_Index
               := No_Token_Index;
      Defer_Res8 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos10 :
            Token_Index
               := No_Token_Index;
      Token_Res10 :
            Token_Index
               := No_Token_Index;
      Row_Pos6 :
            Token_Index
               := No_Token_Index;
      Defer_Pos9 :
            Token_Index
               := No_Token_Index;
      Defer_Res9 :
            Bare_Params
               := No_Bare_Ada_Node;
      Transform_Res4 :
            Bare_Entry_Completion_Formal_Params
               := No_Bare_Ada_Node;
      Transform_Diags4 :
            Ada.Containers.Count_Type;
      Token_Pos11 :
            Token_Index
               := No_Token_Index;
      Token_Res11 :
            Token_Index
               := No_Token_Index;
      Transform_Res5 :
            Bare_Accept_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags5 :
            Ada.Containers.Count_Type;
      Row_Pos7 :
            Token_Index
               := No_Token_Index;
      Token_Pos12 :
            Token_Index
               := No_Token_Index;
      Token_Res12 :
            Token_Index
               := No_Token_Index;
      Defer_Pos10 :
            Token_Index
               := No_Token_Index;
      Defer_Res10 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Row_Pos8 :
            Token_Index
               := No_Token_Index;
      Token_Pos13 :
            Token_Index
               := No_Token_Index;
      Token_Res13 :
            Token_Index
               := No_Token_Index;
      Defer_Pos11 :
            Token_Index
               := No_Token_Index;
      Defer_Res11 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos14 :
            Token_Index
               := No_Token_Index;
      Token_Res14 :
            Token_Index
               := No_Token_Index;
      Row_Pos9 :
            Token_Index
               := No_Token_Index;
      Defer_Pos12 :
            Token_Index
               := No_Token_Index;
      Defer_Res12 :
            Bare_Params
               := No_Bare_Ada_Node;
      Transform_Res6 :
            Bare_Entry_Completion_Formal_Params
               := No_Bare_Ada_Node;
      Transform_Diags6 :
            Ada.Containers.Count_Type;
      Token_Pos15 :
            Token_Index
               := No_Token_Index;
      Token_Res15 :
            Token_Index
               := No_Token_Index;
      Defer_Pos13 :
            Token_Index
               := No_Token_Index;
      Defer_Res13 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos10 :
            Token_Index
               := No_Token_Index;
      Token_Pos16 :
            Token_Index
               := No_Token_Index;
      Token_Res16 :
            Token_Index
               := No_Token_Index;
      Row_Pos11 :
            Token_Index
               := No_Token_Index;
      Defer_Pos14 :
            Token_Index
               := No_Token_Index;
      Defer_Res14 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res7 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags7 :
            Ada.Containers.Count_Type;
      Token_Pos17 :
            Token_Index
               := No_Token_Index;
      Token_Res17 :
            Token_Index
               := No_Token_Index;
      Transform_Res8 :
            Bare_Accept_Stmt_With_Stmts
               := No_Bare_Ada_Node;
      Transform_Diags8 :
            Ada.Containers.Count_Type;
      Or_Pos1 :
            Token_Index
               := No_Token_Index;
      Or_Res1 :
            Bare_Accept_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Accept_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res1 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res1;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos1 := No_Token_Index;
Or_Res1 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags5 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos4 := Pos;



--  Start tok_code

Token_Res8 := Row_Pos4;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res8));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Accept)
   then
       Token_Pos8 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos4 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos4,
             Expected_Token_Id => Ada_Accept,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos8 := Row_Pos4 + 1;
   end if;
end;

--  End tok_code




if Token_Pos8 /= No_Token_Index then

   Row_Pos4 := Token_Pos8;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;


Defer_Res7 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos4);
Defer_Pos7 := Parser.Current_Pos;




if Defer_Pos7 /= No_Token_Index then

   Row_Pos4 := Defer_Pos7;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos5 := Row_Pos4;



--  Start tok_code

Token_Res9 := Row_Pos5;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res9));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos9 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos5 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos5,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos9 := Row_Pos5 + 1;
   end if;
end;

--  End tok_code




if Token_Pos9 /= No_Token_Index then

   Row_Pos5 := Token_Pos9;

else
   Row_Pos5 := No_Token_Index;
   goto Exit_Row5_0;

end if;


Defer_Res8 :=
   Expr_Or_Parse0 (Parser, Row_Pos5);
Defer_Pos8 := Parser.Current_Pos;




if Defer_Pos8 /= No_Token_Index then

   Row_Pos5 := Defer_Pos8;

else
   Row_Pos5 := No_Token_Index;
   goto Exit_Row5_0;

end if;


--  Start tok_code

Token_Res10 := Row_Pos5;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res10));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos10 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos5 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos5,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos10 := Row_Pos5 + 1;
   end if;
end;

--  End tok_code




if Token_Pos10 /= No_Token_Index then

   Row_Pos5 := Token_Pos10;

else
   Row_Pos5 := No_Token_Index;
   goto Exit_Row5_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row5_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos5 = No_Token_Index then

         
   Defer_Res8 := No_Bare_Ada_Node;



       
   Row_Pos5 := Row_Pos4;



end if;

--  End opt_code




if Row_Pos5 /= No_Token_Index then

   Row_Pos4 := Row_Pos5;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;


--  Start transform_code

Transform_Diags4 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos6 := Row_Pos4;



--  Start opt_code












Defer_Res9 :=
   Param_Specs_Transform_Parse0 (Parser, Row_Pos6);
Defer_Pos9 := Parser.Current_Pos;


if Defer_Pos9 = No_Token_Index then

         
   Defer_Res9 := No_Bare_Ada_Node;



       
   Defer_Pos9 := Row_Pos6;



end if;

--  End opt_code




if Defer_Pos9 /= No_Token_Index then

   Row_Pos6 := Defer_Pos9;

else
   Row_Pos6 := No_Token_Index;
   goto Exit_Row6_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row6_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos6 /= No_Token_Index then

   Transform_Res4 := Allocate_Entry_Completion_Formal_Params (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res4,
      Kind => Ada_Entry_Completion_Formal_Params,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos4,
      Token_End_Index   => (if Row_Pos6 = Row_Pos4
                            then No_Token_Index
                            else Row_Pos6 - 1));

      Initialize_Fields_For_Entry_Completion_Formal_Params
        (Self => Transform_Res4, Entry_Completion_Formal_Params_F_Params => Defer_Res9);

         if Defer_Res9 /= null and then Is_Incomplete (Defer_Res9) then
            Transform_Res4.Last_Attempted_Child := 0;
         elsif Defer_Res9 /= null and then not Is_Ghost (Defer_Res9) then
            Transform_Res4.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos6 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags4);
end if;

--  End transform_code




if Row_Pos6 /= No_Token_Index then

   Row_Pos4 := Row_Pos6;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;


--  Start tok_code

Token_Res11 := Row_Pos4;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res11));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos11 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos4 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos4,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos11 := Row_Pos4 + 1;
   end if;
end;

--  End tok_code




if Token_Pos11 /= No_Token_Index then

   Row_Pos4 := Token_Pos11;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row4_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos4 /= No_Token_Index then

   Transform_Res5 := Allocate_Accept_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res5,
      Kind => Ada_Accept_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos4 = Pos
                            then No_Token_Index
                            else Row_Pos4 - 1));

      Initialize_Fields_For_Accept_Stmt
        (Self => Transform_Res5, Accept_Stmt_F_Name => Defer_Res7, Accept_Stmt_F_Entry_Index_Expr => Defer_Res8, Accept_Stmt_F_Params => Transform_Res4);

         if Defer_Res7 /= null and then Is_Incomplete (Defer_Res7) then
            Transform_Res5.Last_Attempted_Child := 0;
         elsif Defer_Res7 /= null and then not Is_Ghost (Defer_Res7) then
            Transform_Res5.Last_Attempted_Child := -1;
         end if;
         if Defer_Res8 /= null and then Is_Incomplete (Defer_Res8) then
            Transform_Res5.Last_Attempted_Child := 0;
         elsif Defer_Res8 /= null and then not Is_Ghost (Defer_Res8) then
            Transform_Res5.Last_Attempted_Child := -1;
         end if;
         if Transform_Res4 /= null and then Is_Incomplete (Transform_Res4) then
            Transform_Res5.Last_Attempted_Child := 0;
         elsif Transform_Res4 /= null and then not Is_Ghost (Transform_Res4) then
            Transform_Res5.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos4 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags5);
end if;

--  End transform_code

    if Row_Pos4 /= No_Token_Index then
        Or_Pos1 := Row_Pos4;
        Or_Res1 := Transform_Res5;
        goto Exit_Or1;
    end if;
    
--  Start transform_code

Transform_Diags8 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos7 := Pos;



--  Start tok_code

Token_Res12 := Row_Pos7;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res12));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Accept)
   then
       Token_Pos12 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos7 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos7,
             Expected_Token_Id => Ada_Accept,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos12 := Row_Pos7 + 1;
   end if;
end;

--  End tok_code




if Token_Pos12 /= No_Token_Index then

   Row_Pos7 := Token_Pos12;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


Defer_Res10 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos7);
Defer_Pos10 := Parser.Current_Pos;




if Defer_Pos10 /= No_Token_Index then

   Row_Pos7 := Defer_Pos10;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos8 := Row_Pos7;



--  Start tok_code

Token_Res13 := Row_Pos8;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res13));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos13 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos8 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos8,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos13 := Row_Pos8 + 1;
   end if;
end;

--  End tok_code




if Token_Pos13 /= No_Token_Index then

   Row_Pos8 := Token_Pos13;

else
   Row_Pos8 := No_Token_Index;
   goto Exit_Row8_0;

end if;


Defer_Res11 :=
   Expr_Or_Parse0 (Parser, Row_Pos8);
Defer_Pos11 := Parser.Current_Pos;




if Defer_Pos11 /= No_Token_Index then

   Row_Pos8 := Defer_Pos11;

else
   Row_Pos8 := No_Token_Index;
   goto Exit_Row8_0;

end if;


--  Start tok_code

Token_Res14 := Row_Pos8;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res14));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos14 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos8 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos8,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos14 := Row_Pos8 + 1;
   end if;
end;

--  End tok_code




if Token_Pos14 /= No_Token_Index then

   Row_Pos8 := Token_Pos14;

else
   Row_Pos8 := No_Token_Index;
   goto Exit_Row8_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row8_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos8 = No_Token_Index then

         
   Defer_Res11 := No_Bare_Ada_Node;



       
   Row_Pos8 := Row_Pos7;



end if;

--  End opt_code




if Row_Pos8 /= No_Token_Index then

   Row_Pos7 := Row_Pos8;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


--  Start transform_code

Transform_Diags6 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos9 := Row_Pos7;



--  Start opt_code












Defer_Res12 :=
   Param_Specs_Transform_Parse0 (Parser, Row_Pos9);
Defer_Pos12 := Parser.Current_Pos;


if Defer_Pos12 = No_Token_Index then

         
   Defer_Res12 := No_Bare_Ada_Node;



       
   Defer_Pos12 := Row_Pos9;



end if;

--  End opt_code




if Defer_Pos12 /= No_Token_Index then

   Row_Pos9 := Defer_Pos12;

else
   Row_Pos9 := No_Token_Index;
   goto Exit_Row9_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row9_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos9 /= No_Token_Index then

   Transform_Res6 := Allocate_Entry_Completion_Formal_Params (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res6,
      Kind => Ada_Entry_Completion_Formal_Params,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos7,
      Token_End_Index   => (if Row_Pos9 = Row_Pos7
                            then No_Token_Index
                            else Row_Pos9 - 1));

      Initialize_Fields_For_Entry_Completion_Formal_Params
        (Self => Transform_Res6, Entry_Completion_Formal_Params_F_Params => Defer_Res12);

         if Defer_Res12 /= null and then Is_Incomplete (Defer_Res12) then
            Transform_Res6.Last_Attempted_Child := 0;
         elsif Defer_Res12 /= null and then not Is_Ghost (Defer_Res12) then
            Transform_Res6.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos9 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags6);
end if;

--  End transform_code




if Row_Pos9 /= No_Token_Index then

   Row_Pos7 := Row_Pos9;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


--  Start tok_code

Token_Res15 := Row_Pos7;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res15));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Do)
   then
       Token_Pos15 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos7 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos7,
             Expected_Token_Id => Ada_Do,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos15 := Row_Pos7 + 1;
   end if;
end;

--  End tok_code




if Token_Pos15 /= No_Token_Index then

   Row_Pos7 := Token_Pos15;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


Defer_Res13 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos7);
Defer_Pos13 := Parser.Current_Pos;




if Defer_Pos13 /= No_Token_Index then

   Row_Pos7 := Defer_Pos13;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


--  Start row_code

Row_Pos10 := Row_Pos7;



--  Start tok_code

Token_Res16 := Row_Pos10;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res16));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos16 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos10 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos10,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos16 := Row_Pos10 + 1;
   end if;
end;

--  End tok_code




if Token_Pos16 /= No_Token_Index then

   Row_Pos10 := Token_Pos16;

else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags7 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos11 := Row_Pos10;



Defer_Res14 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos11);
Defer_Pos14 := Parser.Current_Pos;




if Defer_Pos14 /= No_Token_Index then

   Row_Pos11 := Defer_Pos14;

else
   Row_Pos11 := No_Token_Index;
   goto Exit_Row11_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row11_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos11 /= No_Token_Index then

   Transform_Res7 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res7,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos10,
      Token_End_Index   => (if Row_Pos11 = Row_Pos10
                            then No_Token_Index
                            else Row_Pos11 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res7, End_Name_F_Name => Defer_Res14);

         if Defer_Res14 /= null and then Is_Incomplete (Defer_Res14) then
            Transform_Res7.Last_Attempted_Child := 0;
         elsif Defer_Res14 /= null and then not Is_Ghost (Defer_Res14) then
            Transform_Res7.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos11 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags7);
end if;

--  End transform_code


if Row_Pos11 = No_Token_Index then

         
   Transform_Res7 := No_Bare_Ada_Node;



       
   Row_Pos11 := Row_Pos10;



end if;

--  End opt_code




if Row_Pos11 /= No_Token_Index then

   Row_Pos10 := Row_Pos11;

else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row10_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos10 /= No_Token_Index then

   Row_Pos7 := Row_Pos10;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res17 := Row_Pos7;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res17));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos17 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos7 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos7,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos17 := Row_Pos7 + 1;
   end if;
end;

--  End tok_code


if Token_Pos17 = No_Token_Index then

         
   Token_Res17 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos7)),
                To_Text ("Missing ';'"));

       
   Token_Pos17 := Row_Pos7;



end if;

--  End opt_code




if Token_Pos17 /= No_Token_Index then

   Row_Pos7 := Token_Pos17;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row7_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos7 /= No_Token_Index then

   Transform_Res8 := Allocate_Accept_Stmt_With_Stmts (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res8,
      Kind => Ada_Accept_Stmt_With_Stmts,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos7 = Pos
                            then No_Token_Index
                            else Row_Pos7 - 1));

      Initialize_Fields_For_Accept_Stmt_With_Stmts
        (Self => Transform_Res8, Accept_Stmt_F_Name => Defer_Res10, Accept_Stmt_F_Entry_Index_Expr => Defer_Res11, Accept_Stmt_F_Params => Transform_Res6, Accept_Stmt_With_Stmts_F_Stmts => Defer_Res13, Accept_Stmt_With_Stmts_F_End_Name => Transform_Res7);

         if Defer_Res10 /= null and then Is_Incomplete (Defer_Res10) then
            Transform_Res8.Last_Attempted_Child := 0;
         elsif Defer_Res10 /= null and then not Is_Ghost (Defer_Res10) then
            Transform_Res8.Last_Attempted_Child := -1;
         end if;
         if Defer_Res11 /= null and then Is_Incomplete (Defer_Res11) then
            Transform_Res8.Last_Attempted_Child := 0;
         elsif Defer_Res11 /= null and then not Is_Ghost (Defer_Res11) then
            Transform_Res8.Last_Attempted_Child := -1;
         end if;
         if Transform_Res6 /= null and then Is_Incomplete (Transform_Res6) then
            Transform_Res8.Last_Attempted_Child := 0;
         elsif Transform_Res6 /= null and then not Is_Ghost (Transform_Res6) then
            Transform_Res8.Last_Attempted_Child := -1;
         end if;
         if Defer_Res13 /= null and then Is_Incomplete (Defer_Res13) then
            Transform_Res8.Last_Attempted_Child := 0;
         elsif Defer_Res13 /= null and then not Is_Ghost (Defer_Res13) then
            Transform_Res8.Last_Attempted_Child := -1;
         end if;
         if Transform_Res7 /= null and then Is_Incomplete (Transform_Res7) then
            Transform_Res8.Last_Attempted_Child := 0;
         elsif Transform_Res7 /= null and then not Is_Ghost (Transform_Res7) then
            Transform_Res8.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos7 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags8);
end if;

--  End transform_code

    if Row_Pos7 /= No_Token_Index then
        Or_Pos1 := Row_Pos7;
        Or_Res1 := Transform_Res8;
        goto Exit_Or1;
    end if;
<<Exit_Or1>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Accept_Stmt_Or_Parse0_Memo,
      Or_Pos1 /= No_Token_Index,
      Or_Res1,
      Pos,
      Or_Pos1);


   Parser.Current_Pos := Or_Pos1;

   Exit_Call (Parser, Call_Depth);
   return Or_Res1;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Accept_Stmt_Or_Parse0;

   


function Access_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Access_Def
is
   use Bare_Access_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos12 :
            Token_Index
               := No_Token_Index;
      Row_Pos13 :
            Token_Index
               := No_Token_Index;
      Token_Pos18 :
            Token_Index
               := No_Token_Index;
      Token_Res18 :
            Token_Index
               := No_Token_Index;
      Token_Pos19 :
            Token_Index
               := No_Token_Index;
      Token_Res19 :
            Token_Index
               := No_Token_Index;
      Opt_Res0 :
            Bare_Not_Null
               := No_Bare_Ada_Node;
      Token_Pos20 :
            Token_Index
               := No_Token_Index;
      Token_Res20 :
            Token_Index
               := No_Token_Index;
      Token_Pos21 :
            Token_Index
               := No_Token_Index;
      Token_Res21 :
            Token_Index
               := No_Token_Index;
      Opt_Res1 :
            Bare_Protected_Node
               := No_Bare_Ada_Node;
      Defer_Pos15 :
            Token_Index
               := No_Token_Index;
      Defer_Res15 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Transform_Res9 :
            Bare_Access_To_Subp_Def
               := No_Bare_Ada_Node;
      Transform_Diags9 :
            Ada.Containers.Count_Type;
      Row_Pos14 :
            Token_Index
               := No_Token_Index;
      Row_Pos15 :
            Token_Index
               := No_Token_Index;
      Token_Pos22 :
            Token_Index
               := No_Token_Index;
      Token_Res22 :
            Token_Index
               := No_Token_Index;
      Token_Pos23 :
            Token_Index
               := No_Token_Index;
      Token_Res23 :
            Token_Index
               := No_Token_Index;
      Opt_Res2 :
            Bare_Not_Null
               := No_Bare_Ada_Node;
      Token_Pos24 :
            Token_Index
               := No_Token_Index;
      Token_Res24 :
            Token_Index
               := No_Token_Index;
      Token_Pos25 :
            Token_Index
               := No_Token_Index;
      Token_Res25 :
            Token_Index
               := No_Token_Index;
      Opt_Res3 :
            Bare_All_Node
               := No_Bare_Ada_Node;
      Token_Pos26 :
            Token_Index
               := No_Token_Index;
      Token_Res26 :
            Token_Index
               := No_Token_Index;
      Opt_Res4 :
            Bare_Constant_Node
               := No_Bare_Ada_Node;
      Defer_Pos16 :
            Token_Index
               := No_Token_Index;
      Defer_Res16 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Transform_Res10 :
            Bare_Type_Access_Def
               := No_Bare_Ada_Node;
      Transform_Diags10 :
            Ada.Containers.Count_Type;
      Or_Pos2 :
            Token_Index
               := No_Token_Index;
      Or_Res2 :
            Bare_Access_Def
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Access_Def_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res2 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res2;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos2 := No_Token_Index;
Or_Res2 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags9 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos12 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos13 := Row_Pos12;



--  Start tok_code

Token_Res18 := Row_Pos13;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res18));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos18 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos13 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos13,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos18 := Row_Pos13 + 1;
   end if;
end;

--  End tok_code




if Token_Pos18 /= No_Token_Index then

   Row_Pos13 := Token_Pos18;

else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;

end if;


--  Start tok_code

Token_Res19 := Row_Pos13;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res19));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos19 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos13 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos13,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos19 := Row_Pos13 + 1;
   end if;
end;

--  End tok_code




if Token_Pos19 /= No_Token_Index then

   Row_Pos13 := Token_Pos19;

else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row13_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos13 = No_Token_Index then

         Opt_Res0 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res0,
            Kind              => Ada_Not_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos12,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos13 := Row_Pos12;


else

      Opt_Res0 := Allocate_Not_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res0,
         Kind              => Ada_Not_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos12,
         Token_End_Index   => Row_Pos13 - 1);

end if;

--  End opt_code




if Row_Pos13 /= No_Token_Index then

   Row_Pos12 := Row_Pos13;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;


--  Start tok_code

Token_Res20 := Row_Pos12;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res20));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Access)
   then
       Token_Pos20 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos12 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos12,
             Expected_Token_Id => Ada_Access,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos20 := Row_Pos12 + 1;
   end if;
end;

--  End tok_code




if Token_Pos20 /= No_Token_Index then

   Row_Pos12 := Token_Pos20;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res21 := Row_Pos12;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res21));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Protected)
   then
       Token_Pos21 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos12 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos12,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos21 := Row_Pos12 + 1;
   end if;
end;

--  End tok_code


if Token_Pos21 = No_Token_Index then

         Opt_Res1 := Allocate_Protected_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res1,
            Kind              => Ada_Protected_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos12,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos21 := Row_Pos12;


else

      Opt_Res1 := Allocate_Protected_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res1,
         Kind              => Ada_Protected_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos12,
         Token_End_Index   => Token_Pos21 - 1);

end if;

--  End opt_code




if Token_Pos21 /= No_Token_Index then

   Row_Pos12 := Token_Pos21;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;


Defer_Res15 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos12);
Defer_Pos15 := Parser.Current_Pos;




if Defer_Pos15 /= No_Token_Index then

   Row_Pos12 := Defer_Pos15;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row12_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos12 /= No_Token_Index then

   Transform_Res9 := Allocate_Access_To_Subp_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res9,
      Kind => Ada_Access_To_Subp_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos12 = Pos
                            then No_Token_Index
                            else Row_Pos12 - 1));

      Initialize_Fields_For_Access_To_Subp_Def
        (Self => Transform_Res9, Access_Def_F_Has_Not_Null => Opt_Res0, Access_To_Subp_Def_F_Has_Protected => Opt_Res1, Access_To_Subp_Def_F_Subp_Spec => Defer_Res15);

         if Opt_Res0 /= null and then Is_Incomplete (Opt_Res0) then
            Transform_Res9.Last_Attempted_Child := 0;
         elsif Opt_Res0 /= null and then not Is_Ghost (Opt_Res0) then
            Transform_Res9.Last_Attempted_Child := -1;
         end if;
         if Opt_Res1 /= null and then Is_Incomplete (Opt_Res1) then
            Transform_Res9.Last_Attempted_Child := 0;
         elsif Opt_Res1 /= null and then not Is_Ghost (Opt_Res1) then
            Transform_Res9.Last_Attempted_Child := -1;
         end if;
         if Defer_Res15 /= null and then Is_Incomplete (Defer_Res15) then
            Transform_Res9.Last_Attempted_Child := 0;
         elsif Defer_Res15 /= null and then not Is_Ghost (Defer_Res15) then
            Transform_Res9.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos12 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags9);
end if;

--  End transform_code

    if Row_Pos12 /= No_Token_Index then
        Or_Pos2 := Row_Pos12;
        Or_Res2 := Transform_Res9;
        goto Exit_Or2;
    end if;
    
--  Start transform_code

Transform_Diags10 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos14 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos15 := Row_Pos14;



--  Start tok_code

Token_Res22 := Row_Pos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res22));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos22 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos15,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos22 := Row_Pos15 + 1;
   end if;
end;

--  End tok_code




if Token_Pos22 /= No_Token_Index then

   Row_Pos15 := Token_Pos22;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;


--  Start tok_code

Token_Res23 := Row_Pos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res23));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos23 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos15,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos23 := Row_Pos15 + 1;
   end if;
end;

--  End tok_code




if Token_Pos23 /= No_Token_Index then

   Row_Pos15 := Token_Pos23;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row15_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos15 = No_Token_Index then

         Opt_Res2 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res2,
            Kind              => Ada_Not_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos14,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos15 := Row_Pos14;


else

      Opt_Res2 := Allocate_Not_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res2,
         Kind              => Ada_Not_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos14,
         Token_End_Index   => Row_Pos15 - 1);

end if;

--  End opt_code




if Row_Pos15 /= No_Token_Index then

   Row_Pos14 := Row_Pos15;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


--  Start tok_code

Token_Res24 := Row_Pos14;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res24));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Access)
   then
       Token_Pos24 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos14 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos14,
             Expected_Token_Id => Ada_Access,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos24 := Row_Pos14 + 1;
   end if;
end;

--  End tok_code




if Token_Pos24 /= No_Token_Index then

   Row_Pos14 := Token_Pos24;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res25 := Row_Pos14;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res25));
begin
   if
      T.Kind /= From_Token_Kind (Ada_All)
   then
       Token_Pos25 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos14 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos14,
             Expected_Token_Id => Ada_All,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos25 := Row_Pos14 + 1;
   end if;
end;

--  End tok_code


if Token_Pos25 = No_Token_Index then

         Opt_Res3 := Allocate_All_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res3,
            Kind              => Ada_All_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos14,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos25 := Row_Pos14;


else

      Opt_Res3 := Allocate_All_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res3,
         Kind              => Ada_All_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos14,
         Token_End_Index   => Token_Pos25 - 1);

end if;

--  End opt_code




if Token_Pos25 /= No_Token_Index then

   Row_Pos14 := Token_Pos25;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res26 := Row_Pos14;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res26));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Constant)
   then
       Token_Pos26 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos14 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos14,
             Expected_Token_Id => Ada_Constant,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos26 := Row_Pos14 + 1;
   end if;
end;

--  End tok_code


if Token_Pos26 = No_Token_Index then

         Opt_Res4 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res4,
            Kind              => Ada_Constant_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos14,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos26 := Row_Pos14;


else

      Opt_Res4 := Allocate_Constant_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res4,
         Kind              => Ada_Constant_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos14,
         Token_End_Index   => Token_Pos26 - 1);

end if;

--  End opt_code




if Token_Pos26 /= No_Token_Index then

   Row_Pos14 := Token_Pos26;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


Defer_Res16 :=
   Subtype_Indication_Transform_Parse0 (Parser, Row_Pos14);
Defer_Pos16 := Parser.Current_Pos;




if Defer_Pos16 /= No_Token_Index then

   Row_Pos14 := Defer_Pos16;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row14_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos14 /= No_Token_Index then

   Transform_Res10 := Allocate_Type_Access_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res10,
      Kind => Ada_Type_Access_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos14 = Pos
                            then No_Token_Index
                            else Row_Pos14 - 1));

      Initialize_Fields_For_Type_Access_Def
        (Self => Transform_Res10, Access_Def_F_Has_Not_Null => Opt_Res2, Type_Access_Def_F_Has_All => Opt_Res3, Type_Access_Def_F_Has_Constant => Opt_Res4, Type_Access_Def_F_Subtype_Indication => Defer_Res16);

         if Opt_Res2 /= null and then Is_Incomplete (Opt_Res2) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Opt_Res2 /= null and then not Is_Ghost (Opt_Res2) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;
         if Opt_Res3 /= null and then Is_Incomplete (Opt_Res3) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Opt_Res3 /= null and then not Is_Ghost (Opt_Res3) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;
         if Opt_Res4 /= null and then Is_Incomplete (Opt_Res4) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Opt_Res4 /= null and then not Is_Ghost (Opt_Res4) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;
         if Defer_Res16 /= null and then Is_Incomplete (Defer_Res16) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Defer_Res16 /= null and then not Is_Ghost (Defer_Res16) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos14 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags10);
end if;

--  End transform_code

    if Row_Pos14 /= No_Token_Index then
        Or_Pos2 := Row_Pos14;
        Or_Res2 := Transform_Res10;
        goto Exit_Or2;
    end if;
<<Exit_Or2>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Access_Def_Or_Parse0_Memo,
      Or_Pos2 /= No_Token_Index,
      Or_Res2,
      Pos,
      Or_Pos2);


   Parser.Current_Pos := Or_Pos2;

   Exit_Call (Parser, Call_Depth);
   return Or_Res2;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Access_Def_Or_Parse0;

   


function Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate
is
   use Bare_Base_Aggregate_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos17 :
            Token_Index
               := No_Token_Index;
      Defer_Res17 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Defer_Pos18 :
            Token_Index
               := No_Token_Index;
      Defer_Res18 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Or_Pos3 :
            Token_Index
               := No_Token_Index;
      Or_Res3 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Aggregate_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res3 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos3 := No_Token_Index;
Or_Res3 := No_Bare_Ada_Node;
    
Defer_Res17 :=
   Regular_Aggregate_Or_Parse0 (Parser, Pos);
Defer_Pos17 := Parser.Current_Pos;

    if Defer_Pos17 /= No_Token_Index then
        Or_Pos3 := Defer_Pos17;
        Or_Res3 := Defer_Res17;
        goto Exit_Or3;
    end if;
    
Defer_Res18 :=
   Bracket_Aggregate_Or_Parse0 (Parser, Pos);
Defer_Pos18 := Parser.Current_Pos;

    if Defer_Pos18 /= No_Token_Index then
        Or_Pos3 := Defer_Pos18;
        Or_Res3 := Defer_Res18;
        goto Exit_Or3;
    end if;
<<Exit_Or3>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Aggregate_Or_Parse0_Memo,
      Or_Pos3 /= No_Token_Index,
      Or_Res3,
      Pos,
      Or_Pos3);


   Parser.Current_Pos := Or_Pos3;

   Exit_Call (Parser, Call_Depth);
   return Or_Res3;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Aggregate_Or_Parse0;

   


function Aggregate_Assoc_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Assoc
is
   use Bare_Basic_Assoc_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos19 :
            Token_Index
               := No_Token_Index;
      Defer_Res19 :
            Bare_Iterated_Assoc
               := No_Bare_Ada_Node;
      Row_Pos16 :
            Token_Index
               := No_Token_Index;
      Row_Pos17 :
            Token_Index
               := No_Token_Index;
      Defer_Pos20 :
            Token_Index
               := No_Token_Index;
      Defer_Res20 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;
      Token_Pos27 :
            Token_Index
               := No_Token_Index;
      Token_Res27 :
            Token_Index
               := No_Token_Index;
      Defer_Pos21 :
            Token_Index
               := No_Token_Index;
      Defer_Res21 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Defer_Pos22 :
            Token_Index
               := No_Token_Index;
      Defer_Res22 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos4 :
            Token_Index
               := No_Token_Index;
      Or_Res4 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res11 :
            Bare_Aggregate_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags11 :
            Ada.Containers.Count_Type;
      Or_Pos5 :
            Token_Index
               := No_Token_Index;
      Or_Res5 :
            Bare_Basic_Assoc
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Aggregate_Assoc_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res5 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos5 := No_Token_Index;
Or_Res5 := No_Bare_Ada_Node;
    
Defer_Res19 :=
   Iterated_Assoc_Transform_Parse0 (Parser, Pos);
Defer_Pos19 := Parser.Current_Pos;

    if Defer_Pos19 /= No_Token_Index then
        Or_Pos5 := Defer_Pos19;
        Or_Res5 := Defer_Res19;
        goto Exit_Or4;
    end if;
    
--  Start transform_code

Transform_Diags11 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos16 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos17 := Row_Pos16;



Defer_Res20 :=
   Choice_List_List_Parse0 (Parser, Row_Pos17);
Defer_Pos20 := Parser.Current_Pos;




if Defer_Pos20 /= No_Token_Index then

   Row_Pos17 := Defer_Pos20;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;


--  Start tok_code

Token_Res27 := Row_Pos17;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res27));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos27 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos17,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos27 := Row_Pos17 + 1;
   end if;
end;

--  End tok_code




if Token_Pos27 /= No_Token_Index then

   Row_Pos17 := Token_Pos27;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row17_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos17 = No_Token_Index then

         
   Defer_Res20 :=
     Allocate_Alternatives_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res20,
      Kind              => Ada_Alternatives_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos16 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res20,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos17 := Row_Pos16;



end if;

--  End opt_code




if Row_Pos17 /= No_Token_Index then

   Row_Pos16 := Row_Pos17;

else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;

end if;


--  Start or_code

Or_Pos4 := No_Token_Index;
Or_Res4 := No_Bare_Ada_Node;
    
Defer_Res21 :=
   Box_Expr_Transform_Parse0 (Parser, Row_Pos16);
Defer_Pos21 := Parser.Current_Pos;

    if Defer_Pos21 /= No_Token_Index then
        Or_Pos4 := Defer_Pos21;
        Or_Res4 := Defer_Res21;
        goto Exit_Or5;
    end if;
    
Defer_Res22 :=
   Expr_Or_Parse0 (Parser, Row_Pos16);
Defer_Pos22 := Parser.Current_Pos;

    if Defer_Pos22 /= No_Token_Index then
        Or_Pos4 := Defer_Pos22;
        Or_Res4 := Defer_Res22;
        goto Exit_Or5;
    end if;
<<Exit_Or5>>

--  End or_code




if Or_Pos4 /= No_Token_Index then

   Row_Pos16 := Or_Pos4;

else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row16_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos16 /= No_Token_Index then

   Transform_Res11 := Allocate_Aggregate_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res11,
      Kind => Ada_Aggregate_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos16 = Pos
                            then No_Token_Index
                            else Row_Pos16 - 1));

      Initialize_Fields_For_Aggregate_Assoc
        (Self => Transform_Res11, Aggregate_Assoc_F_Designators => Defer_Res20, Aggregate_Assoc_F_R_Expr => Or_Res4);

         if Defer_Res20 /= null and then Is_Incomplete (Defer_Res20) then
            Transform_Res11.Last_Attempted_Child := 0;
         elsif Defer_Res20 /= null and then not Is_Ghost (Defer_Res20) then
            Transform_Res11.Last_Attempted_Child := -1;
         end if;
         if Or_Res4 /= null and then Is_Incomplete (Or_Res4) then
            Transform_Res11.Last_Attempted_Child := 0;
         elsif Or_Res4 /= null and then not Is_Ghost (Or_Res4) then
            Transform_Res11.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos16 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags11);
end if;

--  End transform_code

    if Row_Pos16 /= No_Token_Index then
        Or_Pos5 := Row_Pos16;
        Or_Res5 := Transform_Res11;
        goto Exit_Or4;
    end if;
<<Exit_Or4>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Aggregate_Assoc_Or_Parse1_Memo,
      Or_Pos5 /= No_Token_Index,
      Or_Res5,
      Pos,
      Or_Pos5);


   Parser.Current_Pos := Or_Pos5;

   Exit_Call (Parser, Call_Depth);
   return Or_Res5;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Aggregate_Assoc_Or_Parse1;

   


function Allocator_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Allocator
is
   use Bare_Allocator_Memos;

   Call_Depth : aliased Natural;

      Nobt0 :
            Boolean
               := False;
      Row_Pos18 :
            Token_Index
               := No_Token_Index;
      Token_Pos28 :
            Token_Index
               := No_Token_Index;
      Token_Res28 :
            Token_Index
               := No_Token_Index;
      Row_Pos19 :
            Token_Index
               := No_Token_Index;
      Token_Pos29 :
            Token_Index
               := No_Token_Index;
      Token_Res29 :
            Token_Index
               := No_Token_Index;
      Defer_Pos23 :
            Token_Index
               := No_Token_Index;
      Defer_Res23 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos30 :
            Token_Index
               := No_Token_Index;
      Token_Res30 :
            Token_Index
               := No_Token_Index;
      Defer_Pos24 :
            Token_Index
               := No_Token_Index;
      Defer_Res24 :
            Bare_Qual_Expr
               := No_Bare_Ada_Node;
      Defer_Pos25 :
            Token_Index
               := No_Token_Index;
      Defer_Res25 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Or_Pos6 :
            Token_Index
               := No_Token_Index;
      Or_Res6 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Row_Progress0 :
            Integer
               := 0;
      Transform_Res12 :
            Bare_Allocator
               := No_Bare_Ada_Node;
      Transform_Has_Failed0 :
            Boolean
               := False;
      Transform_Diags12 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Allocator_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res12 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res12;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags12 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos18 := Pos;



--  Start tok_code

Token_Res28 := Row_Pos18;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res28));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos28 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos18,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos28 := Row_Pos18 + 1;
   end if;
end;

--  End tok_code



Row_Progress0 := 1;

if Token_Pos28 /= No_Token_Index then

   Row_Pos18 := Token_Pos28;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;

Nobt0 := True;

   Nobt0 := Nobt0;

Row_Progress0 := 2;

if Row_Pos18 /= No_Token_Index then

   Row_Pos18 := Row_Pos18;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos19 := Row_Pos18;



--  Start tok_code

Token_Res29 := Row_Pos19;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res29));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos29 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos19,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos29 := Row_Pos19 + 1;
   end if;
end;

--  End tok_code




if Token_Pos29 /= No_Token_Index then

   Row_Pos19 := Token_Pos29;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;


Defer_Res23 :=
   Name_Or_Parse2 (Parser, Row_Pos19);
Defer_Pos23 := Parser.Current_Pos;




if Defer_Pos23 /= No_Token_Index then

   Row_Pos19 := Defer_Pos23;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;


--  Start tok_code

Token_Res30 := Row_Pos19;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res30));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos30 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos19,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos30 := Row_Pos19 + 1;
   end if;
end;

--  End tok_code




if Token_Pos30 /= No_Token_Index then

   Row_Pos19 := Token_Pos30;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row19_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos19 = No_Token_Index then

         
   Defer_Res23 := No_Bare_Ada_Node;



       
   Row_Pos19 := Row_Pos18;



end if;

--  End opt_code



Row_Progress0 := 3;

if Row_Pos19 /= No_Token_Index then

   Row_Pos18 := Row_Pos19;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  Start or_code

Or_Pos6 := No_Token_Index;
Or_Res6 := No_Bare_Ada_Node;
    
Defer_Res24 :=
   Qualified_Name_Transform_Parse0 (Parser, Row_Pos18);
Defer_Pos24 := Parser.Current_Pos;

    if Defer_Pos24 /= No_Token_Index then
        Or_Pos6 := Defer_Pos24;
        Or_Res6 := Defer_Res24;
        goto Exit_Or6;
    end if;
    
Defer_Res25 :=
   Subtype_Indication_Transform_Parse0 (Parser, Row_Pos18);
Defer_Pos25 := Parser.Current_Pos;

    if Defer_Pos25 /= No_Token_Index then
        Or_Pos6 := Defer_Pos25;
        Or_Res6 := Defer_Res25;
        goto Exit_Or6;
    end if;
<<Exit_Or6>>

--  End or_code



Row_Progress0 := 4;

if Or_Pos6 /= No_Token_Index then

   Row_Pos18 := Or_Pos6;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row18_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos18 = No_Token_Index and then Nobt0 then

   Row_Pos18 := Parser.Last_Fail.Pos;

   Transform_Has_Failed0 := True;
end if;

if Row_Pos18 /= No_Token_Index then

   Transform_Res12 := Allocate_Allocator (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res12,
      Kind => Ada_Allocator,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos18 = Pos
                            then No_Token_Index
                            else Row_Pos18 - 1));

      Initialize_Fields_For_Allocator
        (Self => Transform_Res12, Allocator_F_Subpool => Defer_Res23, Allocator_F_Type_Or_Expr => Or_Res6);

         if Defer_Res23 /= null and then Is_Incomplete (Defer_Res23) then
            Transform_Res12.Last_Attempted_Child := 0;
         elsif Defer_Res23 /= null and then not Is_Ghost (Defer_Res23) then
            Transform_Res12.Last_Attempted_Child := -1;
         end if;
         if Or_Res6 /= null and then Is_Incomplete (Or_Res6) then
            Transform_Res12.Last_Attempted_Child := 0;
         elsif Or_Res6 /= null and then not Is_Ghost (Or_Res6) then
            Transform_Res12.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed0 then
      Transform_Res12.Last_Attempted_Child :=
         Row_Progress0;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <allocator>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos18 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags12);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Allocator_Transform_Parse0_Memo,
      Row_Pos18 /= No_Token_Index,
      Transform_Res12,
      Pos,
      Row_Pos18);


   Parser.Current_Pos := Row_Pos18;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res12;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Allocator_Transform_Parse0;

   


function Anonymous_Type_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Anonymous_Type
is
   use Bare_Anonymous_Type_Memos;

   Call_Depth : aliased Natural;

      Row_Pos20 :
            Token_Index
               := No_Token_Index;
      Defer_Pos26 :
            Token_Index
               := No_Token_Index;
      Defer_Res26 :
            Bare_Anonymous_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Res13 :
            Bare_Anonymous_Type
               := No_Bare_Ada_Node;
      Transform_Diags13 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Anonymous_Type_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res13 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res13;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res13;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags13 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos20 := Pos;



Defer_Res26 :=
   Anonymous_Type_Decl_Transform_Parse0 (Parser, Row_Pos20);
Defer_Pos26 := Parser.Current_Pos;




if Defer_Pos26 /= No_Token_Index then

   Row_Pos20 := Defer_Pos26;

else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row20_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos20 /= No_Token_Index then

   Transform_Res13 := Allocate_Anonymous_Type (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res13,
      Kind => Ada_Anonymous_Type,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos20 = Pos
                            then No_Token_Index
                            else Row_Pos20 - 1));

      Initialize_Fields_For_Anonymous_Type
        (Self => Transform_Res13, Anonymous_Type_F_Type_Decl => Defer_Res26);

         if Defer_Res26 /= null and then Is_Incomplete (Defer_Res26) then
            Transform_Res13.Last_Attempted_Child := 0;
         elsif Defer_Res26 /= null and then not Is_Ghost (Defer_Res26) then
            Transform_Res13.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos20 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags13);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Anonymous_Type_Transform_Parse0_Memo,
      Row_Pos20 /= No_Token_Index,
      Transform_Res13,
      Pos,
      Row_Pos20);


   Parser.Current_Pos := Row_Pos20;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res13;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Anonymous_Type_Transform_Parse0;

   


function Anonymous_Type_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Anonymous_Type_Decl
is
   use Bare_Anonymous_Type_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos21 :
            Token_Index
               := No_Token_Index;
      Null_Res0 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Null_Res1 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Defer_Pos27 :
            Token_Index
               := No_Token_Index;
      Defer_Res27 :
            Bare_Array_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos28 :
            Token_Index
               := No_Token_Index;
      Defer_Res28 :
            Bare_Access_Def
               := No_Bare_Ada_Node;
      Or_Pos7 :
            Token_Index
               := No_Token_Index;
      Or_Res7 :
            Bare_Type_Def
               := No_Bare_Ada_Node;
      Transform_Res14 :
            Bare_Anonymous_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags14 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Anonymous_Type_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res14 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res14;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags14 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos21 := Pos;



   Null_Res0 := No_Bare_Ada_Node;




if Row_Pos21 /= No_Token_Index then

   Row_Pos21 := Row_Pos21;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;


   Null_Res1 := No_Bare_Ada_Node;




if Row_Pos21 /= No_Token_Index then

   Row_Pos21 := Row_Pos21;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;


--  Start or_code

Or_Pos7 := No_Token_Index;
Or_Res7 := No_Bare_Ada_Node;
    
Defer_Res27 :=
   Array_Type_Def_Transform_Parse2 (Parser, Row_Pos21);
Defer_Pos27 := Parser.Current_Pos;

    if Defer_Pos27 /= No_Token_Index then
        Or_Pos7 := Defer_Pos27;
        Or_Res7 := Defer_Res27;
        goto Exit_Or7;
    end if;
    
Defer_Res28 :=
   Access_Def_Or_Parse0 (Parser, Row_Pos21);
Defer_Pos28 := Parser.Current_Pos;

    if Defer_Pos28 /= No_Token_Index then
        Or_Pos7 := Defer_Pos28;
        Or_Res7 := Defer_Res28;
        goto Exit_Or7;
    end if;
<<Exit_Or7>>

--  End or_code




if Or_Pos7 /= No_Token_Index then

   Row_Pos21 := Or_Pos7;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row21_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos21 /= No_Token_Index then

   Transform_Res14 := Allocate_Anonymous_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res14,
      Kind => Ada_Anonymous_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos21 = Pos
                            then No_Token_Index
                            else Row_Pos21 - 1));

      Initialize_Fields_For_Anonymous_Type_Decl
        (Self => Transform_Res14, Base_Type_Decl_F_Name => Null_Res0, Type_Decl_F_Discriminants => Null_Res1, Type_Decl_F_Type_Def => Or_Res7);

         if Null_Res0 /= null and then Is_Incomplete (Null_Res0) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Null_Res0 /= null and then not Is_Ghost (Null_Res0) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;
         if Null_Res1 /= null and then Is_Incomplete (Null_Res1) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Null_Res1 /= null and then not Is_Ghost (Null_Res1) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;
         if Or_Res7 /= null and then Is_Incomplete (Or_Res7) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Or_Res7 /= null and then not Is_Ghost (Or_Res7) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos21 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags14);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Anonymous_Type_Decl_Transform_Parse0_Memo,
      Row_Pos21 /= No_Token_Index,
      Transform_Res14,
      Pos,
      Row_Pos21);


   Parser.Current_Pos := Row_Pos21;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res14;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Anonymous_Type_Decl_Transform_Parse0;

   


function Array_Type_Def_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Array_Type_Def
is
   use Bare_Array_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos22 :
            Token_Index
               := No_Token_Index;
      Token_Pos31 :
            Token_Index
               := No_Token_Index;
      Token_Res31 :
            Token_Index
               := No_Token_Index;
      Token_Pos32 :
            Token_Index
               := No_Token_Index;
      Token_Res32 :
            Token_Index
               := No_Token_Index;
      Row_Pos23 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos1 :
            Token_Index
               := No_Token_Index;
      Tmp_List1 :
            Free_Parse_List;
      Defer_Pos29 :
            Token_Index
               := No_Token_Index;
      Defer_Res29 :
            Bare_Unconstrained_Array_Index
               := No_Bare_Ada_Node;
      Token_Pos33 :
            Token_Index
               := No_Token_Index;
      Token_Res33 :
            Token_Index
               := No_Token_Index;
      List_Pos1 :
            Token_Index
               := No_Token_Index;
      List_Res1 :
            Bare_Unconstrained_Array_Index_List
               := No_Bare_Ada_Node;
      Transform_Res15 :
            Bare_Unconstrained_Array_Indices
               := No_Bare_Ada_Node;
      Transform_Diags15 :
            Ada.Containers.Count_Type;
      Row_Pos24 :
            Token_Index
               := No_Token_Index;
      Defer_Pos30 :
            Token_Index
               := No_Token_Index;
      Defer_Res30 :
            Bare_Constraint_List
               := No_Bare_Ada_Node;
      Transform_Res16 :
            Bare_Constrained_Array_Indices
               := No_Bare_Ada_Node;
      Transform_Diags16 :
            Ada.Containers.Count_Type;
      Or_Pos8 :
            Token_Index
               := No_Token_Index;
      Or_Res8 :
            Bare_Array_Indices
               := No_Bare_Ada_Node;
      Token_Pos34 :
            Token_Index
               := No_Token_Index;
      Token_Res34 :
            Token_Index
               := No_Token_Index;
      Token_Pos35 :
            Token_Index
               := No_Token_Index;
      Token_Res35 :
            Token_Index
               := No_Token_Index;
      Defer_Pos31 :
            Token_Index
               := No_Token_Index;
      Defer_Res31 :
            Bare_Component_Def
               := No_Bare_Ada_Node;
      Transform_Res17 :
            Bare_Array_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags17 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Array_Type_Def_Transform_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res17 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res17;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags17 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos22 := Pos;



--  Start tok_code

Token_Res31 := Row_Pos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res31));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Array)
   then
       Token_Pos31 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos22,
             Expected_Token_Id => Ada_Array,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos31 := Row_Pos22 + 1;
   end if;
end;

--  End tok_code




if Token_Pos31 /= No_Token_Index then

   Row_Pos22 := Token_Pos31;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;


--  Start tok_code

Token_Res32 := Row_Pos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res32));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos32 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos22,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos32 := Row_Pos22 + 1;
   end if;
end;

--  End tok_code




if Token_Pos32 /= No_Token_Index then

   Row_Pos22 := Token_Pos32;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;


--  Start or_code

Or_Pos8 := No_Token_Index;
Or_Res8 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags15 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos23 := Row_Pos22;



--  Start list_code

    List_Pos1 := No_Token_Index;



Lst_Cpos1 := Row_Pos23;
Tmp_List1 := Get_Parse_List (Parser);

loop
   
Defer_Res29 :=
   Unconstrained_Index_Transform_Parse0 (Parser, Lst_Cpos1);
Defer_Pos29 := Parser.Current_Pos;


   exit when Defer_Pos29 = No_Token_Index;

   List_Pos1 := Defer_Pos29;
   Lst_Cpos1 := List_Pos1;

   Tmp_List1.Nodes.Append (Defer_Res29);

      
--  Start tok_code

Token_Res33 := Lst_Cpos1;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res33));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos33 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos1 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos1,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos33 := Lst_Cpos1 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos33 /= No_Token_Index then
          Lst_Cpos1 := Token_Pos33;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List1.Nodes.Length;
begin
   List_Res1 :=
      Allocate_Unconstrained_Array_Index_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos23;
      Token_End := (if Lst_Cpos1 = Row_Pos23
                    then Row_Pos23
                    else Lst_Cpos1 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos23, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res1,
      Kind              => Ada_Unconstrained_Array_Index_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res1,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List1.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res1.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List1);

--  End list_code




if List_Pos1 /= No_Token_Index then

   Row_Pos23 := List_Pos1;

else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row23_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos23 /= No_Token_Index then

   Transform_Res15 := Allocate_Unconstrained_Array_Indices (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res15,
      Kind => Ada_Unconstrained_Array_Indices,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos22,
      Token_End_Index   => (if Row_Pos23 = Row_Pos22
                            then No_Token_Index
                            else Row_Pos23 - 1));

      Initialize_Fields_For_Unconstrained_Array_Indices
        (Self => Transform_Res15, Unconstrained_Array_Indices_F_Types => List_Res1);

         if List_Res1 /= null and then Is_Incomplete (List_Res1) then
            Transform_Res15.Last_Attempted_Child := 0;
         elsif List_Res1 /= null and then not Is_Ghost (List_Res1) then
            Transform_Res15.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos23 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags15);
end if;

--  End transform_code

    if Row_Pos23 /= No_Token_Index then
        Or_Pos8 := Row_Pos23;
        Or_Res8 := Transform_Res15;
        goto Exit_Or8;
    end if;
    
--  Start transform_code

Transform_Diags16 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos24 := Row_Pos22;



Defer_Res30 :=
   Constraint_List_List_Parse0 (Parser, Row_Pos24);
Defer_Pos30 := Parser.Current_Pos;




if Defer_Pos30 /= No_Token_Index then

   Row_Pos24 := Defer_Pos30;

else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row24_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos24 /= No_Token_Index then

   Transform_Res16 := Allocate_Constrained_Array_Indices (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res16,
      Kind => Ada_Constrained_Array_Indices,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos22,
      Token_End_Index   => (if Row_Pos24 = Row_Pos22
                            then No_Token_Index
                            else Row_Pos24 - 1));

      Initialize_Fields_For_Constrained_Array_Indices
        (Self => Transform_Res16, Constrained_Array_Indices_F_List => Defer_Res30);

         if Defer_Res30 /= null and then Is_Incomplete (Defer_Res30) then
            Transform_Res16.Last_Attempted_Child := 0;
         elsif Defer_Res30 /= null and then not Is_Ghost (Defer_Res30) then
            Transform_Res16.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos24 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags16);
end if;

--  End transform_code

    if Row_Pos24 /= No_Token_Index then
        Or_Pos8 := Row_Pos24;
        Or_Res8 := Transform_Res16;
        goto Exit_Or8;
    end if;
<<Exit_Or8>>

--  End or_code




if Or_Pos8 /= No_Token_Index then

   Row_Pos22 := Or_Pos8;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;


--  Start tok_code

Token_Res34 := Row_Pos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res34));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos34 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos22,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos34 := Row_Pos22 + 1;
   end if;
end;

--  End tok_code




if Token_Pos34 /= No_Token_Index then

   Row_Pos22 := Token_Pos34;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;


--  Start tok_code

Token_Res35 := Row_Pos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res35));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Of)
   then
       Token_Pos35 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos22,
             Expected_Token_Id => Ada_Of,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos35 := Row_Pos22 + 1;
   end if;
end;

--  End tok_code




if Token_Pos35 /= No_Token_Index then

   Row_Pos22 := Token_Pos35;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;


Defer_Res31 :=
   Component_Def_Transform_Parse0 (Parser, Row_Pos22);
Defer_Pos31 := Parser.Current_Pos;




if Defer_Pos31 /= No_Token_Index then

   Row_Pos22 := Defer_Pos31;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row22_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos22 /= No_Token_Index then

   Transform_Res17 := Allocate_Array_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res17,
      Kind => Ada_Array_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos22 = Pos
                            then No_Token_Index
                            else Row_Pos22 - 1));

      Initialize_Fields_For_Array_Type_Def
        (Self => Transform_Res17, Array_Type_Def_F_Indices => Or_Res8, Array_Type_Def_F_Component_Type => Defer_Res31);

         if Or_Res8 /= null and then Is_Incomplete (Or_Res8) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Or_Res8 /= null and then not Is_Ghost (Or_Res8) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;
         if Defer_Res31 /= null and then Is_Incomplete (Defer_Res31) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Defer_Res31 /= null and then not Is_Ghost (Defer_Res31) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos22 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags17);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Array_Type_Def_Transform_Parse2_Memo,
      Row_Pos22 /= No_Token_Index,
      Transform_Res17,
      Pos,
      Row_Pos22);


   Parser.Current_Pos := Row_Pos22;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res17;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Array_Type_Def_Transform_Parse2;

   


function Aspect_Assoc_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Aspect_Assoc
is
   use Bare_Aspect_Assoc_Memos;

   Call_Depth : aliased Natural;

      Row_Pos25 :
            Token_Index
               := No_Token_Index;
      Row_Pos26 :
            Token_Index
               := No_Token_Index;
      Token_Pos36 :
            Token_Index
               := No_Token_Index;
      Token_Res36 :
            Token_Index
               := No_Token_Index;
      Transform_Res18 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Diags18 :
            Ada.Containers.Count_Type;
      Row_Pos27 :
            Token_Index
               := No_Token_Index;
      Token_Pos37 :
            Token_Index
               := No_Token_Index;
      Token_Res37 :
            Token_Index
               := No_Token_Index;
      Defer_Pos32 :
            Token_Index
               := No_Token_Index;
      Defer_Res32 :
            Bare_Null_Literal
               := No_Bare_Ada_Node;
      Row_Pos28 :
            Token_Index
               := No_Token_Index;
      Defer_Pos33 :
            Token_Index
               := No_Token_Index;
      Defer_Res33 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Transform_Res19 :
            Bare_Abstract_State_Decl_Expr
               := No_Bare_Ada_Node;
      Transform_Diags19 :
            Ada.Containers.Count_Type;
      Or_Pos9 :
            Token_Index
               := No_Token_Index;
      Or_Res9 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res20 :
            Bare_Aspect_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags20 :
            Ada.Containers.Count_Type;
      Row_Pos29 :
            Token_Index
               := No_Token_Index;
      Defer_Pos34 :
            Token_Index
               := No_Token_Index;
      Defer_Res34 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos30 :
            Token_Index
               := No_Token_Index;
      Token_Pos38 :
            Token_Index
               := No_Token_Index;
      Token_Res38 :
            Token_Index
               := No_Token_Index;
      Defer_Pos35 :
            Token_Index
               := No_Token_Index;
      Defer_Res35 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos36 :
            Token_Index
               := No_Token_Index;
      Defer_Res36 :
            Bare_Contract_Cases
               := No_Bare_Ada_Node;
      Or_Pos10 :
            Token_Index
               := No_Token_Index;
      Or_Res10 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res21 :
            Bare_Aspect_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags21 :
            Ada.Containers.Count_Type;
      Or_Pos11 :
            Token_Index
               := No_Token_Index;
      Or_Res11 :
            Bare_Aspect_Assoc
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Aspect_Assoc_Or_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res11 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res11;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos11 := No_Token_Index;
Or_Res11 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags20 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos25 := Pos;



--  Start transform_code

Transform_Diags18 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos26 := Row_Pos25;



--  Start tok_code

Token_Res36 := Row_Pos26;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res36));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract_State)
   then
       Token_Pos36 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos26 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos26,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos36 := Row_Pos26 + 1;
   end if;
end;

--  End tok_code




if Token_Pos36 /= No_Token_Index then

   Row_Pos26 := Token_Pos36;

else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row26_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos26 /= No_Token_Index then

   Transform_Res18 := Allocate_Identifier (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res18,
      Kind => Ada_Identifier,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos25,
      Token_End_Index   => (if Row_Pos26 = Row_Pos25
                            then No_Token_Index
                            else Row_Pos26 - 1));

      Initialize_Fields_For_Identifier
        (Self => Transform_Res18);



elsif Row_Pos26 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags18);
end if;

--  End transform_code




if Row_Pos26 /= No_Token_Index then

   Row_Pos25 := Row_Pos26;

else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos27 := Row_Pos25;



--  Start tok_code

Token_Res37 := Row_Pos27;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res37));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos37 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos27 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos27,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos37 := Row_Pos27 + 1;
   end if;
end;

--  End tok_code




if Token_Pos37 /= No_Token_Index then

   Row_Pos27 := Token_Pos37;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;


--  Start or_code

Or_Pos9 := No_Token_Index;
Or_Res9 := No_Bare_Ada_Node;
    
Defer_Res32 :=
   Null_Literal_Transform_Parse0 (Parser, Row_Pos27);
Defer_Pos32 := Parser.Current_Pos;

    if Defer_Pos32 /= No_Token_Index then
        Or_Pos9 := Defer_Pos32;
        Or_Res9 := Defer_Res32;
        goto Exit_Or10;
    end if;
    
--  Start transform_code

Transform_Diags19 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos28 := Row_Pos27;



Defer_Res33 :=
   Multi_Abstract_State_Decl_Or_Parse0 (Parser, Row_Pos28);
Defer_Pos33 := Parser.Current_Pos;




if Defer_Pos33 /= No_Token_Index then

   Row_Pos28 := Defer_Pos33;

else
   Row_Pos28 := No_Token_Index;
   goto Exit_Row28_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row28_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos28 /= No_Token_Index then

   Transform_Res19 := Allocate_Abstract_State_Decl_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res19,
      Kind => Ada_Abstract_State_Decl_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos27,
      Token_End_Index   => (if Row_Pos28 = Row_Pos27
                            then No_Token_Index
                            else Row_Pos28 - 1));

      Initialize_Fields_For_Abstract_State_Decl_Expr
        (Self => Transform_Res19, Abstract_State_Decl_Expr_F_State_Decl => Defer_Res33);

         if Defer_Res33 /= null and then Is_Incomplete (Defer_Res33) then
            Transform_Res19.Last_Attempted_Child := 0;
         elsif Defer_Res33 /= null and then not Is_Ghost (Defer_Res33) then
            Transform_Res19.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos28 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags19);
end if;

--  End transform_code

    if Row_Pos28 /= No_Token_Index then
        Or_Pos9 := Row_Pos28;
        Or_Res9 := Transform_Res19;
        goto Exit_Or10;
    end if;
<<Exit_Or10>>

--  End or_code




if Or_Pos9 /= No_Token_Index then

   Row_Pos27 := Or_Pos9;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row27_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos27 = No_Token_Index then

         
   Or_Res9 := No_Bare_Ada_Node;



       
   Row_Pos27 := Row_Pos25;



end if;

--  End opt_code




if Row_Pos27 /= No_Token_Index then

   Row_Pos25 := Row_Pos27;

else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row25_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos25 /= No_Token_Index then

   Transform_Res20 := Allocate_Aspect_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res20,
      Kind => Ada_Aspect_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos25 = Pos
                            then No_Token_Index
                            else Row_Pos25 - 1));

      Initialize_Fields_For_Aspect_Assoc
        (Self => Transform_Res20, Aspect_Assoc_F_Id => Transform_Res18, Aspect_Assoc_F_Expr => Or_Res9);

         if Transform_Res18 /= null and then Is_Incomplete (Transform_Res18) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Transform_Res18 /= null and then not Is_Ghost (Transform_Res18) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;
         if Or_Res9 /= null and then Is_Incomplete (Or_Res9) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Or_Res9 /= null and then not Is_Ghost (Or_Res9) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos25 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags20);
end if;

--  End transform_code

    if Row_Pos25 /= No_Token_Index then
        Or_Pos11 := Row_Pos25;
        Or_Res11 := Transform_Res20;
        goto Exit_Or9;
    end if;
    
--  Start transform_code

Transform_Diags21 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos29 := Pos;



Defer_Res34 :=
   Name_Or_Parse2 (Parser, Row_Pos29);
Defer_Pos34 := Parser.Current_Pos;




if Defer_Pos34 /= No_Token_Index then

   Row_Pos29 := Defer_Pos34;

else
   Row_Pos29 := No_Token_Index;
   goto Exit_Row29_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos30 := Row_Pos29;



--  Start tok_code

Token_Res38 := Row_Pos30;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res38));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos38 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos30 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos30,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos38 := Row_Pos30 + 1;
   end if;
end;

--  End tok_code




if Token_Pos38 /= No_Token_Index then

   Row_Pos30 := Token_Pos38;

else
   Row_Pos30 := No_Token_Index;
   goto Exit_Row30_0;

end if;


--  Start or_code

Or_Pos10 := No_Token_Index;
Or_Res10 := No_Bare_Ada_Node;
    
Defer_Res35 :=
   Expr_Or_Parse0 (Parser, Row_Pos30);
Defer_Pos35 := Parser.Current_Pos;

    if Defer_Pos35 /= No_Token_Index then
        Or_Pos10 := Defer_Pos35;
        Or_Res10 := Defer_Res35;
        goto Exit_Or11;
    end if;
    
Defer_Res36 :=
   Contract_Cases_Expr_Transform_Parse0 (Parser, Row_Pos30);
Defer_Pos36 := Parser.Current_Pos;

    if Defer_Pos36 /= No_Token_Index then
        Or_Pos10 := Defer_Pos36;
        Or_Res10 := Defer_Res36;
        goto Exit_Or11;
    end if;
<<Exit_Or11>>

--  End or_code




if Or_Pos10 /= No_Token_Index then

   Row_Pos30 := Or_Pos10;

else
   Row_Pos30 := No_Token_Index;
   goto Exit_Row30_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row30_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos30 = No_Token_Index then

         
   Or_Res10 := No_Bare_Ada_Node;



       
   Row_Pos30 := Row_Pos29;



end if;

--  End opt_code




if Row_Pos30 /= No_Token_Index then

   Row_Pos29 := Row_Pos30;

else
   Row_Pos29 := No_Token_Index;
   goto Exit_Row29_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row29_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos29 /= No_Token_Index then

   Transform_Res21 := Allocate_Aspect_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res21,
      Kind => Ada_Aspect_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos29 = Pos
                            then No_Token_Index
                            else Row_Pos29 - 1));

      Initialize_Fields_For_Aspect_Assoc
        (Self => Transform_Res21, Aspect_Assoc_F_Id => Defer_Res34, Aspect_Assoc_F_Expr => Or_Res10);

         if Defer_Res34 /= null and then Is_Incomplete (Defer_Res34) then
            Transform_Res21.Last_Attempted_Child := 0;
         elsif Defer_Res34 /= null and then not Is_Ghost (Defer_Res34) then
            Transform_Res21.Last_Attempted_Child := -1;
         end if;
         if Or_Res10 /= null and then Is_Incomplete (Or_Res10) then
            Transform_Res21.Last_Attempted_Child := 0;
         elsif Or_Res10 /= null and then not Is_Ghost (Or_Res10) then
            Transform_Res21.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos29 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags21);
end if;

--  End transform_code

    if Row_Pos29 /= No_Token_Index then
        Or_Pos11 := Row_Pos29;
        Or_Res11 := Transform_Res21;
        goto Exit_Or9;
    end if;
<<Exit_Or9>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Aspect_Assoc_Or_Parse2_Memo,
      Or_Pos11 /= No_Token_Index,
      Or_Res11,
      Pos,
      Or_Pos11);


   Parser.Current_Pos := Or_Pos11;

   Exit_Call (Parser, Call_Depth);
   return Or_Res11;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Aspect_Assoc_Or_Parse2;

   


function Aspect_Clause_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Aspect_Clause
is
   use Bare_Aspect_Clause_Memos;

   Call_Depth : aliased Natural;

      Nobt1 :
            Boolean
               := False;
      Nobt2 :
            Boolean
               := False;
      Row_Pos31 :
            Token_Index
               := No_Token_Index;
      Token_Pos39 :
            Token_Index
               := No_Token_Index;
      Token_Res39 :
            Token_Index
               := No_Token_Index;
      Defer_Pos37 :
            Token_Index
               := No_Token_Index;
      Defer_Res37 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos40 :
            Token_Index
               := No_Token_Index;
      Token_Res40 :
            Token_Index
               := No_Token_Index;
      Defer_Pos38 :
            Token_Index
               := No_Token_Index;
      Defer_Res38 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Token_Pos41 :
            Token_Index
               := No_Token_Index;
      Token_Res41 :
            Token_Index
               := No_Token_Index;
      Row_Progress1 :
            Integer
               := 0;
      Transform_Res22 :
            Bare_Enum_Rep_Clause
               := No_Bare_Ada_Node;
      Transform_Has_Failed1 :
            Boolean
               := False;
      Transform_Diags22 :
            Ada.Containers.Count_Type;
      Row_Pos32 :
            Token_Index
               := No_Token_Index;
      Token_Pos42 :
            Token_Index
               := No_Token_Index;
      Token_Res42 :
            Token_Index
               := No_Token_Index;
      Defer_Pos39 :
            Token_Index
               := No_Token_Index;
      Defer_Res39 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos43 :
            Token_Index
               := No_Token_Index;
      Token_Res43 :
            Token_Index
               := No_Token_Index;
      Token_Pos44 :
            Token_Index
               := No_Token_Index;
      Token_Res44 :
            Token_Index
               := No_Token_Index;
      Row_Pos33 :
            Token_Index
               := No_Token_Index;
      Token_Pos45 :
            Token_Index
               := No_Token_Index;
      Token_Res45 :
            Token_Index
               := No_Token_Index;
      Token_Pos46 :
            Token_Index
               := No_Token_Index;
      Token_Res46 :
            Token_Index
               := No_Token_Index;
      Defer_Pos40 :
            Token_Index
               := No_Token_Index;
      Defer_Res40 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos47 :
            Token_Index
               := No_Token_Index;
      Token_Res47 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos2 :
            Token_Index
               := No_Token_Index;
      Tmp_List2 :
            Free_Parse_List;
      Defer_Pos41 :
            Token_Index
               := No_Token_Index;
      Defer_Res41 :
            Bare_Component_Clause
               := No_Bare_Ada_Node;
      Defer_Pos42 :
            Token_Index
               := No_Token_Index;
      Defer_Res42 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos12 :
            Token_Index
               := No_Token_Index;
      Or_Res12 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos2 :
            Token_Index
               := No_Token_Index;
      List_Res2 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Token_Pos48 :
            Token_Index
               := No_Token_Index;
      Token_Res48 :
            Token_Index
               := No_Token_Index;
      Token_Pos49 :
            Token_Index
               := No_Token_Index;
      Token_Res49 :
            Token_Index
               := No_Token_Index;
      Token_Pos50 :
            Token_Index
               := No_Token_Index;
      Token_Res50 :
            Token_Index
               := No_Token_Index;
      Transform_Res23 :
            Bare_Record_Rep_Clause
               := No_Bare_Ada_Node;
      Transform_Diags23 :
            Ada.Containers.Count_Type;
      Row_Pos34 :
            Token_Index
               := No_Token_Index;
      Token_Pos51 :
            Token_Index
               := No_Token_Index;
      Token_Res51 :
            Token_Index
               := No_Token_Index;
      Defer_Pos43 :
            Token_Index
               := No_Token_Index;
      Defer_Res43 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Token_Pos52 :
            Token_Index
               := No_Token_Index;
      Token_Res52 :
            Token_Index
               := No_Token_Index;
      Token_Pos53 :
            Token_Index
               := No_Token_Index;
      Token_Res53 :
            Token_Index
               := No_Token_Index;
      Defer_Pos44 :
            Token_Index
               := No_Token_Index;
      Defer_Res44 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos54 :
            Token_Index
               := No_Token_Index;
      Token_Res54 :
            Token_Index
               := No_Token_Index;
      Transform_Res24 :
            Bare_At_Clause
               := No_Bare_Ada_Node;
      Transform_Diags24 :
            Ada.Containers.Count_Type;
      Row_Pos35 :
            Token_Index
               := No_Token_Index;
      Token_Pos55 :
            Token_Index
               := No_Token_Index;
      Token_Res55 :
            Token_Index
               := No_Token_Index;
      Defer_Pos45 :
            Token_Index
               := No_Token_Index;
      Defer_Res45 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos56 :
            Token_Index
               := No_Token_Index;
      Token_Res56 :
            Token_Index
               := No_Token_Index;
      Defer_Pos46 :
            Token_Index
               := No_Token_Index;
      Defer_Res46 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos57 :
            Token_Index
               := No_Token_Index;
      Token_Res57 :
            Token_Index
               := No_Token_Index;
      Row_Progress2 :
            Integer
               := 0;
      Transform_Res25 :
            Bare_Attribute_Def_Clause
               := No_Bare_Ada_Node;
      Transform_Has_Failed2 :
            Boolean
               := False;
      Transform_Diags25 :
            Ada.Containers.Count_Type;
      Or_Pos13 :
            Token_Index
               := No_Token_Index;
      Or_Res13 :
            Bare_Aspect_Clause
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Aspect_Clause_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res13 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res13;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res13;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos13 := No_Token_Index;
Or_Res13 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags22 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos31 := Pos;



--  Start tok_code

Token_Res39 := Row_Pos31;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res39));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos39 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos31 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos31,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos39 := Row_Pos31 + 1;
   end if;
end;

--  End tok_code



Row_Progress1 := 1;

if Token_Pos39 /= No_Token_Index then

   Row_Pos31 := Token_Pos39;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;


Defer_Res37 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos31);
Defer_Pos37 := Parser.Current_Pos;



Row_Progress1 := 2;

if Defer_Pos37 /= No_Token_Index then

   Row_Pos31 := Defer_Pos37;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;


--  Start tok_code

Token_Res40 := Row_Pos31;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res40));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos40 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos31 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos31,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos40 := Row_Pos31 + 1;
   end if;
end;

--  End tok_code



Row_Progress1 := 3;

if Token_Pos40 /= No_Token_Index then

   Row_Pos31 := Token_Pos40;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;


Defer_Res38 :=
   Regular_Aggregate_Or_Parse0 (Parser, Row_Pos31);
Defer_Pos38 := Parser.Current_Pos;



Row_Progress1 := 4;

if Defer_Pos38 /= No_Token_Index then

   Row_Pos31 := Defer_Pos38;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;

Nobt1 := True;

   Nobt1 := Nobt1;

Row_Progress1 := 5;

if Row_Pos31 /= No_Token_Index then

   Row_Pos31 := Row_Pos31;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;


--  Start tok_code

Token_Res41 := Row_Pos31;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res41));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos41 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos31 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos31,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos41 := Row_Pos31 + 1;
   end if;
end;

--  End tok_code



Row_Progress1 := 6;

if Token_Pos41 /= No_Token_Index then

   Row_Pos31 := Token_Pos41;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row31_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos31 = No_Token_Index and then Nobt1 then

   Row_Pos31 := Parser.Last_Fail.Pos;

   Transform_Has_Failed1 := True;
end if;

if Row_Pos31 /= No_Token_Index then

   Transform_Res22 := Allocate_Enum_Rep_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res22,
      Kind => Ada_Enum_Rep_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos31 = Pos
                            then No_Token_Index
                            else Row_Pos31 - 1));

      Initialize_Fields_For_Enum_Rep_Clause
        (Self => Transform_Res22, Enum_Rep_Clause_F_Type_Name => Defer_Res37, Enum_Rep_Clause_F_Aggregate => Defer_Res38);

         if Defer_Res37 /= null and then Is_Incomplete (Defer_Res37) then
            Transform_Res22.Last_Attempted_Child := 0;
         elsif Defer_Res37 /= null and then not Is_Ghost (Defer_Res37) then
            Transform_Res22.Last_Attempted_Child := -1;
         end if;
         if Defer_Res38 /= null and then Is_Incomplete (Defer_Res38) then
            Transform_Res22.Last_Attempted_Child := 0;
         elsif Defer_Res38 /= null and then not Is_Ghost (Defer_Res38) then
            Transform_Res22.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed1 then
      Transform_Res22.Last_Attempted_Child :=
         Row_Progress1;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <aspect_clause>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos31 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags22);
end if;

--  End transform_code

    if Row_Pos31 /= No_Token_Index then
        Or_Pos13 := Row_Pos31;
        Or_Res13 := Transform_Res22;
        goto Exit_Or12;
    end if;
    
--  Start transform_code

Transform_Diags23 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos32 := Pos;



--  Start tok_code

Token_Res42 := Row_Pos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res42));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos42 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos32,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos42 := Row_Pos32 + 1;
   end if;
end;

--  End tok_code




if Token_Pos42 /= No_Token_Index then

   Row_Pos32 := Token_Pos42;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


Defer_Res39 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos32);
Defer_Pos39 := Parser.Current_Pos;




if Defer_Pos39 /= No_Token_Index then

   Row_Pos32 := Defer_Pos39;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start tok_code

Token_Res43 := Row_Pos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res43));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos43 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos32,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos43 := Row_Pos32 + 1;
   end if;
end;

--  End tok_code




if Token_Pos43 /= No_Token_Index then

   Row_Pos32 := Token_Pos43;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start tok_code

Token_Res44 := Row_Pos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res44));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Record)
   then
       Token_Pos44 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos32,
             Expected_Token_Id => Ada_Record,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos44 := Row_Pos32 + 1;
   end if;
end;

--  End tok_code




if Token_Pos44 /= No_Token_Index then

   Row_Pos32 := Token_Pos44;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos33 := Row_Pos32;



--  Start tok_code

Token_Res45 := Row_Pos33;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res45));
begin
   if
      T.Kind /= From_Token_Kind (Ada_At)
   then
       Token_Pos45 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos33 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos33,
             Expected_Token_Id => Ada_At,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos45 := Row_Pos33 + 1;
   end if;
end;

--  End tok_code




if Token_Pos45 /= No_Token_Index then

   Row_Pos33 := Token_Pos45;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;


--  Start tok_code

Token_Res46 := Row_Pos33;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res46));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Mod)
   then
       Token_Pos46 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos33 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos33,
             Expected_Token_Id => Ada_Mod,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos46 := Row_Pos33 + 1;
   end if;
end;

--  End tok_code




if Token_Pos46 /= No_Token_Index then

   Row_Pos33 := Token_Pos46;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;


Defer_Res40 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos33);
Defer_Pos40 := Parser.Current_Pos;




if Defer_Pos40 /= No_Token_Index then

   Row_Pos33 := Defer_Pos40;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res47 := Row_Pos33;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res47));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos47 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos33 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos33,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos47 := Row_Pos33 + 1;
   end if;
end;

--  End tok_code


if Token_Pos47 = No_Token_Index then

         
   Token_Res47 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos33)),
                To_Text ("Missing ';'"));

       
   Token_Pos47 := Row_Pos33;



end if;

--  End opt_code




if Token_Pos47 /= No_Token_Index then

   Row_Pos33 := Token_Pos47;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row33_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos33 = No_Token_Index then

         
   Defer_Res40 := No_Bare_Ada_Node;



       
   Row_Pos33 := Row_Pos32;



end if;

--  End opt_code




if Row_Pos33 /= No_Token_Index then

   Row_Pos32 := Row_Pos33;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start list_code

    List_Pos2 := Row_Pos32;



Lst_Cpos2 := Row_Pos32;
Tmp_List2 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos12 := No_Token_Index;
Or_Res12 := No_Bare_Ada_Node;
    
Defer_Res41 :=
   Component_Clause_Transform_Parse0 (Parser, Lst_Cpos2);
Defer_Pos41 := Parser.Current_Pos;

    if Defer_Pos41 /= No_Token_Index then
        Or_Pos12 := Defer_Pos41;
        Or_Res12 := Defer_Res41;
        goto Exit_Or13;
    end if;
    
Defer_Res42 :=
   Pragma_Transform_Parse0 (Parser, Lst_Cpos2);
Defer_Pos42 := Parser.Current_Pos;

    if Defer_Pos42 /= No_Token_Index then
        Or_Pos12 := Defer_Pos42;
        Or_Res12 := Defer_Res42;
        goto Exit_Or13;
    end if;
<<Exit_Or13>>

--  End or_code


   exit when Or_Pos12 = No_Token_Index;

   List_Pos2 := Or_Pos12;
   Lst_Cpos2 := List_Pos2;

   Tmp_List2.Nodes.Append (Or_Res12);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List2.Nodes.Length;
begin
   List_Res2 :=
      Allocate_Ada_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos32;
      Token_End := (if Lst_Cpos2 = Row_Pos32
                    then Row_Pos32
                    else Lst_Cpos2 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos32, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res2,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res2,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List2.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res2.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List2);

--  End list_code




if List_Pos2 /= No_Token_Index then

   Row_Pos32 := List_Pos2;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start tok_code

Token_Res48 := Row_Pos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res48));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos48 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos32,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos48 := Row_Pos32 + 1;
   end if;
end;

--  End tok_code




if Token_Pos48 /= No_Token_Index then

   Row_Pos32 := Token_Pos48;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start tok_code

Token_Res49 := Row_Pos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res49));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Record)
   then
       Token_Pos49 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos32,
             Expected_Token_Id => Ada_Record,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos49 := Row_Pos32 + 1;
   end if;
end;

--  End tok_code




if Token_Pos49 /= No_Token_Index then

   Row_Pos32 := Token_Pos49;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res50 := Row_Pos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res50));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos50 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos32,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos50 := Row_Pos32 + 1;
   end if;
end;

--  End tok_code


if Token_Pos50 = No_Token_Index then

         
   Token_Res50 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos32)),
                To_Text ("Missing ';'"));

       
   Token_Pos50 := Row_Pos32;



end if;

--  End opt_code




if Token_Pos50 /= No_Token_Index then

   Row_Pos32 := Token_Pos50;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row32_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos32 /= No_Token_Index then

   Transform_Res23 := Allocate_Record_Rep_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res23,
      Kind => Ada_Record_Rep_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos32 = Pos
                            then No_Token_Index
                            else Row_Pos32 - 1));

      Initialize_Fields_For_Record_Rep_Clause
        (Self => Transform_Res23, Record_Rep_Clause_F_Name => Defer_Res39, Record_Rep_Clause_F_At_Expr => Defer_Res40, Record_Rep_Clause_F_Components => List_Res2);

         if Defer_Res39 /= null and then Is_Incomplete (Defer_Res39) then
            Transform_Res23.Last_Attempted_Child := 0;
         elsif Defer_Res39 /= null and then not Is_Ghost (Defer_Res39) then
            Transform_Res23.Last_Attempted_Child := -1;
         end if;
         if Defer_Res40 /= null and then Is_Incomplete (Defer_Res40) then
            Transform_Res23.Last_Attempted_Child := 0;
         elsif Defer_Res40 /= null and then not Is_Ghost (Defer_Res40) then
            Transform_Res23.Last_Attempted_Child := -1;
         end if;
         if List_Res2 /= null and then Is_Incomplete (List_Res2) then
            Transform_Res23.Last_Attempted_Child := 0;
         elsif List_Res2 /= null and then not Is_Ghost (List_Res2) then
            Transform_Res23.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos32 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags23);
end if;

--  End transform_code

    if Row_Pos32 /= No_Token_Index then
        Or_Pos13 := Row_Pos32;
        Or_Res13 := Transform_Res23;
        goto Exit_Or12;
    end if;
    
--  Start transform_code

Transform_Diags24 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos34 := Pos;



--  Start tok_code

Token_Res51 := Row_Pos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res51));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos51 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos34,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos51 := Row_Pos34 + 1;
   end if;
end;

--  End tok_code




if Token_Pos51 /= No_Token_Index then

   Row_Pos34 := Token_Pos51;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


Defer_Res43 :=
   Direct_Name_Or_Parse0 (Parser, Row_Pos34);
Defer_Pos43 := Parser.Current_Pos;




if Defer_Pos43 /= No_Token_Index then

   Row_Pos34 := Defer_Pos43;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


--  Start tok_code

Token_Res52 := Row_Pos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res52));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos52 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos34,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos52 := Row_Pos34 + 1;
   end if;
end;

--  End tok_code




if Token_Pos52 /= No_Token_Index then

   Row_Pos34 := Token_Pos52;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


--  Start tok_code

Token_Res53 := Row_Pos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res53));
begin
   if
      T.Kind /= From_Token_Kind (Ada_At)
   then
       Token_Pos53 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos34,
             Expected_Token_Id => Ada_At,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos53 := Row_Pos34 + 1;
   end if;
end;

--  End tok_code




if Token_Pos53 /= No_Token_Index then

   Row_Pos34 := Token_Pos53;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


Defer_Res44 :=
   Expr_Or_Parse0 (Parser, Row_Pos34);
Defer_Pos44 := Parser.Current_Pos;




if Defer_Pos44 /= No_Token_Index then

   Row_Pos34 := Defer_Pos44;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


--  Start tok_code

Token_Res54 := Row_Pos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res54));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos54 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos34,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos54 := Row_Pos34 + 1;
   end if;
end;

--  End tok_code




if Token_Pos54 /= No_Token_Index then

   Row_Pos34 := Token_Pos54;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row34_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos34 /= No_Token_Index then

   Transform_Res24 := Allocate_At_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res24,
      Kind => Ada_At_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos34 = Pos
                            then No_Token_Index
                            else Row_Pos34 - 1));

      Initialize_Fields_For_At_Clause
        (Self => Transform_Res24, At_Clause_F_Name => Defer_Res43, At_Clause_F_Expr => Defer_Res44);

         if Defer_Res43 /= null and then Is_Incomplete (Defer_Res43) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Defer_Res43 /= null and then not Is_Ghost (Defer_Res43) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;
         if Defer_Res44 /= null and then Is_Incomplete (Defer_Res44) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Defer_Res44 /= null and then not Is_Ghost (Defer_Res44) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos34 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags24);
end if;

--  End transform_code

    if Row_Pos34 /= No_Token_Index then
        Or_Pos13 := Row_Pos34;
        Or_Res13 := Transform_Res24;
        goto Exit_Or12;
    end if;
    
--  Start transform_code

Transform_Diags25 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos35 := Pos;



--  Start tok_code

Token_Res55 := Row_Pos35;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res55));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos55 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos35 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos35,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos55 := Row_Pos35 + 1;
   end if;
end;

--  End tok_code



Row_Progress2 := 1;

if Token_Pos55 /= No_Token_Index then

   Row_Pos35 := Token_Pos55;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;


Defer_Res45 :=
   Name_Or_Parse2 (Parser, Row_Pos35);
Defer_Pos45 := Parser.Current_Pos;



Row_Progress2 := 2;

if Defer_Pos45 /= No_Token_Index then

   Row_Pos35 := Defer_Pos45;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;


--  Start tok_code

Token_Res56 := Row_Pos35;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res56));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos56 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos35 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos35,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos56 := Row_Pos35 + 1;
   end if;
end;

--  End tok_code



Row_Progress2 := 3;

if Token_Pos56 /= No_Token_Index then

   Row_Pos35 := Token_Pos56;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;

Nobt2 := True;

   Nobt2 := Nobt2;

Row_Progress2 := 4;

if Row_Pos35 /= No_Token_Index then

   Row_Pos35 := Row_Pos35;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;


Defer_Res46 :=
   Expr_Or_Parse0 (Parser, Row_Pos35);
Defer_Pos46 := Parser.Current_Pos;



Row_Progress2 := 5;

if Defer_Pos46 /= No_Token_Index then

   Row_Pos35 := Defer_Pos46;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;


--  Start tok_code

Token_Res57 := Row_Pos35;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res57));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos57 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos35 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos35,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos57 := Row_Pos35 + 1;
   end if;
end;

--  End tok_code



Row_Progress2 := 6;

if Token_Pos57 /= No_Token_Index then

   Row_Pos35 := Token_Pos57;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row35_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos35 = No_Token_Index and then Nobt2 then

   Row_Pos35 := Parser.Last_Fail.Pos;

   Transform_Has_Failed2 := True;
end if;

if Row_Pos35 /= No_Token_Index then

   Transform_Res25 := Allocate_Attribute_Def_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res25,
      Kind => Ada_Attribute_Def_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos35 = Pos
                            then No_Token_Index
                            else Row_Pos35 - 1));

      Initialize_Fields_For_Attribute_Def_Clause
        (Self => Transform_Res25, Attribute_Def_Clause_F_Attribute_Expr => Defer_Res45, Attribute_Def_Clause_F_Expr => Defer_Res46);

         if Defer_Res45 /= null and then Is_Incomplete (Defer_Res45) then
            Transform_Res25.Last_Attempted_Child := 0;
         elsif Defer_Res45 /= null and then not Is_Ghost (Defer_Res45) then
            Transform_Res25.Last_Attempted_Child := -1;
         end if;
         if Defer_Res46 /= null and then Is_Incomplete (Defer_Res46) then
            Transform_Res25.Last_Attempted_Child := 0;
         elsif Defer_Res46 /= null and then not Is_Ghost (Defer_Res46) then
            Transform_Res25.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed2 then
      Transform_Res25.Last_Attempted_Child :=
         Row_Progress2;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <aspect_clause>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos35 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags25);
end if;

--  End transform_code

    if Row_Pos35 /= No_Token_Index then
        Or_Pos13 := Row_Pos35;
        Or_Res13 := Transform_Res25;
        goto Exit_Or12;
    end if;
<<Exit_Or12>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Aspect_Clause_Or_Parse1_Memo,
      Or_Pos13 /= No_Token_Index,
      Or_Res13,
      Pos,
      Or_Pos13);


   Parser.Current_Pos := Or_Pos13;

   Exit_Call (Parser, Call_Depth);
   return Or_Res13;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Aspect_Clause_Or_Parse1;

   


function Aspect_Spec_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Aspect_Spec
is
   use Bare_Aspect_Spec_Memos;

   Call_Depth : aliased Natural;

      Nobt3 :
            Boolean
               := False;
      Row_Pos36 :
            Token_Index
               := No_Token_Index;
      Token_Pos58 :
            Token_Index
               := No_Token_Index;
      Token_Res58 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos3 :
            Token_Index
               := No_Token_Index;
      Tmp_List3 :
            Free_Parse_List;
      Defer_Pos47 :
            Token_Index
               := No_Token_Index;
      Defer_Res47 :
            Bare_Aspect_Assoc
               := No_Bare_Ada_Node;
      Token_Pos59 :
            Token_Index
               := No_Token_Index;
      Token_Res59 :
            Token_Index
               := No_Token_Index;
      List_Pos3 :
            Token_Index
               := No_Token_Index;
      List_Res3 :
            Bare_Aspect_Assoc_List
               := No_Bare_Ada_Node;
      Row_Progress3 :
            Integer
               := 0;
      Transform_Res26 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Transform_Has_Failed3 :
            Boolean
               := False;
      Transform_Diags26 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Aspect_Spec_Opt_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res26 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res26;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res26;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start opt_code












--  Start transform_code

Transform_Diags26 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos36 := Pos;



--  Start tok_code

Token_Res58 := Row_Pos36;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res58));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos58 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos36 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos36,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos58 := Row_Pos36 + 1;
   end if;
end;

--  End tok_code



Row_Progress3 := 1;

if Token_Pos58 /= No_Token_Index then

   Row_Pos36 := Token_Pos58;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;

Nobt3 := True;

   Nobt3 := Nobt3;

Row_Progress3 := 2;

if Row_Pos36 /= No_Token_Index then

   Row_Pos36 := Row_Pos36;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;


--  Start list_code

    List_Pos3 := No_Token_Index;



Lst_Cpos3 := Row_Pos36;
Tmp_List3 := Get_Parse_List (Parser);

loop
   
Defer_Res47 :=
   Aspect_Assoc_Or_Parse2 (Parser, Lst_Cpos3);
Defer_Pos47 := Parser.Current_Pos;


   exit when Defer_Pos47 = No_Token_Index;

   List_Pos3 := Defer_Pos47;
   Lst_Cpos3 := List_Pos3;

   Tmp_List3.Nodes.Append (Defer_Res47);

      
--  Start tok_code

Token_Res59 := Lst_Cpos3;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res59));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos59 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos3 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos3,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos59 := Lst_Cpos3 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos59 /= No_Token_Index then
          Lst_Cpos3 := Token_Pos59;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List3.Nodes.Length;
begin
   List_Res3 :=
      Allocate_Aspect_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos36;
      Token_End := (if Lst_Cpos3 = Row_Pos36
                    then Row_Pos36
                    else Lst_Cpos3 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos36, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res3,
      Kind              => Ada_Aspect_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res3,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List3.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res3.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List3);

--  End list_code



Row_Progress3 := 3;

if List_Pos3 /= No_Token_Index then

   Row_Pos36 := List_Pos3;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row36_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos36 = No_Token_Index and then Nobt3 then

   Row_Pos36 := Parser.Last_Fail.Pos;

   Transform_Has_Failed3 := True;
end if;

if Row_Pos36 /= No_Token_Index then

   Transform_Res26 := Allocate_Aspect_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res26,
      Kind => Ada_Aspect_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos36 = Pos
                            then No_Token_Index
                            else Row_Pos36 - 1));

      Initialize_Fields_For_Aspect_Spec
        (Self => Transform_Res26, Aspect_Spec_F_Aspect_Assocs => List_Res3);

         if List_Res3 /= null and then Is_Incomplete (List_Res3) then
            Transform_Res26.Last_Attempted_Child := 0;
         elsif List_Res3 /= null and then not Is_Ghost (List_Res3) then
            Transform_Res26.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed3 then
      Transform_Res26.Last_Attempted_Child :=
         Row_Progress3;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <aspect_spec>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos36 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags26);
end if;

--  End transform_code


if Row_Pos36 = No_Token_Index then

         
   if Nobt3 then
      Row_Pos36 := Parser.Last_Fail.Pos;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Row_Pos36)),
              To_Text ("Cannot parse <aspect_spec>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;


         if not Nobt3 then
            
   Transform_Res26 := No_Bare_Ada_Node;

         end if;


       if not Nobt3 then
          
   Row_Pos36 := Pos;

       end if;


end if;

--  End opt_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Aspect_Spec_Opt_Parse0_Memo,
      Row_Pos36 /= No_Token_Index,
      Transform_Res26,
      Pos,
      Row_Pos36);


   Parser.Current_Pos := Row_Pos36;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res26;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Aspect_Spec_Opt_Parse0;

   


function Assignment_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Assign_Stmt
is
   use Bare_Assign_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt4 :
            Boolean
               := False;
      Row_Pos37 :
            Token_Index
               := No_Token_Index;
      Defer_Pos48 :
            Token_Index
               := No_Token_Index;
      Defer_Res48 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos60 :
            Token_Index
               := No_Token_Index;
      Token_Res60 :
            Token_Index
               := No_Token_Index;
      Defer_Pos49 :
            Token_Index
               := No_Token_Index;
      Defer_Res49 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos61 :
            Token_Index
               := No_Token_Index;
      Token_Res61 :
            Token_Index
               := No_Token_Index;
      Row_Progress4 :
            Integer
               := 0;
      Transform_Res27 :
            Bare_Assign_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed4 :
            Boolean
               := False;
      Transform_Diags27 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Assignment_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res27 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res27;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res27;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags27 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos37 := Pos;



Defer_Res48 :=
   Name_Or_Parse2 (Parser, Row_Pos37);
Defer_Pos48 := Parser.Current_Pos;



Row_Progress4 := 1;

if Defer_Pos48 /= No_Token_Index then

   Row_Pos37 := Defer_Pos48;

else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;

end if;


--  Start tok_code

Token_Res60 := Row_Pos37;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res60));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos60 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos37 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos37,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos60 := Row_Pos37 + 1;
   end if;
end;

--  End tok_code



Row_Progress4 := 2;

if Token_Pos60 /= No_Token_Index then

   Row_Pos37 := Token_Pos60;

else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;

end if;

Nobt4 := True;

   Nobt4 := Nobt4;

Row_Progress4 := 3;

if Row_Pos37 /= No_Token_Index then

   Row_Pos37 := Row_Pos37;

else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;

end if;


Defer_Res49 :=
   Expr_Or_Parse0 (Parser, Row_Pos37);
Defer_Pos49 := Parser.Current_Pos;



Row_Progress4 := 4;

if Defer_Pos49 /= No_Token_Index then

   Row_Pos37 := Defer_Pos49;

else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res61 := Row_Pos37;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res61));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos61 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos37 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos37,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos61 := Row_Pos37 + 1;
   end if;
end;

--  End tok_code


if Token_Pos61 = No_Token_Index then

         
   Token_Res61 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos37)),
                To_Text ("Missing ';'"));

       
   Token_Pos61 := Row_Pos37;



end if;

--  End opt_code



Row_Progress4 := 5;

if Token_Pos61 /= No_Token_Index then

   Row_Pos37 := Token_Pos61;

else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row37_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos37 = No_Token_Index and then Nobt4 then

   Row_Pos37 := Parser.Last_Fail.Pos;

   Transform_Has_Failed4 := True;
end if;

if Row_Pos37 /= No_Token_Index then

   Transform_Res27 := Allocate_Assign_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res27,
      Kind => Ada_Assign_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos37 = Pos
                            then No_Token_Index
                            else Row_Pos37 - 1));

      Initialize_Fields_For_Assign_Stmt
        (Self => Transform_Res27, Assign_Stmt_F_Dest => Defer_Res48, Assign_Stmt_F_Expr => Defer_Res49);

         if Defer_Res48 /= null and then Is_Incomplete (Defer_Res48) then
            Transform_Res27.Last_Attempted_Child := 0;
         elsif Defer_Res48 /= null and then not Is_Ghost (Defer_Res48) then
            Transform_Res27.Last_Attempted_Child := -1;
         end if;
         if Defer_Res49 /= null and then Is_Incomplete (Defer_Res49) then
            Transform_Res27.Last_Attempted_Child := 0;
         elsif Defer_Res49 /= null and then not Is_Ghost (Defer_Res49) then
            Transform_Res27.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed4 then
      Transform_Res27.Last_Attempted_Child :=
         Row_Progress4;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <assignment_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos37 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags27);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Assignment_Stmt_Transform_Parse0_Memo,
      Row_Pos37 /= No_Token_Index,
      Transform_Res27,
      Pos,
      Row_Pos37);


   Parser.Current_Pos := Row_Pos37;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res27;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Assignment_Stmt_Transform_Parse0;

   


function Attr_Suffix_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Assoc_List
is
   use Bare_Assoc_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos4 :
            Token_Index
               := No_Token_Index;
      Tmp_List4 :
            Free_Parse_List;
      Defer_Pos50 :
            Token_Index
               := No_Token_Index;
      Defer_Res50 :
            Bare_Param_Assoc
               := No_Bare_Ada_Node;
      Token_Pos62 :
            Token_Index
               := No_Token_Index;
      Token_Res62 :
            Token_Index
               := No_Token_Index;
      List_Pos4 :
            Token_Index
               := No_Token_Index;
      List_Res4 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Attr_Suffix_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res4 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos4 := No_Token_Index;



Lst_Cpos4 := Pos;
Tmp_List4 := Get_Parse_List (Parser);

loop
   
Defer_Res50 :=
   Param_Assoc_Transform_Parse0 (Parser, Lst_Cpos4);
Defer_Pos50 := Parser.Current_Pos;


   exit when Defer_Pos50 = No_Token_Index;

   List_Pos4 := Defer_Pos50;
   Lst_Cpos4 := List_Pos4;

   Tmp_List4.Nodes.Append (Defer_Res50);

      
--  Start tok_code

Token_Res62 := Lst_Cpos4;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res62));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos62 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos4 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos4,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos62 := Lst_Cpos4 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos62 /= No_Token_Index then
          Lst_Cpos4 := Token_Pos62;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List4.Nodes.Length;
begin
   List_Res4 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos4 = Pos
                    then Pos
                    else Lst_Cpos4 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res4,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res4,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List4.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res4.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List4);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Attr_Suffix_List_Parse0_Memo,
      List_Pos4 /= No_Token_Index,
      List_Res4,
      Pos,
      List_Pos4);


   Parser.Current_Pos := List_Pos4;

   Exit_Call (Parser, Call_Depth);
   return List_Res4;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Attr_Suffix_List_Parse0;

   


function Basic_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos51 :
            Token_Index
               := No_Token_Index;
      Defer_Res51 :
            Bare_Null_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos52 :
            Token_Index
               := No_Token_Index;
      Defer_Res52 :
            Bare_Abstract_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos53 :
            Token_Index
               := No_Token_Index;
      Defer_Res53 :
            Bare_Expr_Function
               := No_Bare_Ada_Node;
      Defer_Pos54 :
            Token_Index
               := No_Token_Index;
      Defer_Res54 :
            Bare_Subp_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos55 :
            Token_Index
               := No_Token_Index;
      Defer_Res55 :
            Bare_Body_Stub
               := No_Bare_Ada_Node;
      Defer_Pos56 :
            Token_Index
               := No_Token_Index;
      Defer_Res56 :
            Bare_Generic_Instantiation
               := No_Bare_Ada_Node;
      Defer_Pos57 :
            Token_Index
               := No_Token_Index;
      Defer_Res57 :
            Bare_Body_Node
               := No_Bare_Ada_Node;
      Defer_Pos58 :
            Token_Index
               := No_Token_Index;
      Defer_Res58 :
            Bare_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos59 :
            Token_Index
               := No_Token_Index;
      Defer_Res59 :
            Bare_Base_Type_Decl
               := No_Bare_Ada_Node;
      Defer_Pos60 :
            Token_Index
               := No_Token_Index;
      Defer_Res60 :
            Bare_Task_Type_Decl
               := No_Bare_Ada_Node;
      Defer_Pos61 :
            Token_Index
               := No_Token_Index;
      Defer_Res61 :
            Bare_Protected_Type_Decl
               := No_Bare_Ada_Node;
      Defer_Pos62 :
            Token_Index
               := No_Token_Index;
      Defer_Res62 :
            Bare_Subtype_Decl
               := No_Bare_Ada_Node;
      Defer_Pos63 :
            Token_Index
               := No_Token_Index;
      Defer_Res63 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;
      Defer_Pos64 :
            Token_Index
               := No_Token_Index;
      Defer_Res64 :
            Bare_Package_Decl
               := No_Bare_Ada_Node;
      Defer_Pos65 :
            Token_Index
               := No_Token_Index;
      Defer_Res65 :
            Bare_Aspect_Clause
               := No_Bare_Ada_Node;
      Defer_Pos66 :
            Token_Index
               := No_Token_Index;
      Defer_Res66 :
            Bare_Use_Clause
               := No_Bare_Ada_Node;
      Defer_Pos67 :
            Token_Index
               := No_Token_Index;
      Defer_Res67 :
            Bare_Exception_Decl
               := No_Bare_Ada_Node;
      Defer_Pos68 :
            Token_Index
               := No_Token_Index;
      Defer_Res68 :
            Bare_Package_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos69 :
            Token_Index
               := No_Token_Index;
      Defer_Res69 :
            Bare_Generic_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos70 :
            Token_Index
               := No_Token_Index;
      Defer_Res70 :
            Bare_Generic_Decl
               := No_Bare_Ada_Node;
      Defer_Pos71 :
            Token_Index
               := No_Token_Index;
      Defer_Res71 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos14 :
            Token_Index
               := No_Token_Index;
      Or_Res14 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Basic_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res14 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res14;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos14 := No_Token_Index;
Or_Res14 := No_Bare_Ada_Node;
    
Defer_Res51 :=
   Null_Subp_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos51 := Parser.Current_Pos;

    if Defer_Pos51 /= No_Token_Index then
        Or_Pos14 := Defer_Pos51;
        Or_Res14 := Defer_Res51;
        goto Exit_Or14;
    end if;
    
Defer_Res52 :=
   Abstract_Subp_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos52 := Parser.Current_Pos;

    if Defer_Pos52 /= No_Token_Index then
        Or_Pos14 := Defer_Pos52;
        Or_Res14 := Defer_Res52;
        goto Exit_Or14;
    end if;
    
Defer_Res53 :=
   Expr_Fn_Transform_Parse0 (Parser, Pos);
Defer_Pos53 := Parser.Current_Pos;

    if Defer_Pos53 /= No_Token_Index then
        Or_Pos14 := Defer_Pos53;
        Or_Res14 := Defer_Res53;
        goto Exit_Or14;
    end if;
    
Defer_Res54 :=
   Subp_Renaming_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos54 := Parser.Current_Pos;

    if Defer_Pos54 /= No_Token_Index then
        Or_Pos14 := Defer_Pos54;
        Or_Res14 := Defer_Res54;
        goto Exit_Or14;
    end if;
    
Defer_Res55 :=
   Body_Stub_Or_Parse0 (Parser, Pos);
Defer_Pos55 := Parser.Current_Pos;

    if Defer_Pos55 /= No_Token_Index then
        Or_Pos14 := Defer_Pos55;
        Or_Res14 := Defer_Res55;
        goto Exit_Or14;
    end if;
    
Defer_Res56 :=
   Generic_Instantiation_Or_Parse1 (Parser, Pos);
Defer_Pos56 := Parser.Current_Pos;

    if Defer_Pos56 /= No_Token_Index then
        Or_Pos14 := Defer_Pos56;
        Or_Res14 := Defer_Res56;
        goto Exit_Or14;
    end if;
    
Defer_Res57 :=
   Body_Or_Parse0 (Parser, Pos);
Defer_Pos57 := Parser.Current_Pos;

    if Defer_Pos57 /= No_Token_Index then
        Or_Pos14 := Defer_Pos57;
        Or_Res14 := Defer_Res57;
        goto Exit_Or14;
    end if;
    
Defer_Res58 :=
   Simple_Subp_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos58 := Parser.Current_Pos;

    if Defer_Pos58 /= No_Token_Index then
        Or_Pos14 := Defer_Pos58;
        Or_Res14 := Defer_Res58;
        goto Exit_Or14;
    end if;
    
Defer_Res59 :=
   Type_Decl_Or_Parse1 (Parser, Pos);
Defer_Pos59 := Parser.Current_Pos;

    if Defer_Pos59 /= No_Token_Index then
        Or_Pos14 := Defer_Pos59;
        Or_Res14 := Defer_Res59;
        goto Exit_Or14;
    end if;
    
Defer_Res60 :=
   Task_Type_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos60 := Parser.Current_Pos;

    if Defer_Pos60 /= No_Token_Index then
        Or_Pos14 := Defer_Pos60;
        Or_Res14 := Defer_Res60;
        goto Exit_Or14;
    end if;
    
Defer_Res61 :=
   Protected_Type_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos61 := Parser.Current_Pos;

    if Defer_Pos61 /= No_Token_Index then
        Or_Pos14 := Defer_Pos61;
        Or_Res14 := Defer_Res61;
        goto Exit_Or14;
    end if;
    
Defer_Res62 :=
   Subtype_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos62 := Parser.Current_Pos;

    if Defer_Pos62 /= No_Token_Index then
        Or_Pos14 := Defer_Pos62;
        Or_Res14 := Defer_Res62;
        goto Exit_Or14;
    end if;
    
Defer_Res63 :=
   Object_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos63 := Parser.Current_Pos;

    if Defer_Pos63 /= No_Token_Index then
        Or_Pos14 := Defer_Pos63;
        Or_Res14 := Defer_Res63;
        goto Exit_Or14;
    end if;
    
Defer_Res64 :=
   Package_Decl_Transform_Parse3 (Parser, Pos);
Defer_Pos64 := Parser.Current_Pos;

    if Defer_Pos64 /= No_Token_Index then
        Or_Pos14 := Defer_Pos64;
        Or_Res14 := Defer_Res64;
        goto Exit_Or14;
    end if;
    
Defer_Res65 :=
   Aspect_Clause_Or_Parse1 (Parser, Pos);
Defer_Pos65 := Parser.Current_Pos;

    if Defer_Pos65 /= No_Token_Index then
        Or_Pos14 := Defer_Pos65;
        Or_Res14 := Defer_Res65;
        goto Exit_Or14;
    end if;
    
Defer_Res66 :=
   Use_Clause_Or_Parse0 (Parser, Pos);
Defer_Pos66 := Parser.Current_Pos;

    if Defer_Pos66 /= No_Token_Index then
        Or_Pos14 := Defer_Pos66;
        Or_Res14 := Defer_Res66;
        goto Exit_Or14;
    end if;
    
Defer_Res67 :=
   Exception_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos67 := Parser.Current_Pos;

    if Defer_Pos67 /= No_Token_Index then
        Or_Pos14 := Defer_Pos67;
        Or_Res14 := Defer_Res67;
        goto Exit_Or14;
    end if;
    
Defer_Res68 :=
   Package_Renaming_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos68 := Parser.Current_Pos;

    if Defer_Pos68 /= No_Token_Index then
        Or_Pos14 := Defer_Pos68;
        Or_Res14 := Defer_Res68;
        goto Exit_Or14;
    end if;
    
Defer_Res69 :=
   Generic_Renaming_Decl_Or_Parse1 (Parser, Pos);
Defer_Pos69 := Parser.Current_Pos;

    if Defer_Pos69 /= No_Token_Index then
        Or_Pos14 := Defer_Pos69;
        Or_Res14 := Defer_Res69;
        goto Exit_Or14;
    end if;
    
Defer_Res70 :=
   Generic_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos70 := Parser.Current_Pos;

    if Defer_Pos70 /= No_Token_Index then
        Or_Pos14 := Defer_Pos70;
        Or_Res14 := Defer_Res70;
        goto Exit_Or14;
    end if;
    
Defer_Res71 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos71 := Parser.Current_Pos;

    if Defer_Pos71 /= No_Token_Index then
        Or_Pos14 := Defer_Pos71;
        Or_Res14 := Defer_Res71;
        goto Exit_Or14;
    end if;
<<Exit_Or14>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Basic_Decl_Or_Parse0_Memo,
      Or_Pos14 /= No_Token_Index,
      Or_Res14,
      Pos,
      Or_Pos14);


   Parser.Current_Pos := Or_Pos14;

   Exit_Call (Parser, Call_Depth);
   return Or_Res14;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Basic_Decl_Or_Parse0;

   


function Basic_Decls_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node_List
is
   use Bare_Ada_Node_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos5 :
            Token_Index
               := No_Token_Index;
      Tmp_List5 :
            Free_Parse_List;
      Defer_Pos72 :
            Token_Index
               := No_Token_Index;
      Defer_Res72 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Row_Pos38 :
            Token_Index
               := No_Token_Index;
      Transform_Res28 :
            Bare_Error_Decl
               := No_Bare_Ada_Node;
      Transform_Diags28 :
            Ada.Containers.Count_Type;
      Skip_Pos0 :
            Token_Index
               := No_Token_Index;
      Skip_Dummy0 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Or_Pos15 :
            Token_Index
               := No_Token_Index;
      Or_Res15 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos5 :
            Token_Index
               := No_Token_Index;
      List_Res5 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Basic_Decls_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res5 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos5 := Pos;



Lst_Cpos5 := Pos;
Tmp_List5 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos15 := No_Token_Index;
Or_Res15 := No_Bare_Ada_Node;
    
Defer_Res72 :=
   Basic_Decl_Or_Parse0 (Parser, Lst_Cpos5);
Defer_Pos72 := Parser.Current_Pos;

    if Defer_Pos72 /= No_Token_Index then
        Or_Pos15 := Defer_Pos72;
        Or_Res15 := Defer_Res72;
        goto Exit_Or15;
    end if;
    
if Get_Token (Parser.TDH.all, Lst_Cpos5).Kind
   = From_Token_Kind (Ada_Termination)
then
   Skip_Pos0 := No_Token_Index;
   goto Exit_Or16;
end if;

for Fn of Parser.Private_Part.Dont_Skip loop
   Skip_Dummy0 := Fn (Parser, Lst_Cpos5);

   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos0 := No_Token_Index;
      goto Exit_Or16;
   end if;
end loop;

Skip_Pos0 := Lst_Cpos5 + 1;

--  Start transform_code

Transform_Diags28 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos38 := Lst_Cpos5;


pragma Warnings (Off, "referenced");
<<Exit_Row38_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos38 /= No_Token_Index then

   Transform_Res28 := Allocate_Error_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res28,
      Kind => Ada_Error_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos5,
      Token_End_Index   => (if Row_Pos38 = Lst_Cpos5
                            then No_Token_Index
                            else Row_Pos38 - 1));




elsif Row_Pos38 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags28);
end if;

--  End transform_code

Transform_Res28.Token_End_Index := Lst_Cpos5;

Append (Parser.Diagnostics,
        Sloc_Range (Parser.TDH.all,
                    Get_Token (Parser.TDH.all, Lst_Cpos5)),
        To_Text ("Skipped token ")
        & Common.Text
            (Wrap_Token_Reference
               (Parser.Unit.Context,
                Parser.TDH,
                (Lst_Cpos5, No_Token_Index))));

<<Exit_Or16>>

    if Skip_Pos0 /= No_Token_Index then
        Or_Pos15 := Skip_Pos0;
        Or_Res15 := Transform_Res28;
        goto Exit_Or15;
    end if;
<<Exit_Or15>>

--  End or_code


   exit when Or_Pos15 = No_Token_Index;

   List_Pos5 := Or_Pos15;
   Lst_Cpos5 := List_Pos5;

   Tmp_List5.Nodes.Append (Or_Res15);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List5.Nodes.Length;
begin
   List_Res5 :=
      Allocate_Ada_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos5 = Pos
                    then Pos
                    else Lst_Cpos5 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res5,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res5,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List5.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res5.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List5);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Basic_Decls_List_Parse0_Memo,
      List_Pos5 /= No_Token_Index,
      List_Res5,
      Pos,
      List_Pos5);


   Parser.Current_Pos := List_Pos5;

   Exit_Call (Parser, Call_Depth);
   return List_Res5;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Basic_Decls_List_Parse0;

   


function Block_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Stmt
is
   use Bare_Composite_Stmt_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos73 :
            Token_Index
               := No_Token_Index;
      Defer_Res73 :
            Bare_Block_Stmt
               := No_Bare_Ada_Node;
      Row_Pos39 :
            Token_Index
               := No_Token_Index;
      Row_Pos40 :
            Token_Index
               := No_Token_Index;
      Defer_Pos74 :
            Token_Index
               := No_Token_Index;
      Defer_Res74 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Res29 :
            Bare_Named_Stmt_Decl
               := No_Bare_Ada_Node;
      Transform_Diags29 :
            Ada.Containers.Count_Type;
      Token_Pos63 :
            Token_Index
               := No_Token_Index;
      Token_Res63 :
            Token_Index
               := No_Token_Index;
      Defer_Pos75 :
            Token_Index
               := No_Token_Index;
      Defer_Res75 :
            Bare_Block_Stmt
               := No_Bare_Ada_Node;
      Transform_Res30 :
            Bare_Named_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags30 :
            Ada.Containers.Count_Type;
      Or_Pos16 :
            Token_Index
               := No_Token_Index;
      Or_Res16 :
            Bare_Composite_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Block_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res16 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res16;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res16;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos16 := No_Token_Index;
Or_Res16 := No_Bare_Ada_Node;
    
Defer_Res73 :=
   Iblock_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos73 := Parser.Current_Pos;

    if Defer_Pos73 /= No_Token_Index then
        Or_Pos16 := Defer_Pos73;
        Or_Res16 := Defer_Res73;
        goto Exit_Or17;
    end if;
    
--  Start transform_code

Transform_Diags30 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos39 := Pos;



--  Start transform_code

Transform_Diags29 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos40 := Row_Pos39;



Defer_Res74 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos40);
Defer_Pos74 := Parser.Current_Pos;




if Defer_Pos74 /= No_Token_Index then

   Row_Pos40 := Defer_Pos74;

else
   Row_Pos40 := No_Token_Index;
   goto Exit_Row40_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row40_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos40 /= No_Token_Index then

   Transform_Res29 := Allocate_Named_Stmt_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res29,
      Kind => Ada_Named_Stmt_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos39,
      Token_End_Index   => (if Row_Pos40 = Row_Pos39
                            then No_Token_Index
                            else Row_Pos40 - 1));

      Initialize_Fields_For_Named_Stmt_Decl
        (Self => Transform_Res29, Named_Stmt_Decl_F_Name => Defer_Res74);

         if Defer_Res74 /= null and then Is_Incomplete (Defer_Res74) then
            Transform_Res29.Last_Attempted_Child := 0;
         elsif Defer_Res74 /= null and then not Is_Ghost (Defer_Res74) then
            Transform_Res29.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos40 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags29);
end if;

--  End transform_code




if Row_Pos40 /= No_Token_Index then

   Row_Pos39 := Row_Pos40;

else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;

end if;


--  Start tok_code

Token_Res63 := Row_Pos39;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res63));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos63 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos39 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos39,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos63 := Row_Pos39 + 1;
   end if;
end;

--  End tok_code




if Token_Pos63 /= No_Token_Index then

   Row_Pos39 := Token_Pos63;

else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;

end if;


Defer_Res75 :=
   Iblock_Stmt_Or_Parse0 (Parser, Row_Pos39);
Defer_Pos75 := Parser.Current_Pos;




if Defer_Pos75 /= No_Token_Index then

   Row_Pos39 := Defer_Pos75;

else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row39_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos39 /= No_Token_Index then

   Transform_Res30 := Allocate_Named_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res30,
      Kind => Ada_Named_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos39 = Pos
                            then No_Token_Index
                            else Row_Pos39 - 1));

      Initialize_Fields_For_Named_Stmt
        (Self => Transform_Res30, Named_Stmt_F_Decl => Transform_Res29, Named_Stmt_F_Stmt => Defer_Res75);

         if Transform_Res29 /= null and then Is_Incomplete (Transform_Res29) then
            Transform_Res30.Last_Attempted_Child := 0;
         elsif Transform_Res29 /= null and then not Is_Ghost (Transform_Res29) then
            Transform_Res30.Last_Attempted_Child := -1;
         end if;
         if Defer_Res75 /= null and then Is_Incomplete (Defer_Res75) then
            Transform_Res30.Last_Attempted_Child := 0;
         elsif Defer_Res75 /= null and then not Is_Ghost (Defer_Res75) then
            Transform_Res30.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos39 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags30);
end if;

--  End transform_code

    if Row_Pos39 /= No_Token_Index then
        Or_Pos16 := Row_Pos39;
        Or_Res16 := Transform_Res30;
        goto Exit_Or17;
    end if;
<<Exit_Or17>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Block_Stmt_Or_Parse0_Memo,
      Or_Pos16 /= No_Token_Index,
      Or_Res16,
      Pos,
      Or_Pos16);


   Parser.Current_Pos := Or_Pos16;

   Exit_Call (Parser, Call_Depth);
   return Or_Res16;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Block_Stmt_Or_Parse0;

   


function Body_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Body_Node
is
   use Bare_Body_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos76 :
            Token_Index
               := No_Token_Index;
      Defer_Res76 :
            Bare_Subp_Body
               := No_Bare_Ada_Node;
      Defer_Pos77 :
            Token_Index
               := No_Token_Index;
      Defer_Res77 :
            Bare_Package_Body
               := No_Bare_Ada_Node;
      Defer_Pos78 :
            Token_Index
               := No_Token_Index;
      Defer_Res78 :
            Bare_Task_Body
               := No_Bare_Ada_Node;
      Defer_Pos79 :
            Token_Index
               := No_Token_Index;
      Defer_Res79 :
            Bare_Protected_Body
               := No_Bare_Ada_Node;
      Defer_Pos80 :
            Token_Index
               := No_Token_Index;
      Defer_Res80 :
            Bare_Entry_Body
               := No_Bare_Ada_Node;
      Or_Pos17 :
            Token_Index
               := No_Token_Index;
      Or_Res17 :
            Bare_Body_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Body_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res17 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res17;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos17 := No_Token_Index;
Or_Res17 := No_Bare_Ada_Node;
    
Defer_Res76 :=
   Subp_Body_Transform_Parse1 (Parser, Pos);
Defer_Pos76 := Parser.Current_Pos;

    if Defer_Pos76 /= No_Token_Index then
        Or_Pos17 := Defer_Pos76;
        Or_Res17 := Defer_Res76;
        goto Exit_Or18;
    end if;
    
Defer_Res77 :=
   Package_Body_Transform_Parse1 (Parser, Pos);
Defer_Pos77 := Parser.Current_Pos;

    if Defer_Pos77 /= No_Token_Index then
        Or_Pos17 := Defer_Pos77;
        Or_Res17 := Defer_Res77;
        goto Exit_Or18;
    end if;
    
Defer_Res78 :=
   Task_Body_Transform_Parse1 (Parser, Pos);
Defer_Pos78 := Parser.Current_Pos;

    if Defer_Pos78 /= No_Token_Index then
        Or_Pos17 := Defer_Pos78;
        Or_Res17 := Defer_Res78;
        goto Exit_Or18;
    end if;
    
Defer_Res79 :=
   Protected_Body_Transform_Parse1 (Parser, Pos);
Defer_Pos79 := Parser.Current_Pos;

    if Defer_Pos79 /= No_Token_Index then
        Or_Pos17 := Defer_Pos79;
        Or_Res17 := Defer_Res79;
        goto Exit_Or18;
    end if;
    
Defer_Res80 :=
   Entry_Body_Transform_Parse3 (Parser, Pos);
Defer_Pos80 := Parser.Current_Pos;

    if Defer_Pos80 /= No_Token_Index then
        Or_Pos17 := Defer_Pos80;
        Or_Res17 := Defer_Res80;
        goto Exit_Or18;
    end if;
<<Exit_Or18>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Body_Or_Parse0_Memo,
      Or_Pos17 /= No_Token_Index,
      Or_Res17,
      Pos,
      Or_Pos17);


   Parser.Current_Pos := Or_Pos17;

   Exit_Call (Parser, Call_Depth);
   return Or_Res17;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Body_Or_Parse0;

   


function Body_Stub_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Body_Stub
is
   use Bare_Body_Stub_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos81 :
            Token_Index
               := No_Token_Index;
      Defer_Res81 :
            Bare_Subp_Body_Stub
               := No_Bare_Ada_Node;
      Defer_Pos82 :
            Token_Index
               := No_Token_Index;
      Defer_Res82 :
            Bare_Package_Body_Stub
               := No_Bare_Ada_Node;
      Defer_Pos83 :
            Token_Index
               := No_Token_Index;
      Defer_Res83 :
            Bare_Task_Body_Stub
               := No_Bare_Ada_Node;
      Defer_Pos84 :
            Token_Index
               := No_Token_Index;
      Defer_Res84 :
            Bare_Protected_Body_Stub
               := No_Bare_Ada_Node;
      Or_Pos18 :
            Token_Index
               := No_Token_Index;
      Or_Res18 :
            Bare_Body_Stub
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Body_Stub_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res18 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res18;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res18;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos18 := No_Token_Index;
Or_Res18 := No_Bare_Ada_Node;
    
Defer_Res81 :=
   Subp_Body_Stub_Transform_Parse0 (Parser, Pos);
Defer_Pos81 := Parser.Current_Pos;

    if Defer_Pos81 /= No_Token_Index then
        Or_Pos18 := Defer_Pos81;
        Or_Res18 := Defer_Res81;
        goto Exit_Or19;
    end if;
    
Defer_Res82 :=
   Package_Body_Stub_Transform_Parse0 (Parser, Pos);
Defer_Pos82 := Parser.Current_Pos;

    if Defer_Pos82 /= No_Token_Index then
        Or_Pos18 := Defer_Pos82;
        Or_Res18 := Defer_Res82;
        goto Exit_Or19;
    end if;
    
Defer_Res83 :=
   Task_Body_Stub_Transform_Parse0 (Parser, Pos);
Defer_Pos83 := Parser.Current_Pos;

    if Defer_Pos83 /= No_Token_Index then
        Or_Pos18 := Defer_Pos83;
        Or_Res18 := Defer_Res83;
        goto Exit_Or19;
    end if;
    
Defer_Res84 :=
   Protected_Body_Stub_Transform_Parse0 (Parser, Pos);
Defer_Pos84 := Parser.Current_Pos;

    if Defer_Pos84 /= No_Token_Index then
        Or_Pos18 := Defer_Pos84;
        Or_Res18 := Defer_Res84;
        goto Exit_Or19;
    end if;
<<Exit_Or19>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Body_Stub_Or_Parse0_Memo,
      Or_Pos18 /= No_Token_Index,
      Or_Res18,
      Pos,
      Or_Pos18);


   Parser.Current_Pos := Or_Pos18;

   Exit_Call (Parser, Call_Depth);
   return Or_Res18;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Body_Stub_Or_Parse0;

   


function Boolean_Op_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Op
is
   use Bare_Op_Memos;

   Call_Depth : aliased Natural;

      Row_Pos41 :
            Token_Index
               := No_Token_Index;
      Token_Pos64 :
            Token_Index
               := No_Token_Index;
      Token_Res64 :
            Token_Index
               := No_Token_Index;
      Transform_Res31 :
            Bare_Op_Xor
               := No_Bare_Ada_Node;
      Transform_Diags31 :
            Ada.Containers.Count_Type;
      Row_Pos42 :
            Token_Index
               := No_Token_Index;
      Token_Pos65 :
            Token_Index
               := No_Token_Index;
      Token_Res65 :
            Token_Index
               := No_Token_Index;
      Token_Pos66 :
            Token_Index
               := No_Token_Index;
      Token_Res66 :
            Token_Index
               := No_Token_Index;
      Transform_Res32 :
            Bare_Op_And_Then
               := No_Bare_Ada_Node;
      Transform_Diags32 :
            Ada.Containers.Count_Type;
      Row_Pos43 :
            Token_Index
               := No_Token_Index;
      Token_Pos67 :
            Token_Index
               := No_Token_Index;
      Token_Res67 :
            Token_Index
               := No_Token_Index;
      Transform_Res33 :
            Bare_Op_And
               := No_Bare_Ada_Node;
      Transform_Diags33 :
            Ada.Containers.Count_Type;
      Row_Pos44 :
            Token_Index
               := No_Token_Index;
      Token_Pos68 :
            Token_Index
               := No_Token_Index;
      Token_Res68 :
            Token_Index
               := No_Token_Index;
      Token_Pos69 :
            Token_Index
               := No_Token_Index;
      Token_Res69 :
            Token_Index
               := No_Token_Index;
      Transform_Res34 :
            Bare_Op_Or_Else
               := No_Bare_Ada_Node;
      Transform_Diags34 :
            Ada.Containers.Count_Type;
      Row_Pos45 :
            Token_Index
               := No_Token_Index;
      Token_Pos70 :
            Token_Index
               := No_Token_Index;
      Token_Res70 :
            Token_Index
               := No_Token_Index;
      Transform_Res35 :
            Bare_Op_Or
               := No_Bare_Ada_Node;
      Transform_Diags35 :
            Ada.Containers.Count_Type;
      Or_Pos19 :
            Token_Index
               := No_Token_Index;
      Or_Res19 :
            Bare_Op
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Boolean_Op_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res19 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res19;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos19 := No_Token_Index;
Or_Res19 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags31 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos41 := Pos;



--  Start tok_code

Token_Res64 := Row_Pos41;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res64));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Xor)
   then
       Token_Pos64 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos41 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos41,
             Expected_Token_Id => Ada_Xor,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos64 := Row_Pos41 + 1;
   end if;
end;

--  End tok_code




if Token_Pos64 /= No_Token_Index then

   Row_Pos41 := Token_Pos64;

else
   Row_Pos41 := No_Token_Index;
   goto Exit_Row41_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row41_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos41 /= No_Token_Index then

   Transform_Res31 := Allocate_Op_Xor (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res31,
      Kind => Ada_Op_Xor,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos41 = Pos
                            then No_Token_Index
                            else Row_Pos41 - 1));

      Initialize_Fields_For_Op_Xor
        (Self => Transform_Res31);



elsif Row_Pos41 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags31);
end if;

--  End transform_code

    if Row_Pos41 /= No_Token_Index then
        Or_Pos19 := Row_Pos41;
        Or_Res19 := Transform_Res31;
        goto Exit_Or20;
    end if;
    
--  Start transform_code

Transform_Diags32 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos42 := Pos;



--  Start tok_code

Token_Res65 := Row_Pos42;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res65));
begin
   if
      T.Kind /= From_Token_Kind (Ada_And)
   then
       Token_Pos65 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos42 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos42,
             Expected_Token_Id => Ada_And,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos65 := Row_Pos42 + 1;
   end if;
end;

--  End tok_code




if Token_Pos65 /= No_Token_Index then

   Row_Pos42 := Token_Pos65;

else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;

end if;


--  Start tok_code

Token_Res66 := Row_Pos42;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res66));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos66 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos42 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos42,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos66 := Row_Pos42 + 1;
   end if;
end;

--  End tok_code




if Token_Pos66 /= No_Token_Index then

   Row_Pos42 := Token_Pos66;

else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row42_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos42 /= No_Token_Index then

   Transform_Res32 := Allocate_Op_And_Then (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res32,
      Kind => Ada_Op_And_Then,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos42 = Pos
                            then No_Token_Index
                            else Row_Pos42 - 1));

      Initialize_Fields_For_Op_And_Then
        (Self => Transform_Res32);



elsif Row_Pos42 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags32);
end if;

--  End transform_code

    if Row_Pos42 /= No_Token_Index then
        Or_Pos19 := Row_Pos42;
        Or_Res19 := Transform_Res32;
        goto Exit_Or20;
    end if;
    
--  Start transform_code

Transform_Diags33 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos43 := Pos;



--  Start tok_code

Token_Res67 := Row_Pos43;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res67));
begin
   if
      T.Kind /= From_Token_Kind (Ada_And)
   then
       Token_Pos67 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos43 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos43,
             Expected_Token_Id => Ada_And,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos67 := Row_Pos43 + 1;
   end if;
end;

--  End tok_code




if Token_Pos67 /= No_Token_Index then

   Row_Pos43 := Token_Pos67;

else
   Row_Pos43 := No_Token_Index;
   goto Exit_Row43_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row43_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos43 /= No_Token_Index then

   Transform_Res33 := Allocate_Op_And (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res33,
      Kind => Ada_Op_And,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos43 = Pos
                            then No_Token_Index
                            else Row_Pos43 - 1));

      Initialize_Fields_For_Op_And
        (Self => Transform_Res33);



elsif Row_Pos43 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags33);
end if;

--  End transform_code

    if Row_Pos43 /= No_Token_Index then
        Or_Pos19 := Row_Pos43;
        Or_Res19 := Transform_Res33;
        goto Exit_Or20;
    end if;
    
--  Start transform_code

Transform_Diags34 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos44 := Pos;



--  Start tok_code

Token_Res68 := Row_Pos44;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res68));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Or)
   then
       Token_Pos68 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos44 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos44,
             Expected_Token_Id => Ada_Or,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos68 := Row_Pos44 + 1;
   end if;
end;

--  End tok_code




if Token_Pos68 /= No_Token_Index then

   Row_Pos44 := Token_Pos68;

else
   Row_Pos44 := No_Token_Index;
   goto Exit_Row44_0;

end if;


--  Start tok_code

Token_Res69 := Row_Pos44;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res69));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos69 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos44 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos44,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos69 := Row_Pos44 + 1;
   end if;
end;

--  End tok_code




if Token_Pos69 /= No_Token_Index then

   Row_Pos44 := Token_Pos69;

else
   Row_Pos44 := No_Token_Index;
   goto Exit_Row44_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row44_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos44 /= No_Token_Index then

   Transform_Res34 := Allocate_Op_Or_Else (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res34,
      Kind => Ada_Op_Or_Else,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos44 = Pos
                            then No_Token_Index
                            else Row_Pos44 - 1));

      Initialize_Fields_For_Op_Or_Else
        (Self => Transform_Res34);



elsif Row_Pos44 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags34);
end if;

--  End transform_code

    if Row_Pos44 /= No_Token_Index then
        Or_Pos19 := Row_Pos44;
        Or_Res19 := Transform_Res34;
        goto Exit_Or20;
    end if;
    
--  Start transform_code

Transform_Diags35 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos45 := Pos;



--  Start tok_code

Token_Res70 := Row_Pos45;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res70));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Or)
   then
       Token_Pos70 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos45 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos45,
             Expected_Token_Id => Ada_Or,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos70 := Row_Pos45 + 1;
   end if;
end;

--  End tok_code




if Token_Pos70 /= No_Token_Index then

   Row_Pos45 := Token_Pos70;

else
   Row_Pos45 := No_Token_Index;
   goto Exit_Row45_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row45_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos45 /= No_Token_Index then

   Transform_Res35 := Allocate_Op_Or (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res35,
      Kind => Ada_Op_Or,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos45 = Pos
                            then No_Token_Index
                            else Row_Pos45 - 1));

      Initialize_Fields_For_Op_Or
        (Self => Transform_Res35);



elsif Row_Pos45 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags35);
end if;

--  End transform_code

    if Row_Pos45 /= No_Token_Index then
        Or_Pos19 := Row_Pos45;
        Or_Res19 := Transform_Res35;
        goto Exit_Or20;
    end if;
<<Exit_Or20>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Boolean_Op_Or_Parse0_Memo,
      Or_Pos19 /= No_Token_Index,
      Or_Res19,
      Pos,
      Or_Pos19);


   Parser.Current_Pos := Or_Pos19;

   Exit_Call (Parser, Call_Depth);
   return Or_Res19;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Boolean_Op_Or_Parse0;

   


function Box_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Box_Expr
is
   use Bare_Box_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos46 :
            Token_Index
               := No_Token_Index;
      Token_Pos71 :
            Token_Index
               := No_Token_Index;
      Token_Res71 :
            Token_Index
               := No_Token_Index;
      Transform_Res36 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Transform_Diags36 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Box_Expr_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res36 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res36;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res36;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags36 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos46 := Pos;



--  Start tok_code

Token_Res71 := Row_Pos46;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res71));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Diamond)
   then
       Token_Pos71 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos46 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos46,
             Expected_Token_Id => Ada_Diamond,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos71 := Row_Pos46 + 1;
   end if;
end;

--  End tok_code




if Token_Pos71 /= No_Token_Index then

   Row_Pos46 := Token_Pos71;

else
   Row_Pos46 := No_Token_Index;
   goto Exit_Row46_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row46_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos46 /= No_Token_Index then

   Transform_Res36 := Allocate_Box_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res36,
      Kind => Ada_Box_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos46 = Pos
                            then No_Token_Index
                            else Row_Pos46 - 1));

      Initialize_Fields_For_Box_Expr
        (Self => Transform_Res36);



elsif Row_Pos46 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags36);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Box_Expr_Transform_Parse0_Memo,
      Row_Pos46 /= No_Token_Index,
      Transform_Res36,
      Pos,
      Row_Pos46);


   Parser.Current_Pos := Row_Pos46;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res36;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Box_Expr_Transform_Parse0;

   


function Bracket_Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate
is
   use Bare_Base_Aggregate_Memos;

   Call_Depth : aliased Natural;

      Nobt5 :
            Boolean
               := False;
      Nobt6 :
            Boolean
               := False;
      Row_Pos47 :
            Token_Index
               := No_Token_Index;
      Token_Pos72 :
            Token_Index
               := No_Token_Index;
      Token_Res72 :
            Token_Index
               := No_Token_Index;
      Defer_Pos85 :
            Token_Index
               := No_Token_Index;
      Defer_Res85 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos73 :
            Token_Index
               := No_Token_Index;
      Token_Res73 :
            Token_Index
               := No_Token_Index;
      Token_Pos74 :
            Token_Index
               := No_Token_Index;
      Token_Res74 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos6 :
            Token_Index
               := No_Token_Index;
      Tmp_List6 :
            Free_Parse_List;
      Defer_Pos86 :
            Token_Index
               := No_Token_Index;
      Defer_Res86 :
            Bare_Basic_Assoc
               := No_Bare_Ada_Node;
      Token_Pos75 :
            Token_Index
               := No_Token_Index;
      Token_Res75 :
            Token_Index
               := No_Token_Index;
      List_Pos6 :
            Token_Index
               := No_Token_Index;
      List_Res6 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos76 :
            Token_Index
               := No_Token_Index;
      Token_Res76 :
            Token_Index
               := No_Token_Index;
      Row_Progress5 :
            Integer
               := 0;
      Transform_Res37 :
            Bare_Bracket_Delta_Aggregate
               := No_Bare_Ada_Node;
      Transform_Has_Failed5 :
            Boolean
               := False;
      Transform_Diags37 :
            Ada.Containers.Count_Type;
      Row_Pos48 :
            Token_Index
               := No_Token_Index;
      Token_Pos77 :
            Token_Index
               := No_Token_Index;
      Token_Res77 :
            Token_Index
               := No_Token_Index;
      Row_Pos49 :
            Token_Index
               := No_Token_Index;
      Defer_Pos87 :
            Token_Index
               := No_Token_Index;
      Defer_Res87 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos78 :
            Token_Index
               := No_Token_Index;
      Token_Res78 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos7 :
            Token_Index
               := No_Token_Index;
      Tmp_List7 :
            Free_Parse_List;
      Defer_Pos88 :
            Token_Index
               := No_Token_Index;
      Defer_Res88 :
            Bare_Basic_Assoc
               := No_Bare_Ada_Node;
      Token_Pos79 :
            Token_Index
               := No_Token_Index;
      Token_Res79 :
            Token_Index
               := No_Token_Index;
      List_Pos7 :
            Token_Index
               := No_Token_Index;
      List_Res7 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos80 :
            Token_Index
               := No_Token_Index;
      Token_Res80 :
            Token_Index
               := No_Token_Index;
      Row_Progress6 :
            Integer
               := 0;
      Transform_Res38 :
            Bare_Bracket_Aggregate
               := No_Bare_Ada_Node;
      Transform_Has_Failed6 :
            Boolean
               := False;
      Transform_Diags38 :
            Ada.Containers.Count_Type;
      Or_Pos20 :
            Token_Index
               := No_Token_Index;
      Or_Res20 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Bracket_Aggregate_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res20 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res20;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res20;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos20 := No_Token_Index;
Or_Res20 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags37 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos47 := Pos;



--  Start tok_code

Token_Res72 := Row_Pos47;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res72));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Brack_Open)
   then
       Token_Pos72 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos47 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos47,
             Expected_Token_Id => Ada_Brack_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos72 := Row_Pos47 + 1;
   end if;
end;

--  End tok_code



Row_Progress5 := 1;

if Token_Pos72 /= No_Token_Index then

   Row_Pos47 := Token_Pos72;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;


Defer_Res85 :=
   Expr_Or_Parse0 (Parser, Row_Pos47);
Defer_Pos85 := Parser.Current_Pos;



Row_Progress5 := 2;

if Defer_Pos85 /= No_Token_Index then

   Row_Pos47 := Defer_Pos85;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;


--  Start tok_code

Token_Res73 := Row_Pos47;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res73));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos73 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos47 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos47,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos73 := Row_Pos47 + 1;
   end if;
end;

--  End tok_code



Row_Progress5 := 3;

if Token_Pos73 /= No_Token_Index then

   Row_Pos47 := Token_Pos73;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;


--  Start tok_code

Token_Res74 := Row_Pos47;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res74));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Delta)
   then
       Token_Pos74 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos47 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos47,
             Expected_Token_Id => Ada_Delta,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos74 := Row_Pos47 + 1;
   end if;
end;

--  End tok_code



Row_Progress5 := 4;

if Token_Pos74 /= No_Token_Index then

   Row_Pos47 := Token_Pos74;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;

Nobt5 := True;

   Nobt5 := Nobt5;

Row_Progress5 := 5;

if Row_Pos47 /= No_Token_Index then

   Row_Pos47 := Row_Pos47;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;


--  Start list_code

    List_Pos6 := No_Token_Index;



Lst_Cpos6 := Row_Pos47;
Tmp_List6 := Get_Parse_List (Parser);

loop
   
Defer_Res86 :=
   Aggregate_Assoc_Or_Parse1 (Parser, Lst_Cpos6);
Defer_Pos86 := Parser.Current_Pos;


   exit when Defer_Pos86 = No_Token_Index;

   List_Pos6 := Defer_Pos86;
   Lst_Cpos6 := List_Pos6;

   Tmp_List6.Nodes.Append (Defer_Res86);

      
--  Start tok_code

Token_Res75 := Lst_Cpos6;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res75));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos75 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos6 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos6,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos75 := Lst_Cpos6 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos75 /= No_Token_Index then
          Lst_Cpos6 := Token_Pos75;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List6.Nodes.Length;
begin
   List_Res6 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos47;
      Token_End := (if Lst_Cpos6 = Row_Pos47
                    then Row_Pos47
                    else Lst_Cpos6 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos47, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res6,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res6,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List6.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res6.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List6);

--  End list_code



Row_Progress5 := 6;

if List_Pos6 /= No_Token_Index then

   Row_Pos47 := List_Pos6;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;


--  Start tok_code

Token_Res76 := Row_Pos47;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res76));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Brack_Close)
   then
       Token_Pos76 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos47 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos47,
             Expected_Token_Id => Ada_Brack_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos76 := Row_Pos47 + 1;
   end if;
end;

--  End tok_code



Row_Progress5 := 7;

if Token_Pos76 /= No_Token_Index then

   Row_Pos47 := Token_Pos76;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row47_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos47 = No_Token_Index and then Nobt5 then

   Row_Pos47 := Parser.Last_Fail.Pos;

   Transform_Has_Failed5 := True;
end if;

if Row_Pos47 /= No_Token_Index then

   Transform_Res37 := Allocate_Bracket_Delta_Aggregate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res37,
      Kind => Ada_Bracket_Delta_Aggregate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos47 = Pos
                            then No_Token_Index
                            else Row_Pos47 - 1));

      Initialize_Fields_For_Bracket_Delta_Aggregate
        (Self => Transform_Res37, Base_Aggregate_F_Ancestor_Expr => Defer_Res85, Base_Aggregate_F_Assocs => List_Res6);

         if Defer_Res85 /= null and then Is_Incomplete (Defer_Res85) then
            Transform_Res37.Last_Attempted_Child := 0;
         elsif Defer_Res85 /= null and then not Is_Ghost (Defer_Res85) then
            Transform_Res37.Last_Attempted_Child := -1;
         end if;
         if List_Res6 /= null and then Is_Incomplete (List_Res6) then
            Transform_Res37.Last_Attempted_Child := 0;
         elsif List_Res6 /= null and then not Is_Ghost (List_Res6) then
            Transform_Res37.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed5 then
      Transform_Res37.Last_Attempted_Child :=
         Row_Progress5;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <bracket_aggregate>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos47 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags37);
end if;

--  End transform_code

    if Row_Pos47 /= No_Token_Index then
        Or_Pos20 := Row_Pos47;
        Or_Res20 := Transform_Res37;
        goto Exit_Or21;
    end if;
    
--  Start transform_code

Transform_Diags38 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos48 := Pos;



--  Start tok_code

Token_Res77 := Row_Pos48;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res77));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Brack_Open)
   then
       Token_Pos77 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos48 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos48,
             Expected_Token_Id => Ada_Brack_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos77 := Row_Pos48 + 1;
   end if;
end;

--  End tok_code



Row_Progress6 := 1;

if Token_Pos77 /= No_Token_Index then

   Row_Pos48 := Token_Pos77;

else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;

end if;

Nobt6 := True;

   Nobt6 := Nobt6;

Row_Progress6 := 2;

if Row_Pos48 /= No_Token_Index then

   Row_Pos48 := Row_Pos48;

else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos49 := Row_Pos48;



Defer_Res87 :=
   Expr_Or_Parse0 (Parser, Row_Pos49);
Defer_Pos87 := Parser.Current_Pos;




if Defer_Pos87 /= No_Token_Index then

   Row_Pos49 := Defer_Pos87;

else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;

end if;


--  Start tok_code

Token_Res78 := Row_Pos49;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res78));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos78 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos49 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos49,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos78 := Row_Pos49 + 1;
   end if;
end;

--  End tok_code




if Token_Pos78 /= No_Token_Index then

   Row_Pos49 := Token_Pos78;

else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row49_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos49 = No_Token_Index then

         
   Defer_Res87 := No_Bare_Ada_Node;



       
   Row_Pos49 := Row_Pos48;



end if;

--  End opt_code



Row_Progress6 := 3;

if Row_Pos49 /= No_Token_Index then

   Row_Pos48 := Row_Pos49;

else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;

end if;


--  Start list_code

    List_Pos7 := Row_Pos48;



Lst_Cpos7 := Row_Pos48;
Tmp_List7 := Get_Parse_List (Parser);

loop
   
Defer_Res88 :=
   Aggregate_Assoc_Or_Parse1 (Parser, Lst_Cpos7);
Defer_Pos88 := Parser.Current_Pos;


   exit when Defer_Pos88 = No_Token_Index;

   List_Pos7 := Defer_Pos88;
   Lst_Cpos7 := List_Pos7;

   Tmp_List7.Nodes.Append (Defer_Res88);

      
--  Start tok_code

Token_Res79 := Lst_Cpos7;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res79));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos79 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos7 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos7,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos79 := Lst_Cpos7 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos79 /= No_Token_Index then
          Lst_Cpos7 := Token_Pos79;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List7.Nodes.Length;
begin
   List_Res7 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos48;
      Token_End := (if Lst_Cpos7 = Row_Pos48
                    then Row_Pos48
                    else Lst_Cpos7 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos48, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res7,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res7,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List7.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res7.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List7);

--  End list_code



Row_Progress6 := 4;

if List_Pos7 /= No_Token_Index then

   Row_Pos48 := List_Pos7;

else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;

end if;


--  Start tok_code

Token_Res80 := Row_Pos48;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res80));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Brack_Close)
   then
       Token_Pos80 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos48 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos48,
             Expected_Token_Id => Ada_Brack_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos80 := Row_Pos48 + 1;
   end if;
end;

--  End tok_code



Row_Progress6 := 5;

if Token_Pos80 /= No_Token_Index then

   Row_Pos48 := Token_Pos80;

else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row48_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos48 = No_Token_Index and then Nobt6 then

   Row_Pos48 := Parser.Last_Fail.Pos;

   Transform_Has_Failed6 := True;
end if;

if Row_Pos48 /= No_Token_Index then

   Transform_Res38 := Allocate_Bracket_Aggregate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res38,
      Kind => Ada_Bracket_Aggregate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos48 = Pos
                            then No_Token_Index
                            else Row_Pos48 - 1));

      Initialize_Fields_For_Bracket_Aggregate
        (Self => Transform_Res38, Base_Aggregate_F_Ancestor_Expr => Defer_Res87, Base_Aggregate_F_Assocs => List_Res7);

         if Defer_Res87 /= null and then Is_Incomplete (Defer_Res87) then
            Transform_Res38.Last_Attempted_Child := 0;
         elsif Defer_Res87 /= null and then not Is_Ghost (Defer_Res87) then
            Transform_Res38.Last_Attempted_Child := -1;
         end if;
         if List_Res7 /= null and then Is_Incomplete (List_Res7) then
            Transform_Res38.Last_Attempted_Child := 0;
         elsif List_Res7 /= null and then not Is_Ghost (List_Res7) then
            Transform_Res38.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed6 then
      Transform_Res38.Last_Attempted_Child :=
         Row_Progress6;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <bracket_aggregate>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos48 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags38);
end if;

--  End transform_code

    if Row_Pos48 /= No_Token_Index then
        Or_Pos20 := Row_Pos48;
        Or_Res20 := Transform_Res38;
        goto Exit_Or21;
    end if;
<<Exit_Or21>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Bracket_Aggregate_Or_Parse0_Memo,
      Or_Pos20 /= No_Token_Index,
      Or_Res20,
      Pos,
      Or_Pos20);


   Parser.Current_Pos := Or_Pos20;

   Exit_Call (Parser, Call_Depth);
   return Or_Res20;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Bracket_Aggregate_Or_Parse0;

   


function Call_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Call_Stmt
is
   use Bare_Call_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos50 :
            Token_Index
               := No_Token_Index;
      Defer_Pos89 :
            Token_Index
               := No_Token_Index;
      Defer_Res89 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos81 :
            Token_Index
               := No_Token_Index;
      Token_Res81 :
            Token_Index
               := No_Token_Index;
      Transform_Res39 :
            Bare_Call_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags39 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Call_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res39 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res39;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res39;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags39 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos50 := Pos;



Defer_Res89 :=
   Name_Or_Parse2 (Parser, Row_Pos50);
Defer_Pos89 := Parser.Current_Pos;




if Defer_Pos89 /= No_Token_Index then

   Row_Pos50 := Defer_Pos89;

else
   Row_Pos50 := No_Token_Index;
   goto Exit_Row50_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res81 := Row_Pos50;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res81));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos81 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos50 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos50,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos81 := Row_Pos50 + 1;
   end if;
end;

--  End tok_code


if Token_Pos81 = No_Token_Index then

         
   Token_Res81 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos50)),
                To_Text ("Missing ';'"));

       
   Token_Pos81 := Row_Pos50;



end if;

--  End opt_code




if Token_Pos81 /= No_Token_Index then

   Row_Pos50 := Token_Pos81;

else
   Row_Pos50 := No_Token_Index;
   goto Exit_Row50_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row50_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos50 /= No_Token_Index then

   Transform_Res39 := Allocate_Call_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res39,
      Kind => Ada_Call_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos50 = Pos
                            then No_Token_Index
                            else Row_Pos50 - 1));

      Initialize_Fields_For_Call_Stmt
        (Self => Transform_Res39, Call_Stmt_F_Call => Defer_Res89);

         if Defer_Res89 /= null and then Is_Incomplete (Defer_Res89) then
            Transform_Res39.Last_Attempted_Child := 0;
         elsif Defer_Res89 /= null and then not Is_Ghost (Defer_Res89) then
            Transform_Res39.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos50 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags39);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Call_Stmt_Transform_Parse0_Memo,
      Row_Pos50 /= No_Token_Index,
      Transform_Res39,
      Pos,
      Row_Pos50);


   Parser.Current_Pos := Row_Pos50;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res39;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Call_Stmt_Transform_Parse0;

   


function Call_Suffix_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos90 :
            Token_Index
               := No_Token_Index;
      Defer_Res90 :
            Bare_Discrete_Subtype_Indication
               := No_Bare_Ada_Node;
      Defer_Pos91 :
            Token_Index
               := No_Token_Index;
      Defer_Res91 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Lst_Cpos8 :
            Token_Index
               := No_Token_Index;
      Tmp_List8 :
            Free_Parse_List;
      Defer_Pos92 :
            Token_Index
               := No_Token_Index;
      Defer_Res92 :
            Bare_Param_Assoc
               := No_Bare_Ada_Node;
      Token_Pos82 :
            Token_Index
               := No_Token_Index;
      Token_Res82 :
            Token_Index
               := No_Token_Index;
      List_Pos8 :
            Token_Index
               := No_Token_Index;
      List_Res8 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Or_Pos21 :
            Token_Index
               := No_Token_Index;
      Or_Res21 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Call_Suffix_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res21 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res21;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res21;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos21 := No_Token_Index;
Or_Res21 := No_Bare_Ada_Node;
    
Defer_Res90 :=
   Discrete_Subtype_Indication_Transform_Parse0 (Parser, Pos);
Defer_Pos90 := Parser.Current_Pos;

    if Defer_Pos90 /= No_Token_Index then
        Or_Pos21 := Defer_Pos90;
        Or_Res21 := Defer_Res90;
        goto Exit_Or22;
    end if;
    
Defer_Res91 :=
   Discrete_Range_Or_Parse0 (Parser, Pos);
Defer_Pos91 := Parser.Current_Pos;

    if Defer_Pos91 /= No_Token_Index then
        Or_Pos21 := Defer_Pos91;
        Or_Res21 := Defer_Res91;
        goto Exit_Or22;
    end if;
    
--  Start list_code

    List_Pos8 := No_Token_Index;



Lst_Cpos8 := Pos;
Tmp_List8 := Get_Parse_List (Parser);

loop
   
Defer_Res92 :=
   Param_Assoc_Transform_Parse0 (Parser, Lst_Cpos8);
Defer_Pos92 := Parser.Current_Pos;


   exit when Defer_Pos92 = No_Token_Index;

   List_Pos8 := Defer_Pos92;
   Lst_Cpos8 := List_Pos8;

   Tmp_List8.Nodes.Append (Defer_Res92);

      
--  Start tok_code

Token_Res82 := Lst_Cpos8;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res82));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos82 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos8 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos8,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos82 := Lst_Cpos8 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos82 /= No_Token_Index then
          Lst_Cpos8 := Token_Pos82;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List8.Nodes.Length;
begin
   List_Res8 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos8 = Pos
                    then Pos
                    else Lst_Cpos8 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res8,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res8,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List8.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res8.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List8);

--  End list_code

    if List_Pos8 /= No_Token_Index then
        Or_Pos21 := List_Pos8;
        Or_Res21 := List_Res8;
        goto Exit_Or22;
    end if;
<<Exit_Or22>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Call_Suffix_Or_Parse0_Memo,
      Or_Pos21 /= No_Token_Index,
      Or_Res21,
      Pos,
      Or_Pos21);


   Parser.Current_Pos := Or_Pos21;

   Exit_Call (Parser, Call_Depth);
   return Or_Res21;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Call_Suffix_Or_Parse0;

   


function Case_Alt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Stmt_Alternative
is
   use Bare_Case_Stmt_Alternative_Memos;

   Call_Depth : aliased Natural;

      Nobt7 :
            Boolean
               := False;
      Row_Pos51 :
            Token_Index
               := No_Token_Index;
      Token_Pos83 :
            Token_Index
               := No_Token_Index;
      Token_Res83 :
            Token_Index
               := No_Token_Index;
      Defer_Pos93 :
            Token_Index
               := No_Token_Index;
      Defer_Res93 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;
      Token_Pos84 :
            Token_Index
               := No_Token_Index;
      Token_Res84 :
            Token_Index
               := No_Token_Index;
      Defer_Pos94 :
            Token_Index
               := No_Token_Index;
      Defer_Res94 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Row_Progress7 :
            Integer
               := 0;
      Transform_Res40 :
            Bare_Case_Stmt_Alternative
               := No_Bare_Ada_Node;
      Transform_Has_Failed7 :
            Boolean
               := False;
      Transform_Diags40 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Case_Alt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res40 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res40;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res40;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags40 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos51 := Pos;



--  Start tok_code

Token_Res83 := Row_Pos51;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res83));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos83 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos51 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos51,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos83 := Row_Pos51 + 1;
   end if;
end;

--  End tok_code



Row_Progress7 := 1;

if Token_Pos83 /= No_Token_Index then

   Row_Pos51 := Token_Pos83;

else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;

end if;

Nobt7 := True;

   Nobt7 := Nobt7;

Row_Progress7 := 2;

if Row_Pos51 /= No_Token_Index then

   Row_Pos51 := Row_Pos51;

else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;

end if;


Defer_Res93 :=
   Choice_List_List_Parse0 (Parser, Row_Pos51);
Defer_Pos93 := Parser.Current_Pos;



Row_Progress7 := 3;

if Defer_Pos93 /= No_Token_Index then

   Row_Pos51 := Defer_Pos93;

else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;

end if;


--  Start tok_code

Token_Res84 := Row_Pos51;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res84));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos84 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos51 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos51,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos84 := Row_Pos51 + 1;
   end if;
end;

--  End tok_code



Row_Progress7 := 4;

if Token_Pos84 /= No_Token_Index then

   Row_Pos51 := Token_Pos84;

else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Case_Alt0_Extract_Parse0'Access);
        
Defer_Res94 :=
   Stmts_List_Parse0 (Parser, Row_Pos51);
Defer_Pos94 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        


Row_Progress7 := 5;

if Defer_Pos94 /= No_Token_Index then

   Row_Pos51 := Defer_Pos94;

else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row51_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos51 = No_Token_Index and then Nobt7 then

   Row_Pos51 := Parser.Last_Fail.Pos;

   Transform_Has_Failed7 := True;
end if;

if Row_Pos51 /= No_Token_Index then

   Transform_Res40 := Allocate_Case_Stmt_Alternative (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res40,
      Kind => Ada_Case_Stmt_Alternative,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos51 = Pos
                            then No_Token_Index
                            else Row_Pos51 - 1));

      Initialize_Fields_For_Case_Stmt_Alternative
        (Self => Transform_Res40, Case_Stmt_Alternative_F_Choices => Defer_Res93, Case_Stmt_Alternative_F_Stmts => Defer_Res94);

         if Defer_Res93 /= null and then Is_Incomplete (Defer_Res93) then
            Transform_Res40.Last_Attempted_Child := 0;
         elsif Defer_Res93 /= null and then not Is_Ghost (Defer_Res93) then
            Transform_Res40.Last_Attempted_Child := -1;
         end if;
         if Defer_Res94 /= null and then Is_Incomplete (Defer_Res94) then
            Transform_Res40.Last_Attempted_Child := 0;
         elsif Defer_Res94 /= null and then not Is_Ghost (Defer_Res94) then
            Transform_Res40.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed7 then
      Transform_Res40.Last_Attempted_Child :=
         Row_Progress7;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <case_alt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos51 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags40);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Case_Alt_Transform_Parse0_Memo,
      Row_Pos51 /= No_Token_Index,
      Transform_Res40,
      Pos,
      Row_Pos51);


   Parser.Current_Pos := Row_Pos51;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res40;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Case_Alt_Transform_Parse0;

   


function Case_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Expr
is
   use Bare_Case_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos52 :
            Token_Index
               := No_Token_Index;
      Token_Pos85 :
            Token_Index
               := No_Token_Index;
      Token_Res85 :
            Token_Index
               := No_Token_Index;
      Defer_Pos95 :
            Token_Index
               := No_Token_Index;
      Defer_Res95 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos86 :
            Token_Index
               := No_Token_Index;
      Token_Res86 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos9 :
            Token_Index
               := No_Token_Index;
      Tmp_List9 :
            Free_Parse_List;
      Defer_Pos96 :
            Token_Index
               := No_Token_Index;
      Defer_Res96 :
            Bare_Case_Expr_Alternative
               := No_Bare_Ada_Node;
      Token_Pos87 :
            Token_Index
               := No_Token_Index;
      Token_Res87 :
            Token_Index
               := No_Token_Index;
      List_Pos9 :
            Token_Index
               := No_Token_Index;
      List_Res9 :
            Bare_Case_Expr_Alternative_List
               := No_Bare_Ada_Node;
      Transform_Res41 :
            Bare_Case_Expr
               := No_Bare_Ada_Node;
      Transform_Diags41 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Case_Expr_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res41 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res41;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res41;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags41 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos52 := Pos;



--  Start tok_code

Token_Res85 := Row_Pos52;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res85));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Case)
   then
       Token_Pos85 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos52 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos52,
             Expected_Token_Id => Ada_Case,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos85 := Row_Pos52 + 1;
   end if;
end;

--  End tok_code




if Token_Pos85 /= No_Token_Index then

   Row_Pos52 := Token_Pos85;

else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;

end if;


Defer_Res95 :=
   Expr_Or_Parse0 (Parser, Row_Pos52);
Defer_Pos95 := Parser.Current_Pos;




if Defer_Pos95 /= No_Token_Index then

   Row_Pos52 := Defer_Pos95;

else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;

end if;


--  Start tok_code

Token_Res86 := Row_Pos52;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res86));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos86 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos52 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos52,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos86 := Row_Pos52 + 1;
   end if;
end;

--  End tok_code




if Token_Pos86 /= No_Token_Index then

   Row_Pos52 := Token_Pos86;

else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;

end if;


--  Start list_code

    List_Pos9 := No_Token_Index;



Lst_Cpos9 := Row_Pos52;
Tmp_List9 := Get_Parse_List (Parser);

loop
   
Defer_Res96 :=
   Case_Expr_Alt_Transform_Parse0 (Parser, Lst_Cpos9);
Defer_Pos96 := Parser.Current_Pos;


   exit when Defer_Pos96 = No_Token_Index;

   List_Pos9 := Defer_Pos96;
   Lst_Cpos9 := List_Pos9;

   Tmp_List9.Nodes.Append (Defer_Res96);

      
--  Start tok_code

Token_Res87 := Lst_Cpos9;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res87));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos87 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos9 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos9,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos87 := Lst_Cpos9 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos87 /= No_Token_Index then
          Lst_Cpos9 := Token_Pos87;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List9.Nodes.Length;
begin
   List_Res9 :=
      Allocate_Case_Expr_Alternative_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos52;
      Token_End := (if Lst_Cpos9 = Row_Pos52
                    then Row_Pos52
                    else Lst_Cpos9 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos52, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res9,
      Kind              => Ada_Case_Expr_Alternative_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res9,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List9.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res9.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List9);

--  End list_code




if List_Pos9 /= No_Token_Index then

   Row_Pos52 := List_Pos9;

else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row52_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos52 /= No_Token_Index then

   Transform_Res41 := Allocate_Case_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res41,
      Kind => Ada_Case_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos52 = Pos
                            then No_Token_Index
                            else Row_Pos52 - 1));

      Initialize_Fields_For_Case_Expr
        (Self => Transform_Res41, Case_Expr_F_Expr => Defer_Res95, Case_Expr_F_Cases => List_Res9);

         if Defer_Res95 /= null and then Is_Incomplete (Defer_Res95) then
            Transform_Res41.Last_Attempted_Child := 0;
         elsif Defer_Res95 /= null and then not Is_Ghost (Defer_Res95) then
            Transform_Res41.Last_Attempted_Child := -1;
         end if;
         if List_Res9 /= null and then Is_Incomplete (List_Res9) then
            Transform_Res41.Last_Attempted_Child := 0;
         elsif List_Res9 /= null and then not Is_Ghost (List_Res9) then
            Transform_Res41.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos52 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags41);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Case_Expr_Transform_Parse0_Memo,
      Row_Pos52 /= No_Token_Index,
      Transform_Res41,
      Pos,
      Row_Pos52);


   Parser.Current_Pos := Row_Pos52;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res41;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Case_Expr_Transform_Parse0;

   


function Case_Expr_Alt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Expr_Alternative
is
   use Bare_Case_Expr_Alternative_Memos;

   Call_Depth : aliased Natural;

      Row_Pos53 :
            Token_Index
               := No_Token_Index;
      Token_Pos88 :
            Token_Index
               := No_Token_Index;
      Token_Res88 :
            Token_Index
               := No_Token_Index;
      Defer_Pos97 :
            Token_Index
               := No_Token_Index;
      Defer_Res97 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;
      Token_Pos89 :
            Token_Index
               := No_Token_Index;
      Token_Res89 :
            Token_Index
               := No_Token_Index;
      Defer_Pos98 :
            Token_Index
               := No_Token_Index;
      Defer_Res98 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res42 :
            Bare_Case_Expr_Alternative
               := No_Bare_Ada_Node;
      Transform_Diags42 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Case_Expr_Alt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res42 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res42;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res42;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags42 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos53 := Pos;



--  Start tok_code

Token_Res88 := Row_Pos53;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res88));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos88 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos53 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos53,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos88 := Row_Pos53 + 1;
   end if;
end;

--  End tok_code




if Token_Pos88 /= No_Token_Index then

   Row_Pos53 := Token_Pos88;

else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;

end if;


Defer_Res97 :=
   Choice_List_List_Parse0 (Parser, Row_Pos53);
Defer_Pos97 := Parser.Current_Pos;




if Defer_Pos97 /= No_Token_Index then

   Row_Pos53 := Defer_Pos97;

else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;

end if;


--  Start tok_code

Token_Res89 := Row_Pos53;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res89));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos89 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos53 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos53,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos89 := Row_Pos53 + 1;
   end if;
end;

--  End tok_code




if Token_Pos89 /= No_Token_Index then

   Row_Pos53 := Token_Pos89;

else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;

end if;


Defer_Res98 :=
   Expr_Or_Parse0 (Parser, Row_Pos53);
Defer_Pos98 := Parser.Current_Pos;




if Defer_Pos98 /= No_Token_Index then

   Row_Pos53 := Defer_Pos98;

else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row53_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos53 /= No_Token_Index then

   Transform_Res42 := Allocate_Case_Expr_Alternative (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res42,
      Kind => Ada_Case_Expr_Alternative,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos53 = Pos
                            then No_Token_Index
                            else Row_Pos53 - 1));

      Initialize_Fields_For_Case_Expr_Alternative
        (Self => Transform_Res42, Case_Expr_Alternative_F_Choices => Defer_Res97, Case_Expr_Alternative_F_Expr => Defer_Res98);

         if Defer_Res97 /= null and then Is_Incomplete (Defer_Res97) then
            Transform_Res42.Last_Attempted_Child := 0;
         elsif Defer_Res97 /= null and then not Is_Ghost (Defer_Res97) then
            Transform_Res42.Last_Attempted_Child := -1;
         end if;
         if Defer_Res98 /= null and then Is_Incomplete (Defer_Res98) then
            Transform_Res42.Last_Attempted_Child := 0;
         elsif Defer_Res98 /= null and then not Is_Ghost (Defer_Res98) then
            Transform_Res42.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos53 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags42);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Case_Expr_Alt_Transform_Parse0_Memo,
      Row_Pos53 /= No_Token_Index,
      Transform_Res42,
      Pos,
      Row_Pos53);


   Parser.Current_Pos := Row_Pos53;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res42;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Case_Expr_Alt_Transform_Parse0;

   


function Case_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Case_Stmt
is
   use Bare_Case_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt8 :
            Boolean
               := False;
      Row_Pos54 :
            Token_Index
               := No_Token_Index;
      Token_Pos90 :
            Token_Index
               := No_Token_Index;
      Token_Res90 :
            Token_Index
               := No_Token_Index;
      Defer_Pos99 :
            Token_Index
               := No_Token_Index;
      Defer_Res99 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos91 :
            Token_Index
               := No_Token_Index;
      Token_Res91 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos10 :
            Token_Index
               := No_Token_Index;
      Tmp_List10 :
            Free_Parse_List;
      Defer_Pos100 :
            Token_Index
               := No_Token_Index;
      Defer_Res100 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      List_Pos10 :
            Token_Index
               := No_Token_Index;
      List_Res10 :
            Bare_Pragma_Node_List
               := No_Bare_Ada_Node;
      Lst_Cpos11 :
            Token_Index
               := No_Token_Index;
      Tmp_List11 :
            Free_Parse_List;
      Defer_Pos101 :
            Token_Index
               := No_Token_Index;
      Defer_Res101 :
            Bare_Case_Stmt_Alternative
               := No_Bare_Ada_Node;
      List_Pos11 :
            Token_Index
               := No_Token_Index;
      List_Res11 :
            Bare_Case_Stmt_Alternative_List
               := No_Bare_Ada_Node;
      Token_Pos92 :
            Token_Index
               := No_Token_Index;
      Token_Res92 :
            Token_Index
               := No_Token_Index;
      Token_Pos93 :
            Token_Index
               := No_Token_Index;
      Token_Res93 :
            Token_Index
               := No_Token_Index;
      Token_Pos94 :
            Token_Index
               := No_Token_Index;
      Token_Res94 :
            Token_Index
               := No_Token_Index;
      Row_Progress8 :
            Integer
               := 0;
      Transform_Res43 :
            Bare_Case_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed8 :
            Boolean
               := False;
      Transform_Diags43 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Case_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res43 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res43;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res43;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags43 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos54 := Pos;



--  Start tok_code

Token_Res90 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res90));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Case)
   then
       Token_Pos90 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Ada_Case,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos90 := Row_Pos54 + 1;
   end if;
end;

--  End tok_code



Row_Progress8 := 1;

if Token_Pos90 /= No_Token_Index then

   Row_Pos54 := Token_Pos90;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;

Nobt8 := True;

   Nobt8 := Nobt8;

Row_Progress8 := 2;

if Row_Pos54 /= No_Token_Index then

   Row_Pos54 := Row_Pos54;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


Defer_Res99 :=
   Expr_Or_Parse0 (Parser, Row_Pos54);
Defer_Pos99 := Parser.Current_Pos;



Row_Progress8 := 3;

if Defer_Pos99 /= No_Token_Index then

   Row_Pos54 := Defer_Pos99;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  Start tok_code

Token_Res91 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res91));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos91 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos91 := Row_Pos54 + 1;
   end if;
end;

--  End tok_code



Row_Progress8 := 4;

if Token_Pos91 /= No_Token_Index then

   Row_Pos54 := Token_Pos91;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  Start list_code

    List_Pos10 := Row_Pos54;



Lst_Cpos10 := Row_Pos54;
Tmp_List10 := Get_Parse_List (Parser);

loop
   
Defer_Res100 :=
   Pragma_Transform_Parse0 (Parser, Lst_Cpos10);
Defer_Pos100 := Parser.Current_Pos;


   exit when Defer_Pos100 = No_Token_Index;

   List_Pos10 := Defer_Pos100;
   Lst_Cpos10 := List_Pos10;

   Tmp_List10.Nodes.Append (Defer_Res100);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List10.Nodes.Length;
begin
   List_Res10 :=
      Allocate_Pragma_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos54;
      Token_End := (if Lst_Cpos10 = Row_Pos54
                    then Row_Pos54
                    else Lst_Cpos10 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos54, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res10,
      Kind              => Ada_Pragma_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res10,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List10.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res10.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List10);

--  End list_code



Row_Progress8 := 5;

if List_Pos10 /= No_Token_Index then

   Row_Pos54 := List_Pos10;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  Start list_code

    List_Pos11 := No_Token_Index;



Lst_Cpos11 := Row_Pos54;
Tmp_List11 := Get_Parse_List (Parser);

loop
   
Defer_Res101 :=
   Case_Alt_Transform_Parse0 (Parser, Lst_Cpos11);
Defer_Pos101 := Parser.Current_Pos;


   exit when Defer_Pos101 = No_Token_Index;

   List_Pos11 := Defer_Pos101;
   Lst_Cpos11 := List_Pos11;

   Tmp_List11.Nodes.Append (Defer_Res101);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List11.Nodes.Length;
begin
   List_Res11 :=
      Allocate_Case_Stmt_Alternative_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos54;
      Token_End := (if Lst_Cpos11 = Row_Pos54
                    then Row_Pos54
                    else Lst_Cpos11 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos54, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res11,
      Kind              => Ada_Case_Stmt_Alternative_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res11,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List11.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res11.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List11);

--  End list_code



Row_Progress8 := 6;

if List_Pos11 /= No_Token_Index then

   Row_Pos54 := List_Pos11;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  Start tok_code

Token_Res92 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res92));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos92 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos92 := Row_Pos54 + 1;
   end if;
end;

--  End tok_code



Row_Progress8 := 7;

if Token_Pos92 /= No_Token_Index then

   Row_Pos54 := Token_Pos92;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  Start tok_code

Token_Res93 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res93));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Case)
   then
       Token_Pos93 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Ada_Case,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos93 := Row_Pos54 + 1;
   end if;
end;

--  End tok_code



Row_Progress8 := 8;

if Token_Pos93 /= No_Token_Index then

   Row_Pos54 := Token_Pos93;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  Start tok_code

Token_Res94 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res94));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos94 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos94 := Row_Pos54 + 1;
   end if;
end;

--  End tok_code



Row_Progress8 := 9;

if Token_Pos94 /= No_Token_Index then

   Row_Pos54 := Token_Pos94;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row54_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos54 = No_Token_Index and then Nobt8 then

   Row_Pos54 := Parser.Last_Fail.Pos;

   Transform_Has_Failed8 := True;
end if;

if Row_Pos54 /= No_Token_Index then

   Transform_Res43 := Allocate_Case_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res43,
      Kind => Ada_Case_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos54 = Pos
                            then No_Token_Index
                            else Row_Pos54 - 1));

      Initialize_Fields_For_Case_Stmt
        (Self => Transform_Res43, Case_Stmt_F_Expr => Defer_Res99, Case_Stmt_F_Pragmas => List_Res10, Case_Stmt_F_Alternatives => List_Res11);

         if Defer_Res99 /= null and then Is_Incomplete (Defer_Res99) then
            Transform_Res43.Last_Attempted_Child := 0;
         elsif Defer_Res99 /= null and then not Is_Ghost (Defer_Res99) then
            Transform_Res43.Last_Attempted_Child := -1;
         end if;
         if List_Res10 /= null and then Is_Incomplete (List_Res10) then
            Transform_Res43.Last_Attempted_Child := 0;
         elsif List_Res10 /= null and then not Is_Ghost (List_Res10) then
            Transform_Res43.Last_Attempted_Child := -1;
         end if;
         if List_Res11 /= null and then Is_Incomplete (List_Res11) then
            Transform_Res43.Last_Attempted_Child := 0;
         elsif List_Res11 /= null and then not Is_Ghost (List_Res11) then
            Transform_Res43.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed8 then
      Transform_Res43.Last_Attempted_Child :=
         Row_Progress8;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <case_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos54 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags43);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Case_Stmt_Transform_Parse0_Memo,
      Row_Pos54 /= No_Token_Index,
      Transform_Res43,
      Pos,
      Row_Pos54);


   Parser.Current_Pos := Row_Pos54;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res43;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Case_Stmt_Transform_Parse0;

   


function Char_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Char_Literal
is
   use Bare_Char_Literal_Memos;

   Call_Depth : aliased Natural;

      Row_Pos55 :
            Token_Index
               := No_Token_Index;
      Token_Pos95 :
            Token_Index
               := No_Token_Index;
      Token_Res95 :
            Token_Index
               := No_Token_Index;
      Transform_Res44 :
            Bare_Char_Literal
               := No_Bare_Ada_Node;
      Transform_Diags44 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Char_Literal_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res44 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res44;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res44;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags44 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos55 := Pos;



--  Start tok_code

Token_Res95 := Row_Pos55;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res95));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Char)
   then
       Token_Pos95 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos55 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos55,
             Expected_Token_Id => Ada_Char,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos95 := Row_Pos55 + 1;
   end if;
end;

--  End tok_code




if Token_Pos95 /= No_Token_Index then

   Row_Pos55 := Token_Pos95;

else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row55_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos55 /= No_Token_Index then

   Transform_Res44 := Allocate_Char_Literal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res44,
      Kind => Ada_Char_Literal,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos55 = Pos
                            then No_Token_Index
                            else Row_Pos55 - 1));

      Initialize_Fields_For_Char_Literal
        (Self => Transform_Res44);



elsif Row_Pos55 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags44);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Char_Literal_Transform_Parse0_Memo,
      Row_Pos55 /= No_Token_Index,
      Transform_Res44,
      Pos,
      Row_Pos55);


   Parser.Current_Pos := Row_Pos55;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res44;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Char_Literal_Transform_Parse0;

   


function Choice_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos102 :
            Token_Index
               := No_Token_Index;
      Defer_Res102 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos103 :
            Token_Index
               := No_Token_Index;
      Defer_Res103 :
            Bare_Discrete_Subtype_Indication
               := No_Bare_Ada_Node;
      Defer_Pos104 :
            Token_Index
               := No_Token_Index;
      Defer_Res104 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos105 :
            Token_Index
               := No_Token_Index;
      Defer_Res105 :
            Bare_Others_Designator
               := No_Bare_Ada_Node;
      Or_Pos22 :
            Token_Index
               := No_Token_Index;
      Or_Res22 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Choice_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res22 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res22;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos22 := No_Token_Index;
Or_Res22 := No_Bare_Ada_Node;
    
Defer_Res102 :=
   Discrete_Range_Or_Parse0 (Parser, Pos);
Defer_Pos102 := Parser.Current_Pos;

    if Defer_Pos102 /= No_Token_Index then
        Or_Pos22 := Defer_Pos102;
        Or_Res22 := Defer_Res102;
        goto Exit_Or23;
    end if;
    
Defer_Res103 :=
   Discrete_Subtype_Indication_Transform_Parse0 (Parser, Pos);
Defer_Pos103 := Parser.Current_Pos;

    if Defer_Pos103 /= No_Token_Index then
        Or_Pos22 := Defer_Pos103;
        Or_Res22 := Defer_Res103;
        goto Exit_Or23;
    end if;
    
Defer_Res104 :=
   Expr_Or_Parse0 (Parser, Pos);
Defer_Pos104 := Parser.Current_Pos;

    if Defer_Pos104 /= No_Token_Index then
        Or_Pos22 := Defer_Pos104;
        Or_Res22 := Defer_Res104;
        goto Exit_Or23;
    end if;
    
Defer_Res105 :=
   Others_Designator_Transform_Parse0 (Parser, Pos);
Defer_Pos105 := Parser.Current_Pos;

    if Defer_Pos105 /= No_Token_Index then
        Or_Pos22 := Defer_Pos105;
        Or_Res22 := Defer_Res105;
        goto Exit_Or23;
    end if;
<<Exit_Or23>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Choice_Or_Parse0_Memo,
      Or_Pos22 /= No_Token_Index,
      Or_Res22,
      Pos,
      Or_Pos22);


   Parser.Current_Pos := Or_Pos22;

   Exit_Call (Parser, Call_Depth);
   return Or_Res22;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Choice_Or_Parse0;

   


function Choice_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Alternatives_List
is
   use Bare_Alternatives_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos12 :
            Token_Index
               := No_Token_Index;
      Tmp_List12 :
            Free_Parse_List;
      Defer_Pos106 :
            Token_Index
               := No_Token_Index;
      Defer_Res106 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos96 :
            Token_Index
               := No_Token_Index;
      Token_Res96 :
            Token_Index
               := No_Token_Index;
      List_Pos12 :
            Token_Index
               := No_Token_Index;
      List_Res12 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Choice_List_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res12 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res12;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos12 := No_Token_Index;



Lst_Cpos12 := Pos;
Tmp_List12 := Get_Parse_List (Parser);

loop
   
Defer_Res106 :=
   Choice_Or_Parse0 (Parser, Lst_Cpos12);
Defer_Pos106 := Parser.Current_Pos;


   exit when Defer_Pos106 = No_Token_Index;

   List_Pos12 := Defer_Pos106;
   Lst_Cpos12 := List_Pos12;

   Tmp_List12.Nodes.Append (Defer_Res106);

      
--  Start tok_code

Token_Res96 := Lst_Cpos12;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res96));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pipe)
   then
       Token_Pos96 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos12 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos12,
             Expected_Token_Id => Ada_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos96 := Lst_Cpos12 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos96 /= No_Token_Index then
          Lst_Cpos12 := Token_Pos96;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List12.Nodes.Length;
begin
   List_Res12 :=
      Allocate_Alternatives_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos12 = Pos
                    then Pos
                    else Lst_Cpos12 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res12,
      Kind              => Ada_Alternatives_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res12,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List12.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res12.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List12);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Choice_List_List_Parse0_Memo,
      List_Pos12 /= No_Token_Index,
      List_Res12,
      Pos,
      List_Pos12);


   Parser.Current_Pos := List_Pos12;

   Exit_Call (Parser, Call_Depth);
   return List_Res12;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Choice_List_List_Parse0;

   


function Compilation_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos56 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos13 :
            Token_Index
               := No_Token_Index;
      Tmp_List13 :
            Free_Parse_List;
      Defer_Pos107 :
            Token_Index
               := No_Token_Index;
      Defer_Res107 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      List_Pos13 :
            Token_Index
               := No_Token_Index;
      List_Res13 :
            Bare_Pragma_Node_List
               := No_Bare_Ada_Node;
      Token_Pos97 :
            Token_Index
               := No_Token_Index;
      Token_Res97 :
            Token_Index
               := No_Token_Index;
      Row_Pos57 :
            Token_Index
               := No_Token_Index;
      Defer_Pos108 :
            Token_Index
               := No_Token_Index;
      Defer_Res108 :
            Bare_Compilation_Unit
               := No_Bare_Ada_Node;
      Token_Pos98 :
            Token_Index
               := No_Token_Index;
      Token_Res98 :
            Token_Index
               := No_Token_Index;
      Row_Pos58 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos14 :
            Token_Index
               := No_Token_Index;
      Tmp_List14 :
            Free_Parse_List;
      Defer_Pos109 :
            Token_Index
               := No_Token_Index;
      Defer_Res109 :
            Bare_Compilation_Unit
               := No_Bare_Ada_Node;
      List_Pos14 :
            Token_Index
               := No_Token_Index;
      List_Res14 :
            Bare_Compilation_Unit_List
               := No_Bare_Ada_Node;
      Token_Pos99 :
            Token_Index
               := No_Token_Index;
      Token_Res99 :
            Token_Index
               := No_Token_Index;
      Or_Pos23 :
            Token_Index
               := No_Token_Index;
      Or_Res23 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Compilation_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res23 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res23;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res23;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos23 := No_Token_Index;
Or_Res23 := No_Bare_Ada_Node;
    
--  Start row_code

Row_Pos56 := Pos;



--  Start list_code

    List_Pos13 := No_Token_Index;



Lst_Cpos13 := Row_Pos56;
Tmp_List13 := Get_Parse_List (Parser);

loop
   
Defer_Res107 :=
   Pragma_Transform_Parse0 (Parser, Lst_Cpos13);
Defer_Pos107 := Parser.Current_Pos;


   exit when Defer_Pos107 = No_Token_Index;

   List_Pos13 := Defer_Pos107;
   Lst_Cpos13 := List_Pos13;

   Tmp_List13.Nodes.Append (Defer_Res107);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List13.Nodes.Length;
begin
   List_Res13 :=
      Allocate_Pragma_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos56;
      Token_End := (if Lst_Cpos13 = Row_Pos56
                    then Row_Pos56
                    else Lst_Cpos13 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos56, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res13,
      Kind              => Ada_Pragma_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res13,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List13.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res13.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List13);

--  End list_code




if List_Pos13 /= No_Token_Index then

   Row_Pos56 := List_Pos13;

else
   Row_Pos56 := No_Token_Index;
   goto Exit_Row56_0;

end if;


--  Start tok_code

Token_Res97 := Row_Pos56;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res97));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Termination)
   then
       Token_Pos97 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos56 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos56,
             Expected_Token_Id => Ada_Termination,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos97 := Row_Pos56;
   end if;
end;

--  End tok_code




if Token_Pos97 /= No_Token_Index then

   Row_Pos56 := Token_Pos97;

else
   Row_Pos56 := No_Token_Index;
   goto Exit_Row56_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row56_0>>
pragma Warnings (On, "referenced");

--  End row_code

    if Row_Pos56 /= No_Token_Index then
        Or_Pos23 := Row_Pos56;
        Or_Res23 := List_Res13;
        goto Exit_Or24;
    end if;
    
--  Start row_code

Row_Pos57 := Pos;



Defer_Res108 :=
   Compilation_Unit_Transform_Parse0 (Parser, Row_Pos57);
Defer_Pos108 := Parser.Current_Pos;




if Defer_Pos108 /= No_Token_Index then

   Row_Pos57 := Defer_Pos108;

else
   Row_Pos57 := No_Token_Index;
   goto Exit_Row57_0;

end if;


--  Start tok_code

Token_Res98 := Row_Pos57;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res98));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Termination)
   then
       Token_Pos98 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos57 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos57,
             Expected_Token_Id => Ada_Termination,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos98 := Row_Pos57;
   end if;
end;

--  End tok_code




if Token_Pos98 /= No_Token_Index then

   Row_Pos57 := Token_Pos98;

else
   Row_Pos57 := No_Token_Index;
   goto Exit_Row57_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row57_0>>
pragma Warnings (On, "referenced");

--  End row_code

    if Row_Pos57 /= No_Token_Index then
        Or_Pos23 := Row_Pos57;
        Or_Res23 := Defer_Res108;
        goto Exit_Or24;
    end if;
    
--  Start row_code

Row_Pos58 := Pos;



--  Start list_code

    List_Pos14 := Row_Pos58;



Lst_Cpos14 := Row_Pos58;
Tmp_List14 := Get_Parse_List (Parser);

loop
   
Defer_Res109 :=
   Compilation_Unit_Transform_Parse0 (Parser, Lst_Cpos14);
Defer_Pos109 := Parser.Current_Pos;


   exit when Defer_Pos109 = No_Token_Index;

   List_Pos14 := Defer_Pos109;
   Lst_Cpos14 := List_Pos14;

   Tmp_List14.Nodes.Append (Defer_Res109);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List14.Nodes.Length;
begin
   List_Res14 :=
      Allocate_Compilation_Unit_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos58;
      Token_End := (if Lst_Cpos14 = Row_Pos58
                    then Row_Pos58
                    else Lst_Cpos14 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos58, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res14,
      Kind              => Ada_Compilation_Unit_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res14,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List14.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res14.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List14);

--  End list_code




if List_Pos14 /= No_Token_Index then

   Row_Pos58 := List_Pos14;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;


--  Start tok_code

Token_Res99 := Row_Pos58;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res99));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Termination)
   then
       Token_Pos99 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos58 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos58,
             Expected_Token_Id => Ada_Termination,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos99 := Row_Pos58;
   end if;
end;

--  End tok_code




if Token_Pos99 /= No_Token_Index then

   Row_Pos58 := Token_Pos99;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row58_0>>
pragma Warnings (On, "referenced");

--  End row_code

    if Row_Pos58 /= No_Token_Index then
        Or_Pos23 := Row_Pos58;
        Or_Res23 := List_Res14;
        goto Exit_Or24;
    end if;
<<Exit_Or24>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Compilation_Or_Parse0_Memo,
      Or_Pos23 /= No_Token_Index,
      Or_Res23,
      Pos,
      Or_Pos23);


   Parser.Current_Pos := Or_Pos23;

   Exit_Call (Parser, Call_Depth);
   return Or_Res23;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Compilation_Or_Parse0;

   


function Compilation_Unit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Compilation_Unit
is
   use Bare_Compilation_Unit_Memos;

   Call_Depth : aliased Natural;

      Row_Pos59 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos15 :
            Token_Index
               := No_Token_Index;
      Tmp_List15 :
            Free_Parse_List;
      Defer_Pos110 :
            Token_Index
               := No_Token_Index;
      Defer_Res110 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos15 :
            Token_Index
               := No_Token_Index;
      List_Res15 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Defer_Pos111 :
            Token_Index
               := No_Token_Index;
      Defer_Res111 :
            Bare_Subunit
               := No_Bare_Ada_Node;
      Defer_Pos112 :
            Token_Index
               := No_Token_Index;
      Defer_Res112 :
            Bare_Library_Item
               := No_Bare_Ada_Node;
      Or_Pos24 :
            Token_Index
               := No_Token_Index;
      Or_Res24 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Lst_Cpos16 :
            Token_Index
               := No_Token_Index;
      Tmp_List16 :
            Free_Parse_List;
      Defer_Pos113 :
            Token_Index
               := No_Token_Index;
      Defer_Res113 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      List_Pos16 :
            Token_Index
               := No_Token_Index;
      List_Res16 :
            Bare_Pragma_Node_List
               := No_Bare_Ada_Node;
      Transform_Res45 :
            Bare_Compilation_Unit
               := No_Bare_Ada_Node;
      Transform_Diags45 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Compilation_Unit_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res45 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res45;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res45;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags45 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos59 := Pos;



--  Start list_code

    List_Pos15 := Row_Pos59;



Lst_Cpos15 := Row_Pos59;
Tmp_List15 := Get_Parse_List (Parser);

loop
   
Defer_Res110 :=
   Context_Item_Or_Parse0 (Parser, Lst_Cpos15);
Defer_Pos110 := Parser.Current_Pos;


   exit when Defer_Pos110 = No_Token_Index;

   List_Pos15 := Defer_Pos110;
   Lst_Cpos15 := List_Pos15;

   Tmp_List15.Nodes.Append (Defer_Res110);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List15.Nodes.Length;
begin
   List_Res15 :=
      Allocate_Ada_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos59;
      Token_End := (if Lst_Cpos15 = Row_Pos59
                    then Row_Pos59
                    else Lst_Cpos15 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos59, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res15,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res15,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List15.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res15.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List15);

--  End list_code




if List_Pos15 /= No_Token_Index then

   Row_Pos59 := List_Pos15;

else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;

end if;


--  Start or_code

Or_Pos24 := No_Token_Index;
Or_Res24 := No_Bare_Ada_Node;
    
Defer_Res111 :=
   Subunit_Transform_Parse0 (Parser, Row_Pos59);
Defer_Pos111 := Parser.Current_Pos;

    if Defer_Pos111 /= No_Token_Index then
        Or_Pos24 := Defer_Pos111;
        Or_Res24 := Defer_Res111;
        goto Exit_Or25;
    end if;
    
Defer_Res112 :=
   Library_Item_Transform_Parse1 (Parser, Row_Pos59);
Defer_Pos112 := Parser.Current_Pos;

    if Defer_Pos112 /= No_Token_Index then
        Or_Pos24 := Defer_Pos112;
        Or_Res24 := Defer_Res112;
        goto Exit_Or25;
    end if;
<<Exit_Or25>>

--  End or_code




if Or_Pos24 /= No_Token_Index then

   Row_Pos59 := Or_Pos24;

else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;

end if;


--  Start list_code

    List_Pos16 := Row_Pos59;



Lst_Cpos16 := Row_Pos59;
Tmp_List16 := Get_Parse_List (Parser);

loop
   
Defer_Res113 :=
   Pragma_Transform_Parse0 (Parser, Lst_Cpos16);
Defer_Pos113 := Parser.Current_Pos;


   exit when Defer_Pos113 = No_Token_Index;

   List_Pos16 := Defer_Pos113;
   Lst_Cpos16 := List_Pos16;

   Tmp_List16.Nodes.Append (Defer_Res113);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List16.Nodes.Length;
begin
   List_Res16 :=
      Allocate_Pragma_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos59;
      Token_End := (if Lst_Cpos16 = Row_Pos59
                    then Row_Pos59
                    else Lst_Cpos16 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos59, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res16,
      Kind              => Ada_Pragma_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res16,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List16.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res16.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List16);

--  End list_code




if List_Pos16 /= No_Token_Index then

   Row_Pos59 := List_Pos16;

else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row59_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos59 /= No_Token_Index then

   Transform_Res45 := Allocate_Compilation_Unit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res45,
      Kind => Ada_Compilation_Unit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos59 = Pos
                            then No_Token_Index
                            else Row_Pos59 - 1));

      Initialize_Fields_For_Compilation_Unit
        (Self => Transform_Res45, Compilation_Unit_F_Prelude => List_Res15, Compilation_Unit_F_Body => Or_Res24, Compilation_Unit_F_Pragmas => List_Res16);

         if List_Res15 /= null and then Is_Incomplete (List_Res15) then
            Transform_Res45.Last_Attempted_Child := 0;
         elsif List_Res15 /= null and then not Is_Ghost (List_Res15) then
            Transform_Res45.Last_Attempted_Child := -1;
         end if;
         if Or_Res24 /= null and then Is_Incomplete (Or_Res24) then
            Transform_Res45.Last_Attempted_Child := 0;
         elsif Or_Res24 /= null and then not Is_Ghost (Or_Res24) then
            Transform_Res45.Last_Attempted_Child := -1;
         end if;
         if List_Res16 /= null and then Is_Incomplete (List_Res16) then
            Transform_Res45.Last_Attempted_Child := 0;
         elsif List_Res16 /= null and then not Is_Ghost (List_Res16) then
            Transform_Res45.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos59 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags45);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Compilation_Unit_Transform_Parse0_Memo,
      Row_Pos59 /= No_Token_Index,
      Transform_Res45,
      Pos,
      Row_Pos59);


   Parser.Current_Pos := Row_Pos59;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res45;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Compilation_Unit_Transform_Parse0;

   


function Component_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_Clause
is
   use Bare_Component_Clause_Memos;

   Call_Depth : aliased Natural;

      Row_Pos60 :
            Token_Index
               := No_Token_Index;
      Defer_Pos114 :
            Token_Index
               := No_Token_Index;
      Defer_Res114 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Token_Pos100 :
            Token_Index
               := No_Token_Index;
      Token_Res100 :
            Token_Index
               := No_Token_Index;
      Defer_Pos115 :
            Token_Index
               := No_Token_Index;
      Defer_Res115 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos116 :
            Token_Index
               := No_Token_Index;
      Defer_Res116 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Token_Pos101 :
            Token_Index
               := No_Token_Index;
      Token_Res101 :
            Token_Index
               := No_Token_Index;
      Transform_Res46 :
            Bare_Component_Clause
               := No_Bare_Ada_Node;
      Transform_Diags46 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Component_Clause_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res46 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res46;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res46;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags46 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos60 := Pos;



Defer_Res114 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos60);
Defer_Pos114 := Parser.Current_Pos;




if Defer_Pos114 /= No_Token_Index then

   Row_Pos60 := Defer_Pos114;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  Start tok_code

Token_Res100 := Row_Pos60;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res100));
begin
   if
      T.Kind /= From_Token_Kind (Ada_At)
   then
       Token_Pos100 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos60,
             Expected_Token_Id => Ada_At,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos100 := Row_Pos60 + 1;
   end if;
end;

--  End tok_code




if Token_Pos100 /= No_Token_Index then

   Row_Pos60 := Token_Pos100;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


Defer_Res115 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos60);
Defer_Pos115 := Parser.Current_Pos;




if Defer_Pos115 /= No_Token_Index then

   Row_Pos60 := Defer_Pos115;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


Defer_Res116 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos60);
Defer_Pos116 := Parser.Current_Pos;




if Defer_Pos116 /= No_Token_Index then

   Row_Pos60 := Defer_Pos116;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res101 := Row_Pos60;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res101));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos101 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos60,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos101 := Row_Pos60 + 1;
   end if;
end;

--  End tok_code


if Token_Pos101 = No_Token_Index then

         
   Token_Res101 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos60)),
                To_Text ("Missing ';'"));

       
   Token_Pos101 := Row_Pos60;



end if;

--  End opt_code




if Token_Pos101 /= No_Token_Index then

   Row_Pos60 := Token_Pos101;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row60_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos60 /= No_Token_Index then

   Transform_Res46 := Allocate_Component_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res46,
      Kind => Ada_Component_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos60 = Pos
                            then No_Token_Index
                            else Row_Pos60 - 1));

      Initialize_Fields_For_Component_Clause
        (Self => Transform_Res46, Component_Clause_F_Id => Defer_Res114, Component_Clause_F_Position => Defer_Res115, Component_Clause_F_Range => Defer_Res116);

         if Defer_Res114 /= null and then Is_Incomplete (Defer_Res114) then
            Transform_Res46.Last_Attempted_Child := 0;
         elsif Defer_Res114 /= null and then not Is_Ghost (Defer_Res114) then
            Transform_Res46.Last_Attempted_Child := -1;
         end if;
         if Defer_Res115 /= null and then Is_Incomplete (Defer_Res115) then
            Transform_Res46.Last_Attempted_Child := 0;
         elsif Defer_Res115 /= null and then not Is_Ghost (Defer_Res115) then
            Transform_Res46.Last_Attempted_Child := -1;
         end if;
         if Defer_Res116 /= null and then Is_Incomplete (Defer_Res116) then
            Transform_Res46.Last_Attempted_Child := 0;
         elsif Defer_Res116 /= null and then not Is_Ghost (Defer_Res116) then
            Transform_Res46.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos60 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags46);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Component_Clause_Transform_Parse0_Memo,
      Row_Pos60 /= No_Token_Index,
      Transform_Res46,
      Pos,
      Row_Pos60);


   Parser.Current_Pos := Row_Pos60;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res46;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Component_Clause_Transform_Parse0;

   


function Component_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_Decl
is
   use Bare_Component_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos61 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos17 :
            Token_Index
               := No_Token_Index;
      Tmp_List17 :
            Free_Parse_List;
      Defer_Pos117 :
            Token_Index
               := No_Token_Index;
      Defer_Res117 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos102 :
            Token_Index
               := No_Token_Index;
      Token_Res102 :
            Token_Index
               := No_Token_Index;
      List_Pos17 :
            Token_Index
               := No_Token_Index;
      List_Res17 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos103 :
            Token_Index
               := No_Token_Index;
      Token_Res103 :
            Token_Index
               := No_Token_Index;
      Defer_Pos118 :
            Token_Index
               := No_Token_Index;
      Defer_Res118 :
            Bare_Component_Def
               := No_Bare_Ada_Node;
      Row_Pos62 :
            Token_Index
               := No_Token_Index;
      Token_Pos104 :
            Token_Index
               := No_Token_Index;
      Token_Res104 :
            Token_Index
               := No_Token_Index;
      Defer_Pos119 :
            Token_Index
               := No_Token_Index;
      Defer_Res119 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos120 :
            Token_Index
               := No_Token_Index;
      Defer_Res120 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos105 :
            Token_Index
               := No_Token_Index;
      Token_Res105 :
            Token_Index
               := No_Token_Index;
      Transform_Res47 :
            Bare_Component_Decl
               := No_Bare_Ada_Node;
      Transform_Diags47 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Component_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res47 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res47;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res47;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags47 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos61 := Pos;



--  Start list_code

    List_Pos17 := No_Token_Index;



Lst_Cpos17 := Row_Pos61;
Tmp_List17 := Get_Parse_List (Parser);

loop
   
Defer_Res117 :=
   Defining_Id_Transform_Parse0 (Parser, Lst_Cpos17);
Defer_Pos117 := Parser.Current_Pos;


   exit when Defer_Pos117 = No_Token_Index;

   List_Pos17 := Defer_Pos117;
   Lst_Cpos17 := List_Pos17;

   Tmp_List17.Nodes.Append (Defer_Res117);

      
--  Start tok_code

Token_Res102 := Lst_Cpos17;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res102));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos102 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos17 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos17,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos102 := Lst_Cpos17 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos102 /= No_Token_Index then
          Lst_Cpos17 := Token_Pos102;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List17.Nodes.Length;
begin
   List_Res17 :=
      Allocate_Defining_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos61;
      Token_End := (if Lst_Cpos17 = Row_Pos61
                    then Row_Pos61
                    else Lst_Cpos17 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos61, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res17,
      Kind              => Ada_Defining_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res17,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List17.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res17.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List17);

--  End list_code




if List_Pos17 /= No_Token_Index then

   Row_Pos61 := List_Pos17;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;


--  Start tok_code

Token_Res103 := Row_Pos61;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res103));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos103 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos61 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos61,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos103 := Row_Pos61 + 1;
   end if;
end;

--  End tok_code




if Token_Pos103 /= No_Token_Index then

   Row_Pos61 := Token_Pos103;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;


Defer_Res118 :=
   Component_Def_Transform_Parse0 (Parser, Row_Pos61);
Defer_Pos118 := Parser.Current_Pos;




if Defer_Pos118 /= No_Token_Index then

   Row_Pos61 := Defer_Pos118;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos62 := Row_Pos61;



--  Start tok_code

Token_Res104 := Row_Pos62;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res104));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos104 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos62 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos62,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos104 := Row_Pos62 + 1;
   end if;
end;

--  End tok_code




if Token_Pos104 /= No_Token_Index then

   Row_Pos62 := Token_Pos104;

else
   Row_Pos62 := No_Token_Index;
   goto Exit_Row62_0;

end if;


Defer_Res119 :=
   Expr_Or_Parse0 (Parser, Row_Pos62);
Defer_Pos119 := Parser.Current_Pos;




if Defer_Pos119 /= No_Token_Index then

   Row_Pos62 := Defer_Pos119;

else
   Row_Pos62 := No_Token_Index;
   goto Exit_Row62_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row62_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos62 = No_Token_Index then

         
   Defer_Res119 := No_Bare_Ada_Node;



       
   Row_Pos62 := Row_Pos61;



end if;

--  End opt_code




if Row_Pos62 /= No_Token_Index then

   Row_Pos61 := Row_Pos62;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;


Defer_Res120 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos61);
Defer_Pos120 := Parser.Current_Pos;




if Defer_Pos120 /= No_Token_Index then

   Row_Pos61 := Defer_Pos120;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res105 := Row_Pos61;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res105));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos105 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos61 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos61,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos105 := Row_Pos61 + 1;
   end if;
end;

--  End tok_code


if Token_Pos105 = No_Token_Index then

         
   Token_Res105 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos61)),
                To_Text ("Missing ';'"));

       
   Token_Pos105 := Row_Pos61;



end if;

--  End opt_code




if Token_Pos105 /= No_Token_Index then

   Row_Pos61 := Token_Pos105;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row61_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos61 /= No_Token_Index then

   Transform_Res47 := Allocate_Component_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res47,
      Kind => Ada_Component_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos61 = Pos
                            then No_Token_Index
                            else Row_Pos61 - 1));

      Initialize_Fields_For_Component_Decl
        (Self => Transform_Res47, Component_Decl_F_Ids => List_Res17, Component_Decl_F_Component_Def => Defer_Res118, Component_Decl_F_Default_Expr => Defer_Res119, Component_Decl_F_Aspects => Defer_Res120);

         if List_Res17 /= null and then Is_Incomplete (List_Res17) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif List_Res17 /= null and then not Is_Ghost (List_Res17) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;
         if Defer_Res118 /= null and then Is_Incomplete (Defer_Res118) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif Defer_Res118 /= null and then not Is_Ghost (Defer_Res118) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;
         if Defer_Res119 /= null and then Is_Incomplete (Defer_Res119) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif Defer_Res119 /= null and then not Is_Ghost (Defer_Res119) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;
         if Defer_Res120 /= null and then Is_Incomplete (Defer_Res120) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif Defer_Res120 /= null and then not Is_Ghost (Defer_Res120) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos61 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags47);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Component_Decl_Transform_Parse0_Memo,
      Row_Pos61 /= No_Token_Index,
      Transform_Res47,
      Pos,
      Row_Pos61);


   Parser.Current_Pos := Row_Pos61;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res47;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Component_Decl_Transform_Parse0;

   


function Component_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_Def
is
   use Bare_Component_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos63 :
            Token_Index
               := No_Token_Index;
      Token_Pos106 :
            Token_Index
               := No_Token_Index;
      Token_Res106 :
            Token_Index
               := No_Token_Index;
      Opt_Res5 :
            Bare_Aliased_Node
               := No_Bare_Ada_Node;
      Token_Pos107 :
            Token_Index
               := No_Token_Index;
      Token_Res107 :
            Token_Index
               := No_Token_Index;
      Opt_Res6 :
            Bare_Constant_Node
               := No_Bare_Ada_Node;
      Defer_Pos121 :
            Token_Index
               := No_Token_Index;
      Defer_Res121 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Transform_Res48 :
            Bare_Component_Def
               := No_Bare_Ada_Node;
      Transform_Diags48 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Component_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res48 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res48;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res48;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags48 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos63 := Pos;



--  Start opt_code












--  Start tok_code

Token_Res106 := Row_Pos63;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res106));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Aliased)
   then
       Token_Pos106 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos63,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos106 := Row_Pos63 + 1;
   end if;
end;

--  End tok_code


if Token_Pos106 = No_Token_Index then

         Opt_Res5 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res5,
            Kind              => Ada_Aliased_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos63,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos106 := Row_Pos63;


else

      Opt_Res5 := Allocate_Aliased_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res5,
         Kind              => Ada_Aliased_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos63,
         Token_End_Index   => Token_Pos106 - 1);

end if;

--  End opt_code




if Token_Pos106 /= No_Token_Index then

   Row_Pos63 := Token_Pos106;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res107 := Row_Pos63;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res107));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Constant)
   then
       Token_Pos107 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos63,
             Expected_Token_Id => Ada_Constant,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos107 := Row_Pos63 + 1;
   end if;
end;

--  End tok_code


if Token_Pos107 = No_Token_Index then

         Opt_Res6 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res6,
            Kind              => Ada_Constant_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos63,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos107 := Row_Pos63;


else

      Opt_Res6 := Allocate_Constant_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res6,
         Kind              => Ada_Constant_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos63,
         Token_End_Index   => Token_Pos107 - 1);

end if;

--  End opt_code




if Token_Pos107 /= No_Token_Index then

   Row_Pos63 := Token_Pos107;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;


Defer_Res121 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos63);
Defer_Pos121 := Parser.Current_Pos;




if Defer_Pos121 /= No_Token_Index then

   Row_Pos63 := Defer_Pos121;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row63_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos63 /= No_Token_Index then

   Transform_Res48 := Allocate_Component_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res48,
      Kind => Ada_Component_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos63 = Pos
                            then No_Token_Index
                            else Row_Pos63 - 1));

      Initialize_Fields_For_Component_Def
        (Self => Transform_Res48, Component_Def_F_Has_Aliased => Opt_Res5, Component_Def_F_Has_Constant => Opt_Res6, Component_Def_F_Type_Expr => Defer_Res121);

         if Opt_Res5 /= null and then Is_Incomplete (Opt_Res5) then
            Transform_Res48.Last_Attempted_Child := 0;
         elsif Opt_Res5 /= null and then not Is_Ghost (Opt_Res5) then
            Transform_Res48.Last_Attempted_Child := -1;
         end if;
         if Opt_Res6 /= null and then Is_Incomplete (Opt_Res6) then
            Transform_Res48.Last_Attempted_Child := 0;
         elsif Opt_Res6 /= null and then not Is_Ghost (Opt_Res6) then
            Transform_Res48.Last_Attempted_Child := -1;
         end if;
         if Defer_Res121 /= null and then Is_Incomplete (Defer_Res121) then
            Transform_Res48.Last_Attempted_Child := 0;
         elsif Defer_Res121 /= null and then not Is_Ghost (Defer_Res121) then
            Transform_Res48.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos63 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags48);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Component_Def_Transform_Parse0_Memo,
      Row_Pos63 /= No_Token_Index,
      Transform_Res48,
      Pos,
      Row_Pos63);


   Parser.Current_Pos := Row_Pos63;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res48;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Component_Def_Transform_Parse0;

   


function Component_Item_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos64 :
            Token_Index
               := No_Token_Index;
      Token_Pos108 :
            Token_Index
               := No_Token_Index;
      Token_Res108 :
            Token_Index
               := No_Token_Index;
      Token_Pos109 :
            Token_Index
               := No_Token_Index;
      Token_Res109 :
            Token_Index
               := No_Token_Index;
      Transform_Res49 :
            Bare_Null_Component_Decl
               := No_Bare_Ada_Node;
      Transform_Diags49 :
            Ada.Containers.Count_Type;
      Defer_Pos122 :
            Token_Index
               := No_Token_Index;
      Defer_Res122 :
            Bare_Component_Decl
               := No_Bare_Ada_Node;
      Defer_Pos123 :
            Token_Index
               := No_Token_Index;
      Defer_Res123 :
            Bare_Aspect_Clause
               := No_Bare_Ada_Node;
      Defer_Pos124 :
            Token_Index
               := No_Token_Index;
      Defer_Res124 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos25 :
            Token_Index
               := No_Token_Index;
      Or_Res25 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Component_Item_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res25 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res25;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos25 := No_Token_Index;
Or_Res25 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags49 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos64 := Pos;



--  Start tok_code

Token_Res108 := Row_Pos64;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res108));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos108 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos64 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos64,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos108 := Row_Pos64 + 1;
   end if;
end;

--  End tok_code




if Token_Pos108 /= No_Token_Index then

   Row_Pos64 := Token_Pos108;

else
   Row_Pos64 := No_Token_Index;
   goto Exit_Row64_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res109 := Row_Pos64;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res109));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos109 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos64 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos64,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos109 := Row_Pos64 + 1;
   end if;
end;

--  End tok_code


if Token_Pos109 = No_Token_Index then

         
   Token_Res109 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos64)),
                To_Text ("Missing ';'"));

       
   Token_Pos109 := Row_Pos64;



end if;

--  End opt_code




if Token_Pos109 /= No_Token_Index then

   Row_Pos64 := Token_Pos109;

else
   Row_Pos64 := No_Token_Index;
   goto Exit_Row64_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row64_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos64 /= No_Token_Index then

   Transform_Res49 := Allocate_Null_Component_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res49,
      Kind => Ada_Null_Component_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos64 = Pos
                            then No_Token_Index
                            else Row_Pos64 - 1));




elsif Row_Pos64 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags49);
end if;

--  End transform_code

    if Row_Pos64 /= No_Token_Index then
        Or_Pos25 := Row_Pos64;
        Or_Res25 := Transform_Res49;
        goto Exit_Or26;
    end if;
    
Defer_Res122 :=
   Component_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos122 := Parser.Current_Pos;

    if Defer_Pos122 /= No_Token_Index then
        Or_Pos25 := Defer_Pos122;
        Or_Res25 := Defer_Res122;
        goto Exit_Or26;
    end if;
    
Defer_Res123 :=
   Aspect_Clause_Or_Parse1 (Parser, Pos);
Defer_Pos123 := Parser.Current_Pos;

    if Defer_Pos123 /= No_Token_Index then
        Or_Pos25 := Defer_Pos123;
        Or_Res25 := Defer_Res123;
        goto Exit_Or26;
    end if;
    
Defer_Res124 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos124 := Parser.Current_Pos;

    if Defer_Pos124 /= No_Token_Index then
        Or_Pos25 := Defer_Pos124;
        Or_Res25 := Defer_Res124;
        goto Exit_Or26;
    end if;
<<Exit_Or26>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Component_Item_Or_Parse0_Memo,
      Or_Pos25 /= No_Token_Index,
      Or_Res25,
      Pos,
      Or_Pos25);


   Parser.Current_Pos := Or_Pos25;

   Exit_Call (Parser, Call_Depth);
   return Or_Res25;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Component_Item_Or_Parse0;

   


function Component_List_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Component_List
is
   use Bare_Component_List_Memos;

   Call_Depth : aliased Natural;

      Row_Pos65 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos18 :
            Token_Index
               := No_Token_Index;
      Tmp_List18 :
            Free_Parse_List;
      Defer_Pos125 :
            Token_Index
               := No_Token_Index;
      Defer_Res125 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos18 :
            Token_Index
               := No_Token_Index;
      List_Res18 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Defer_Pos126 :
            Token_Index
               := No_Token_Index;
      Defer_Res126 :
            Bare_Variant_Part
               := No_Bare_Ada_Node;
      Transform_Res50 :
            Bare_Component_List
               := No_Bare_Ada_Node;
      Transform_Diags50 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Component_List_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res50 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res50;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res50;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags50 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos65 := Pos;



--  Start list_code

    List_Pos18 := Row_Pos65;



Lst_Cpos18 := Row_Pos65;
Tmp_List18 := Get_Parse_List (Parser);

loop
   
Defer_Res125 :=
   Component_Item_Or_Parse0 (Parser, Lst_Cpos18);
Defer_Pos125 := Parser.Current_Pos;


   exit when Defer_Pos125 = No_Token_Index;

   List_Pos18 := Defer_Pos125;
   Lst_Cpos18 := List_Pos18;

   Tmp_List18.Nodes.Append (Defer_Res125);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List18.Nodes.Length;
begin
   List_Res18 :=
      Allocate_Ada_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos65;
      Token_End := (if Lst_Cpos18 = Row_Pos65
                    then Row_Pos65
                    else Lst_Cpos18 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos65, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res18,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res18,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List18.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res18.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List18);

--  End list_code




if List_Pos18 /= No_Token_Index then

   Row_Pos65 := List_Pos18;

else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;

end if;


--  Start opt_code












Defer_Res126 :=
   Variant_Part_Transform_Parse0 (Parser, Row_Pos65);
Defer_Pos126 := Parser.Current_Pos;


if Defer_Pos126 = No_Token_Index then

         
   Defer_Res126 := No_Bare_Ada_Node;



       
   Defer_Pos126 := Row_Pos65;



end if;

--  End opt_code




if Defer_Pos126 /= No_Token_Index then

   Row_Pos65 := Defer_Pos126;

else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row65_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos65 /= No_Token_Index then

   Transform_Res50 := Allocate_Component_List (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res50,
      Kind => Ada_Component_List,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos65 = Pos
                            then No_Token_Index
                            else Row_Pos65 - 1));

      Initialize_Fields_For_Component_List
        (Self => Transform_Res50, Component_List_F_Components => List_Res18, Component_List_F_Variant_Part => Defer_Res126);

         if List_Res18 /= null and then Is_Incomplete (List_Res18) then
            Transform_Res50.Last_Attempted_Child := 0;
         elsif List_Res18 /= null and then not Is_Ghost (List_Res18) then
            Transform_Res50.Last_Attempted_Child := -1;
         end if;
         if Defer_Res126 /= null and then Is_Incomplete (Defer_Res126) then
            Transform_Res50.Last_Attempted_Child := 0;
         elsif Defer_Res126 /= null and then not Is_Ghost (Defer_Res126) then
            Transform_Res50.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos65 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags50);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Component_List_Transform_Parse0_Memo,
      Row_Pos65 /= No_Token_Index,
      Transform_Res50,
      Pos,
      Row_Pos65);


   Parser.Current_Pos := Row_Pos65;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res50;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Component_List_Transform_Parse0;

   


function Composite_Constraint_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Constraint
is
   use Bare_Composite_Constraint_Memos;

   Call_Depth : aliased Natural;

      Row_Pos66 :
            Token_Index
               := No_Token_Index;
      Token_Pos110 :
            Token_Index
               := No_Token_Index;
      Token_Res110 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos19 :
            Token_Index
               := No_Token_Index;
      Tmp_List19 :
            Free_Parse_List;
      Defer_Pos127 :
            Token_Index
               := No_Token_Index;
      Defer_Res127 :
            Bare_Composite_Constraint_Assoc
               := No_Bare_Ada_Node;
      Token_Pos111 :
            Token_Index
               := No_Token_Index;
      Token_Res111 :
            Token_Index
               := No_Token_Index;
      List_Pos19 :
            Token_Index
               := No_Token_Index;
      List_Res19 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos112 :
            Token_Index
               := No_Token_Index;
      Token_Res112 :
            Token_Index
               := No_Token_Index;
      Transform_Res51 :
            Bare_Composite_Constraint
               := No_Bare_Ada_Node;
      Transform_Diags51 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Composite_Constraint_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res51 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res51;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res51;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags51 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos66 := Pos;



--  Start tok_code

Token_Res110 := Row_Pos66;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res110));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos110 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos66 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos66,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos110 := Row_Pos66 + 1;
   end if;
end;

--  End tok_code




if Token_Pos110 /= No_Token_Index then

   Row_Pos66 := Token_Pos110;

else
   Row_Pos66 := No_Token_Index;
   goto Exit_Row66_0;

end if;


--  Start list_code

    List_Pos19 := No_Token_Index;



Lst_Cpos19 := Row_Pos66;
Tmp_List19 := Get_Parse_List (Parser);

loop
   
Defer_Res127 :=
   Composite_Constraint_Assoc_Transform_Parse0 (Parser, Lst_Cpos19);
Defer_Pos127 := Parser.Current_Pos;


   exit when Defer_Pos127 = No_Token_Index;

   List_Pos19 := Defer_Pos127;
   Lst_Cpos19 := List_Pos19;

   Tmp_List19.Nodes.Append (Defer_Res127);

      
--  Start tok_code

Token_Res111 := Lst_Cpos19;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res111));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos111 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos19 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos19,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos111 := Lst_Cpos19 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos111 /= No_Token_Index then
          Lst_Cpos19 := Token_Pos111;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List19.Nodes.Length;
begin
   List_Res19 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos66;
      Token_End := (if Lst_Cpos19 = Row_Pos66
                    then Row_Pos66
                    else Lst_Cpos19 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos66, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res19,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res19,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List19.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res19.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List19);

--  End list_code




if List_Pos19 /= No_Token_Index then

   Row_Pos66 := List_Pos19;

else
   Row_Pos66 := No_Token_Index;
   goto Exit_Row66_0;

end if;


--  Start tok_code

Token_Res112 := Row_Pos66;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res112));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos112 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos66 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos66,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos112 := Row_Pos66 + 1;
   end if;
end;

--  End tok_code




if Token_Pos112 /= No_Token_Index then

   Row_Pos66 := Token_Pos112;

else
   Row_Pos66 := No_Token_Index;
   goto Exit_Row66_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row66_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos66 /= No_Token_Index then

   Transform_Res51 := Allocate_Composite_Constraint (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res51,
      Kind => Ada_Composite_Constraint,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos66 = Pos
                            then No_Token_Index
                            else Row_Pos66 - 1));

      Initialize_Fields_For_Composite_Constraint
        (Self => Transform_Res51, Composite_Constraint_F_Constraints => List_Res19);

         if List_Res19 /= null and then Is_Incomplete (List_Res19) then
            Transform_Res51.Last_Attempted_Child := 0;
         elsif List_Res19 /= null and then not Is_Ghost (List_Res19) then
            Transform_Res51.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos66 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags51);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Composite_Constraint_Transform_Parse0_Memo,
      Row_Pos66 /= No_Token_Index,
      Transform_Res51,
      Pos,
      Row_Pos66);


   Parser.Current_Pos := Row_Pos66;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res51;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Composite_Constraint_Transform_Parse0;

   


function Composite_Constraint_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Constraint_Assoc
is
   use Bare_Composite_Constraint_Assoc_Memos;

   Call_Depth : aliased Natural;

      Row_Pos67 :
            Token_Index
               := No_Token_Index;
      Row_Pos68 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos20 :
            Token_Index
               := No_Token_Index;
      Tmp_List20 :
            Free_Parse_List;
      Defer_Pos128 :
            Token_Index
               := No_Token_Index;
      Defer_Res128 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Token_Pos113 :
            Token_Index
               := No_Token_Index;
      Token_Res113 :
            Token_Index
               := No_Token_Index;
      List_Pos20 :
            Token_Index
               := No_Token_Index;
      List_Res20 :
            Bare_Discriminant_Choice_List
               := No_Bare_Ada_Node;
      Token_Pos114 :
            Token_Index
               := No_Token_Index;
      Token_Res114 :
            Token_Index
               := No_Token_Index;
      Defer_Pos129 :
            Token_Index
               := No_Token_Index;
      Defer_Res129 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos130 :
            Token_Index
               := No_Token_Index;
      Defer_Res130 :
            Bare_Discrete_Subtype_Indication
               := No_Bare_Ada_Node;
      Defer_Pos131 :
            Token_Index
               := No_Token_Index;
      Defer_Res131 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos26 :
            Token_Index
               := No_Token_Index;
      Or_Res26 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Transform_Res52 :
            Bare_Composite_Constraint_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags52 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Composite_Constraint_Assoc_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res52 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res52;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res52;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags52 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos67 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos68 := Row_Pos67;



--  Start list_code

    List_Pos20 := No_Token_Index;



Lst_Cpos20 := Row_Pos68;
Tmp_List20 := Get_Parse_List (Parser);

loop
   
Defer_Res128 :=
   Identifier_Transform_Parse0 (Parser, Lst_Cpos20);
Defer_Pos128 := Parser.Current_Pos;


   exit when Defer_Pos128 = No_Token_Index;

   List_Pos20 := Defer_Pos128;
   Lst_Cpos20 := List_Pos20;

   Tmp_List20.Nodes.Append (Defer_Res128);

      
--  Start tok_code

Token_Res113 := Lst_Cpos20;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res113));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pipe)
   then
       Token_Pos113 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos20 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos20,
             Expected_Token_Id => Ada_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos113 := Lst_Cpos20 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos113 /= No_Token_Index then
          Lst_Cpos20 := Token_Pos113;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List20.Nodes.Length;
begin
   List_Res20 :=
      Allocate_Discriminant_Choice_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos68;
      Token_End := (if Lst_Cpos20 = Row_Pos68
                    then Row_Pos68
                    else Lst_Cpos20 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos68, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res20,
      Kind              => Ada_Discriminant_Choice_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res20,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List20.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res20.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List20);

--  End list_code




if List_Pos20 /= No_Token_Index then

   Row_Pos68 := List_Pos20;

else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;

end if;


--  Start tok_code

Token_Res114 := Row_Pos68;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res114));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos114 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos68 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos68,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos114 := Row_Pos68 + 1;
   end if;
end;

--  End tok_code




if Token_Pos114 /= No_Token_Index then

   Row_Pos68 := Token_Pos114;

else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row68_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos68 = No_Token_Index then

         
   List_Res20 :=
     Allocate_Discriminant_Choice_List (Parser.Mem_Pool);
   Initialize
     (Self              => List_Res20,
      Kind              => Ada_Discriminant_Choice_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos67 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => List_Res20,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos68 := Row_Pos67;



end if;

--  End opt_code




if Row_Pos68 /= No_Token_Index then

   Row_Pos67 := Row_Pos68;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;


--  Start or_code

Or_Pos26 := No_Token_Index;
Or_Res26 := No_Bare_Ada_Node;
    
Defer_Res129 :=
   Discrete_Range_Or_Parse0 (Parser, Row_Pos67);
Defer_Pos129 := Parser.Current_Pos;

    if Defer_Pos129 /= No_Token_Index then
        Or_Pos26 := Defer_Pos129;
        Or_Res26 := Defer_Res129;
        goto Exit_Or27;
    end if;
    
Defer_Res130 :=
   Discrete_Subtype_Indication_Transform_Parse0 (Parser, Row_Pos67);
Defer_Pos130 := Parser.Current_Pos;

    if Defer_Pos130 /= No_Token_Index then
        Or_Pos26 := Defer_Pos130;
        Or_Res26 := Defer_Res130;
        goto Exit_Or27;
    end if;
    
Defer_Res131 :=
   Expr_Or_Parse0 (Parser, Row_Pos67);
Defer_Pos131 := Parser.Current_Pos;

    if Defer_Pos131 /= No_Token_Index then
        Or_Pos26 := Defer_Pos131;
        Or_Res26 := Defer_Res131;
        goto Exit_Or27;
    end if;
<<Exit_Or27>>

--  End or_code




if Or_Pos26 /= No_Token_Index then

   Row_Pos67 := Or_Pos26;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row67_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos67 /= No_Token_Index then

   Transform_Res52 := Allocate_Composite_Constraint_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res52,
      Kind => Ada_Composite_Constraint_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos67 = Pos
                            then No_Token_Index
                            else Row_Pos67 - 1));

      Initialize_Fields_For_Composite_Constraint_Assoc
        (Self => Transform_Res52, Composite_Constraint_Assoc_F_Ids => List_Res20, Composite_Constraint_Assoc_F_Constraint_Expr => Or_Res26);

         if List_Res20 /= null and then Is_Incomplete (List_Res20) then
            Transform_Res52.Last_Attempted_Child := 0;
         elsif List_Res20 /= null and then not Is_Ghost (List_Res20) then
            Transform_Res52.Last_Attempted_Child := -1;
         end if;
         if Or_Res26 /= null and then Is_Incomplete (Or_Res26) then
            Transform_Res52.Last_Attempted_Child := 0;
         elsif Or_Res26 /= null and then not Is_Ghost (Or_Res26) then
            Transform_Res52.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos67 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags52);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Composite_Constraint_Assoc_Transform_Parse0_Memo,
      Row_Pos67 /= No_Token_Index,
      Transform_Res52,
      Pos,
      Row_Pos67);


   Parser.Current_Pos := Row_Pos67;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res52;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Composite_Constraint_Assoc_Transform_Parse0;

   


function Compound_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Stmt
is
   use Bare_Composite_Stmt_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos132 :
            Token_Index
               := No_Token_Index;
      Defer_Res132 :
            Bare_If_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos133 :
            Token_Index
               := No_Token_Index;
      Defer_Res133 :
            Bare_Composite_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos134 :
            Token_Index
               := No_Token_Index;
      Defer_Res134 :
            Bare_Composite_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos135 :
            Token_Index
               := No_Token_Index;
      Defer_Res135 :
            Bare_Extended_Return_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos136 :
            Token_Index
               := No_Token_Index;
      Defer_Res136 :
            Bare_Case_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos137 :
            Token_Index
               := No_Token_Index;
      Defer_Res137 :
            Bare_Accept_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos138 :
            Token_Index
               := No_Token_Index;
      Defer_Res138 :
            Bare_Select_Stmt
               := No_Bare_Ada_Node;
      Or_Pos27 :
            Token_Index
               := No_Token_Index;
      Or_Res27 :
            Bare_Composite_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Compound_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res27 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res27;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res27;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos27 := No_Token_Index;
Or_Res27 := No_Bare_Ada_Node;
    
Defer_Res132 :=
   If_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos132 := Parser.Current_Pos;

    if Defer_Pos132 /= No_Token_Index then
        Or_Pos27 := Defer_Pos132;
        Or_Res27 := Defer_Res132;
        goto Exit_Or28;
    end if;
    
Defer_Res133 :=
   Block_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos133 := Parser.Current_Pos;

    if Defer_Pos133 /= No_Token_Index then
        Or_Pos27 := Defer_Pos133;
        Or_Res27 := Defer_Res133;
        goto Exit_Or28;
    end if;
    
Defer_Res134 :=
   Loop_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos134 := Parser.Current_Pos;

    if Defer_Pos134 /= No_Token_Index then
        Or_Pos27 := Defer_Pos134;
        Or_Res27 := Defer_Res134;
        goto Exit_Or28;
    end if;
    
Defer_Res135 :=
   Ext_Return_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos135 := Parser.Current_Pos;

    if Defer_Pos135 /= No_Token_Index then
        Or_Pos27 := Defer_Pos135;
        Or_Res27 := Defer_Res135;
        goto Exit_Or28;
    end if;
    
Defer_Res136 :=
   Case_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos136 := Parser.Current_Pos;

    if Defer_Pos136 /= No_Token_Index then
        Or_Pos27 := Defer_Pos136;
        Or_Res27 := Defer_Res136;
        goto Exit_Or28;
    end if;
    
Defer_Res137 :=
   Accept_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos137 := Parser.Current_Pos;

    if Defer_Pos137 /= No_Token_Index then
        Or_Pos27 := Defer_Pos137;
        Or_Res27 := Defer_Res137;
        goto Exit_Or28;
    end if;
    
Defer_Res138 :=
   Select_Stmt_Transform_Parse1 (Parser, Pos);
Defer_Pos138 := Parser.Current_Pos;

    if Defer_Pos138 /= No_Token_Index then
        Or_Pos27 := Defer_Pos138;
        Or_Res27 := Defer_Res138;
        goto Exit_Or28;
    end if;
<<Exit_Or28>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Compound_Stmt_Or_Parse0_Memo,
      Or_Pos27 /= No_Token_Index,
      Or_Res27,
      Pos,
      Or_Pos27);


   Parser.Current_Pos := Or_Pos27;

   Exit_Call (Parser, Call_Depth);
   return Or_Res27;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Compound_Stmt_Or_Parse0;

   


function Conditional_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos139 :
            Token_Index
               := No_Token_Index;
      Defer_Res139 :
            Bare_If_Expr
               := No_Bare_Ada_Node;
      Defer_Pos140 :
            Token_Index
               := No_Token_Index;
      Defer_Res140 :
            Bare_Case_Expr
               := No_Bare_Ada_Node;
      Defer_Pos141 :
            Token_Index
               := No_Token_Index;
      Defer_Res141 :
            Bare_Quantified_Expr
               := No_Bare_Ada_Node;
      Or_Pos28 :
            Token_Index
               := No_Token_Index;
      Or_Res28 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Conditional_Expr_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res28 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res28;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res28;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos28 := No_Token_Index;
Or_Res28 := No_Bare_Ada_Node;
    
Defer_Res139 :=
   If_Expr_Transform_Parse1 (Parser, Pos);
Defer_Pos139 := Parser.Current_Pos;

    if Defer_Pos139 /= No_Token_Index then
        Or_Pos28 := Defer_Pos139;
        Or_Res28 := Defer_Res139;
        goto Exit_Or29;
    end if;
    
Defer_Res140 :=
   Case_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos140 := Parser.Current_Pos;

    if Defer_Pos140 /= No_Token_Index then
        Or_Pos28 := Defer_Pos140;
        Or_Res28 := Defer_Res140;
        goto Exit_Or29;
    end if;
    
Defer_Res141 :=
   Quantified_Expr_Transform_Parse2 (Parser, Pos);
Defer_Pos141 := Parser.Current_Pos;

    if Defer_Pos141 /= No_Token_Index then
        Or_Pos28 := Defer_Pos141;
        Or_Res28 := Defer_Res141;
        goto Exit_Or29;
    end if;
<<Exit_Or29>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Conditional_Expr_Or_Parse0_Memo,
      Or_Pos28 /= No_Token_Index,
      Or_Res28,
      Pos,
      Or_Pos28);


   Parser.Current_Pos := Or_Pos28;

   Exit_Call (Parser, Call_Depth);
   return Or_Res28;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Conditional_Expr_Or_Parse0;

   


function Constrained_Subtype_Indication_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Constrained_Subtype_Indication
is
   use Bare_Constrained_Subtype_Indication_Memos;

   Call_Depth : aliased Natural;

      Row_Pos69 :
            Token_Index
               := No_Token_Index;
      Row_Pos70 :
            Token_Index
               := No_Token_Index;
      Token_Pos115 :
            Token_Index
               := No_Token_Index;
      Token_Res115 :
            Token_Index
               := No_Token_Index;
      Token_Pos116 :
            Token_Index
               := No_Token_Index;
      Token_Res116 :
            Token_Index
               := No_Token_Index;
      Opt_Res7 :
            Bare_Not_Null
               := No_Bare_Ada_Node;
      Defer_Pos142 :
            Token_Index
               := No_Token_Index;
      Defer_Res142 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos143 :
            Token_Index
               := No_Token_Index;
      Defer_Res143 :
            Bare_Constraint
               := No_Bare_Ada_Node;
      Transform_Res53 :
            Bare_Constrained_Subtype_Indication
               := No_Bare_Ada_Node;
      Transform_Diags53 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Constrained_Subtype_Indication_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res53 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res53;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res53;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags53 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos69 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos70 := Row_Pos69;



--  Start tok_code

Token_Res115 := Row_Pos70;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res115));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos115 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos70,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos115 := Row_Pos70 + 1;
   end if;
end;

--  End tok_code




if Token_Pos115 /= No_Token_Index then

   Row_Pos70 := Token_Pos115;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;


--  Start tok_code

Token_Res116 := Row_Pos70;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res116));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos116 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos70,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos116 := Row_Pos70 + 1;
   end if;
end;

--  End tok_code




if Token_Pos116 /= No_Token_Index then

   Row_Pos70 := Token_Pos116;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row70_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos70 = No_Token_Index then

         Opt_Res7 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res7,
            Kind              => Ada_Not_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos69,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos70 := Row_Pos69;


else

      Opt_Res7 := Allocate_Not_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res7,
         Kind              => Ada_Not_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos69,
         Token_End_Index   => Row_Pos70 - 1);

end if;

--  End opt_code




if Row_Pos70 /= No_Token_Index then

   Row_Pos69 := Row_Pos70;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


Defer_Res142 :=
   Subtype_Name_Or_Parse0 (Parser, Row_Pos69);
Defer_Pos142 := Parser.Current_Pos;




if Defer_Pos142 /= No_Token_Index then

   Row_Pos69 := Defer_Pos142;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


Defer_Res143 :=
   Constraint_Or_Parse0 (Parser, Row_Pos69);
Defer_Pos143 := Parser.Current_Pos;




if Defer_Pos143 /= No_Token_Index then

   Row_Pos69 := Defer_Pos143;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row69_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos69 /= No_Token_Index then

   Transform_Res53 := Allocate_Constrained_Subtype_Indication (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res53,
      Kind => Ada_Constrained_Subtype_Indication,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos69 = Pos
                            then No_Token_Index
                            else Row_Pos69 - 1));

      Initialize_Fields_For_Constrained_Subtype_Indication
        (Self => Transform_Res53, Subtype_Indication_F_Has_Not_Null => Opt_Res7, Subtype_Indication_F_Name => Defer_Res142, Subtype_Indication_F_Constraint => Defer_Res143);

         if Opt_Res7 /= null and then Is_Incomplete (Opt_Res7) then
            Transform_Res53.Last_Attempted_Child := 0;
         elsif Opt_Res7 /= null and then not Is_Ghost (Opt_Res7) then
            Transform_Res53.Last_Attempted_Child := -1;
         end if;
         if Defer_Res142 /= null and then Is_Incomplete (Defer_Res142) then
            Transform_Res53.Last_Attempted_Child := 0;
         elsif Defer_Res142 /= null and then not Is_Ghost (Defer_Res142) then
            Transform_Res53.Last_Attempted_Child := -1;
         end if;
         if Defer_Res143 /= null and then Is_Incomplete (Defer_Res143) then
            Transform_Res53.Last_Attempted_Child := 0;
         elsif Defer_Res143 /= null and then not Is_Ghost (Defer_Res143) then
            Transform_Res53.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos69 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags53);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Constrained_Subtype_Indication_Transform_Parse0_Memo,
      Row_Pos69 /= No_Token_Index,
      Transform_Res53,
      Pos,
      Row_Pos69);


   Parser.Current_Pos := Row_Pos69;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res53;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Constrained_Subtype_Indication_Transform_Parse0;

   


function Constraint_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Constraint
is
   use Bare_Constraint_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos144 :
            Token_Index
               := No_Token_Index;
      Defer_Res144 :
            Bare_Digits_Constraint
               := No_Bare_Ada_Node;
      Defer_Pos145 :
            Token_Index
               := No_Token_Index;
      Defer_Res145 :
            Bare_Delta_Constraint
               := No_Bare_Ada_Node;
      Defer_Pos146 :
            Token_Index
               := No_Token_Index;
      Defer_Res146 :
            Bare_Range_Constraint
               := No_Bare_Ada_Node;
      Defer_Pos147 :
            Token_Index
               := No_Token_Index;
      Defer_Res147 :
            Bare_Composite_Constraint
               := No_Bare_Ada_Node;
      Or_Pos29 :
            Token_Index
               := No_Token_Index;
      Or_Res29 :
            Bare_Constraint
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Constraint_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res29 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res29;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res29;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos29 := No_Token_Index;
Or_Res29 := No_Bare_Ada_Node;
    
Defer_Res144 :=
   Digits_Constraint_Transform_Parse0 (Parser, Pos);
Defer_Pos144 := Parser.Current_Pos;

    if Defer_Pos144 /= No_Token_Index then
        Or_Pos29 := Defer_Pos144;
        Or_Res29 := Defer_Res144;
        goto Exit_Or30;
    end if;
    
Defer_Res145 :=
   Delta_Constraint_Transform_Parse0 (Parser, Pos);
Defer_Pos145 := Parser.Current_Pos;

    if Defer_Pos145 /= No_Token_Index then
        Or_Pos29 := Defer_Pos145;
        Or_Res29 := Defer_Res145;
        goto Exit_Or30;
    end if;
    
Defer_Res146 :=
   Range_Constraint_Transform_Parse1 (Parser, Pos);
Defer_Pos146 := Parser.Current_Pos;

    if Defer_Pos146 /= No_Token_Index then
        Or_Pos29 := Defer_Pos146;
        Or_Res29 := Defer_Res146;
        goto Exit_Or30;
    end if;
    
Defer_Res147 :=
   Composite_Constraint_Transform_Parse0 (Parser, Pos);
Defer_Pos147 := Parser.Current_Pos;

    if Defer_Pos147 /= No_Token_Index then
        Or_Pos29 := Defer_Pos147;
        Or_Res29 := Defer_Res147;
        goto Exit_Or30;
    end if;
<<Exit_Or30>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Constraint_Or_Parse0_Memo,
      Or_Pos29 /= No_Token_Index,
      Or_Res29,
      Pos,
      Or_Pos29);


   Parser.Current_Pos := Or_Pos29;

   Exit_Call (Parser, Call_Depth);
   return Or_Res29;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Constraint_Or_Parse0;

   


function Constraint_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Constraint_List
is
   use Bare_Constraint_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos21 :
            Token_Index
               := No_Token_Index;
      Tmp_List21 :
            Free_Parse_List;
      Defer_Pos148 :
            Token_Index
               := No_Token_Index;
      Defer_Res148 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos117 :
            Token_Index
               := No_Token_Index;
      Token_Res117 :
            Token_Index
               := No_Token_Index;
      List_Pos21 :
            Token_Index
               := No_Token_Index;
      List_Res21 :
            Bare_Constraint_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Constraint_List_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res21 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res21;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res21;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos21 := No_Token_Index;



Lst_Cpos21 := Pos;
Tmp_List21 := Get_Parse_List (Parser);

loop
   
Defer_Res148 :=
   Discrete_Subtype_Definition_Or_Parse0 (Parser, Lst_Cpos21);
Defer_Pos148 := Parser.Current_Pos;


   exit when Defer_Pos148 = No_Token_Index;

   List_Pos21 := Defer_Pos148;
   Lst_Cpos21 := List_Pos21;

   Tmp_List21.Nodes.Append (Defer_Res148);

      
--  Start tok_code

Token_Res117 := Lst_Cpos21;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res117));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos117 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos21 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos21,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos117 := Lst_Cpos21 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos117 /= No_Token_Index then
          Lst_Cpos21 := Token_Pos117;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List21.Nodes.Length;
begin
   List_Res21 :=
      Allocate_Constraint_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos21 = Pos
                    then Pos
                    else Lst_Cpos21 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res21,
      Kind              => Ada_Constraint_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res21,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List21.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res21.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List21);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Constraint_List_List_Parse0_Memo,
      List_Pos21 /= No_Token_Index,
      List_Res21,
      Pos,
      List_Pos21);


   Parser.Current_Pos := List_Pos21;

   Exit_Call (Parser, Call_Depth);
   return List_Res21;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Constraint_List_List_Parse0;

   


function Context_Item_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos149 :
            Token_Index
               := No_Token_Index;
      Defer_Res149 :
            Bare_With_Clause
               := No_Bare_Ada_Node;
      Defer_Pos150 :
            Token_Index
               := No_Token_Index;
      Defer_Res150 :
            Bare_Use_Clause
               := No_Bare_Ada_Node;
      Defer_Pos151 :
            Token_Index
               := No_Token_Index;
      Defer_Res151 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos30 :
            Token_Index
               := No_Token_Index;
      Or_Res30 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Context_Item_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res30 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res30;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res30;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos30 := No_Token_Index;
Or_Res30 := No_Bare_Ada_Node;
    
Defer_Res149 :=
   With_Clause_Transform_Parse0 (Parser, Pos);
Defer_Pos149 := Parser.Current_Pos;

    if Defer_Pos149 /= No_Token_Index then
        Or_Pos30 := Defer_Pos149;
        Or_Res30 := Defer_Res149;
        goto Exit_Or31;
    end if;
    
Defer_Res150 :=
   Use_Clause_Or_Parse0 (Parser, Pos);
Defer_Pos150 := Parser.Current_Pos;

    if Defer_Pos150 /= No_Token_Index then
        Or_Pos30 := Defer_Pos150;
        Or_Res30 := Defer_Res150;
        goto Exit_Or31;
    end if;
    
Defer_Res151 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos151 := Parser.Current_Pos;

    if Defer_Pos151 /= No_Token_Index then
        Or_Pos30 := Defer_Pos151;
        Or_Res30 := Defer_Res151;
        goto Exit_Or31;
    end if;
<<Exit_Or31>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Context_Item_Or_Parse0_Memo,
      Or_Pos30 /= No_Token_Index,
      Or_Res30,
      Pos,
      Or_Pos30);


   Parser.Current_Pos := Or_Pos30;

   Exit_Call (Parser, Call_Depth);
   return Or_Res30;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Context_Item_Or_Parse0;

   


function Contract_Case_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Contract_Case_Assoc
is
   use Bare_Contract_Case_Assoc_Memos;

   Call_Depth : aliased Natural;

      Row_Pos71 :
            Token_Index
               := No_Token_Index;
      Defer_Pos152 :
            Token_Index
               := No_Token_Index;
      Defer_Res152 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos153 :
            Token_Index
               := No_Token_Index;
      Defer_Res153 :
            Bare_Others_Designator
               := No_Bare_Ada_Node;
      Or_Pos31 :
            Token_Index
               := No_Token_Index;
      Or_Res31 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos118 :
            Token_Index
               := No_Token_Index;
      Token_Res118 :
            Token_Index
               := No_Token_Index;
      Defer_Pos154 :
            Token_Index
               := No_Token_Index;
      Defer_Res154 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res54 :
            Bare_Contract_Case_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags54 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Contract_Case_Assoc_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res54 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res54;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res54;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags54 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos71 := Pos;



--  Start or_code

Or_Pos31 := No_Token_Index;
Or_Res31 := No_Bare_Ada_Node;
    
Defer_Res152 :=
   Expr_Or_Parse0 (Parser, Row_Pos71);
Defer_Pos152 := Parser.Current_Pos;

    if Defer_Pos152 /= No_Token_Index then
        Or_Pos31 := Defer_Pos152;
        Or_Res31 := Defer_Res152;
        goto Exit_Or32;
    end if;
    
Defer_Res153 :=
   Others_Designator_Transform_Parse0 (Parser, Row_Pos71);
Defer_Pos153 := Parser.Current_Pos;

    if Defer_Pos153 /= No_Token_Index then
        Or_Pos31 := Defer_Pos153;
        Or_Res31 := Defer_Res153;
        goto Exit_Or32;
    end if;
<<Exit_Or32>>

--  End or_code




if Or_Pos31 /= No_Token_Index then

   Row_Pos71 := Or_Pos31;

else
   Row_Pos71 := No_Token_Index;
   goto Exit_Row71_0;

end if;


--  Start tok_code

Token_Res118 := Row_Pos71;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res118));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos118 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos71 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos71,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos118 := Row_Pos71 + 1;
   end if;
end;

--  End tok_code




if Token_Pos118 /= No_Token_Index then

   Row_Pos71 := Token_Pos118;

else
   Row_Pos71 := No_Token_Index;
   goto Exit_Row71_0;

end if;


Defer_Res154 :=
   Expr_Or_Parse0 (Parser, Row_Pos71);
Defer_Pos154 := Parser.Current_Pos;




if Defer_Pos154 /= No_Token_Index then

   Row_Pos71 := Defer_Pos154;

else
   Row_Pos71 := No_Token_Index;
   goto Exit_Row71_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row71_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos71 /= No_Token_Index then

   Transform_Res54 := Allocate_Contract_Case_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res54,
      Kind => Ada_Contract_Case_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos71 = Pos
                            then No_Token_Index
                            else Row_Pos71 - 1));

      Initialize_Fields_For_Contract_Case_Assoc
        (Self => Transform_Res54, Contract_Case_Assoc_F_Guard => Or_Res31, Contract_Case_Assoc_F_Consequence => Defer_Res154);

         if Or_Res31 /= null and then Is_Incomplete (Or_Res31) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Or_Res31 /= null and then not Is_Ghost (Or_Res31) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
         if Defer_Res154 /= null and then Is_Incomplete (Defer_Res154) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res154 /= null and then not Is_Ghost (Defer_Res154) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos71 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags54);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Contract_Case_Assoc_Transform_Parse0_Memo,
      Row_Pos71 /= No_Token_Index,
      Transform_Res54,
      Pos,
      Row_Pos71);


   Parser.Current_Pos := Row_Pos71;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res54;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Contract_Case_Assoc_Transform_Parse0;

   


function Contract_Cases_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Contract_Cases
is
   use Bare_Contract_Cases_Memos;

   Call_Depth : aliased Natural;

      Row_Pos72 :
            Token_Index
               := No_Token_Index;
      Token_Pos119 :
            Token_Index
               := No_Token_Index;
      Token_Res119 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos22 :
            Token_Index
               := No_Token_Index;
      Tmp_List22 :
            Free_Parse_List;
      Defer_Pos155 :
            Token_Index
               := No_Token_Index;
      Defer_Res155 :
            Bare_Contract_Case_Assoc
               := No_Bare_Ada_Node;
      Token_Pos120 :
            Token_Index
               := No_Token_Index;
      Token_Res120 :
            Token_Index
               := No_Token_Index;
      List_Pos22 :
            Token_Index
               := No_Token_Index;
      List_Res22 :
            Bare_Contract_Case_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos121 :
            Token_Index
               := No_Token_Index;
      Token_Res121 :
            Token_Index
               := No_Token_Index;
      Transform_Res55 :
            Bare_Contract_Cases
               := No_Bare_Ada_Node;
      Transform_Diags55 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Contract_Cases_Expr_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res55 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res55;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res55;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags55 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos72 := Pos;



--  Start tok_code

Token_Res119 := Row_Pos72;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res119));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos119 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos72 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos72,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos119 := Row_Pos72 + 1;
   end if;
end;

--  End tok_code




if Token_Pos119 /= No_Token_Index then

   Row_Pos72 := Token_Pos119;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  Start list_code

    List_Pos22 := No_Token_Index;



Lst_Cpos22 := Row_Pos72;
Tmp_List22 := Get_Parse_List (Parser);

loop
   
Defer_Res155 :=
   Contract_Case_Assoc_Transform_Parse0 (Parser, Lst_Cpos22);
Defer_Pos155 := Parser.Current_Pos;


   exit when Defer_Pos155 = No_Token_Index;

   List_Pos22 := Defer_Pos155;
   Lst_Cpos22 := List_Pos22;

   Tmp_List22.Nodes.Append (Defer_Res155);

      
--  Start tok_code

Token_Res120 := Lst_Cpos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res120));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos120 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos22,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos120 := Lst_Cpos22 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos120 /= No_Token_Index then
          Lst_Cpos22 := Token_Pos120;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List22.Nodes.Length;
begin
   List_Res22 :=
      Allocate_Contract_Case_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos72;
      Token_End := (if Lst_Cpos22 = Row_Pos72
                    then Row_Pos72
                    else Lst_Cpos22 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos72, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res22,
      Kind              => Ada_Contract_Case_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res22,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List22.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res22.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List22);

--  End list_code




if List_Pos22 /= No_Token_Index then

   Row_Pos72 := List_Pos22;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  Start tok_code

Token_Res121 := Row_Pos72;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res121));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos121 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos72 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos72,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos121 := Row_Pos72 + 1;
   end if;
end;

--  End tok_code




if Token_Pos121 /= No_Token_Index then

   Row_Pos72 := Token_Pos121;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row72_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos72 /= No_Token_Index then

   Transform_Res55 := Allocate_Contract_Cases (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res55,
      Kind => Ada_Contract_Cases,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos72 = Pos
                            then No_Token_Index
                            else Row_Pos72 - 1));

      Initialize_Fields_For_Contract_Cases
        (Self => Transform_Res55, Contract_Cases_F_Contract_Cases => List_Res22);

         if List_Res22 /= null and then Is_Incomplete (List_Res22) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif List_Res22 /= null and then not Is_Ghost (List_Res22) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos72 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags55);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Contract_Cases_Expr_Transform_Parse0_Memo,
      Row_Pos72 /= No_Token_Index,
      Transform_Res55,
      Pos,
      Row_Pos72);


   Parser.Current_Pos := Row_Pos72;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res55;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Contract_Cases_Expr_Transform_Parse0;

   


function Dec_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Real_Literal
is
   use Bare_Real_Literal_Memos;

   Call_Depth : aliased Natural;

      Row_Pos73 :
            Token_Index
               := No_Token_Index;
      Token_Pos122 :
            Token_Index
               := No_Token_Index;
      Token_Res122 :
            Token_Index
               := No_Token_Index;
      Transform_Res56 :
            Bare_Real_Literal
               := No_Bare_Ada_Node;
      Transform_Diags56 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Dec_Literal_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res56 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res56;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res56;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags56 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos73 := Pos;



--  Start tok_code

Token_Res122 := Row_Pos73;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res122));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Decimal)
   then
       Token_Pos122 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos73 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos73,
             Expected_Token_Id => Ada_Decimal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos122 := Row_Pos73 + 1;
   end if;
end;

--  End tok_code




if Token_Pos122 /= No_Token_Index then

   Row_Pos73 := Token_Pos122;

else
   Row_Pos73 := No_Token_Index;
   goto Exit_Row73_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row73_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos73 /= No_Token_Index then

   Transform_Res56 := Allocate_Real_Literal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res56,
      Kind => Ada_Real_Literal,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos73 = Pos
                            then No_Token_Index
                            else Row_Pos73 - 1));

      Initialize_Fields_For_Real_Literal
        (Self => Transform_Res56);



elsif Row_Pos73 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags56);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dec_Literal_Transform_Parse0_Memo,
      Row_Pos73 /= No_Token_Index,
      Transform_Res56,
      Pos,
      Row_Pos73);


   Parser.Current_Pos := Row_Pos73;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res56;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dec_Literal_Transform_Parse0;

   


function Decimal_Fixed_Point_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decimal_Fixed_Point_Def
is
   use Bare_Decimal_Fixed_Point_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos74 :
            Token_Index
               := No_Token_Index;
      Token_Pos123 :
            Token_Index
               := No_Token_Index;
      Token_Res123 :
            Token_Index
               := No_Token_Index;
      Defer_Pos156 :
            Token_Index
               := No_Token_Index;
      Defer_Res156 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos124 :
            Token_Index
               := No_Token_Index;
      Token_Res124 :
            Token_Index
               := No_Token_Index;
      Defer_Pos157 :
            Token_Index
               := No_Token_Index;
      Defer_Res157 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos158 :
            Token_Index
               := No_Token_Index;
      Defer_Res158 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Res57 :
            Bare_Decimal_Fixed_Point_Def
               := No_Bare_Ada_Node;
      Transform_Diags57 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Decimal_Fixed_Point_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res57 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res57;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res57;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags57 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos74 := Pos;



--  Start tok_code

Token_Res123 := Row_Pos74;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res123));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Delta)
   then
       Token_Pos123 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos74 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos74,
             Expected_Token_Id => Ada_Delta,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos123 := Row_Pos74 + 1;
   end if;
end;

--  End tok_code




if Token_Pos123 /= No_Token_Index then

   Row_Pos74 := Token_Pos123;

else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;

end if;


Defer_Res156 :=
   Sexpr_Or_Box_Or_Parse0 (Parser, Row_Pos74);
Defer_Pos156 := Parser.Current_Pos;




if Defer_Pos156 /= No_Token_Index then

   Row_Pos74 := Defer_Pos156;

else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;

end if;


--  Start tok_code

Token_Res124 := Row_Pos74;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res124));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Digits)
   then
       Token_Pos124 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos74 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos74,
             Expected_Token_Id => Ada_Digits,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos124 := Row_Pos74 + 1;
   end if;
end;

--  End tok_code




if Token_Pos124 /= No_Token_Index then

   Row_Pos74 := Token_Pos124;

else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;

end if;


Defer_Res157 :=
   Sexpr_Or_Box_Or_Parse0 (Parser, Row_Pos74);
Defer_Pos157 := Parser.Current_Pos;




if Defer_Pos157 /= No_Token_Index then

   Row_Pos74 := Defer_Pos157;

else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;

end if;


--  Start opt_code












Defer_Res158 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos74);
Defer_Pos158 := Parser.Current_Pos;


if Defer_Pos158 = No_Token_Index then

         
   Defer_Res158 := No_Bare_Ada_Node;



       
   Defer_Pos158 := Row_Pos74;



end if;

--  End opt_code




if Defer_Pos158 /= No_Token_Index then

   Row_Pos74 := Defer_Pos158;

else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row74_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos74 /= No_Token_Index then

   Transform_Res57 := Allocate_Decimal_Fixed_Point_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res57,
      Kind => Ada_Decimal_Fixed_Point_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos74 = Pos
                            then No_Token_Index
                            else Row_Pos74 - 1));

      Initialize_Fields_For_Decimal_Fixed_Point_Def
        (Self => Transform_Res57, Decimal_Fixed_Point_Def_F_Delta => Defer_Res156, Decimal_Fixed_Point_Def_F_Digits => Defer_Res157, Decimal_Fixed_Point_Def_F_Range => Defer_Res158);

         if Defer_Res156 /= null and then Is_Incomplete (Defer_Res156) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res156 /= null and then not Is_Ghost (Defer_Res156) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res157 /= null and then Is_Incomplete (Defer_Res157) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res157 /= null and then not Is_Ghost (Defer_Res157) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res158 /= null and then Is_Incomplete (Defer_Res158) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res158 /= null and then not Is_Ghost (Defer_Res158) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos74 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags57);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Decimal_Fixed_Point_Def_Transform_Parse0_Memo,
      Row_Pos74 /= No_Token_Index,
      Transform_Res57,
      Pos,
      Row_Pos74);


   Parser.Current_Pos := Row_Pos74;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res57;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Decimal_Fixed_Point_Def_Transform_Parse0;

   


function Decl_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Declarative_Part
is
   use Bare_Declarative_Part_Memos;

   Call_Depth : aliased Natural;

      Row_Pos75 :
            Token_Index
               := No_Token_Index;
      Defer_Pos159 :
            Token_Index
               := No_Token_Index;
      Defer_Res159 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res58 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Transform_Diags58 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Decl_Part_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res58 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res58;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res58;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags58 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos75 := Pos;



Defer_Res159 :=
   Basic_Decls_List_Parse0 (Parser, Row_Pos75);
Defer_Pos159 := Parser.Current_Pos;




if Defer_Pos159 /= No_Token_Index then

   Row_Pos75 := Defer_Pos159;

else
   Row_Pos75 := No_Token_Index;
   goto Exit_Row75_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row75_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos75 /= No_Token_Index then

   Transform_Res58 := Allocate_Declarative_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res58,
      Kind => Ada_Declarative_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos75 = Pos
                            then No_Token_Index
                            else Row_Pos75 - 1));

      Initialize_Fields_For_Declarative_Part
        (Self => Transform_Res58, Declarative_Part_F_Decls => Defer_Res159);

         if Defer_Res159 /= null and then Is_Incomplete (Defer_Res159) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif Defer_Res159 /= null and then not Is_Ghost (Defer_Res159) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos75 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags58);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Decl_Part_Transform_Parse0_Memo,
      Row_Pos75 /= No_Token_Index,
      Transform_Res58,
      Pos,
      Row_Pos75);


   Parser.Current_Pos := Row_Pos75;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res58;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Decl_Part_Transform_Parse0;

   


function Declare_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Expr
is
   use Bare_Decl_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos76 :
            Token_Index
               := No_Token_Index;
      Token_Pos125 :
            Token_Index
               := No_Token_Index;
      Token_Res125 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos23 :
            Token_Index
               := No_Token_Index;
      Tmp_List23 :
            Free_Parse_List;
      Defer_Pos160 :
            Token_Index
               := No_Token_Index;
      Defer_Res160 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;
      List_Pos23 :
            Token_Index
               := No_Token_Index;
      List_Res23 :
            Bare_Basic_Decl_List
               := No_Bare_Ada_Node;
      Token_Pos126 :
            Token_Index
               := No_Token_Index;
      Token_Res126 :
            Token_Index
               := No_Token_Index;
      Defer_Pos161 :
            Token_Index
               := No_Token_Index;
      Defer_Res161 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res59 :
            Bare_Decl_Expr
               := No_Bare_Ada_Node;
      Transform_Diags59 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Declare_Expr_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res59 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res59;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res59;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags59 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos76 := Pos;



--  Start tok_code

Token_Res125 := Row_Pos76;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res125));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Declare)
   then
       Token_Pos125 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos76 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos76,
             Expected_Token_Id => Ada_Declare,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos125 := Row_Pos76 + 1;
   end if;
end;

--  End tok_code




if Token_Pos125 /= No_Token_Index then

   Row_Pos76 := Token_Pos125;

else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;

end if;


--  Start list_code

    List_Pos23 := Row_Pos76;



Lst_Cpos23 := Row_Pos76;
Tmp_List23 := Get_Parse_List (Parser);

loop
   
Defer_Res160 :=
   Object_Decl_Or_Parse0 (Parser, Lst_Cpos23);
Defer_Pos160 := Parser.Current_Pos;


   exit when Defer_Pos160 = No_Token_Index;

   List_Pos23 := Defer_Pos160;
   Lst_Cpos23 := List_Pos23;

   Tmp_List23.Nodes.Append (Defer_Res160);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List23.Nodes.Length;
begin
   List_Res23 :=
      Allocate_Basic_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos76;
      Token_End := (if Lst_Cpos23 = Row_Pos76
                    then Row_Pos76
                    else Lst_Cpos23 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos76, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res23,
      Kind              => Ada_Basic_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res23,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List23.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res23.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List23);

--  End list_code




if List_Pos23 /= No_Token_Index then

   Row_Pos76 := List_Pos23;

else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;

end if;


--  Start tok_code

Token_Res126 := Row_Pos76;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res126));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos126 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos76 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos76,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos126 := Row_Pos76 + 1;
   end if;
end;

--  End tok_code




if Token_Pos126 /= No_Token_Index then

   Row_Pos76 := Token_Pos126;

else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;

end if;


Defer_Res161 :=
   Expr_Or_Parse0 (Parser, Row_Pos76);
Defer_Pos161 := Parser.Current_Pos;




if Defer_Pos161 /= No_Token_Index then

   Row_Pos76 := Defer_Pos161;

else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row76_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos76 /= No_Token_Index then

   Transform_Res59 := Allocate_Decl_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res59,
      Kind => Ada_Decl_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos76 = Pos
                            then No_Token_Index
                            else Row_Pos76 - 1));

      Initialize_Fields_For_Decl_Expr
        (Self => Transform_Res59, Decl_Expr_F_Decls => List_Res23, Decl_Expr_F_Expr => Defer_Res161);

         if List_Res23 /= null and then Is_Incomplete (List_Res23) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif List_Res23 /= null and then not Is_Ghost (List_Res23) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;
         if Defer_Res161 /= null and then Is_Incomplete (Defer_Res161) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif Defer_Res161 /= null and then not Is_Ghost (Defer_Res161) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos76 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags59);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Declare_Expr_Transform_Parse0_Memo,
      Row_Pos76 /= No_Token_Index,
      Transform_Res59,
      Pos,
      Row_Pos76);


   Parser.Current_Pos := Row_Pos76;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res59;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Declare_Expr_Transform_Parse0;

   


function Defining_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Defining_Name
is
   use Bare_Defining_Name_Memos;

   Call_Depth : aliased Natural;

      Row_Pos77 :
            Token_Index
               := No_Token_Index;
      Defer_Pos162 :
            Token_Index
               := No_Token_Index;
      Defer_Res162 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res60 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Diags60 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Defining_Id_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res60 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res60;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res60;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags60 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos77 := Pos;



Defer_Res162 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos77);
Defer_Pos162 := Parser.Current_Pos;




if Defer_Pos162 /= No_Token_Index then

   Row_Pos77 := Defer_Pos162;

else
   Row_Pos77 := No_Token_Index;
   goto Exit_Row77_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row77_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos77 /= No_Token_Index then

   Transform_Res60 := Allocate_Defining_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res60,
      Kind => Ada_Defining_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos77 = Pos
                            then No_Token_Index
                            else Row_Pos77 - 1));

      Initialize_Fields_For_Defining_Name
        (Self => Transform_Res60, Defining_Name_F_Name => Defer_Res162);

         if Defer_Res162 /= null and then Is_Incomplete (Defer_Res162) then
            Transform_Res60.Last_Attempted_Child := 0;
         elsif Defer_Res162 /= null and then not Is_Ghost (Defer_Res162) then
            Transform_Res60.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos77 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags60);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Defining_Id_Transform_Parse0_Memo,
      Row_Pos77 /= No_Token_Index,
      Transform_Res60,
      Pos,
      Row_Pos77);


   Parser.Current_Pos := Row_Pos77;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res60;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Defining_Id_Transform_Parse0;

   


function Defining_Id_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Defining_Name_List
is
   use Bare_Defining_Name_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos24 :
            Token_Index
               := No_Token_Index;
      Tmp_List24 :
            Free_Parse_List;
      Defer_Pos163 :
            Token_Index
               := No_Token_Index;
      Defer_Res163 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos127 :
            Token_Index
               := No_Token_Index;
      Token_Res127 :
            Token_Index
               := No_Token_Index;
      List_Pos24 :
            Token_Index
               := No_Token_Index;
      List_Res24 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Defining_Id_List_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res24 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res24;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res24;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos24 := No_Token_Index;



Lst_Cpos24 := Pos;
Tmp_List24 := Get_Parse_List (Parser);

loop
   
Defer_Res163 :=
   Defining_Id_Transform_Parse0 (Parser, Lst_Cpos24);
Defer_Pos163 := Parser.Current_Pos;


   exit when Defer_Pos163 = No_Token_Index;

   List_Pos24 := Defer_Pos163;
   Lst_Cpos24 := List_Pos24;

   Tmp_List24.Nodes.Append (Defer_Res163);

      
--  Start tok_code

Token_Res127 := Lst_Cpos24;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res127));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos127 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos24 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos24,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos127 := Lst_Cpos24 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos127 /= No_Token_Index then
          Lst_Cpos24 := Token_Pos127;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List24.Nodes.Length;
begin
   List_Res24 :=
      Allocate_Defining_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos24 = Pos
                    then Pos
                    else Lst_Cpos24 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res24,
      Kind              => Ada_Defining_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res24,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List24.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res24.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List24);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Defining_Id_List_List_Parse0_Memo,
      List_Pos24 /= No_Token_Index,
      List_Res24,
      Pos,
      List_Pos24);


   Parser.Current_Pos := List_Pos24;

   Exit_Call (Parser, Call_Depth);
   return List_Res24;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Defining_Id_List_List_Parse0;

   


function Defining_Name_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Defining_Name
is
   use Bare_Defining_Name_Memos;

   Call_Depth : aliased Natural;

      Row_Pos78 :
            Token_Index
               := No_Token_Index;
      Defer_Pos164 :
            Token_Index
               := No_Token_Index;
      Defer_Res164 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res61 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Diags61 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Defining_Name_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res61 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res61;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res61;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags61 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos78 := Pos;



Defer_Res164 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos78);
Defer_Pos164 := Parser.Current_Pos;




if Defer_Pos164 /= No_Token_Index then

   Row_Pos78 := Defer_Pos164;

else
   Row_Pos78 := No_Token_Index;
   goto Exit_Row78_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row78_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos78 /= No_Token_Index then

   Transform_Res61 := Allocate_Defining_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res61,
      Kind => Ada_Defining_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos78 = Pos
                            then No_Token_Index
                            else Row_Pos78 - 1));

      Initialize_Fields_For_Defining_Name
        (Self => Transform_Res61, Defining_Name_F_Name => Defer_Res164);

         if Defer_Res164 /= null and then Is_Incomplete (Defer_Res164) then
            Transform_Res61.Last_Attempted_Child := 0;
         elsif Defer_Res164 /= null and then not Is_Ghost (Defer_Res164) then
            Transform_Res61.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos78 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags61);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Defining_Name_Transform_Parse0_Memo,
      Row_Pos78 /= No_Token_Index,
      Transform_Res61,
      Pos,
      Row_Pos78);


   Parser.Current_Pos := Row_Pos78;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res61;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Defining_Name_Transform_Parse0;

   


function Delay_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Delay_Stmt
is
   use Bare_Delay_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos79 :
            Token_Index
               := No_Token_Index;
      Token_Pos128 :
            Token_Index
               := No_Token_Index;
      Token_Res128 :
            Token_Index
               := No_Token_Index;
      Token_Pos129 :
            Token_Index
               := No_Token_Index;
      Token_Res129 :
            Token_Index
               := No_Token_Index;
      Opt_Res8 :
            Bare_Until_Node
               := No_Bare_Ada_Node;
      Defer_Pos165 :
            Token_Index
               := No_Token_Index;
      Defer_Res165 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos130 :
            Token_Index
               := No_Token_Index;
      Token_Res130 :
            Token_Index
               := No_Token_Index;
      Transform_Res62 :
            Bare_Delay_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags62 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Delay_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res62 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res62;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res62;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags62 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos79 := Pos;



--  Start tok_code

Token_Res128 := Row_Pos79;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res128));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Delay)
   then
       Token_Pos128 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos79,
             Expected_Token_Id => Ada_Delay,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos128 := Row_Pos79 + 1;
   end if;
end;

--  End tok_code




if Token_Pos128 /= No_Token_Index then

   Row_Pos79 := Token_Pos128;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res129 := Row_Pos79;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res129));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Until)
   then
       Token_Pos129 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos79,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos129 := Row_Pos79 + 1;
   end if;
end;

--  End tok_code


if Token_Pos129 = No_Token_Index then

         Opt_Res8 := Allocate_Until_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res8,
            Kind              => Ada_Until_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos79,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos129 := Row_Pos79;


else

      Opt_Res8 := Allocate_Until_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res8,
         Kind              => Ada_Until_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos79,
         Token_End_Index   => Token_Pos129 - 1);

end if;

--  End opt_code




if Token_Pos129 /= No_Token_Index then

   Row_Pos79 := Token_Pos129;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;


Defer_Res165 :=
   Expr_Or_Parse0 (Parser, Row_Pos79);
Defer_Pos165 := Parser.Current_Pos;




if Defer_Pos165 /= No_Token_Index then

   Row_Pos79 := Defer_Pos165;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res130 := Row_Pos79;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res130));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos130 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos79,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos130 := Row_Pos79 + 1;
   end if;
end;

--  End tok_code


if Token_Pos130 = No_Token_Index then

         
   Token_Res130 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos79)),
                To_Text ("Missing ';'"));

       
   Token_Pos130 := Row_Pos79;



end if;

--  End opt_code




if Token_Pos130 /= No_Token_Index then

   Row_Pos79 := Token_Pos130;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row79_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos79 /= No_Token_Index then

   Transform_Res62 := Allocate_Delay_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res62,
      Kind => Ada_Delay_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos79 = Pos
                            then No_Token_Index
                            else Row_Pos79 - 1));

      Initialize_Fields_For_Delay_Stmt
        (Self => Transform_Res62, Delay_Stmt_F_Has_Until => Opt_Res8, Delay_Stmt_F_Expr => Defer_Res165);

         if Opt_Res8 /= null and then Is_Incomplete (Opt_Res8) then
            Transform_Res62.Last_Attempted_Child := 0;
         elsif Opt_Res8 /= null and then not Is_Ghost (Opt_Res8) then
            Transform_Res62.Last_Attempted_Child := -1;
         end if;
         if Defer_Res165 /= null and then Is_Incomplete (Defer_Res165) then
            Transform_Res62.Last_Attempted_Child := 0;
         elsif Defer_Res165 /= null and then not Is_Ghost (Defer_Res165) then
            Transform_Res62.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos79 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags62);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Delay_Stmt_Transform_Parse0_Memo,
      Row_Pos79 /= No_Token_Index,
      Transform_Res62,
      Pos,
      Row_Pos79);


   Parser.Current_Pos := Row_Pos79;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res62;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Delay_Stmt_Transform_Parse0;

   


function Delta_Constraint_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Delta_Constraint
is
   use Bare_Delta_Constraint_Memos;

   Call_Depth : aliased Natural;

      Row_Pos80 :
            Token_Index
               := No_Token_Index;
      Token_Pos131 :
            Token_Index
               := No_Token_Index;
      Token_Res131 :
            Token_Index
               := No_Token_Index;
      Defer_Pos166 :
            Token_Index
               := No_Token_Index;
      Defer_Res166 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos167 :
            Token_Index
               := No_Token_Index;
      Defer_Res167 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Res63 :
            Bare_Delta_Constraint
               := No_Bare_Ada_Node;
      Transform_Diags63 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Delta_Constraint_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res63 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res63;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res63;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags63 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos80 := Pos;



--  Start tok_code

Token_Res131 := Row_Pos80;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res131));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Delta)
   then
       Token_Pos131 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos80 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos80,
             Expected_Token_Id => Ada_Delta,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos131 := Row_Pos80 + 1;
   end if;
end;

--  End tok_code




if Token_Pos131 /= No_Token_Index then

   Row_Pos80 := Token_Pos131;

else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;

end if;


Defer_Res166 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos80);
Defer_Pos166 := Parser.Current_Pos;




if Defer_Pos166 /= No_Token_Index then

   Row_Pos80 := Defer_Pos166;

else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;

end if;


--  Start opt_code












Defer_Res167 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos80);
Defer_Pos167 := Parser.Current_Pos;


if Defer_Pos167 = No_Token_Index then

         
   Defer_Res167 := No_Bare_Ada_Node;



       
   Defer_Pos167 := Row_Pos80;



end if;

--  End opt_code




if Defer_Pos167 /= No_Token_Index then

   Row_Pos80 := Defer_Pos167;

else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row80_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos80 /= No_Token_Index then

   Transform_Res63 := Allocate_Delta_Constraint (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res63,
      Kind => Ada_Delta_Constraint,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos80 = Pos
                            then No_Token_Index
                            else Row_Pos80 - 1));

      Initialize_Fields_For_Delta_Constraint
        (Self => Transform_Res63, Delta_Constraint_F_Digits => Defer_Res166, Delta_Constraint_F_Range => Defer_Res167);

         if Defer_Res166 /= null and then Is_Incomplete (Defer_Res166) then
            Transform_Res63.Last_Attempted_Child := 0;
         elsif Defer_Res166 /= null and then not Is_Ghost (Defer_Res166) then
            Transform_Res63.Last_Attempted_Child := -1;
         end if;
         if Defer_Res167 /= null and then Is_Incomplete (Defer_Res167) then
            Transform_Res63.Last_Attempted_Child := 0;
         elsif Defer_Res167 /= null and then not Is_Ghost (Defer_Res167) then
            Transform_Res63.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos80 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags63);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Delta_Constraint_Transform_Parse0_Memo,
      Row_Pos80 /= No_Token_Index,
      Transform_Res63,
      Pos,
      Row_Pos80);


   Parser.Current_Pos := Row_Pos80;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res63;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Delta_Constraint_Transform_Parse0;

   


function Derived_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Derived_Type_Def
is
   use Bare_Derived_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos81 :
            Token_Index
               := No_Token_Index;
      Token_Pos132 :
            Token_Index
               := No_Token_Index;
      Token_Res132 :
            Token_Index
               := No_Token_Index;
      Opt_Res9 :
            Bare_Abstract_Node
               := No_Bare_Ada_Node;
      Token_Pos133 :
            Token_Index
               := No_Token_Index;
      Token_Res133 :
            Token_Index
               := No_Token_Index;
      Opt_Res10 :
            Bare_Limited_Node
               := No_Bare_Ada_Node;
      Token_Pos134 :
            Token_Index
               := No_Token_Index;
      Token_Res134 :
            Token_Index
               := No_Token_Index;
      Opt_Res11 :
            Bare_Synchronized_Node
               := No_Bare_Ada_Node;
      Token_Pos135 :
            Token_Index
               := No_Token_Index;
      Token_Res135 :
            Token_Index
               := No_Token_Index;
      Defer_Pos168 :
            Token_Index
               := No_Token_Index;
      Defer_Res168 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Row_Pos82 :
            Token_Index
               := No_Token_Index;
      Token_Pos136 :
            Token_Index
               := No_Token_Index;
      Token_Res136 :
            Token_Index
               := No_Token_Index;
      Defer_Pos169 :
            Token_Index
               := No_Token_Index;
      Defer_Res169 :
            Bare_Parent_List
               := No_Bare_Ada_Node;
      Row_Pos83 :
            Token_Index
               := No_Token_Index;
      Token_Pos137 :
            Token_Index
               := No_Token_Index;
      Token_Res137 :
            Token_Index
               := No_Token_Index;
      Defer_Pos170 :
            Token_Index
               := No_Token_Index;
      Defer_Res170 :
            Bare_Base_Record_Def
               := No_Bare_Ada_Node;
      Row_Pos84 :
            Token_Index
               := No_Token_Index;
      Token_Pos138 :
            Token_Index
               := No_Token_Index;
      Token_Res138 :
            Token_Index
               := No_Token_Index;
      Token_Pos139 :
            Token_Index
               := No_Token_Index;
      Token_Res139 :
            Token_Index
               := No_Token_Index;
      Opt_Res12 :
            Bare_With_Private
               := No_Bare_Ada_Node;
      Transform_Res64 :
            Bare_Derived_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags64 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Derived_Type_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res64 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res64;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res64;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags64 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos81 := Pos;



--  Start opt_code












--  Start tok_code

Token_Res132 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res132));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos132 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos132 := Row_Pos81 + 1;
   end if;
end;

--  End tok_code


if Token_Pos132 = No_Token_Index then

         Opt_Res9 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res9,
            Kind              => Ada_Abstract_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos81,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos132 := Row_Pos81;


else

      Opt_Res9 := Allocate_Abstract_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res9,
         Kind              => Ada_Abstract_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos81,
         Token_End_Index   => Token_Pos132 - 1);

end if;

--  End opt_code




if Token_Pos132 /= No_Token_Index then

   Row_Pos81 := Token_Pos132;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res133 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res133));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Limited)
   then
       Token_Pos133 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Ada_Limited,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos133 := Row_Pos81 + 1;
   end if;
end;

--  End tok_code


if Token_Pos133 = No_Token_Index then

         Opt_Res10 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res10,
            Kind              => Ada_Limited_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos81,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos133 := Row_Pos81;


else

      Opt_Res10 := Allocate_Limited_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res10,
         Kind              => Ada_Limited_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos81,
         Token_End_Index   => Token_Pos133 - 1);

end if;

--  End opt_code




if Token_Pos133 /= No_Token_Index then

   Row_Pos81 := Token_Pos133;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res134 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res134));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Synchronized)
   then
       Token_Pos134 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos134 := Row_Pos81 + 1;
   end if;
end;

--  End tok_code


if Token_Pos134 = No_Token_Index then

         Opt_Res11 := Allocate_Synchronized_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res11,
            Kind              => Ada_Synchronized_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos81,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos134 := Row_Pos81;


else

      Opt_Res11 := Allocate_Synchronized_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res11,
         Kind              => Ada_Synchronized_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos81,
         Token_End_Index   => Token_Pos134 - 1);

end if;

--  End opt_code




if Token_Pos134 /= No_Token_Index then

   Row_Pos81 := Token_Pos134;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  Start tok_code

Token_Res135 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res135));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos135 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos135 := Row_Pos81 + 1;
   end if;
end;

--  End tok_code




if Token_Pos135 /= No_Token_Index then

   Row_Pos81 := Token_Pos135;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


Defer_Res168 :=
   Subtype_Indication_Transform_Parse0 (Parser, Row_Pos81);
Defer_Pos168 := Parser.Current_Pos;




if Defer_Pos168 /= No_Token_Index then

   Row_Pos81 := Defer_Pos168;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos82 := Row_Pos81;



--  Start tok_code

Token_Res136 := Row_Pos82;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res136));
begin
   if
      T.Kind /= From_Token_Kind (Ada_And)
   then
       Token_Pos136 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos82 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos82,
             Expected_Token_Id => Ada_And,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos136 := Row_Pos82 + 1;
   end if;
end;

--  End tok_code




if Token_Pos136 /= No_Token_Index then

   Row_Pos82 := Token_Pos136;

else
   Row_Pos82 := No_Token_Index;
   goto Exit_Row82_0;

end if;


Defer_Res169 :=
   Parent_List_List_Parse0 (Parser, Row_Pos82);
Defer_Pos169 := Parser.Current_Pos;




if Defer_Pos169 /= No_Token_Index then

   Row_Pos82 := Defer_Pos169;

else
   Row_Pos82 := No_Token_Index;
   goto Exit_Row82_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row82_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos82 = No_Token_Index then

         
   Defer_Res169 :=
     Allocate_Parent_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res169,
      Kind              => Ada_Parent_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos81 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res169,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos82 := Row_Pos81;



end if;

--  End opt_code




if Row_Pos82 /= No_Token_Index then

   Row_Pos81 := Row_Pos82;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos83 := Row_Pos81;



--  Start tok_code

Token_Res137 := Row_Pos83;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res137));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos137 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos83 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos83,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos137 := Row_Pos83 + 1;
   end if;
end;

--  End tok_code




if Token_Pos137 /= No_Token_Index then

   Row_Pos83 := Token_Pos137;

else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;

end if;


Defer_Res170 :=
   Record_Def_Or_Parse0 (Parser, Row_Pos83);
Defer_Pos170 := Parser.Current_Pos;




if Defer_Pos170 /= No_Token_Index then

   Row_Pos83 := Defer_Pos170;

else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row83_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos83 = No_Token_Index then

         
   Defer_Res170 := No_Bare_Ada_Node;



       
   Row_Pos83 := Row_Pos81;



end if;

--  End opt_code




if Row_Pos83 /= No_Token_Index then

   Row_Pos81 := Row_Pos83;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos84 := Row_Pos81;



--  Start tok_code

Token_Res138 := Row_Pos84;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res138));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos138 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos84 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos84,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos138 := Row_Pos84 + 1;
   end if;
end;

--  End tok_code




if Token_Pos138 /= No_Token_Index then

   Row_Pos84 := Token_Pos138;

else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;

end if;


--  Start tok_code

Token_Res139 := Row_Pos84;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res139));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos139 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos84 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos84,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos139 := Row_Pos84 + 1;
   end if;
end;

--  End tok_code




if Token_Pos139 /= No_Token_Index then

   Row_Pos84 := Token_Pos139;

else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row84_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos84 = No_Token_Index then

         Opt_Res12 := Allocate_With_Private_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res12,
            Kind              => Ada_With_Private_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos81,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos84 := Row_Pos81;


else

      Opt_Res12 := Allocate_With_Private_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res12,
         Kind              => Ada_With_Private_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos81,
         Token_End_Index   => Row_Pos84 - 1);

end if;

--  End opt_code




if Row_Pos84 /= No_Token_Index then

   Row_Pos81 := Row_Pos84;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row81_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos81 /= No_Token_Index then

   Transform_Res64 := Allocate_Derived_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res64,
      Kind => Ada_Derived_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos81 = Pos
                            then No_Token_Index
                            else Row_Pos81 - 1));

      Initialize_Fields_For_Derived_Type_Def
        (Self => Transform_Res64, Derived_Type_Def_F_Has_Abstract => Opt_Res9, Derived_Type_Def_F_Has_Limited => Opt_Res10, Derived_Type_Def_F_Has_Synchronized => Opt_Res11, Derived_Type_Def_F_Subtype_Indication => Defer_Res168, Derived_Type_Def_F_Interfaces => Defer_Res169, Derived_Type_Def_F_Record_Extension => Defer_Res170, Derived_Type_Def_F_Has_With_Private => Opt_Res12);

         if Opt_Res9 /= null and then Is_Incomplete (Opt_Res9) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Opt_Res9 /= null and then not Is_Ghost (Opt_Res9) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Opt_Res10 /= null and then Is_Incomplete (Opt_Res10) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Opt_Res10 /= null and then not Is_Ghost (Opt_Res10) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Opt_Res11 /= null and then Is_Incomplete (Opt_Res11) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Opt_Res11 /= null and then not Is_Ghost (Opt_Res11) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Defer_Res168 /= null and then Is_Incomplete (Defer_Res168) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Defer_Res168 /= null and then not Is_Ghost (Defer_Res168) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Defer_Res169 /= null and then Is_Incomplete (Defer_Res169) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Defer_Res169 /= null and then not Is_Ghost (Defer_Res169) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Defer_Res170 /= null and then Is_Incomplete (Defer_Res170) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Defer_Res170 /= null and then not Is_Ghost (Defer_Res170) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Opt_Res12 /= null and then Is_Incomplete (Opt_Res12) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Opt_Res12 /= null and then not Is_Ghost (Opt_Res12) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos81 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags64);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Derived_Type_Def_Transform_Parse0_Memo,
      Row_Pos81 /= No_Token_Index,
      Transform_Res64,
      Pos,
      Row_Pos81);


   Parser.Current_Pos := Row_Pos81;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res64;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Derived_Type_Def_Transform_Parse0;

   


function Digits_Constraint_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Digits_Constraint
is
   use Bare_Digits_Constraint_Memos;

   Call_Depth : aliased Natural;

      Row_Pos85 :
            Token_Index
               := No_Token_Index;
      Token_Pos140 :
            Token_Index
               := No_Token_Index;
      Token_Res140 :
            Token_Index
               := No_Token_Index;
      Defer_Pos171 :
            Token_Index
               := No_Token_Index;
      Defer_Res171 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos172 :
            Token_Index
               := No_Token_Index;
      Defer_Res172 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Res65 :
            Bare_Digits_Constraint
               := No_Bare_Ada_Node;
      Transform_Diags65 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Digits_Constraint_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res65 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res65;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res65;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags65 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos85 := Pos;



--  Start tok_code

Token_Res140 := Row_Pos85;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res140));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Digits)
   then
       Token_Pos140 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos85,
             Expected_Token_Id => Ada_Digits,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos140 := Row_Pos85 + 1;
   end if;
end;

--  End tok_code




if Token_Pos140 /= No_Token_Index then

   Row_Pos85 := Token_Pos140;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;


Defer_Res171 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos85);
Defer_Pos171 := Parser.Current_Pos;




if Defer_Pos171 /= No_Token_Index then

   Row_Pos85 := Defer_Pos171;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;


--  Start opt_code












Defer_Res172 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos85);
Defer_Pos172 := Parser.Current_Pos;


if Defer_Pos172 = No_Token_Index then

         
   Defer_Res172 := No_Bare_Ada_Node;



       
   Defer_Pos172 := Row_Pos85;



end if;

--  End opt_code




if Defer_Pos172 /= No_Token_Index then

   Row_Pos85 := Defer_Pos172;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row85_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos85 /= No_Token_Index then

   Transform_Res65 := Allocate_Digits_Constraint (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res65,
      Kind => Ada_Digits_Constraint,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos85 = Pos
                            then No_Token_Index
                            else Row_Pos85 - 1));

      Initialize_Fields_For_Digits_Constraint
        (Self => Transform_Res65, Digits_Constraint_F_Digits => Defer_Res171, Digits_Constraint_F_Range => Defer_Res172);

         if Defer_Res171 /= null and then Is_Incomplete (Defer_Res171) then
            Transform_Res65.Last_Attempted_Child := 0;
         elsif Defer_Res171 /= null and then not Is_Ghost (Defer_Res171) then
            Transform_Res65.Last_Attempted_Child := -1;
         end if;
         if Defer_Res172 /= null and then Is_Incomplete (Defer_Res172) then
            Transform_Res65.Last_Attempted_Child := 0;
         elsif Defer_Res172 /= null and then not Is_Ghost (Defer_Res172) then
            Transform_Res65.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos85 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags65);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Digits_Constraint_Transform_Parse0_Memo,
      Row_Pos85 /= No_Token_Index,
      Transform_Res65,
      Pos,
      Row_Pos85);


   Parser.Current_Pos := Row_Pos85;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res65;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Digits_Constraint_Transform_Parse0;

   


function Direct_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Id
is
   use Bare_Base_Id_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos173 :
            Token_Index
               := No_Token_Index;
      Defer_Res173 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Defer_Pos174 :
            Token_Index
               := No_Token_Index;
      Defer_Res174 :
            Bare_String_Literal
               := No_Bare_Ada_Node;
      Defer_Pos175 :
            Token_Index
               := No_Token_Index;
      Defer_Res175 :
            Bare_Char_Literal
               := No_Bare_Ada_Node;
      Or_Pos32 :
            Token_Index
               := No_Token_Index;
      Or_Res32 :
            Bare_Base_Id
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Direct_Name_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res32 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res32;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res32;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos32 := No_Token_Index;
Or_Res32 := No_Bare_Ada_Node;
    
Defer_Res173 :=
   Identifier_Transform_Parse0 (Parser, Pos);
Defer_Pos173 := Parser.Current_Pos;

    if Defer_Pos173 /= No_Token_Index then
        Or_Pos32 := Defer_Pos173;
        Or_Res32 := Defer_Res173;
        goto Exit_Or33;
    end if;
    
Defer_Res174 :=
   String_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos174 := Parser.Current_Pos;

    if Defer_Pos174 /= No_Token_Index then
        Or_Pos32 := Defer_Pos174;
        Or_Res32 := Defer_Res174;
        goto Exit_Or33;
    end if;
    
Defer_Res175 :=
   Char_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos175 := Parser.Current_Pos;

    if Defer_Pos175 /= No_Token_Index then
        Or_Pos32 := Defer_Pos175;
        Or_Res32 := Defer_Res175;
        goto Exit_Or33;
    end if;
<<Exit_Or33>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Direct_Name_Or_Parse0_Memo,
      Or_Pos32 /= No_Token_Index,
      Or_Res32,
      Pos,
      Or_Pos32);


   Parser.Current_Pos := Or_Pos32;

   Exit_Call (Parser, Call_Depth);
   return Or_Res32;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Direct_Name_Or_Parse0;

   


function Direct_Name_Or_Target_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name
is
   use Bare_Name_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos176 :
            Token_Index
               := No_Token_Index;
      Defer_Res176 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Defer_Pos177 :
            Token_Index
               := No_Token_Index;
      Defer_Res177 :
            Bare_Target_Name
               := No_Bare_Ada_Node;
      Or_Pos33 :
            Token_Index
               := No_Token_Index;
      Or_Res33 :
            Bare_Name
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Direct_Name_Or_Target_Name_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res33 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res33;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res33;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos33 := No_Token_Index;
Or_Res33 := No_Bare_Ada_Node;
    
Defer_Res176 :=
   Direct_Name_Or_Parse0 (Parser, Pos);
Defer_Pos176 := Parser.Current_Pos;

    if Defer_Pos176 /= No_Token_Index then
        Or_Pos33 := Defer_Pos176;
        Or_Res33 := Defer_Res176;
        goto Exit_Or34;
    end if;
    
Defer_Res177 :=
   Target_Name_Transform_Parse0 (Parser, Pos);
Defer_Pos177 := Parser.Current_Pos;

    if Defer_Pos177 /= No_Token_Index then
        Or_Pos33 := Defer_Pos177;
        Or_Res33 := Defer_Res177;
        goto Exit_Or34;
    end if;
<<Exit_Or34>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Direct_Name_Or_Target_Name_Or_Parse0_Memo,
      Or_Pos33 /= No_Token_Index,
      Or_Res33,
      Pos,
      Or_Pos33);


   Parser.Current_Pos := Or_Pos33;

   Exit_Call (Parser, Call_Depth);
   return Or_Res33;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Direct_Name_Or_Target_Name_Or_Parse0;

   


function Discr_Spec_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discriminant_Spec_List
is
   use Bare_Discriminant_Spec_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos25 :
            Token_Index
               := No_Token_Index;
      Tmp_List25 :
            Free_Parse_List;
      Defer_Pos178 :
            Token_Index
               := No_Token_Index;
      Defer_Res178 :
            Bare_Discriminant_Spec
               := No_Bare_Ada_Node;
      Token_Pos141 :
            Token_Index
               := No_Token_Index;
      Token_Res141 :
            Token_Index
               := No_Token_Index;
      List_Pos25 :
            Token_Index
               := No_Token_Index;
      List_Res25 :
            Bare_Discriminant_Spec_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Discr_Spec_List_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res25 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res25;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos25 := No_Token_Index;



Lst_Cpos25 := Pos;
Tmp_List25 := Get_Parse_List (Parser);

loop
   
Defer_Res178 :=
   Discriminant_Spec_Transform_Parse0 (Parser, Lst_Cpos25);
Defer_Pos178 := Parser.Current_Pos;


   exit when Defer_Pos178 = No_Token_Index;

   List_Pos25 := Defer_Pos178;
   Lst_Cpos25 := List_Pos25;

   Tmp_List25.Nodes.Append (Defer_Res178);

      
--  Start tok_code

Token_Res141 := Lst_Cpos25;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res141));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos141 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos25 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos25,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos141 := Lst_Cpos25 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos141 /= No_Token_Index then
          Lst_Cpos25 := Token_Pos141;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List25.Nodes.Length;
begin
   List_Res25 :=
      Allocate_Discriminant_Spec_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos25 = Pos
                    then Pos
                    else Lst_Cpos25 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res25,
      Kind              => Ada_Discriminant_Spec_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res25,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List25.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res25.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List25);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Discr_Spec_List_List_Parse0_Memo,
      List_Pos25 /= No_Token_Index,
      List_Res25,
      Pos,
      List_Pos25);


   Parser.Current_Pos := List_Pos25;

   Exit_Call (Parser, Call_Depth);
   return List_Res25;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Discr_Spec_List_List_Parse0;

   


function Discrete_Range_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos86 :
            Token_Index
               := No_Token_Index;
      Defer_Pos179 :
            Token_Index
               := No_Token_Index;
      Defer_Res179 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Pos87 :
            Token_Index
               := No_Token_Index;
      Token_Pos142 :
            Token_Index
               := No_Token_Index;
      Token_Res142 :
            Token_Index
               := No_Token_Index;
      Transform_Res66 :
            Bare_Op_Double_Dot
               := No_Bare_Ada_Node;
      Transform_Diags66 :
            Ada.Containers.Count_Type;
      Defer_Pos180 :
            Token_Index
               := No_Token_Index;
      Defer_Res180 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res67 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Diags67 :
            Ada.Containers.Count_Type;
      Defer_Pos181 :
            Token_Index
               := No_Token_Index;
      Defer_Res181 :
            Bare_Name
               := No_Bare_Ada_Node;
      Predicate_Pos0 :
            Token_Index
               := No_Token_Index;
      Predicate_Res0 :
            Bare_Name
               := No_Bare_Ada_Node;
      Or_Pos34 :
            Token_Index
               := No_Token_Index;
      Or_Res34 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Discrete_Range_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res34 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res34;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res34;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos34 := No_Token_Index;
Or_Res34 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags67 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos86 := Pos;



Defer_Res179 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos86);
Defer_Pos179 := Parser.Current_Pos;




if Defer_Pos179 /= No_Token_Index then

   Row_Pos86 := Defer_Pos179;

else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;

end if;


--  Start transform_code

Transform_Diags66 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos87 := Row_Pos86;



--  Start tok_code

Token_Res142 := Row_Pos87;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res142));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Doubledot)
   then
       Token_Pos142 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos87 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos87,
             Expected_Token_Id => Ada_Doubledot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos142 := Row_Pos87 + 1;
   end if;
end;

--  End tok_code




if Token_Pos142 /= No_Token_Index then

   Row_Pos87 := Token_Pos142;

else
   Row_Pos87 := No_Token_Index;
   goto Exit_Row87_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row87_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos87 /= No_Token_Index then

   Transform_Res66 := Allocate_Op_Double_Dot (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res66,
      Kind => Ada_Op_Double_Dot,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos86,
      Token_End_Index   => (if Row_Pos87 = Row_Pos86
                            then No_Token_Index
                            else Row_Pos87 - 1));

      Initialize_Fields_For_Op_Double_Dot
        (Self => Transform_Res66);



elsif Row_Pos87 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags66);
end if;

--  End transform_code




if Row_Pos87 /= No_Token_Index then

   Row_Pos86 := Row_Pos87;

else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;

end if;


Defer_Res180 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos86);
Defer_Pos180 := Parser.Current_Pos;




if Defer_Pos180 /= No_Token_Index then

   Row_Pos86 := Defer_Pos180;

else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row86_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos86 /= No_Token_Index then

   Transform_Res67 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res67,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos86 = Pos
                            then No_Token_Index
                            else Row_Pos86 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res67, Bin_Op_F_Left => Defer_Res179, Bin_Op_F_Op => Transform_Res66, Bin_Op_F_Right => Defer_Res180);

         if Defer_Res179 /= null and then Is_Incomplete (Defer_Res179) then
            Transform_Res67.Last_Attempted_Child := 0;
         elsif Defer_Res179 /= null and then not Is_Ghost (Defer_Res179) then
            Transform_Res67.Last_Attempted_Child := -1;
         end if;
         if Transform_Res66 /= null and then Is_Incomplete (Transform_Res66) then
            Transform_Res67.Last_Attempted_Child := 0;
         elsif Transform_Res66 /= null and then not Is_Ghost (Transform_Res66) then
            Transform_Res67.Last_Attempted_Child := -1;
         end if;
         if Defer_Res180 /= null and then Is_Incomplete (Defer_Res180) then
            Transform_Res67.Last_Attempted_Child := 0;
         elsif Defer_Res180 /= null and then not Is_Ghost (Defer_Res180) then
            Transform_Res67.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos86 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags67);
end if;

--  End transform_code

    if Row_Pos86 /= No_Token_Index then
        Or_Pos34 := Row_Pos86;
        Or_Res34 := Transform_Res67;
        goto Exit_Or35;
    end if;
    
--  Start predicate_code


Defer_Res181 :=
   Name_Or_Parse2 (Parser, Pos);
Defer_Pos181 := Parser.Current_Pos;


if Defer_Res181 /= null
   and then Name_P_Is_Range_Attribute (Defer_Res181)
then
    Predicate_Res0 := Defer_Res181;
    Predicate_Pos0 := Defer_Pos181;
else
    Predicate_Pos0 := No_Token_Index;
    Predicate_Res0 := null;

    if Parser.Last_Fail.Pos <= Pos then
       Parser.Last_Fail :=
         (Kind           => Custom_Fail,
          Pos            => Pos,
          Custom_Message => Generic_Parsing_Error_Message_Access);
    end if;
end if;

--  End predicate_code

    if Predicate_Pos0 /= No_Token_Index then
        Or_Pos34 := Predicate_Pos0;
        Or_Res34 := Predicate_Res0;
        goto Exit_Or35;
    end if;
<<Exit_Or35>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Discrete_Range_Or_Parse0_Memo,
      Or_Pos34 /= No_Token_Index,
      Or_Res34,
      Pos,
      Or_Pos34);


   Parser.Current_Pos := Or_Pos34;

   Exit_Call (Parser, Call_Depth);
   return Or_Res34;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Discrete_Range_Or_Parse0;

   


function Discrete_Subtype_Definition_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos182 :
            Token_Index
               := No_Token_Index;
      Defer_Res182 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos183 :
            Token_Index
               := No_Token_Index;
      Defer_Res183 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Or_Pos35 :
            Token_Index
               := No_Token_Index;
      Or_Res35 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Discrete_Subtype_Definition_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res35 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res35;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res35;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos35 := No_Token_Index;
Or_Res35 := No_Bare_Ada_Node;
    
Defer_Res182 :=
   Discrete_Range_Or_Parse0 (Parser, Pos);
Defer_Pos182 := Parser.Current_Pos;

    if Defer_Pos182 /= No_Token_Index then
        Or_Pos35 := Defer_Pos182;
        Or_Res35 := Defer_Res182;
        goto Exit_Or36;
    end if;
    
Defer_Res183 :=
   Subtype_Indication_Transform_Parse0 (Parser, Pos);
Defer_Pos183 := Parser.Current_Pos;

    if Defer_Pos183 /= No_Token_Index then
        Or_Pos35 := Defer_Pos183;
        Or_Res35 := Defer_Res183;
        goto Exit_Or36;
    end if;
<<Exit_Or36>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Discrete_Subtype_Definition_Or_Parse0_Memo,
      Or_Pos35 /= No_Token_Index,
      Or_Res35,
      Pos,
      Or_Pos35);


   Parser.Current_Pos := Or_Pos35;

   Exit_Call (Parser, Call_Depth);
   return Or_Res35;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Discrete_Subtype_Definition_Or_Parse0;

   


function Discrete_Subtype_Indication_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discrete_Subtype_Indication
is
   use Bare_Discrete_Subtype_Indication_Memos;

   Call_Depth : aliased Natural;

      Row_Pos88 :
            Token_Index
               := No_Token_Index;
      Row_Pos89 :
            Token_Index
               := No_Token_Index;
      Token_Pos143 :
            Token_Index
               := No_Token_Index;
      Token_Res143 :
            Token_Index
               := No_Token_Index;
      Token_Pos144 :
            Token_Index
               := No_Token_Index;
      Token_Res144 :
            Token_Index
               := No_Token_Index;
      Opt_Res13 :
            Bare_Not_Null
               := No_Bare_Ada_Node;
      Defer_Pos184 :
            Token_Index
               := No_Token_Index;
      Defer_Res184 :
            Bare_Name
               := No_Bare_Ada_Node;
      Stopcut_Pos0 :
            Token_Index
               := No_Token_Index;
      Defer_Pos185 :
            Token_Index
               := No_Token_Index;
      Defer_Res185 :
            Bare_Range_Constraint
               := No_Bare_Ada_Node;
      Transform_Res68 :
            Bare_Discrete_Subtype_Indication
               := No_Bare_Ada_Node;
      Transform_Diags68 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Discrete_Subtype_Indication_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res68 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res68;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res68;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags68 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos88 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos89 := Row_Pos88;



--  Start tok_code

Token_Res143 := Row_Pos89;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res143));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos143 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos89,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos143 := Row_Pos89 + 1;
   end if;
end;

--  End tok_code




if Token_Pos143 /= No_Token_Index then

   Row_Pos89 := Token_Pos143;

else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;

end if;


--  Start tok_code

Token_Res144 := Row_Pos89;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res144));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos144 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos89,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos144 := Row_Pos89 + 1;
   end if;
end;

--  End tok_code




if Token_Pos144 /= No_Token_Index then

   Row_Pos89 := Token_Pos144;

else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row89_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos89 = No_Token_Index then

         Opt_Res13 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res13,
            Kind              => Ada_Not_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos88,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos89 := Row_Pos88;


else

      Opt_Res13 := Allocate_Not_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res13,
         Kind              => Ada_Not_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos88,
         Token_End_Index   => Row_Pos89 - 1);

end if;

--  End opt_code




if Row_Pos89 /= No_Token_Index then

   Row_Pos88 := Row_Pos89;

else
   Row_Pos88 := No_Token_Index;
   goto Exit_Row88_0;

end if;


        declare
            Nb_Diags : constant Ada.Containers.Count_Type
              := Parser.Diagnostics.Length;
        begin
            
Defer_Res184 :=
   Subtype_Name_Or_Parse0 (Parser, Row_Pos88);
Defer_Pos184 := Parser.Current_Pos;


            if (Defer_Res184 /= null
                and then Defer_Res184.Last_Attempted_Child /= -1)

               --  If the subparser has failed, we still want to reset the
               --  diagnostics, because parsing might have failed because of
               --  a cut.
               or else Defer_Pos184 = No_Token_Index
            then
                Stopcut_Pos0 := No_Token_Index;
                Parser.Diagnostics.Set_Length (Nb_Diags);
            else
                Stopcut_Pos0 := Defer_Pos184;
            end if;
        end;
        



if Stopcut_Pos0 /= No_Token_Index then

   Row_Pos88 := Stopcut_Pos0;

else
   Row_Pos88 := No_Token_Index;
   goto Exit_Row88_0;

end if;


Defer_Res185 :=
   Range_Constraint_Transform_Parse1 (Parser, Row_Pos88);
Defer_Pos185 := Parser.Current_Pos;




if Defer_Pos185 /= No_Token_Index then

   Row_Pos88 := Defer_Pos185;

else
   Row_Pos88 := No_Token_Index;
   goto Exit_Row88_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row88_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos88 /= No_Token_Index then

   Transform_Res68 := Allocate_Discrete_Subtype_Indication (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res68,
      Kind => Ada_Discrete_Subtype_Indication,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos88 = Pos
                            then No_Token_Index
                            else Row_Pos88 - 1));

      Initialize_Fields_For_Discrete_Subtype_Indication
        (Self => Transform_Res68, Subtype_Indication_F_Has_Not_Null => Opt_Res13, Subtype_Indication_F_Name => Defer_Res184, Subtype_Indication_F_Constraint => Defer_Res185);

         if Opt_Res13 /= null and then Is_Incomplete (Opt_Res13) then
            Transform_Res68.Last_Attempted_Child := 0;
         elsif Opt_Res13 /= null and then not Is_Ghost (Opt_Res13) then
            Transform_Res68.Last_Attempted_Child := -1;
         end if;
         if Defer_Res184 /= null and then Is_Incomplete (Defer_Res184) then
            Transform_Res68.Last_Attempted_Child := 0;
         elsif Defer_Res184 /= null and then not Is_Ghost (Defer_Res184) then
            Transform_Res68.Last_Attempted_Child := -1;
         end if;
         if Defer_Res185 /= null and then Is_Incomplete (Defer_Res185) then
            Transform_Res68.Last_Attempted_Child := 0;
         elsif Defer_Res185 /= null and then not Is_Ghost (Defer_Res185) then
            Transform_Res68.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos88 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags68);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Discrete_Subtype_Indication_Transform_Parse0_Memo,
      Row_Pos88 /= No_Token_Index,
      Transform_Res68,
      Pos,
      Row_Pos88);


   Parser.Current_Pos := Row_Pos88;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res68;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Discrete_Subtype_Indication_Transform_Parse0;

   


function Discriminant_Part_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discriminant_Part
is
   use Bare_Discriminant_Part_Memos;

   Call_Depth : aliased Natural;

      Row_Pos90 :
            Token_Index
               := No_Token_Index;
      Token_Pos145 :
            Token_Index
               := No_Token_Index;
      Token_Res145 :
            Token_Index
               := No_Token_Index;
      Defer_Pos186 :
            Token_Index
               := No_Token_Index;
      Defer_Res186 :
            Bare_Discriminant_Spec_List
               := No_Bare_Ada_Node;
      Token_Pos146 :
            Token_Index
               := No_Token_Index;
      Token_Res146 :
            Token_Index
               := No_Token_Index;
      Transform_Res69 :
            Bare_Known_Discriminant_Part
               := No_Bare_Ada_Node;
      Transform_Diags69 :
            Ada.Containers.Count_Type;
      Row_Pos91 :
            Token_Index
               := No_Token_Index;
      Token_Pos147 :
            Token_Index
               := No_Token_Index;
      Token_Res147 :
            Token_Index
               := No_Token_Index;
      Token_Pos148 :
            Token_Index
               := No_Token_Index;
      Token_Res148 :
            Token_Index
               := No_Token_Index;
      Token_Pos149 :
            Token_Index
               := No_Token_Index;
      Token_Res149 :
            Token_Index
               := No_Token_Index;
      Transform_Res70 :
            Bare_Unknown_Discriminant_Part
               := No_Bare_Ada_Node;
      Transform_Diags70 :
            Ada.Containers.Count_Type;
      Or_Pos36 :
            Token_Index
               := No_Token_Index;
      Or_Res36 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Discriminant_Part_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res36 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res36;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res36;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos36 := No_Token_Index;
Or_Res36 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags69 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos90 := Pos;



--  Start tok_code

Token_Res145 := Row_Pos90;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res145));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos145 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos90,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos145 := Row_Pos90 + 1;
   end if;
end;

--  End tok_code




if Token_Pos145 /= No_Token_Index then

   Row_Pos90 := Token_Pos145;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;


Defer_Res186 :=
   Discr_Spec_List_List_Parse0 (Parser, Row_Pos90);
Defer_Pos186 := Parser.Current_Pos;




if Defer_Pos186 /= No_Token_Index then

   Row_Pos90 := Defer_Pos186;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;


--  Start tok_code

Token_Res146 := Row_Pos90;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res146));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos146 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos90,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos146 := Row_Pos90 + 1;
   end if;
end;

--  End tok_code




if Token_Pos146 /= No_Token_Index then

   Row_Pos90 := Token_Pos146;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row90_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos90 /= No_Token_Index then

   Transform_Res69 := Allocate_Known_Discriminant_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res69,
      Kind => Ada_Known_Discriminant_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos90 = Pos
                            then No_Token_Index
                            else Row_Pos90 - 1));

      Initialize_Fields_For_Known_Discriminant_Part
        (Self => Transform_Res69, Known_Discriminant_Part_F_Discr_Specs => Defer_Res186);

         if Defer_Res186 /= null and then Is_Incomplete (Defer_Res186) then
            Transform_Res69.Last_Attempted_Child := 0;
         elsif Defer_Res186 /= null and then not Is_Ghost (Defer_Res186) then
            Transform_Res69.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos90 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags69);
end if;

--  End transform_code

    if Row_Pos90 /= No_Token_Index then
        Or_Pos36 := Row_Pos90;
        Or_Res36 := Transform_Res69;
        goto Exit_Or37;
    end if;
    
--  Start transform_code

Transform_Diags70 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos91 := Pos;



--  Start tok_code

Token_Res147 := Row_Pos91;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res147));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos147 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos91,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos147 := Row_Pos91 + 1;
   end if;
end;

--  End tok_code




if Token_Pos147 /= No_Token_Index then

   Row_Pos91 := Token_Pos147;

else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;

end if;


--  Start tok_code

Token_Res148 := Row_Pos91;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res148));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Diamond)
   then
       Token_Pos148 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos91,
             Expected_Token_Id => Ada_Diamond,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos148 := Row_Pos91 + 1;
   end if;
end;

--  End tok_code




if Token_Pos148 /= No_Token_Index then

   Row_Pos91 := Token_Pos148;

else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;

end if;


--  Start tok_code

Token_Res149 := Row_Pos91;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res149));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos149 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos91,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos149 := Row_Pos91 + 1;
   end if;
end;

--  End tok_code




if Token_Pos149 /= No_Token_Index then

   Row_Pos91 := Token_Pos149;

else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row91_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos91 /= No_Token_Index then

   Transform_Res70 := Allocate_Unknown_Discriminant_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res70,
      Kind => Ada_Unknown_Discriminant_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos91 = Pos
                            then No_Token_Index
                            else Row_Pos91 - 1));




elsif Row_Pos91 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags70);
end if;

--  End transform_code

    if Row_Pos91 /= No_Token_Index then
        Or_Pos36 := Row_Pos91;
        Or_Res36 := Transform_Res70;
        goto Exit_Or37;
    end if;
<<Exit_Or37>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Discriminant_Part_Or_Parse0_Memo,
      Or_Pos36 /= No_Token_Index,
      Or_Res36,
      Pos,
      Or_Pos36);


   Parser.Current_Pos := Or_Pos36;

   Exit_Call (Parser, Call_Depth);
   return Or_Res36;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Discriminant_Part_Or_Parse0;

   


function Discriminant_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Discriminant_Spec
is
   use Bare_Discriminant_Spec_Memos;

   Call_Depth : aliased Natural;

      Row_Pos92 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos26 :
            Token_Index
               := No_Token_Index;
      Tmp_List26 :
            Free_Parse_List;
      Defer_Pos187 :
            Token_Index
               := No_Token_Index;
      Defer_Res187 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos150 :
            Token_Index
               := No_Token_Index;
      Token_Res150 :
            Token_Index
               := No_Token_Index;
      List_Pos26 :
            Token_Index
               := No_Token_Index;
      List_Res26 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos151 :
            Token_Index
               := No_Token_Index;
      Token_Res151 :
            Token_Index
               := No_Token_Index;
      Defer_Pos188 :
            Token_Index
               := No_Token_Index;
      Defer_Res188 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Row_Pos93 :
            Token_Index
               := No_Token_Index;
      Token_Pos152 :
            Token_Index
               := No_Token_Index;
      Token_Res152 :
            Token_Index
               := No_Token_Index;
      Defer_Pos189 :
            Token_Index
               := No_Token_Index;
      Defer_Res189 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos190 :
            Token_Index
               := No_Token_Index;
      Defer_Res190 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Transform_Res71 :
            Bare_Discriminant_Spec
               := No_Bare_Ada_Node;
      Transform_Diags71 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Discriminant_Spec_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res71 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res71;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res71;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags71 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos92 := Pos;



--  Start list_code

    List_Pos26 := No_Token_Index;



Lst_Cpos26 := Row_Pos92;
Tmp_List26 := Get_Parse_List (Parser);

loop
   
Defer_Res187 :=
   Defining_Id_Transform_Parse0 (Parser, Lst_Cpos26);
Defer_Pos187 := Parser.Current_Pos;


   exit when Defer_Pos187 = No_Token_Index;

   List_Pos26 := Defer_Pos187;
   Lst_Cpos26 := List_Pos26;

   Tmp_List26.Nodes.Append (Defer_Res187);

      
--  Start tok_code

Token_Res150 := Lst_Cpos26;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res150));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos150 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos26 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos26,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos150 := Lst_Cpos26 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos150 /= No_Token_Index then
          Lst_Cpos26 := Token_Pos150;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List26.Nodes.Length;
begin
   List_Res26 :=
      Allocate_Defining_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos92;
      Token_End := (if Lst_Cpos26 = Row_Pos92
                    then Row_Pos92
                    else Lst_Cpos26 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos92, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res26,
      Kind              => Ada_Defining_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res26,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List26.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res26.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List26);

--  End list_code




if List_Pos26 /= No_Token_Index then

   Row_Pos92 := List_Pos26;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;


--  Start tok_code

Token_Res151 := Row_Pos92;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res151));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos151 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos92,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos151 := Row_Pos92 + 1;
   end if;
end;

--  End tok_code




if Token_Pos151 /= No_Token_Index then

   Row_Pos92 := Token_Pos151;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;


Defer_Res188 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos92);
Defer_Pos188 := Parser.Current_Pos;




if Defer_Pos188 /= No_Token_Index then

   Row_Pos92 := Defer_Pos188;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos93 := Row_Pos92;



--  Start tok_code

Token_Res152 := Row_Pos93;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res152));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos152 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos93 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos93,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos152 := Row_Pos93 + 1;
   end if;
end;

--  End tok_code




if Token_Pos152 /= No_Token_Index then

   Row_Pos93 := Token_Pos152;

else
   Row_Pos93 := No_Token_Index;
   goto Exit_Row93_0;

end if;


Defer_Res189 :=
   Expr_Or_Parse0 (Parser, Row_Pos93);
Defer_Pos189 := Parser.Current_Pos;




if Defer_Pos189 /= No_Token_Index then

   Row_Pos93 := Defer_Pos189;

else
   Row_Pos93 := No_Token_Index;
   goto Exit_Row93_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row93_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos93 = No_Token_Index then

         
   Defer_Res189 := No_Bare_Ada_Node;



       
   Row_Pos93 := Row_Pos92;



end if;

--  End opt_code




if Row_Pos93 /= No_Token_Index then

   Row_Pos92 := Row_Pos93;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;


--  Start opt_code












Defer_Res190 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos92);
Defer_Pos190 := Parser.Current_Pos;


if Defer_Pos190 = No_Token_Index then

         
   Defer_Res190 := No_Bare_Ada_Node;



       
   Defer_Pos190 := Row_Pos92;



end if;

--  End opt_code




if Defer_Pos190 /= No_Token_Index then

   Row_Pos92 := Defer_Pos190;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row92_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos92 /= No_Token_Index then

   Transform_Res71 := Allocate_Discriminant_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res71,
      Kind => Ada_Discriminant_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos92 = Pos
                            then No_Token_Index
                            else Row_Pos92 - 1));

      Initialize_Fields_For_Discriminant_Spec
        (Self => Transform_Res71, Discriminant_Spec_F_Ids => List_Res26, Discriminant_Spec_F_Type_Expr => Defer_Res188, Discriminant_Spec_F_Default_Expr => Defer_Res189, Discriminant_Spec_F_Aspects => Defer_Res190);

         if List_Res26 /= null and then Is_Incomplete (List_Res26) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif List_Res26 /= null and then not Is_Ghost (List_Res26) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
         if Defer_Res188 /= null and then Is_Incomplete (Defer_Res188) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Defer_Res188 /= null and then not Is_Ghost (Defer_Res188) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
         if Defer_Res189 /= null and then Is_Incomplete (Defer_Res189) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Defer_Res189 /= null and then not Is_Ghost (Defer_Res189) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
         if Defer_Res190 /= null and then Is_Incomplete (Defer_Res190) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Defer_Res190 /= null and then not Is_Ghost (Defer_Res190) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos92 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags71);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Discriminant_Spec_Transform_Parse0_Memo,
      Row_Pos92 /= No_Token_Index,
      Transform_Res71,
      Pos,
      Row_Pos92);


   Parser.Current_Pos := Row_Pos92;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res71;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Discriminant_Spec_Transform_Parse0;

   


function Dontskip_Case_Alt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos94 :
            Token_Index
               := No_Token_Index;
      Null_Res2 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos153 :
            Token_Index
               := No_Token_Index;
      Token_Res153 :
            Token_Index
               := No_Token_Index;
      Token_Pos154 :
            Token_Index
               := No_Token_Index;
      Token_Res154 :
            Token_Index
               := No_Token_Index;
      Or_Pos37 :
            Token_Index
               := No_Token_Index;
      Or_Res37 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Case_Alt0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res2 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res2;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos94 := Pos;



   Null_Res2 := No_Bare_Ada_Node;




if Row_Pos94 /= No_Token_Index then

   Row_Pos94 := Row_Pos94;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  Start or_code

Or_Pos37 := No_Token_Index;
Or_Res37 := No_Token_Index;
    
--  Start tok_code

Token_Res153 := Row_Pos94;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res153));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos153 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos94,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos153 := Row_Pos94 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos153 /= No_Token_Index then
        Or_Pos37 := Token_Pos153;
        Or_Res37 := Token_Res153;
        goto Exit_Or38;
    end if;
    
--  Start tok_code

Token_Res154 := Row_Pos94;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res154));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos154 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos94,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos154 := Row_Pos94 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos154 /= No_Token_Index then
        Or_Pos37 := Token_Pos154;
        Or_Res37 := Token_Res154;
        goto Exit_Or38;
    end if;
<<Exit_Or38>>

--  End or_code




if Or_Pos37 /= No_Token_Index then

   Row_Pos94 := Or_Pos37;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row94_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Case_Alt0_Extract_Parse0_Memo,
      Row_Pos94 /= No_Token_Index,
      Null_Res2,
      Pos,
      Row_Pos94);


   Parser.Current_Pos := Row_Pos94;

   Exit_Call (Parser, Call_Depth);
   return Null_Res2;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Case_Alt0_Extract_Parse0;

   


function Dontskip_Elsif_Part0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos95 :
            Token_Index
               := No_Token_Index;
      Null_Res3 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos155 :
            Token_Index
               := No_Token_Index;
      Token_Res155 :
            Token_Index
               := No_Token_Index;
      Token_Pos156 :
            Token_Index
               := No_Token_Index;
      Token_Res156 :
            Token_Index
               := No_Token_Index;
      Token_Pos157 :
            Token_Index
               := No_Token_Index;
      Token_Res157 :
            Token_Index
               := No_Token_Index;
      Or_Pos38 :
            Token_Index
               := No_Token_Index;
      Or_Res38 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Elsif_Part0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res3 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos95 := Pos;



   Null_Res3 := No_Bare_Ada_Node;




if Row_Pos95 /= No_Token_Index then

   Row_Pos95 := Row_Pos95;

else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;

end if;


--  Start or_code

Or_Pos38 := No_Token_Index;
Or_Res38 := No_Token_Index;
    
--  Start tok_code

Token_Res155 := Row_Pos95;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res155));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Elsif)
   then
       Token_Pos155 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos95 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos95,
             Expected_Token_Id => Ada_Elsif,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos155 := Row_Pos95 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos155 /= No_Token_Index then
        Or_Pos38 := Token_Pos155;
        Or_Res38 := Token_Res155;
        goto Exit_Or39;
    end if;
    
--  Start tok_code

Token_Res156 := Row_Pos95;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res156));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos156 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos95 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos95,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos156 := Row_Pos95 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos156 /= No_Token_Index then
        Or_Pos38 := Token_Pos156;
        Or_Res38 := Token_Res156;
        goto Exit_Or39;
    end if;
    
--  Start tok_code

Token_Res157 := Row_Pos95;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res157));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos157 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos95 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos95,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos157 := Row_Pos95 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos157 /= No_Token_Index then
        Or_Pos38 := Token_Pos157;
        Or_Res38 := Token_Res157;
        goto Exit_Or39;
    end if;
<<Exit_Or39>>

--  End or_code




if Or_Pos38 /= No_Token_Index then

   Row_Pos95 := Or_Pos38;

else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row95_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Elsif_Part0_Extract_Parse0_Memo,
      Row_Pos95 /= No_Token_Index,
      Null_Res3,
      Pos,
      Row_Pos95);


   Parser.Current_Pos := Row_Pos95;

   Exit_Call (Parser, Call_Depth);
   return Null_Res3;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Elsif_Part0_Extract_Parse0;

   


function Dontskip_Exception_Handler0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos96 :
            Token_Index
               := No_Token_Index;
      Null_Res4 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos158 :
            Token_Index
               := No_Token_Index;
      Token_Res158 :
            Token_Index
               := No_Token_Index;
      Token_Pos159 :
            Token_Index
               := No_Token_Index;
      Token_Res159 :
            Token_Index
               := No_Token_Index;
      Token_Pos160 :
            Token_Index
               := No_Token_Index;
      Token_Res160 :
            Token_Index
               := No_Token_Index;
      Or_Pos39 :
            Token_Index
               := No_Token_Index;
      Or_Res39 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Exception_Handler0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res4 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos96 := Pos;



   Null_Res4 := No_Bare_Ada_Node;




if Row_Pos96 /= No_Token_Index then

   Row_Pos96 := Row_Pos96;

else
   Row_Pos96 := No_Token_Index;
   goto Exit_Row96_0;

end if;


--  Start or_code

Or_Pos39 := No_Token_Index;
Or_Res39 := No_Token_Index;
    
--  Start tok_code

Token_Res158 := Row_Pos96;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res158));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos158 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos96 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos96,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos158 := Row_Pos96 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos158 /= No_Token_Index then
        Or_Pos39 := Token_Pos158;
        Or_Res39 := Token_Res158;
        goto Exit_Or40;
    end if;
    
--  Start tok_code

Token_Res159 := Row_Pos96;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res159));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pragma)
   then
       Token_Pos159 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos96 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos96,
             Expected_Token_Id => Ada_Pragma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos159 := Row_Pos96 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos159 /= No_Token_Index then
        Or_Pos39 := Token_Pos159;
        Or_Res39 := Token_Res159;
        goto Exit_Or40;
    end if;
    
--  Start tok_code

Token_Res160 := Row_Pos96;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res160));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos160 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos96 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos96,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos160 := Row_Pos96 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos160 /= No_Token_Index then
        Or_Pos39 := Token_Pos160;
        Or_Res39 := Token_Res160;
        goto Exit_Or40;
    end if;
<<Exit_Or40>>

--  End or_code




if Or_Pos39 /= No_Token_Index then

   Row_Pos96 := Or_Pos39;

else
   Row_Pos96 := No_Token_Index;
   goto Exit_Row96_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row96_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Exception_Handler0_Extract_Parse0_Memo,
      Row_Pos96 /= No_Token_Index,
      Null_Res4,
      Pos,
      Row_Pos96);


   Parser.Current_Pos := Row_Pos96;

   Exit_Call (Parser, Call_Depth);
   return Null_Res4;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Exception_Handler0_Extract_Parse0;

   


function Dontskip_Generic_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos97 :
            Token_Index
               := No_Token_Index;
      Null_Res5 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos161 :
            Token_Index
               := No_Token_Index;
      Token_Res161 :
            Token_Index
               := No_Token_Index;
      Token_Pos162 :
            Token_Index
               := No_Token_Index;
      Token_Res162 :
            Token_Index
               := No_Token_Index;
      Or_Pos40 :
            Token_Index
               := No_Token_Index;
      Or_Res40 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Generic_Decl0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res5 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos97 := Pos;



   Null_Res5 := No_Bare_Ada_Node;




if Row_Pos97 /= No_Token_Index then

   Row_Pos97 := Row_Pos97;

else
   Row_Pos97 := No_Token_Index;
   goto Exit_Row97_0;

end if;


--  Start or_code

Or_Pos40 := No_Token_Index;
Or_Res40 := No_Token_Index;
    
--  Start tok_code

Token_Res161 := Row_Pos97;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res161));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos161 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos97 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos97,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos161 := Row_Pos97 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos161 /= No_Token_Index then
        Or_Pos40 := Token_Pos161;
        Or_Res40 := Token_Res161;
        goto Exit_Or41;
    end if;
    
--  Start tok_code

Token_Res162 := Row_Pos97;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res162));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos162 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos97 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos97,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos162 := Row_Pos97 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos162 /= No_Token_Index then
        Or_Pos40 := Token_Pos162;
        Or_Res40 := Token_Res162;
        goto Exit_Or41;
    end if;
<<Exit_Or41>>

--  End or_code




if Or_Pos40 /= No_Token_Index then

   Row_Pos97 := Or_Pos40;

else
   Row_Pos97 := No_Token_Index;
   goto Exit_Row97_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row97_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Generic_Decl0_Extract_Parse0_Memo,
      Row_Pos97 /= No_Token_Index,
      Null_Res5,
      Pos,
      Row_Pos97);


   Parser.Current_Pos := Row_Pos97;

   Exit_Call (Parser, Call_Depth);
   return Null_Res5;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Generic_Decl0_Extract_Parse0;

   


function Dontskip_Generic_Decl1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos98 :
            Token_Index
               := No_Token_Index;
      Null_Res6 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos163 :
            Token_Index
               := No_Token_Index;
      Token_Res163 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Generic_Decl1_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res6 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos98 := Pos;



   Null_Res6 := No_Bare_Ada_Node;




if Row_Pos98 /= No_Token_Index then

   Row_Pos98 := Row_Pos98;

else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;

end if;


--  Start tok_code

Token_Res163 := Row_Pos98;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res163));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos163 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos98 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos98,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos163 := Row_Pos98 + 1;
   end if;
end;

--  End tok_code




if Token_Pos163 /= No_Token_Index then

   Row_Pos98 := Token_Pos163;

else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row98_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Generic_Decl1_Extract_Parse0_Memo,
      Row_Pos98 /= No_Token_Index,
      Null_Res6,
      Pos,
      Row_Pos98);


   Parser.Current_Pos := Row_Pos98;

   Exit_Call (Parser, Call_Depth);
   return Null_Res6;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Generic_Decl1_Extract_Parse0;

   


function Dontskip_Handled_Stmts0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos99 :
            Token_Index
               := No_Token_Index;
      Null_Res7 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos164 :
            Token_Index
               := No_Token_Index;
      Token_Res164 :
            Token_Index
               := No_Token_Index;
      Token_Pos165 :
            Token_Index
               := No_Token_Index;
      Token_Res165 :
            Token_Index
               := No_Token_Index;
      Or_Pos41 :
            Token_Index
               := No_Token_Index;
      Or_Res41 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Handled_Stmts0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res7 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res7;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos99 := Pos;



   Null_Res7 := No_Bare_Ada_Node;




if Row_Pos99 /= No_Token_Index then

   Row_Pos99 := Row_Pos99;

else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;

end if;


--  Start or_code

Or_Pos41 := No_Token_Index;
Or_Res41 := No_Token_Index;
    
--  Start tok_code

Token_Res164 := Row_Pos99;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res164));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Exception)
   then
       Token_Pos164 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos99 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos99,
             Expected_Token_Id => Ada_Exception,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos164 := Row_Pos99 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos164 /= No_Token_Index then
        Or_Pos41 := Token_Pos164;
        Or_Res41 := Token_Res164;
        goto Exit_Or42;
    end if;
    
--  Start tok_code

Token_Res165 := Row_Pos99;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res165));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos165 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos99 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos99,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos165 := Row_Pos99 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos165 /= No_Token_Index then
        Or_Pos41 := Token_Pos165;
        Or_Res41 := Token_Res165;
        goto Exit_Or42;
    end if;
<<Exit_Or42>>

--  End or_code




if Or_Pos41 /= No_Token_Index then

   Row_Pos99 := Or_Pos41;

else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row99_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Handled_Stmts0_Extract_Parse0_Memo,
      Row_Pos99 /= No_Token_Index,
      Null_Res7,
      Pos,
      Row_Pos99);


   Parser.Current_Pos := Row_Pos99;

   Exit_Call (Parser, Call_Depth);
   return Null_Res7;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Handled_Stmts0_Extract_Parse0;

   


function Dontskip_If_Stmt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos100 :
            Token_Index
               := No_Token_Index;
      Null_Res8 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos166 :
            Token_Index
               := No_Token_Index;
      Token_Res166 :
            Token_Index
               := No_Token_Index;
      Token_Pos167 :
            Token_Index
               := No_Token_Index;
      Token_Res167 :
            Token_Index
               := No_Token_Index;
      Token_Pos168 :
            Token_Index
               := No_Token_Index;
      Token_Res168 :
            Token_Index
               := No_Token_Index;
      Or_Pos42 :
            Token_Index
               := No_Token_Index;
      Or_Res42 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_If_Stmt0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res8 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res8;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos100 := Pos;



   Null_Res8 := No_Bare_Ada_Node;




if Row_Pos100 /= No_Token_Index then

   Row_Pos100 := Row_Pos100;

else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;

end if;


--  Start or_code

Or_Pos42 := No_Token_Index;
Or_Res42 := No_Token_Index;
    
--  Start tok_code

Token_Res166 := Row_Pos100;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res166));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Elsif)
   then
       Token_Pos166 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos100 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos100,
             Expected_Token_Id => Ada_Elsif,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos166 := Row_Pos100 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos166 /= No_Token_Index then
        Or_Pos42 := Token_Pos166;
        Or_Res42 := Token_Res166;
        goto Exit_Or43;
    end if;
    
--  Start tok_code

Token_Res167 := Row_Pos100;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res167));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos167 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos100 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos100,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos167 := Row_Pos100 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos167 /= No_Token_Index then
        Or_Pos42 := Token_Pos167;
        Or_Res42 := Token_Res167;
        goto Exit_Or43;
    end if;
    
--  Start tok_code

Token_Res168 := Row_Pos100;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res168));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos168 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos100 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos100,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos168 := Row_Pos100 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos168 /= No_Token_Index then
        Or_Pos42 := Token_Pos168;
        Or_Res42 := Token_Res168;
        goto Exit_Or43;
    end if;
<<Exit_Or43>>

--  End or_code




if Or_Pos42 /= No_Token_Index then

   Row_Pos100 := Or_Pos42;

else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row100_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_If_Stmt0_Extract_Parse0_Memo,
      Row_Pos100 /= No_Token_Index,
      Null_Res8,
      Pos,
      Row_Pos100);


   Parser.Current_Pos := Row_Pos100;

   Exit_Call (Parser, Call_Depth);
   return Null_Res8;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_If_Stmt0_Extract_Parse0;

   


function Dontskip_If_Stmt1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos101 :
            Token_Index
               := No_Token_Index;
      Null_Res9 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos169 :
            Token_Index
               := No_Token_Index;
      Token_Res169 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_If_Stmt1_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res9 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res9;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res9;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos101 := Pos;



   Null_Res9 := No_Bare_Ada_Node;




if Row_Pos101 /= No_Token_Index then

   Row_Pos101 := Row_Pos101;

else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;

end if;


--  Start tok_code

Token_Res169 := Row_Pos101;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res169));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos169 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos101 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos101,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos169 := Row_Pos101 + 1;
   end if;
end;

--  End tok_code




if Token_Pos169 /= No_Token_Index then

   Row_Pos101 := Token_Pos169;

else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row101_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_If_Stmt1_Extract_Parse0_Memo,
      Row_Pos101 /= No_Token_Index,
      Null_Res9,
      Pos,
      Row_Pos101);


   Parser.Current_Pos := Row_Pos101;

   Exit_Call (Parser, Call_Depth);
   return Null_Res9;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_If_Stmt1_Extract_Parse0;

   


function Dontskip_Iloop_Stmt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos102 :
            Token_Index
               := No_Token_Index;
      Null_Res10 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos170 :
            Token_Index
               := No_Token_Index;
      Token_Res170 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Iloop_Stmt0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res10 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res10;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res10;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos102 := Pos;



   Null_Res10 := No_Bare_Ada_Node;




if Row_Pos102 /= No_Token_Index then

   Row_Pos102 := Row_Pos102;

else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;

end if;


--  Start tok_code

Token_Res170 := Row_Pos102;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res170));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos170 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos102 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos102,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos170 := Row_Pos102 + 1;
   end if;
end;

--  End tok_code




if Token_Pos170 /= No_Token_Index then

   Row_Pos102 := Token_Pos170;

else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row102_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Iloop_Stmt0_Extract_Parse0_Memo,
      Row_Pos102 /= No_Token_Index,
      Null_Res10,
      Pos,
      Row_Pos102);


   Parser.Current_Pos := Row_Pos102;

   Exit_Call (Parser, Call_Depth);
   return Null_Res10;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Iloop_Stmt0_Extract_Parse0;

   


function Dontskip_Iloop_Stmt1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos103 :
            Token_Index
               := No_Token_Index;
      Null_Res11 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos171 :
            Token_Index
               := No_Token_Index;
      Token_Res171 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Iloop_Stmt1_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res11 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res11;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos103 := Pos;



   Null_Res11 := No_Bare_Ada_Node;




if Row_Pos103 /= No_Token_Index then

   Row_Pos103 := Row_Pos103;

else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;

end if;


--  Start tok_code

Token_Res171 := Row_Pos103;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res171));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos171 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos103 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos103,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos171 := Row_Pos103 + 1;
   end if;
end;

--  End tok_code




if Token_Pos171 /= No_Token_Index then

   Row_Pos103 := Token_Pos171;

else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row103_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Iloop_Stmt1_Extract_Parse0_Memo,
      Row_Pos103 /= No_Token_Index,
      Null_Res11,
      Pos,
      Row_Pos103);


   Parser.Current_Pos := Row_Pos103;

   Exit_Call (Parser, Call_Depth);
   return Null_Res11;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Iloop_Stmt1_Extract_Parse0;

   


function Dontskip_Iloop_Stmt2_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos104 :
            Token_Index
               := No_Token_Index;
      Null_Res12 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos172 :
            Token_Index
               := No_Token_Index;
      Token_Res172 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Iloop_Stmt2_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res12 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res12;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos104 := Pos;



   Null_Res12 := No_Bare_Ada_Node;




if Row_Pos104 /= No_Token_Index then

   Row_Pos104 := Row_Pos104;

else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;

end if;


--  Start tok_code

Token_Res172 := Row_Pos104;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res172));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos172 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos104 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos104,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos172 := Row_Pos104 + 1;
   end if;
end;

--  End tok_code




if Token_Pos172 /= No_Token_Index then

   Row_Pos104 := Token_Pos172;

else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row104_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Iloop_Stmt2_Extract_Parse0_Memo,
      Row_Pos104 /= No_Token_Index,
      Null_Res12,
      Pos,
      Row_Pos104);


   Parser.Current_Pos := Row_Pos104;

   Exit_Call (Parser, Call_Depth);
   return Null_Res12;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Iloop_Stmt2_Extract_Parse0;

   


function Dontskip_Package_Body0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos105 :
            Token_Index
               := No_Token_Index;
      Null_Res13 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos173 :
            Token_Index
               := No_Token_Index;
      Token_Res173 :
            Token_Index
               := No_Token_Index;
      Token_Pos174 :
            Token_Index
               := No_Token_Index;
      Token_Res174 :
            Token_Index
               := No_Token_Index;
      Or_Pos43 :
            Token_Index
               := No_Token_Index;
      Or_Res43 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Package_Body0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res13 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res13;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res13;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos105 := Pos;



   Null_Res13 := No_Bare_Ada_Node;




if Row_Pos105 /= No_Token_Index then

   Row_Pos105 := Row_Pos105;

else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;

end if;


--  Start or_code

Or_Pos43 := No_Token_Index;
Or_Res43 := No_Token_Index;
    
--  Start tok_code

Token_Res173 := Row_Pos105;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res173));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos173 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos105 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos105,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos173 := Row_Pos105 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos173 /= No_Token_Index then
        Or_Pos43 := Token_Pos173;
        Or_Res43 := Token_Res173;
        goto Exit_Or44;
    end if;
    
--  Start tok_code

Token_Res174 := Row_Pos105;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res174));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos174 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos105 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos105,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos174 := Row_Pos105 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos174 /= No_Token_Index then
        Or_Pos43 := Token_Pos174;
        Or_Res43 := Token_Res174;
        goto Exit_Or44;
    end if;
<<Exit_Or44>>

--  End or_code




if Or_Pos43 /= No_Token_Index then

   Row_Pos105 := Or_Pos43;

else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row105_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Package_Body0_Extract_Parse0_Memo,
      Row_Pos105 /= No_Token_Index,
      Null_Res13,
      Pos,
      Row_Pos105);


   Parser.Current_Pos := Row_Pos105;

   Exit_Call (Parser, Call_Depth);
   return Null_Res13;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Package_Body0_Extract_Parse0;

   


function Dontskip_Package_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos106 :
            Token_Index
               := No_Token_Index;
      Null_Res14 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos175 :
            Token_Index
               := No_Token_Index;
      Token_Res175 :
            Token_Index
               := No_Token_Index;
      Token_Pos176 :
            Token_Index
               := No_Token_Index;
      Token_Res176 :
            Token_Index
               := No_Token_Index;
      Or_Pos44 :
            Token_Index
               := No_Token_Index;
      Or_Res44 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Package_Decl0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res14 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res14;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos106 := Pos;



   Null_Res14 := No_Bare_Ada_Node;




if Row_Pos106 /= No_Token_Index then

   Row_Pos106 := Row_Pos106;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  Start or_code

Or_Pos44 := No_Token_Index;
Or_Res44 := No_Token_Index;
    
--  Start tok_code

Token_Res175 := Row_Pos106;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res175));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos175 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos106 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos106,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos175 := Row_Pos106 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos175 /= No_Token_Index then
        Or_Pos44 := Token_Pos175;
        Or_Res44 := Token_Res175;
        goto Exit_Or45;
    end if;
    
--  Start tok_code

Token_Res176 := Row_Pos106;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res176));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos176 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos106 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos106,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos176 := Row_Pos106 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos176 /= No_Token_Index then
        Or_Pos44 := Token_Pos176;
        Or_Res44 := Token_Res176;
        goto Exit_Or45;
    end if;
<<Exit_Or45>>

--  End or_code




if Or_Pos44 /= No_Token_Index then

   Row_Pos106 := Or_Pos44;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row106_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Package_Decl0_Extract_Parse0_Memo,
      Row_Pos106 /= No_Token_Index,
      Null_Res14,
      Pos,
      Row_Pos106);


   Parser.Current_Pos := Row_Pos106;

   Exit_Call (Parser, Call_Depth);
   return Null_Res14;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Package_Decl0_Extract_Parse0;

   


function Dontskip_Package_Decl1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos107 :
            Token_Index
               := No_Token_Index;
      Null_Res15 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos177 :
            Token_Index
               := No_Token_Index;
      Token_Res177 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Package_Decl1_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res15 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res15;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res15;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos107 := Pos;



   Null_Res15 := No_Bare_Ada_Node;




if Row_Pos107 /= No_Token_Index then

   Row_Pos107 := Row_Pos107;

else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;

end if;


--  Start tok_code

Token_Res177 := Row_Pos107;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res177));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos177 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos107 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos107,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos177 := Row_Pos107 + 1;
   end if;
end;

--  End tok_code




if Token_Pos177 /= No_Token_Index then

   Row_Pos107 := Token_Pos177;

else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row107_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Package_Decl1_Extract_Parse0_Memo,
      Row_Pos107 /= No_Token_Index,
      Null_Res15,
      Pos,
      Row_Pos107);


   Parser.Current_Pos := Row_Pos107;

   Exit_Call (Parser, Call_Depth);
   return Null_Res15;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Package_Decl1_Extract_Parse0;

   


function Dontskip_Protected_Body0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos108 :
            Token_Index
               := No_Token_Index;
      Null_Res16 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos178 :
            Token_Index
               := No_Token_Index;
      Token_Res178 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Protected_Body0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res16 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res16;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res16;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos108 := Pos;



   Null_Res16 := No_Bare_Ada_Node;




if Row_Pos108 /= No_Token_Index then

   Row_Pos108 := Row_Pos108;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;


--  Start tok_code

Token_Res178 := Row_Pos108;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res178));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos178 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos108,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos178 := Row_Pos108 + 1;
   end if;
end;

--  End tok_code




if Token_Pos178 /= No_Token_Index then

   Row_Pos108 := Token_Pos178;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row108_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Protected_Body0_Extract_Parse0_Memo,
      Row_Pos108 /= No_Token_Index,
      Null_Res16,
      Pos,
      Row_Pos108);


   Parser.Current_Pos := Row_Pos108;

   Exit_Call (Parser, Call_Depth);
   return Null_Res16;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Protected_Body0_Extract_Parse0;

   


function Dontskip_Recov_Decl_Part0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos109 :
            Token_Index
               := No_Token_Index;
      Null_Res17 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos179 :
            Token_Index
               := No_Token_Index;
      Token_Res179 :
            Token_Index
               := No_Token_Index;
      Token_Pos180 :
            Token_Index
               := No_Token_Index;
      Token_Res180 :
            Token_Index
               := No_Token_Index;
      Token_Pos181 :
            Token_Index
               := No_Token_Index;
      Token_Res181 :
            Token_Index
               := No_Token_Index;
      Token_Pos182 :
            Token_Index
               := No_Token_Index;
      Token_Res182 :
            Token_Index
               := No_Token_Index;
      Token_Pos183 :
            Token_Index
               := No_Token_Index;
      Token_Res183 :
            Token_Index
               := No_Token_Index;
      Token_Pos184 :
            Token_Index
               := No_Token_Index;
      Token_Res184 :
            Token_Index
               := No_Token_Index;
      Token_Pos185 :
            Token_Index
               := No_Token_Index;
      Token_Res185 :
            Token_Index
               := No_Token_Index;
      Token_Pos186 :
            Token_Index
               := No_Token_Index;
      Token_Res186 :
            Token_Index
               := No_Token_Index;
      Token_Pos187 :
            Token_Index
               := No_Token_Index;
      Token_Res187 :
            Token_Index
               := No_Token_Index;
      Token_Pos188 :
            Token_Index
               := No_Token_Index;
      Token_Res188 :
            Token_Index
               := No_Token_Index;
      Or_Pos45 :
            Token_Index
               := No_Token_Index;
      Or_Res45 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Recov_Decl_Part0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res17 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res17;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos109 := Pos;



   Null_Res17 := No_Bare_Ada_Node;




if Row_Pos109 /= No_Token_Index then

   Row_Pos109 := Row_Pos109;

else
   Row_Pos109 := No_Token_Index;
   goto Exit_Row109_0;

end if;


--  Start or_code

Or_Pos45 := No_Token_Index;
Or_Res45 := No_Token_Index;
    
--  Start tok_code

Token_Res179 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res179));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos179 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos179 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos179 /= No_Token_Index then
        Or_Pos45 := Token_Pos179;
        Or_Res45 := Token_Res179;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res180 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res180));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos180 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos180 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos180 /= No_Token_Index then
        Or_Pos45 := Token_Pos180;
        Or_Res45 := Token_Res180;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res181 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res181));
begin
   if
      T.Kind /= From_Token_Kind (Ada_If)
   then
       Token_Pos181 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_If,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos181 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos181 /= No_Token_Index then
        Or_Pos45 := Token_Pos181;
        Or_Res45 := Token_Res181;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res182 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res182));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos182 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos182 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos182 /= No_Token_Index then
        Or_Pos45 := Token_Pos182;
        Or_Res45 := Token_Res182;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res183 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res183));
begin
   if
      T.Kind /= From_Token_Kind (Ada_While)
   then
       Token_Pos183 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_While,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos183 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos183 /= No_Token_Index then
        Or_Pos45 := Token_Pos183;
        Or_Res45 := Token_Res183;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res184 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res184));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos184 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos184 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos184 /= No_Token_Index then
        Or_Pos45 := Token_Pos184;
        Or_Res45 := Token_Res184;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res185 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res185));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Declare)
   then
       Token_Pos185 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_Declare,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos185 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos185 /= No_Token_Index then
        Or_Pos45 := Token_Pos185;
        Or_Res45 := Token_Res185;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res186 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res186));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Accept)
   then
       Token_Pos186 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_Accept,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos186 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos186 /= No_Token_Index then
        Or_Pos45 := Token_Pos186;
        Or_Res45 := Token_Res186;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res187 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res187));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Select)
   then
       Token_Pos187 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_Select,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos187 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos187 /= No_Token_Index then
        Or_Pos45 := Token_Pos187;
        Or_Res45 := Token_Res187;
        goto Exit_Or46;
    end if;
    
--  Start tok_code

Token_Res188 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res188));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Case)
   then
       Token_Pos188 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Ada_Case,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos188 := Row_Pos109 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos188 /= No_Token_Index then
        Or_Pos45 := Token_Pos188;
        Or_Res45 := Token_Res188;
        goto Exit_Or46;
    end if;
<<Exit_Or46>>

--  End or_code




if Or_Pos45 /= No_Token_Index then

   Row_Pos109 := Or_Pos45;

else
   Row_Pos109 := No_Token_Index;
   goto Exit_Row109_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row109_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Recov_Decl_Part0_Extract_Parse0_Memo,
      Row_Pos109 /= No_Token_Index,
      Null_Res17,
      Pos,
      Row_Pos109);


   Parser.Current_Pos := Row_Pos109;

   Exit_Call (Parser, Call_Depth);
   return Null_Res17;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Recov_Decl_Part0_Extract_Parse0;

   


function Dontskip_Select_Stmt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos110 :
            Token_Index
               := No_Token_Index;
      Null_Res18 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos189 :
            Token_Index
               := No_Token_Index;
      Token_Res189 :
            Token_Index
               := No_Token_Index;
      Token_Pos190 :
            Token_Index
               := No_Token_Index;
      Token_Res190 :
            Token_Index
               := No_Token_Index;
      Token_Pos191 :
            Token_Index
               := No_Token_Index;
      Token_Res191 :
            Token_Index
               := No_Token_Index;
      Token_Pos192 :
            Token_Index
               := No_Token_Index;
      Token_Res192 :
            Token_Index
               := No_Token_Index;
      Or_Pos46 :
            Token_Index
               := No_Token_Index;
      Or_Res46 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Select_Stmt0_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res18 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res18;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res18;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos110 := Pos;



   Null_Res18 := No_Bare_Ada_Node;




if Row_Pos110 /= No_Token_Index then

   Row_Pos110 := Row_Pos110;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;


--  Start or_code

Or_Pos46 := No_Token_Index;
Or_Res46 := No_Token_Index;
    
--  Start tok_code

Token_Res189 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res189));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos189 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos189 := Row_Pos110 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos189 /= No_Token_Index then
        Or_Pos46 := Token_Pos189;
        Or_Res46 := Token_Res189;
        goto Exit_Or47;
    end if;
    
--  Start tok_code

Token_Res190 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res190));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos190 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos190 := Row_Pos110 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos190 /= No_Token_Index then
        Or_Pos46 := Token_Pos190;
        Or_Res46 := Token_Res190;
        goto Exit_Or47;
    end if;
    
--  Start tok_code

Token_Res191 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res191));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos191 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos191 := Row_Pos110 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos191 /= No_Token_Index then
        Or_Pos46 := Token_Pos191;
        Or_Res46 := Token_Res191;
        goto Exit_Or47;
    end if;
    
--  Start tok_code

Token_Res192 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res192));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Or)
   then
       Token_Pos192 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Ada_Or,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos192 := Row_Pos110 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos192 /= No_Token_Index then
        Or_Pos46 := Token_Pos192;
        Or_Res46 := Token_Res192;
        goto Exit_Or47;
    end if;
<<Exit_Or47>>

--  End or_code




if Or_Pos46 /= No_Token_Index then

   Row_Pos110 := Or_Pos46;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row110_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Select_Stmt0_Extract_Parse0_Memo,
      Row_Pos110 /= No_Token_Index,
      Null_Res18,
      Pos,
      Row_Pos110);


   Parser.Current_Pos := Row_Pos110;

   Exit_Call (Parser, Call_Depth);
   return Null_Res18;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Select_Stmt0_Extract_Parse0;

   


function Dontskip_Select_Stmt1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos111 :
            Token_Index
               := No_Token_Index;
      Null_Res19 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos193 :
            Token_Index
               := No_Token_Index;
      Token_Res193 :
            Token_Index
               := No_Token_Index;
      Token_Pos194 :
            Token_Index
               := No_Token_Index;
      Token_Res194 :
            Token_Index
               := No_Token_Index;
      Or_Pos47 :
            Token_Index
               := No_Token_Index;
      Or_Res47 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Select_Stmt1_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res19 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res19;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos111 := Pos;



   Null_Res19 := No_Bare_Ada_Node;




if Row_Pos111 /= No_Token_Index then

   Row_Pos111 := Row_Pos111;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;


--  Start or_code

Or_Pos47 := No_Token_Index;
Or_Res47 := No_Token_Index;
    
--  Start tok_code

Token_Res193 := Row_Pos111;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res193));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos193 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos111 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos111,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos193 := Row_Pos111 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos193 /= No_Token_Index then
        Or_Pos47 := Token_Pos193;
        Or_Res47 := Token_Res193;
        goto Exit_Or48;
    end if;
    
--  Start tok_code

Token_Res194 := Row_Pos111;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res194));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos194 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos111 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos111,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos194 := Row_Pos111 + 1;
   end if;
end;

--  End tok_code

    if Token_Pos194 /= No_Token_Index then
        Or_Pos47 := Token_Pos194;
        Or_Res47 := Token_Res194;
        goto Exit_Or48;
    end if;
<<Exit_Or48>>

--  End or_code




if Or_Pos47 /= No_Token_Index then

   Row_Pos111 := Or_Pos47;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row111_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Select_Stmt1_Extract_Parse0_Memo,
      Row_Pos111 /= No_Token_Index,
      Null_Res19,
      Pos,
      Row_Pos111);


   Parser.Current_Pos := Row_Pos111;

   Exit_Call (Parser, Call_Depth);
   return Null_Res19;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Select_Stmt1_Extract_Parse0;

   


function Dontskip_Select_Stmt2_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos112 :
            Token_Index
               := No_Token_Index;
      Null_Res20 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos195 :
            Token_Index
               := No_Token_Index;
      Token_Res195 :
            Token_Index
               := No_Token_Index;


   M : Memo_Entry := Get (Parser.Private_Part.Dontskip_Select_Stmt2_Extract_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Null_Res20 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Null_Res20;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Null_Res20;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start row_code

Row_Pos112 := Pos;



   Null_Res20 := No_Bare_Ada_Node;




if Row_Pos112 /= No_Token_Index then

   Row_Pos112 := Row_Pos112;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;


--  Start tok_code

Token_Res195 := Row_Pos112;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res195));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos195 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos112,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos195 := Row_Pos112 + 1;
   end if;
end;

--  End tok_code




if Token_Pos195 /= No_Token_Index then

   Row_Pos112 := Token_Pos195;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row112_0>>
pragma Warnings (On, "referenced");

--  End row_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Dontskip_Select_Stmt2_Extract_Parse0_Memo,
      Row_Pos112 /= No_Token_Index,
      Null_Res20,
      Pos,
      Row_Pos112);


   Parser.Current_Pos := Row_Pos112;

   Exit_Call (Parser, Call_Depth);
   return Null_Res20;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Dontskip_Select_Stmt2_Extract_Parse0;

   


function Elsif_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Elsif_Stmt_Part
is
   use Bare_Elsif_Stmt_Part_Memos;

   Call_Depth : aliased Natural;

      Row_Pos113 :
            Token_Index
               := No_Token_Index;
      Token_Pos196 :
            Token_Index
               := No_Token_Index;
      Token_Res196 :
            Token_Index
               := No_Token_Index;
      Defer_Pos191 :
            Token_Index
               := No_Token_Index;
      Defer_Res191 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos197 :
            Token_Index
               := No_Token_Index;
      Token_Res197 :
            Token_Index
               := No_Token_Index;
      Defer_Pos192 :
            Token_Index
               := No_Token_Index;
      Defer_Res192 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Transform_Res72 :
            Bare_Elsif_Stmt_Part
               := No_Bare_Ada_Node;
      Transform_Diags72 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Elsif_Part_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res72 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res72;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res72;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags72 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos113 := Pos;



--  Start tok_code

Token_Res196 := Row_Pos113;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res196));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Elsif)
   then
       Token_Pos196 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos113 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos113,
             Expected_Token_Id => Ada_Elsif,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos196 := Row_Pos113 + 1;
   end if;
end;

--  End tok_code




if Token_Pos196 /= No_Token_Index then

   Row_Pos113 := Token_Pos196;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;


Defer_Res191 :=
   Expr_Or_Parse0 (Parser, Row_Pos113);
Defer_Pos191 := Parser.Current_Pos;




if Defer_Pos191 /= No_Token_Index then

   Row_Pos113 := Defer_Pos191;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;


--  Start tok_code

Token_Res197 := Row_Pos113;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res197));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos197 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos113 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos113,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos197 := Row_Pos113 + 1;
   end if;
end;

--  End tok_code




if Token_Pos197 /= No_Token_Index then

   Row_Pos113 := Token_Pos197;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Elsif_Part0_Extract_Parse0'Access);
        
Defer_Res192 :=
   Stmts_List_Parse0 (Parser, Row_Pos113);
Defer_Pos192 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos192 /= No_Token_Index then

   Row_Pos113 := Defer_Pos192;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row113_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos113 /= No_Token_Index then

   Transform_Res72 := Allocate_Elsif_Stmt_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res72,
      Kind => Ada_Elsif_Stmt_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos113 = Pos
                            then No_Token_Index
                            else Row_Pos113 - 1));

      Initialize_Fields_For_Elsif_Stmt_Part
        (Self => Transform_Res72, Elsif_Stmt_Part_F_Cond_Expr => Defer_Res191, Elsif_Stmt_Part_F_Stmts => Defer_Res192);

         if Defer_Res191 /= null and then Is_Incomplete (Defer_Res191) then
            Transform_Res72.Last_Attempted_Child := 0;
         elsif Defer_Res191 /= null and then not Is_Ghost (Defer_Res191) then
            Transform_Res72.Last_Attempted_Child := -1;
         end if;
         if Defer_Res192 /= null and then Is_Incomplete (Defer_Res192) then
            Transform_Res72.Last_Attempted_Child := 0;
         elsif Defer_Res192 /= null and then not Is_Ghost (Defer_Res192) then
            Transform_Res72.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos113 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags72);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Elsif_Part_Transform_Parse0_Memo,
      Row_Pos113 /= No_Token_Index,
      Transform_Res72,
      Pos,
      Row_Pos113);


   Parser.Current_Pos := Row_Pos113;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res72;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Elsif_Part_Transform_Parse0;

   


function Entry_Body_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Entry_Body
is
   use Bare_Entry_Body_Memos;

   Call_Depth : aliased Natural;

      Nobt9 :
            Boolean
               := False;
      Row_Pos114 :
            Token_Index
               := No_Token_Index;
      Token_Pos198 :
            Token_Index
               := No_Token_Index;
      Token_Res198 :
            Token_Index
               := No_Token_Index;
      Defer_Pos193 :
            Token_Index
               := No_Token_Index;
      Defer_Res193 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Row_Pos115 :
            Token_Index
               := No_Token_Index;
      Token_Pos199 :
            Token_Index
               := No_Token_Index;
      Token_Res199 :
            Token_Index
               := No_Token_Index;
      Token_Pos200 :
            Token_Index
               := No_Token_Index;
      Token_Res200 :
            Token_Index
               := No_Token_Index;
      Defer_Pos194 :
            Token_Index
               := No_Token_Index;
      Defer_Res194 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos201 :
            Token_Index
               := No_Token_Index;
      Token_Res201 :
            Token_Index
               := No_Token_Index;
      Defer_Pos195 :
            Token_Index
               := No_Token_Index;
      Defer_Res195 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Defer_Pos196 :
            Token_Index
               := No_Token_Index;
      Defer_Res196 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos202 :
            Token_Index
               := No_Token_Index;
      Token_Res202 :
            Token_Index
               := No_Token_Index;
      Transform_Res73 :
            Bare_Entry_Index_Spec
               := No_Bare_Ada_Node;
      Transform_Diags73 :
            Ada.Containers.Count_Type;
      Row_Pos116 :
            Token_Index
               := No_Token_Index;
      Defer_Pos197 :
            Token_Index
               := No_Token_Index;
      Defer_Res197 :
            Bare_Params
               := No_Bare_Ada_Node;
      Transform_Res74 :
            Bare_Entry_Completion_Formal_Params
               := No_Bare_Ada_Node;
      Transform_Diags74 :
            Ada.Containers.Count_Type;
      Defer_Pos198 :
            Token_Index
               := No_Token_Index;
      Defer_Res198 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos203 :
            Token_Index
               := No_Token_Index;
      Token_Res203 :
            Token_Index
               := No_Token_Index;
      Defer_Pos199 :
            Token_Index
               := No_Token_Index;
      Defer_Res199 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos204 :
            Token_Index
               := No_Token_Index;
      Token_Res204 :
            Token_Index
               := No_Token_Index;
      Defer_Pos200 :
            Token_Index
               := No_Token_Index;
      Defer_Res200 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Token_Pos205 :
            Token_Index
               := No_Token_Index;
      Token_Res205 :
            Token_Index
               := No_Token_Index;
      Defer_Pos201 :
            Token_Index
               := No_Token_Index;
      Defer_Res201 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos117 :
            Token_Index
               := No_Token_Index;
      Token_Pos206 :
            Token_Index
               := No_Token_Index;
      Token_Res206 :
            Token_Index
               := No_Token_Index;
      Row_Pos118 :
            Token_Index
               := No_Token_Index;
      Defer_Pos202 :
            Token_Index
               := No_Token_Index;
      Defer_Res202 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res75 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags75 :
            Ada.Containers.Count_Type;
      Token_Pos207 :
            Token_Index
               := No_Token_Index;
      Token_Res207 :
            Token_Index
               := No_Token_Index;
      Row_Progress9 :
            Integer
               := 0;
      Transform_Res76 :
            Bare_Entry_Body
               := No_Bare_Ada_Node;
      Transform_Has_Failed9 :
            Boolean
               := False;
      Transform_Diags76 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Entry_Body_Transform_Parse3_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res76 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res76;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res76;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags76 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos114 := Pos;



--  Start tok_code

Token_Res198 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res198));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Entry)
   then
       Token_Pos198 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Ada_Entry,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos198 := Row_Pos114 + 1;
   end if;
end;

--  End tok_code



Row_Progress9 := 1;

if Token_Pos198 /= No_Token_Index then

   Row_Pos114 := Token_Pos198;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


Defer_Res193 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos114);
Defer_Pos193 := Parser.Current_Pos;



Row_Progress9 := 2;

if Defer_Pos193 /= No_Token_Index then

   Row_Pos114 := Defer_Pos193;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags73 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos115 := Row_Pos114;



--  Start tok_code

Token_Res199 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res199));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos199 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos199 := Row_Pos115 + 1;
   end if;
end;

--  End tok_code




if Token_Pos199 /= No_Token_Index then

   Row_Pos115 := Token_Pos199;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  Start tok_code

Token_Res200 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res200));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos200 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos200 := Row_Pos115 + 1;
   end if;
end;

--  End tok_code




if Token_Pos200 /= No_Token_Index then

   Row_Pos115 := Token_Pos200;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


Defer_Res194 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos115);
Defer_Pos194 := Parser.Current_Pos;




if Defer_Pos194 /= No_Token_Index then

   Row_Pos115 := Defer_Pos194;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  Start tok_code

Token_Res201 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res201));
begin
   if
      T.Kind /= From_Token_Kind (Ada_In)
   then
       Token_Pos201 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Ada_In,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos201 := Row_Pos115 + 1;
   end if;
end;

--  End tok_code




if Token_Pos201 /= No_Token_Index then

   Row_Pos115 := Token_Pos201;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


Defer_Res195 :=
   Discrete_Subtype_Definition_Or_Parse0 (Parser, Row_Pos115);
Defer_Pos195 := Parser.Current_Pos;




if Defer_Pos195 /= No_Token_Index then

   Row_Pos115 := Defer_Pos195;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  Start opt_code












Defer_Res196 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos115);
Defer_Pos196 := Parser.Current_Pos;


if Defer_Pos196 = No_Token_Index then

         
   Defer_Res196 := No_Bare_Ada_Node;



       
   Defer_Pos196 := Row_Pos115;



end if;

--  End opt_code




if Defer_Pos196 /= No_Token_Index then

   Row_Pos115 := Defer_Pos196;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  Start tok_code

Token_Res202 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res202));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos202 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos202 := Row_Pos115 + 1;
   end if;
end;

--  End tok_code




if Token_Pos202 /= No_Token_Index then

   Row_Pos115 := Token_Pos202;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row115_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos115 /= No_Token_Index then

   Transform_Res73 := Allocate_Entry_Index_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res73,
      Kind => Ada_Entry_Index_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos114,
      Token_End_Index   => (if Row_Pos115 = Row_Pos114
                            then No_Token_Index
                            else Row_Pos115 - 1));

      Initialize_Fields_For_Entry_Index_Spec
        (Self => Transform_Res73, Entry_Index_Spec_F_Id => Defer_Res194, Entry_Index_Spec_F_Subtype => Defer_Res195, Entry_Index_Spec_F_Aspects => Defer_Res196);

         if Defer_Res194 /= null and then Is_Incomplete (Defer_Res194) then
            Transform_Res73.Last_Attempted_Child := 0;
         elsif Defer_Res194 /= null and then not Is_Ghost (Defer_Res194) then
            Transform_Res73.Last_Attempted_Child := -1;
         end if;
         if Defer_Res195 /= null and then Is_Incomplete (Defer_Res195) then
            Transform_Res73.Last_Attempted_Child := 0;
         elsif Defer_Res195 /= null and then not Is_Ghost (Defer_Res195) then
            Transform_Res73.Last_Attempted_Child := -1;
         end if;
         if Defer_Res196 /= null and then Is_Incomplete (Defer_Res196) then
            Transform_Res73.Last_Attempted_Child := 0;
         elsif Defer_Res196 /= null and then not Is_Ghost (Defer_Res196) then
            Transform_Res73.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos115 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags73);
end if;

--  End transform_code


if Row_Pos115 = No_Token_Index then

         
   Transform_Res73 := No_Bare_Ada_Node;



       
   Row_Pos115 := Row_Pos114;



end if;

--  End opt_code



Row_Progress9 := 3;

if Row_Pos115 /= No_Token_Index then

   Row_Pos114 := Row_Pos115;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start transform_code

Transform_Diags74 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos116 := Row_Pos114;



--  Start opt_code












Defer_Res197 :=
   Param_Specs_Transform_Parse0 (Parser, Row_Pos116);
Defer_Pos197 := Parser.Current_Pos;


if Defer_Pos197 = No_Token_Index then

         
   Defer_Res197 := No_Bare_Ada_Node;



       
   Defer_Pos197 := Row_Pos116;



end if;

--  End opt_code




if Defer_Pos197 /= No_Token_Index then

   Row_Pos116 := Defer_Pos197;

else
   Row_Pos116 := No_Token_Index;
   goto Exit_Row116_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row116_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos116 /= No_Token_Index then

   Transform_Res74 := Allocate_Entry_Completion_Formal_Params (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res74,
      Kind => Ada_Entry_Completion_Formal_Params,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos114,
      Token_End_Index   => (if Row_Pos116 = Row_Pos114
                            then No_Token_Index
                            else Row_Pos116 - 1));

      Initialize_Fields_For_Entry_Completion_Formal_Params
        (Self => Transform_Res74, Entry_Completion_Formal_Params_F_Params => Defer_Res197);

         if Defer_Res197 /= null and then Is_Incomplete (Defer_Res197) then
            Transform_Res74.Last_Attempted_Child := 0;
         elsif Defer_Res197 /= null and then not Is_Ghost (Defer_Res197) then
            Transform_Res74.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos116 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags74);
end if;

--  End transform_code



Row_Progress9 := 4;

if Row_Pos116 /= No_Token_Index then

   Row_Pos114 := Row_Pos116;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


Defer_Res198 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos114);
Defer_Pos198 := Parser.Current_Pos;



Row_Progress9 := 5;

if Defer_Pos198 /= No_Token_Index then

   Row_Pos114 := Defer_Pos198;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start tok_code

Token_Res203 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res203));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos203 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos203 := Row_Pos114 + 1;
   end if;
end;

--  End tok_code



Row_Progress9 := 6;

if Token_Pos203 /= No_Token_Index then

   Row_Pos114 := Token_Pos203;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


Defer_Res199 :=
   Expr_Or_Parse0 (Parser, Row_Pos114);
Defer_Pos199 := Parser.Current_Pos;



Row_Progress9 := 7;

if Defer_Pos199 /= No_Token_Index then

   Row_Pos114 := Defer_Pos199;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start tok_code

Token_Res204 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res204));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos204 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos204 := Row_Pos114 + 1;
   end if;
end;

--  End tok_code



Row_Progress9 := 8;

if Token_Pos204 /= No_Token_Index then

   Row_Pos114 := Token_Pos204;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;

Nobt9 := True;

   Nobt9 := Nobt9;

Row_Progress9 := 9;

if Row_Pos114 /= No_Token_Index then

   Row_Pos114 := Row_Pos114;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


Defer_Res200 :=
   Recov_Decl_Part_Dont_Skip_Parse0 (Parser, Row_Pos114);
Defer_Pos200 := Parser.Current_Pos;



Row_Progress9 := 10;

if Defer_Pos200 /= No_Token_Index then

   Row_Pos114 := Defer_Pos200;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start tok_code

Token_Res205 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res205));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos205 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos205 := Row_Pos114 + 1;
   end if;
end;

--  End tok_code



Row_Progress9 := 11;

if Token_Pos205 /= No_Token_Index then

   Row_Pos114 := Token_Pos205;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


Defer_Res201 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos114);
Defer_Pos201 := Parser.Current_Pos;



Row_Progress9 := 12;

if Defer_Pos201 /= No_Token_Index then

   Row_Pos114 := Defer_Pos201;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start row_code

Row_Pos117 := Row_Pos114;



--  Start tok_code

Token_Res206 := Row_Pos117;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res206));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos206 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos117,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos206 := Row_Pos117 + 1;
   end if;
end;

--  End tok_code




if Token_Pos206 /= No_Token_Index then

   Row_Pos117 := Token_Pos206;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags75 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos118 := Row_Pos117;



Defer_Res202 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos118);
Defer_Pos202 := Parser.Current_Pos;




if Defer_Pos202 /= No_Token_Index then

   Row_Pos118 := Defer_Pos202;

else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row118_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos118 /= No_Token_Index then

   Transform_Res75 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res75,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos117,
      Token_End_Index   => (if Row_Pos118 = Row_Pos117
                            then No_Token_Index
                            else Row_Pos118 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res75, End_Name_F_Name => Defer_Res202);

         if Defer_Res202 /= null and then Is_Incomplete (Defer_Res202) then
            Transform_Res75.Last_Attempted_Child := 0;
         elsif Defer_Res202 /= null and then not Is_Ghost (Defer_Res202) then
            Transform_Res75.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos118 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags75);
end if;

--  End transform_code


if Row_Pos118 = No_Token_Index then

         
   Transform_Res75 := No_Bare_Ada_Node;



       
   Row_Pos118 := Row_Pos117;



end if;

--  End opt_code




if Row_Pos118 /= No_Token_Index then

   Row_Pos117 := Row_Pos118;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row117_0>>
pragma Warnings (On, "referenced");

--  End row_code



Row_Progress9 := 13;

if Row_Pos117 /= No_Token_Index then

   Row_Pos114 := Row_Pos117;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res207 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res207));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos207 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos207 := Row_Pos114 + 1;
   end if;
end;

--  End tok_code


if Token_Pos207 = No_Token_Index then

         
   Token_Res207 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos114)),
                To_Text ("Missing ';'"));

       
   Token_Pos207 := Row_Pos114;



end if;

--  End opt_code



Row_Progress9 := 14;

if Token_Pos207 /= No_Token_Index then

   Row_Pos114 := Token_Pos207;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row114_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos114 = No_Token_Index and then Nobt9 then

   Row_Pos114 := Parser.Last_Fail.Pos;

   Transform_Has_Failed9 := True;
end if;

if Row_Pos114 /= No_Token_Index then

   Transform_Res76 := Allocate_Entry_Body (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res76,
      Kind => Ada_Entry_Body,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos114 = Pos
                            then No_Token_Index
                            else Row_Pos114 - 1));

      Initialize_Fields_For_Entry_Body
        (Self => Transform_Res76, Entry_Body_F_Entry_Name => Defer_Res193, Entry_Body_F_Index_Spec => Transform_Res73, Entry_Body_F_Params => Transform_Res74, Entry_Body_F_Aspects => Defer_Res198, Entry_Body_F_Barrier => Defer_Res199, Entry_Body_F_Decls => Defer_Res200, Entry_Body_F_Stmts => Defer_Res201, Entry_Body_F_End_Name => Transform_Res75);

         if Defer_Res193 /= null and then Is_Incomplete (Defer_Res193) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Defer_Res193 /= null and then not Is_Ghost (Defer_Res193) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Transform_Res73 /= null and then Is_Incomplete (Transform_Res73) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Transform_Res73 /= null and then not Is_Ghost (Transform_Res73) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Transform_Res74 /= null and then Is_Incomplete (Transform_Res74) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Transform_Res74 /= null and then not Is_Ghost (Transform_Res74) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Defer_Res198 /= null and then Is_Incomplete (Defer_Res198) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Defer_Res198 /= null and then not Is_Ghost (Defer_Res198) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Defer_Res199 /= null and then Is_Incomplete (Defer_Res199) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Defer_Res199 /= null and then not Is_Ghost (Defer_Res199) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Defer_Res200 /= null and then Is_Incomplete (Defer_Res200) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Defer_Res200 /= null and then not Is_Ghost (Defer_Res200) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Defer_Res201 /= null and then Is_Incomplete (Defer_Res201) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Defer_Res201 /= null and then not Is_Ghost (Defer_Res201) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
         if Transform_Res75 /= null and then Is_Incomplete (Transform_Res75) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif Transform_Res75 /= null and then not Is_Ghost (Transform_Res75) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed9 then
      Transform_Res76.Last_Attempted_Child :=
         Row_Progress9;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <entry_body>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos114 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags76);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Entry_Body_Transform_Parse3_Memo,
      Row_Pos114 /= No_Token_Index,
      Transform_Res76,
      Pos,
      Row_Pos114);


   Parser.Current_Pos := Row_Pos114;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res76;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Entry_Body_Transform_Parse3;

   


function Entry_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Entry_Decl
is
   use Bare_Entry_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos119 :
            Token_Index
               := No_Token_Index;
      Defer_Pos203 :
            Token_Index
               := No_Token_Index;
      Defer_Res203 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Row_Pos120 :
            Token_Index
               := No_Token_Index;
      Token_Pos208 :
            Token_Index
               := No_Token_Index;
      Token_Res208 :
            Token_Index
               := No_Token_Index;
      Defer_Pos204 :
            Token_Index
               := No_Token_Index;
      Defer_Res204 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Row_Pos121 :
            Token_Index
               := No_Token_Index;
      Token_Pos209 :
            Token_Index
               := No_Token_Index;
      Token_Res209 :
            Token_Index
               := No_Token_Index;
      Defer_Pos205 :
            Token_Index
               := No_Token_Index;
      Defer_Res205 :
            Bare_Constrained_Subtype_Indication
               := No_Bare_Ada_Node;
      Defer_Pos206 :
            Token_Index
               := No_Token_Index;
      Defer_Res206 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos207 :
            Token_Index
               := No_Token_Index;
      Defer_Res207 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Or_Pos48 :
            Token_Index
               := No_Token_Index;
      Or_Res48 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos210 :
            Token_Index
               := No_Token_Index;
      Token_Res210 :
            Token_Index
               := No_Token_Index;
      Defer_Pos208 :
            Token_Index
               := No_Token_Index;
      Defer_Res208 :
            Bare_Params
               := No_Bare_Ada_Node;
      Transform_Res77 :
            Bare_Entry_Spec
               := No_Bare_Ada_Node;
      Transform_Diags77 :
            Ada.Containers.Count_Type;
      Defer_Pos209 :
            Token_Index
               := No_Token_Index;
      Defer_Res209 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos211 :
            Token_Index
               := No_Token_Index;
      Token_Res211 :
            Token_Index
               := No_Token_Index;
      Transform_Res78 :
            Bare_Entry_Decl
               := No_Bare_Ada_Node;
      Transform_Diags78 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Entry_Decl_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res78 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res78;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res78;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags78 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos119 := Pos;



Defer_Res203 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos119);
Defer_Pos203 := Parser.Current_Pos;




if Defer_Pos203 /= No_Token_Index then

   Row_Pos119 := Defer_Pos203;

else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;

end if;


--  Start transform_code

Transform_Diags77 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos120 := Row_Pos119;



--  Start tok_code

Token_Res208 := Row_Pos120;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res208));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Entry)
   then
       Token_Pos208 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos120 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos120,
             Expected_Token_Id => Ada_Entry,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos208 := Row_Pos120 + 1;
   end if;
end;

--  End tok_code




if Token_Pos208 /= No_Token_Index then

   Row_Pos120 := Token_Pos208;

else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;

end if;


Defer_Res204 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos120);
Defer_Pos204 := Parser.Current_Pos;




if Defer_Pos204 /= No_Token_Index then

   Row_Pos120 := Defer_Pos204;

else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos121 := Row_Pos120;



--  Start tok_code

Token_Res209 := Row_Pos121;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res209));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos209 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos121 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos121,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos209 := Row_Pos121 + 1;
   end if;
end;

--  End tok_code




if Token_Pos209 /= No_Token_Index then

   Row_Pos121 := Token_Pos209;

else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;

end if;


--  Start or_code

Or_Pos48 := No_Token_Index;
Or_Res48 := No_Bare_Ada_Node;
    
Defer_Res205 :=
   Constrained_Subtype_Indication_Transform_Parse0 (Parser, Row_Pos121);
Defer_Pos205 := Parser.Current_Pos;

    if Defer_Pos205 /= No_Token_Index then
        Or_Pos48 := Defer_Pos205;
        Or_Res48 := Defer_Res205;
        goto Exit_Or49;
    end if;
    
Defer_Res206 :=
   Discrete_Range_Or_Parse0 (Parser, Row_Pos121);
Defer_Pos206 := Parser.Current_Pos;

    if Defer_Pos206 /= No_Token_Index then
        Or_Pos48 := Defer_Pos206;
        Or_Res48 := Defer_Res206;
        goto Exit_Or49;
    end if;
    
Defer_Res207 :=
   Subtype_Indication_Transform_Parse0 (Parser, Row_Pos121);
Defer_Pos207 := Parser.Current_Pos;

    if Defer_Pos207 /= No_Token_Index then
        Or_Pos48 := Defer_Pos207;
        Or_Res48 := Defer_Res207;
        goto Exit_Or49;
    end if;
<<Exit_Or49>>

--  End or_code




if Or_Pos48 /= No_Token_Index then

   Row_Pos121 := Or_Pos48;

else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;

end if;


--  Start tok_code

Token_Res210 := Row_Pos121;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res210));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos210 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos121 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos121,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos210 := Row_Pos121 + 1;
   end if;
end;

--  End tok_code




if Token_Pos210 /= No_Token_Index then

   Row_Pos121 := Token_Pos210;

else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row121_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos121 = No_Token_Index then

         
   Or_Res48 := No_Bare_Ada_Node;



       
   Row_Pos121 := Row_Pos120;



end if;

--  End opt_code




if Row_Pos121 /= No_Token_Index then

   Row_Pos120 := Row_Pos121;

else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;

end if;


--  Start opt_code












Defer_Res208 :=
   Param_Specs_Transform_Parse0 (Parser, Row_Pos120);
Defer_Pos208 := Parser.Current_Pos;


if Defer_Pos208 = No_Token_Index then

         
   Defer_Res208 := No_Bare_Ada_Node;



       
   Defer_Pos208 := Row_Pos120;



end if;

--  End opt_code




if Defer_Pos208 /= No_Token_Index then

   Row_Pos120 := Defer_Pos208;

else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row120_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos120 /= No_Token_Index then

   Transform_Res77 := Allocate_Entry_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res77,
      Kind => Ada_Entry_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos119,
      Token_End_Index   => (if Row_Pos120 = Row_Pos119
                            then No_Token_Index
                            else Row_Pos120 - 1));

      Initialize_Fields_For_Entry_Spec
        (Self => Transform_Res77, Entry_Spec_F_Entry_Name => Defer_Res204, Entry_Spec_F_Family_Type => Or_Res48, Entry_Spec_F_Entry_Params => Defer_Res208);

         if Defer_Res204 /= null and then Is_Incomplete (Defer_Res204) then
            Transform_Res77.Last_Attempted_Child := 0;
         elsif Defer_Res204 /= null and then not Is_Ghost (Defer_Res204) then
            Transform_Res77.Last_Attempted_Child := -1;
         end if;
         if Or_Res48 /= null and then Is_Incomplete (Or_Res48) then
            Transform_Res77.Last_Attempted_Child := 0;
         elsif Or_Res48 /= null and then not Is_Ghost (Or_Res48) then
            Transform_Res77.Last_Attempted_Child := -1;
         end if;
         if Defer_Res208 /= null and then Is_Incomplete (Defer_Res208) then
            Transform_Res77.Last_Attempted_Child := 0;
         elsif Defer_Res208 /= null and then not Is_Ghost (Defer_Res208) then
            Transform_Res77.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos120 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags77);
end if;

--  End transform_code




if Row_Pos120 /= No_Token_Index then

   Row_Pos119 := Row_Pos120;

else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;

end if;


Defer_Res209 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos119);
Defer_Pos209 := Parser.Current_Pos;




if Defer_Pos209 /= No_Token_Index then

   Row_Pos119 := Defer_Pos209;

else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res211 := Row_Pos119;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res211));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos211 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos119 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos119,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos211 := Row_Pos119 + 1;
   end if;
end;

--  End tok_code


if Token_Pos211 = No_Token_Index then

         
   Token_Res211 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos119)),
                To_Text ("Missing ';'"));

       
   Token_Pos211 := Row_Pos119;



end if;

--  End opt_code




if Token_Pos211 /= No_Token_Index then

   Row_Pos119 := Token_Pos211;

else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row119_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos119 /= No_Token_Index then

   Transform_Res78 := Allocate_Entry_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res78,
      Kind => Ada_Entry_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos119 = Pos
                            then No_Token_Index
                            else Row_Pos119 - 1));

      Initialize_Fields_For_Entry_Decl
        (Self => Transform_Res78, Entry_Decl_F_Overriding => Defer_Res203, Entry_Decl_F_Spec => Transform_Res77, Entry_Decl_F_Aspects => Defer_Res209);

         if Defer_Res203 /= null and then Is_Incomplete (Defer_Res203) then
            Transform_Res78.Last_Attempted_Child := 0;
         elsif Defer_Res203 /= null and then not Is_Ghost (Defer_Res203) then
            Transform_Res78.Last_Attempted_Child := -1;
         end if;
         if Transform_Res77 /= null and then Is_Incomplete (Transform_Res77) then
            Transform_Res78.Last_Attempted_Child := 0;
         elsif Transform_Res77 /= null and then not Is_Ghost (Transform_Res77) then
            Transform_Res78.Last_Attempted_Child := -1;
         end if;
         if Defer_Res209 /= null and then Is_Incomplete (Defer_Res209) then
            Transform_Res78.Last_Attempted_Child := 0;
         elsif Defer_Res209 /= null and then not Is_Ghost (Defer_Res209) then
            Transform_Res78.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos119 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags78);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Entry_Decl_Transform_Parse1_Memo,
      Row_Pos119 /= No_Token_Index,
      Transform_Res78,
      Pos,
      Row_Pos119);


   Parser.Current_Pos := Row_Pos119;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res78;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Entry_Decl_Transform_Parse1;

   


function Enum_Literal_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Literal_Decl
is
   use Bare_Enum_Literal_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos122 :
            Token_Index
               := No_Token_Index;
      Defer_Pos210 :
            Token_Index
               := No_Token_Index;
      Defer_Res210 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Row_Pos123 :
            Token_Index
               := No_Token_Index;
      Defer_Pos211 :
            Token_Index
               := No_Token_Index;
      Defer_Res211 :
            Bare_Char_Literal
               := No_Bare_Ada_Node;
      Transform_Res79 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Diags79 :
            Ada.Containers.Count_Type;
      Or_Pos49 :
            Token_Index
               := No_Token_Index;
      Or_Res49 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Res80 :
            Bare_Enum_Literal_Decl
               := No_Bare_Ada_Node;
      Transform_Diags80 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Enum_Literal_Decl_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res80 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res80;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res80;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags80 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos122 := Pos;



--  Start or_code

Or_Pos49 := No_Token_Index;
Or_Res49 := No_Bare_Ada_Node;
    
Defer_Res210 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos122);
Defer_Pos210 := Parser.Current_Pos;

    if Defer_Pos210 /= No_Token_Index then
        Or_Pos49 := Defer_Pos210;
        Or_Res49 := Defer_Res210;
        goto Exit_Or50;
    end if;
    
--  Start transform_code

Transform_Diags79 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos123 := Row_Pos122;



Defer_Res211 :=
   Char_Literal_Transform_Parse0 (Parser, Row_Pos123);
Defer_Pos211 := Parser.Current_Pos;




if Defer_Pos211 /= No_Token_Index then

   Row_Pos123 := Defer_Pos211;

else
   Row_Pos123 := No_Token_Index;
   goto Exit_Row123_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row123_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos123 /= No_Token_Index then

   Transform_Res79 := Allocate_Defining_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res79,
      Kind => Ada_Defining_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos122,
      Token_End_Index   => (if Row_Pos123 = Row_Pos122
                            then No_Token_Index
                            else Row_Pos123 - 1));

      Initialize_Fields_For_Defining_Name
        (Self => Transform_Res79, Defining_Name_F_Name => Defer_Res211);

         if Defer_Res211 /= null and then Is_Incomplete (Defer_Res211) then
            Transform_Res79.Last_Attempted_Child := 0;
         elsif Defer_Res211 /= null and then not Is_Ghost (Defer_Res211) then
            Transform_Res79.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos123 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags79);
end if;

--  End transform_code

    if Row_Pos123 /= No_Token_Index then
        Or_Pos49 := Row_Pos123;
        Or_Res49 := Transform_Res79;
        goto Exit_Or50;
    end if;
<<Exit_Or50>>

--  End or_code




if Or_Pos49 /= No_Token_Index then

   Row_Pos122 := Or_Pos49;

else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row122_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos122 /= No_Token_Index then

   Transform_Res80 := Allocate_Enum_Literal_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res80,
      Kind => Ada_Enum_Literal_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos122 = Pos
                            then No_Token_Index
                            else Row_Pos122 - 1));

      Initialize_Fields_For_Enum_Literal_Decl
        (Self => Transform_Res80, Enum_Literal_Decl_F_Name => Or_Res49);

         if Or_Res49 /= null and then Is_Incomplete (Or_Res49) then
            Transform_Res80.Last_Attempted_Child := 0;
         elsif Or_Res49 /= null and then not Is_Ghost (Or_Res49) then
            Transform_Res80.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos122 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags80);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Enum_Literal_Decl_Transform_Parse1_Memo,
      Row_Pos122 /= No_Token_Index,
      Transform_Res80,
      Pos,
      Row_Pos122);


   Parser.Current_Pos := Row_Pos122;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res80;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Enum_Literal_Decl_Transform_Parse1;

   


function Enum_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Type_Def
is
   use Bare_Enum_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos124 :
            Token_Index
               := No_Token_Index;
      Token_Pos212 :
            Token_Index
               := No_Token_Index;
      Token_Res212 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos27 :
            Token_Index
               := No_Token_Index;
      Tmp_List27 :
            Free_Parse_List;
      Defer_Pos212 :
            Token_Index
               := No_Token_Index;
      Defer_Res212 :
            Bare_Enum_Literal_Decl
               := No_Bare_Ada_Node;
      Token_Pos213 :
            Token_Index
               := No_Token_Index;
      Token_Res213 :
            Token_Index
               := No_Token_Index;
      List_Pos27 :
            Token_Index
               := No_Token_Index;
      List_Res27 :
            Bare_Enum_Literal_Decl_List
               := No_Bare_Ada_Node;
      Token_Pos214 :
            Token_Index
               := No_Token_Index;
      Token_Res214 :
            Token_Index
               := No_Token_Index;
      Transform_Res81 :
            Bare_Enum_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags81 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Enum_Type_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res81 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res81;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res81;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags81 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos124 := Pos;



--  Start tok_code

Token_Res212 := Row_Pos124;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res212));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos212 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos124 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos124,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos212 := Row_Pos124 + 1;
   end if;
end;

--  End tok_code




if Token_Pos212 /= No_Token_Index then

   Row_Pos124 := Token_Pos212;

else
   Row_Pos124 := No_Token_Index;
   goto Exit_Row124_0;

end if;


--  Start list_code

    List_Pos27 := No_Token_Index;



Lst_Cpos27 := Row_Pos124;
Tmp_List27 := Get_Parse_List (Parser);

loop
   
Defer_Res212 :=
   Enum_Literal_Decl_Transform_Parse1 (Parser, Lst_Cpos27);
Defer_Pos212 := Parser.Current_Pos;


   exit when Defer_Pos212 = No_Token_Index;

   List_Pos27 := Defer_Pos212;
   Lst_Cpos27 := List_Pos27;

   Tmp_List27.Nodes.Append (Defer_Res212);

      
--  Start tok_code

Token_Res213 := Lst_Cpos27;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res213));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos213 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos27 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos27,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos213 := Lst_Cpos27 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos213 /= No_Token_Index then
          Lst_Cpos27 := Token_Pos213;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List27.Nodes.Length;
begin
   List_Res27 :=
      Allocate_Enum_Literal_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos124;
      Token_End := (if Lst_Cpos27 = Row_Pos124
                    then Row_Pos124
                    else Lst_Cpos27 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos124, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res27,
      Kind              => Ada_Enum_Literal_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res27,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List27.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res27.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List27);

--  End list_code




if List_Pos27 /= No_Token_Index then

   Row_Pos124 := List_Pos27;

else
   Row_Pos124 := No_Token_Index;
   goto Exit_Row124_0;

end if;


--  Start tok_code

Token_Res214 := Row_Pos124;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res214));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos214 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos124 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos124,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos214 := Row_Pos124 + 1;
   end if;
end;

--  End tok_code




if Token_Pos214 /= No_Token_Index then

   Row_Pos124 := Token_Pos214;

else
   Row_Pos124 := No_Token_Index;
   goto Exit_Row124_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row124_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos124 /= No_Token_Index then

   Transform_Res81 := Allocate_Enum_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res81,
      Kind => Ada_Enum_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos124 = Pos
                            then No_Token_Index
                            else Row_Pos124 - 1));

      Initialize_Fields_For_Enum_Type_Def
        (Self => Transform_Res81, Enum_Type_Def_F_Enum_Literals => List_Res27);

         if List_Res27 /= null and then Is_Incomplete (List_Res27) then
            Transform_Res81.Last_Attempted_Child := 0;
         elsif List_Res27 /= null and then not Is_Ghost (List_Res27) then
            Transform_Res81.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos124 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags81);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Enum_Type_Def_Transform_Parse0_Memo,
      Row_Pos124 /= No_Token_Index,
      Transform_Res81,
      Pos,
      Row_Pos124);


   Parser.Current_Pos := Row_Pos124;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res81;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Enum_Type_Def_Transform_Parse0;

   


function Exception_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Exception_Decl
is
   use Bare_Exception_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos125 :
            Token_Index
               := No_Token_Index;
      Defer_Pos213 :
            Token_Index
               := No_Token_Index;
      Defer_Res213 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos215 :
            Token_Index
               := No_Token_Index;
      Token_Res215 :
            Token_Index
               := No_Token_Index;
      Token_Pos216 :
            Token_Index
               := No_Token_Index;
      Token_Res216 :
            Token_Index
               := No_Token_Index;
      Defer_Pos214 :
            Token_Index
               := No_Token_Index;
      Defer_Res214 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Defer_Pos215 :
            Token_Index
               := No_Token_Index;
      Defer_Res215 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos217 :
            Token_Index
               := No_Token_Index;
      Token_Res217 :
            Token_Index
               := No_Token_Index;
      Transform_Res82 :
            Bare_Exception_Decl
               := No_Bare_Ada_Node;
      Transform_Diags82 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Exception_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res82 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res82;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res82;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags82 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos125 := Pos;



Defer_Res213 :=
   Defining_Id_List_List_Parse0 (Parser, Row_Pos125);
Defer_Pos213 := Parser.Current_Pos;




if Defer_Pos213 /= No_Token_Index then

   Row_Pos125 := Defer_Pos213;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;


--  Start tok_code

Token_Res215 := Row_Pos125;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res215));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos215 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos125 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos125,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos215 := Row_Pos125 + 1;
   end if;
end;

--  End tok_code




if Token_Pos215 /= No_Token_Index then

   Row_Pos125 := Token_Pos215;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;


--  Start tok_code

Token_Res216 := Row_Pos125;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res216));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Exception)
   then
       Token_Pos216 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos125 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos125,
             Expected_Token_Id => Ada_Exception,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos216 := Row_Pos125 + 1;
   end if;
end;

--  End tok_code




if Token_Pos216 /= No_Token_Index then

   Row_Pos125 := Token_Pos216;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;


--  Start opt_code












Defer_Res214 :=
   Renaming_Clause_Transform_Parse0 (Parser, Row_Pos125);
Defer_Pos214 := Parser.Current_Pos;


if Defer_Pos214 = No_Token_Index then

         
   Defer_Res214 := No_Bare_Ada_Node;



       
   Defer_Pos214 := Row_Pos125;



end if;

--  End opt_code




if Defer_Pos214 /= No_Token_Index then

   Row_Pos125 := Defer_Pos214;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;


Defer_Res215 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos125);
Defer_Pos215 := Parser.Current_Pos;




if Defer_Pos215 /= No_Token_Index then

   Row_Pos125 := Defer_Pos215;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res217 := Row_Pos125;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res217));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos217 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos125 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos125,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos217 := Row_Pos125 + 1;
   end if;
end;

--  End tok_code


if Token_Pos217 = No_Token_Index then

         
   Token_Res217 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos125)),
                To_Text ("Missing ';'"));

       
   Token_Pos217 := Row_Pos125;



end if;

--  End opt_code




if Token_Pos217 /= No_Token_Index then

   Row_Pos125 := Token_Pos217;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row125_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos125 /= No_Token_Index then

   Transform_Res82 := Allocate_Exception_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res82,
      Kind => Ada_Exception_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos125 = Pos
                            then No_Token_Index
                            else Row_Pos125 - 1));

      Initialize_Fields_For_Exception_Decl
        (Self => Transform_Res82, Exception_Decl_F_Ids => Defer_Res213, Exception_Decl_F_Renames => Defer_Res214, Exception_Decl_F_Aspects => Defer_Res215);

         if Defer_Res213 /= null and then Is_Incomplete (Defer_Res213) then
            Transform_Res82.Last_Attempted_Child := 0;
         elsif Defer_Res213 /= null and then not Is_Ghost (Defer_Res213) then
            Transform_Res82.Last_Attempted_Child := -1;
         end if;
         if Defer_Res214 /= null and then Is_Incomplete (Defer_Res214) then
            Transform_Res82.Last_Attempted_Child := 0;
         elsif Defer_Res214 /= null and then not Is_Ghost (Defer_Res214) then
            Transform_Res82.Last_Attempted_Child := -1;
         end if;
         if Defer_Res215 /= null and then Is_Incomplete (Defer_Res215) then
            Transform_Res82.Last_Attempted_Child := 0;
         elsif Defer_Res215 /= null and then not Is_Ghost (Defer_Res215) then
            Transform_Res82.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos125 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags82);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Exception_Decl_Transform_Parse0_Memo,
      Row_Pos125 /= No_Token_Index,
      Transform_Res82,
      Pos,
      Row_Pos125);


   Parser.Current_Pos := Row_Pos125;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res82;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Exception_Decl_Transform_Parse0;

   


function Exception_Handler_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Exception_Handler
is
   use Bare_Exception_Handler_Memos;

   Call_Depth : aliased Natural;

      Row_Pos126 :
            Token_Index
               := No_Token_Index;
      Token_Pos218 :
            Token_Index
               := No_Token_Index;
      Token_Res218 :
            Token_Index
               := No_Token_Index;
      Row_Pos127 :
            Token_Index
               := No_Token_Index;
      Defer_Pos216 :
            Token_Index
               := No_Token_Index;
      Defer_Res216 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos219 :
            Token_Index
               := No_Token_Index;
      Token_Res219 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos28 :
            Token_Index
               := No_Token_Index;
      Tmp_List28 :
            Free_Parse_List;
      Defer_Pos217 :
            Token_Index
               := No_Token_Index;
      Defer_Res217 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos218 :
            Token_Index
               := No_Token_Index;
      Defer_Res218 :
            Bare_Others_Designator
               := No_Bare_Ada_Node;
      Or_Pos50 :
            Token_Index
               := No_Token_Index;
      Or_Res50 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos220 :
            Token_Index
               := No_Token_Index;
      Token_Res220 :
            Token_Index
               := No_Token_Index;
      List_Pos28 :
            Token_Index
               := No_Token_Index;
      List_Res28 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;
      Token_Pos221 :
            Token_Index
               := No_Token_Index;
      Token_Res221 :
            Token_Index
               := No_Token_Index;
      Defer_Pos219 :
            Token_Index
               := No_Token_Index;
      Defer_Res219 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Transform_Res83 :
            Bare_Exception_Handler
               := No_Bare_Ada_Node;
      Transform_Diags83 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Exception_Handler_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res83 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res83;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res83;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags83 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos126 := Pos;



--  Start tok_code

Token_Res218 := Row_Pos126;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res218));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos218 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos126 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos126,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos218 := Row_Pos126 + 1;
   end if;
end;

--  End tok_code




if Token_Pos218 /= No_Token_Index then

   Row_Pos126 := Token_Pos218;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos127 := Row_Pos126;



Defer_Res216 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos127);
Defer_Pos216 := Parser.Current_Pos;




if Defer_Pos216 /= No_Token_Index then

   Row_Pos127 := Defer_Pos216;

else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;

end if;


--  Start tok_code

Token_Res219 := Row_Pos127;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res219));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos219 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos127 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos127,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos219 := Row_Pos127 + 1;
   end if;
end;

--  End tok_code




if Token_Pos219 /= No_Token_Index then

   Row_Pos127 := Token_Pos219;

else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row127_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos127 = No_Token_Index then

         
   Defer_Res216 := No_Bare_Ada_Node;



       
   Row_Pos127 := Row_Pos126;



end if;

--  End opt_code




if Row_Pos127 /= No_Token_Index then

   Row_Pos126 := Row_Pos127;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


--  Start list_code

    List_Pos28 := No_Token_Index;



Lst_Cpos28 := Row_Pos126;
Tmp_List28 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos50 := No_Token_Index;
Or_Res50 := No_Bare_Ada_Node;
    
Defer_Res217 :=
   Name_Or_Parse2 (Parser, Lst_Cpos28);
Defer_Pos217 := Parser.Current_Pos;

    if Defer_Pos217 /= No_Token_Index then
        Or_Pos50 := Defer_Pos217;
        Or_Res50 := Defer_Res217;
        goto Exit_Or51;
    end if;
    
Defer_Res218 :=
   Others_Designator_Transform_Parse0 (Parser, Lst_Cpos28);
Defer_Pos218 := Parser.Current_Pos;

    if Defer_Pos218 /= No_Token_Index then
        Or_Pos50 := Defer_Pos218;
        Or_Res50 := Defer_Res218;
        goto Exit_Or51;
    end if;
<<Exit_Or51>>

--  End or_code


   exit when Or_Pos50 = No_Token_Index;

   List_Pos28 := Or_Pos50;
   Lst_Cpos28 := List_Pos28;

   Tmp_List28.Nodes.Append (Or_Res50);

      
--  Start tok_code

Token_Res220 := Lst_Cpos28;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res220));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pipe)
   then
       Token_Pos220 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos28 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos28,
             Expected_Token_Id => Ada_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos220 := Lst_Cpos28 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos220 /= No_Token_Index then
          Lst_Cpos28 := Token_Pos220;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List28.Nodes.Length;
begin
   List_Res28 :=
      Allocate_Alternatives_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos126;
      Token_End := (if Lst_Cpos28 = Row_Pos126
                    then Row_Pos126
                    else Lst_Cpos28 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos126, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res28,
      Kind              => Ada_Alternatives_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res28,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List28.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res28.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List28);

--  End list_code




if List_Pos28 /= No_Token_Index then

   Row_Pos126 := List_Pos28;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


--  Start tok_code

Token_Res221 := Row_Pos126;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res221));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos221 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos126 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos126,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos221 := Row_Pos126 + 1;
   end if;
end;

--  End tok_code




if Token_Pos221 /= No_Token_Index then

   Row_Pos126 := Token_Pos221;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Exception_Handler0_Extract_Parse0'Access);
        
Defer_Res219 :=
   Stmts_List_Parse0 (Parser, Row_Pos126);
Defer_Pos219 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos219 /= No_Token_Index then

   Row_Pos126 := Defer_Pos219;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row126_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos126 /= No_Token_Index then

   Transform_Res83 := Allocate_Exception_Handler (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res83,
      Kind => Ada_Exception_Handler,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos126 = Pos
                            then No_Token_Index
                            else Row_Pos126 - 1));

      Initialize_Fields_For_Exception_Handler
        (Self => Transform_Res83, Exception_Handler_F_Exception_Name => Defer_Res216, Exception_Handler_F_Handled_Exceptions => List_Res28, Exception_Handler_F_Stmts => Defer_Res219);

         if Defer_Res216 /= null and then Is_Incomplete (Defer_Res216) then
            Transform_Res83.Last_Attempted_Child := 0;
         elsif Defer_Res216 /= null and then not Is_Ghost (Defer_Res216) then
            Transform_Res83.Last_Attempted_Child := -1;
         end if;
         if List_Res28 /= null and then Is_Incomplete (List_Res28) then
            Transform_Res83.Last_Attempted_Child := 0;
         elsif List_Res28 /= null and then not Is_Ghost (List_Res28) then
            Transform_Res83.Last_Attempted_Child := -1;
         end if;
         if Defer_Res219 /= null and then Is_Incomplete (Defer_Res219) then
            Transform_Res83.Last_Attempted_Child := 0;
         elsif Defer_Res219 /= null and then not Is_Ghost (Defer_Res219) then
            Transform_Res83.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos126 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags83);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Exception_Handler_Transform_Parse0_Memo,
      Row_Pos126 /= No_Token_Index,
      Transform_Res83,
      Pos,
      Row_Pos126);


   Parser.Current_Pos := Row_Pos126;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res83;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Exception_Handler_Transform_Parse0;

   


function Exit_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Exit_Stmt
is
   use Bare_Exit_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt10 :
            Boolean
               := False;
      Row_Pos128 :
            Token_Index
               := No_Token_Index;
      Token_Pos222 :
            Token_Index
               := No_Token_Index;
      Token_Res222 :
            Token_Index
               := No_Token_Index;
      Defer_Pos220 :
            Token_Index
               := No_Token_Index;
      Defer_Res220 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos129 :
            Token_Index
               := No_Token_Index;
      Token_Pos223 :
            Token_Index
               := No_Token_Index;
      Token_Res223 :
            Token_Index
               := No_Token_Index;
      Defer_Pos221 :
            Token_Index
               := No_Token_Index;
      Defer_Res221 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos224 :
            Token_Index
               := No_Token_Index;
      Token_Res224 :
            Token_Index
               := No_Token_Index;
      Row_Progress10 :
            Integer
               := 0;
      Transform_Res84 :
            Bare_Exit_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed10 :
            Boolean
               := False;
      Transform_Diags84 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Exit_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res84 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res84;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res84;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags84 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos128 := Pos;



--  Start tok_code

Token_Res222 := Row_Pos128;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res222));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Exit)
   then
       Token_Pos222 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos128 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos128,
             Expected_Token_Id => Ada_Exit,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos222 := Row_Pos128 + 1;
   end if;
end;

--  End tok_code



Row_Progress10 := 1;

if Token_Pos222 /= No_Token_Index then

   Row_Pos128 := Token_Pos222;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;

Nobt10 := True;

   Nobt10 := Nobt10;

Row_Progress10 := 2;

if Row_Pos128 /= No_Token_Index then

   Row_Pos128 := Row_Pos128;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;


--  Start opt_code












Defer_Res220 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos128);
Defer_Pos220 := Parser.Current_Pos;


if Defer_Pos220 = No_Token_Index then

         
   Defer_Res220 := No_Bare_Ada_Node;



       
   Defer_Pos220 := Row_Pos128;



end if;

--  End opt_code



Row_Progress10 := 3;

if Defer_Pos220 /= No_Token_Index then

   Row_Pos128 := Defer_Pos220;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos129 := Row_Pos128;



--  Start tok_code

Token_Res223 := Row_Pos129;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res223));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos223 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos129 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos129,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos223 := Row_Pos129 + 1;
   end if;
end;

--  End tok_code




if Token_Pos223 /= No_Token_Index then

   Row_Pos129 := Token_Pos223;

else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;

end if;


Defer_Res221 :=
   Expr_Or_Parse0 (Parser, Row_Pos129);
Defer_Pos221 := Parser.Current_Pos;




if Defer_Pos221 /= No_Token_Index then

   Row_Pos129 := Defer_Pos221;

else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row129_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos129 = No_Token_Index then

         
   Defer_Res221 := No_Bare_Ada_Node;



       
   Row_Pos129 := Row_Pos128;



end if;

--  End opt_code



Row_Progress10 := 4;

if Row_Pos129 /= No_Token_Index then

   Row_Pos128 := Row_Pos129;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res224 := Row_Pos128;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res224));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos224 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos128 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos128,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos224 := Row_Pos128 + 1;
   end if;
end;

--  End tok_code


if Token_Pos224 = No_Token_Index then

         
   Token_Res224 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos128)),
                To_Text ("Missing ';'"));

       
   Token_Pos224 := Row_Pos128;



end if;

--  End opt_code



Row_Progress10 := 5;

if Token_Pos224 /= No_Token_Index then

   Row_Pos128 := Token_Pos224;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row128_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos128 = No_Token_Index and then Nobt10 then

   Row_Pos128 := Parser.Last_Fail.Pos;

   Transform_Has_Failed10 := True;
end if;

if Row_Pos128 /= No_Token_Index then

   Transform_Res84 := Allocate_Exit_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res84,
      Kind => Ada_Exit_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos128 = Pos
                            then No_Token_Index
                            else Row_Pos128 - 1));

      Initialize_Fields_For_Exit_Stmt
        (Self => Transform_Res84, Exit_Stmt_F_Loop_Name => Defer_Res220, Exit_Stmt_F_Cond_Expr => Defer_Res221);

         if Defer_Res220 /= null and then Is_Incomplete (Defer_Res220) then
            Transform_Res84.Last_Attempted_Child := 0;
         elsif Defer_Res220 /= null and then not Is_Ghost (Defer_Res220) then
            Transform_Res84.Last_Attempted_Child := -1;
         end if;
         if Defer_Res221 /= null and then Is_Incomplete (Defer_Res221) then
            Transform_Res84.Last_Attempted_Child := 0;
         elsif Defer_Res221 /= null and then not Is_Ghost (Defer_Res221) then
            Transform_Res84.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed10 then
      Transform_Res84.Last_Attempted_Child :=
         Row_Progress10;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <exit_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos128 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags84);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Exit_Stmt_Transform_Parse0_Memo,
      Row_Pos128 /= No_Token_Index,
      Transform_Res84,
      Pos,
      Row_Pos128);


   Parser.Current_Pos := Row_Pos128;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res84;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Exit_Stmt_Transform_Parse0;

   


function Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt11 :
            Boolean
               := False;
      Row_Pos130 :
            Token_Index
               := No_Token_Index;
      Defer_Pos222 :
            Token_Index
               := No_Token_Index;
      Defer_Res222 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos223 :
            Token_Index
               := No_Token_Index;
      Defer_Res223 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos224 :
            Token_Index
               := No_Token_Index;
      Defer_Res224 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress11 :
            Integer
               := 0;
      Transform_Res85 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed11 :
            Boolean
               := False;
      Transform_Diags85 :
            Ada.Containers.Count_Type;
      Defer_Pos225 :
            Token_Index
               := No_Token_Index;
      Defer_Res225 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos51 :
            Token_Index
               := No_Token_Index;
      Or_Res51 :
            Bare_Expr
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Expr_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res51 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res51;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res51;
   end if;

       Set (Parser.Private_Part.Expr_Or_Parse0_Memo, False, Or_Res51, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt11 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos51 := No_Token_Index;
Or_Res51 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags85 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos130 := Pos;



Defer_Res222 :=
   Expr_Or_Parse0 (Parser, Row_Pos130);
Defer_Pos222 := Parser.Current_Pos;



Row_Progress11 := 1;

if Defer_Pos222 /= No_Token_Index then

   Row_Pos130 := Defer_Pos222;

else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;

end if;


Defer_Res223 :=
   Boolean_Op_Or_Parse0 (Parser, Row_Pos130);
Defer_Pos223 := Parser.Current_Pos;



Row_Progress11 := 2;

if Defer_Pos223 /= No_Token_Index then

   Row_Pos130 := Defer_Pos223;

else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;

end if;

Nobt11 := True;

   Nobt11 := Nobt11;

Row_Progress11 := 3;

if Row_Pos130 /= No_Token_Index then

   Row_Pos130 := Row_Pos130;

else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;

end if;


Defer_Res224 :=
   Relation_Or_Parse1 (Parser, Row_Pos130);
Defer_Pos224 := Parser.Current_Pos;



Row_Progress11 := 4;

if Defer_Pos224 /= No_Token_Index then

   Row_Pos130 := Defer_Pos224;

else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row130_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos130 = No_Token_Index and then Nobt11 then

   Row_Pos130 := Parser.Last_Fail.Pos;

   Transform_Has_Failed11 := True;
end if;

if Row_Pos130 /= No_Token_Index then

   Transform_Res85 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res85,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos130 = Pos
                            then No_Token_Index
                            else Row_Pos130 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res85, Bin_Op_F_Left => Defer_Res222, Bin_Op_F_Op => Defer_Res223, Bin_Op_F_Right => Defer_Res224);

         if Defer_Res222 /= null and then Is_Incomplete (Defer_Res222) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res222 /= null and then not Is_Ghost (Defer_Res222) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
         if Defer_Res223 /= null and then Is_Incomplete (Defer_Res223) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res223 /= null and then not Is_Ghost (Defer_Res223) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
         if Defer_Res224 /= null and then Is_Incomplete (Defer_Res224) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res224 /= null and then not Is_Ghost (Defer_Res224) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed11 then
      Transform_Res85.Last_Attempted_Child :=
         Row_Progress11;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <expr>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos130 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags85);
end if;

--  End transform_code

    if Row_Pos130 /= No_Token_Index then
        Or_Pos51 := Row_Pos130;
        Or_Res51 := Transform_Res85;
        goto Exit_Or52;
    end if;
    
Defer_Res225 :=
   Relation_Or_Parse1 (Parser, Pos);
Defer_Pos225 := Parser.Current_Pos;

    if Defer_Pos225 /= No_Token_Index then
        Or_Pos51 := Defer_Pos225;
        Or_Res51 := Defer_Res225;
        goto Exit_Or52;
    end if;
<<Exit_Or52>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos51 > Mem_Pos then
         Mem_Pos := Or_Pos51;
         Mem_Res := Or_Res51;
         Set
           (Parser.Private_Part.Expr_Or_Parse0_Memo,
            Or_Pos51 /= No_Token_Index,
            Or_Res51,
            Pos,
            Or_Pos51);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res51 := Mem_Res;
         Or_Pos51 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Expr_Or_Parse0_Memo,
      Or_Pos51 /= No_Token_Index,
      Or_Res51,
      Pos,
      Or_Pos51);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos51;

   Exit_Call (Parser, Call_Depth);
   return Or_Res51;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Expr_Or_Parse0;

   


function Expr_Fn_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr_Function
is
   use Bare_Expr_Function_Memos;

   Call_Depth : aliased Natural;

      Row_Pos131 :
            Token_Index
               := No_Token_Index;
      Defer_Pos226 :
            Token_Index
               := No_Token_Index;
      Defer_Res226 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos227 :
            Token_Index
               := No_Token_Index;
      Defer_Res227 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Token_Pos225 :
            Token_Index
               := No_Token_Index;
      Token_Res225 :
            Token_Index
               := No_Token_Index;
      Defer_Pos228 :
            Token_Index
               := No_Token_Index;
      Defer_Res228 :
            Bare_Paren_Expr
               := No_Bare_Ada_Node;
      Defer_Pos229 :
            Token_Index
               := No_Token_Index;
      Defer_Res229 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Or_Pos52 :
            Token_Index
               := No_Token_Index;
      Or_Res52 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos230 :
            Token_Index
               := No_Token_Index;
      Defer_Res230 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos226 :
            Token_Index
               := No_Token_Index;
      Token_Res226 :
            Token_Index
               := No_Token_Index;
      Transform_Res86 :
            Bare_Expr_Function
               := No_Bare_Ada_Node;
      Transform_Diags86 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Expr_Fn_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res86 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res86;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res86;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags86 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos131 := Pos;



Defer_Res226 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos131);
Defer_Pos226 := Parser.Current_Pos;




if Defer_Pos226 /= No_Token_Index then

   Row_Pos131 := Defer_Pos226;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;


Defer_Res227 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos131);
Defer_Pos227 := Parser.Current_Pos;




if Defer_Pos227 /= No_Token_Index then

   Row_Pos131 := Defer_Pos227;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;


--  Start tok_code

Token_Res225 := Row_Pos131;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res225));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos225 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos131 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos131,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos225 := Row_Pos131 + 1;
   end if;
end;

--  End tok_code




if Token_Pos225 /= No_Token_Index then

   Row_Pos131 := Token_Pos225;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;


--  Start or_code

Or_Pos52 := No_Token_Index;
Or_Res52 := No_Bare_Ada_Node;
    
Defer_Res228 :=
   Paren_Expr_Transform_Parse0 (Parser, Row_Pos131);
Defer_Pos228 := Parser.Current_Pos;

    if Defer_Pos228 /= No_Token_Index then
        Or_Pos52 := Defer_Pos228;
        Or_Res52 := Defer_Res228;
        goto Exit_Or53;
    end if;
    
Defer_Res229 :=
   Aggregate_Or_Parse0 (Parser, Row_Pos131);
Defer_Pos229 := Parser.Current_Pos;

    if Defer_Pos229 /= No_Token_Index then
        Or_Pos52 := Defer_Pos229;
        Or_Res52 := Defer_Res229;
        goto Exit_Or53;
    end if;
<<Exit_Or53>>

--  End or_code




if Or_Pos52 /= No_Token_Index then

   Row_Pos131 := Or_Pos52;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;


Defer_Res230 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos131);
Defer_Pos230 := Parser.Current_Pos;




if Defer_Pos230 /= No_Token_Index then

   Row_Pos131 := Defer_Pos230;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res226 := Row_Pos131;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res226));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos226 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos131 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos131,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos226 := Row_Pos131 + 1;
   end if;
end;

--  End tok_code


if Token_Pos226 = No_Token_Index then

         
   Token_Res226 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos131)),
                To_Text ("Missing ';'"));

       
   Token_Pos226 := Row_Pos131;



end if;

--  End opt_code




if Token_Pos226 /= No_Token_Index then

   Row_Pos131 := Token_Pos226;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row131_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos131 /= No_Token_Index then

   Transform_Res86 := Allocate_Expr_Function (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res86,
      Kind => Ada_Expr_Function,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos131 = Pos
                            then No_Token_Index
                            else Row_Pos131 - 1));

      Initialize_Fields_For_Expr_Function
        (Self => Transform_Res86, Base_Subp_Body_F_Overriding => Defer_Res226, Base_Subp_Body_F_Subp_Spec => Defer_Res227, Expr_Function_F_Expr => Or_Res52, Expr_Function_F_Aspects => Defer_Res230);

         if Defer_Res226 /= null and then Is_Incomplete (Defer_Res226) then
            Transform_Res86.Last_Attempted_Child := 0;
         elsif Defer_Res226 /= null and then not Is_Ghost (Defer_Res226) then
            Transform_Res86.Last_Attempted_Child := -1;
         end if;
         if Defer_Res227 /= null and then Is_Incomplete (Defer_Res227) then
            Transform_Res86.Last_Attempted_Child := 0;
         elsif Defer_Res227 /= null and then not Is_Ghost (Defer_Res227) then
            Transform_Res86.Last_Attempted_Child := -1;
         end if;
         if Or_Res52 /= null and then Is_Incomplete (Or_Res52) then
            Transform_Res86.Last_Attempted_Child := 0;
         elsif Or_Res52 /= null and then not Is_Ghost (Or_Res52) then
            Transform_Res86.Last_Attempted_Child := -1;
         end if;
         if Defer_Res230 /= null and then Is_Incomplete (Defer_Res230) then
            Transform_Res86.Last_Attempted_Child := 0;
         elsif Defer_Res230 /= null and then not Is_Ghost (Defer_Res230) then
            Transform_Res86.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos131 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags86);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Expr_Fn_Transform_Parse0_Memo,
      Row_Pos131 /= No_Token_Index,
      Transform_Res86,
      Pos,
      Row_Pos131);


   Parser.Current_Pos := Row_Pos131;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res86;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Expr_Fn_Transform_Parse0;

   


function Ext_Ret_Stmt_Object_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Extended_Return_Stmt_Object_Decl
is
   use Bare_Extended_Return_Stmt_Object_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos132 :
            Token_Index
               := No_Token_Index;
      Defer_Pos231 :
            Token_Index
               := No_Token_Index;
      Defer_Res231 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos227 :
            Token_Index
               := No_Token_Index;
      Token_Res227 :
            Token_Index
               := No_Token_Index;
      Token_Pos228 :
            Token_Index
               := No_Token_Index;
      Token_Res228 :
            Token_Index
               := No_Token_Index;
      Opt_Res14 :
            Bare_Aliased_Node
               := No_Bare_Ada_Node;
      Token_Pos229 :
            Token_Index
               := No_Token_Index;
      Token_Res229 :
            Token_Index
               := No_Token_Index;
      Opt_Res15 :
            Bare_Constant_Node
               := No_Bare_Ada_Node;
      Defer_Pos232 :
            Token_Index
               := No_Token_Index;
      Defer_Res232 :
            Bare_Mode
               := No_Bare_Ada_Node;
      Defer_Pos233 :
            Token_Index
               := No_Token_Index;
      Defer_Res233 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Row_Pos133 :
            Token_Index
               := No_Token_Index;
      Token_Pos230 :
            Token_Index
               := No_Token_Index;
      Token_Res230 :
            Token_Index
               := No_Token_Index;
      Defer_Pos234 :
            Token_Index
               := No_Token_Index;
      Defer_Res234 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos235 :
            Token_Index
               := No_Token_Index;
      Defer_Res235 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Defer_Pos236 :
            Token_Index
               := No_Token_Index;
      Defer_Res236 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Transform_Res87 :
            Bare_Extended_Return_Stmt_Object_Decl
               := No_Bare_Ada_Node;
      Transform_Diags87 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Ext_Ret_Stmt_Object_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res87 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res87;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res87;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags87 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos132 := Pos;



Defer_Res231 :=
   Defining_Id_List_List_Parse0 (Parser, Row_Pos132);
Defer_Pos231 := Parser.Current_Pos;




if Defer_Pos231 /= No_Token_Index then

   Row_Pos132 := Defer_Pos231;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


--  Start tok_code

Token_Res227 := Row_Pos132;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res227));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos227 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos132,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos227 := Row_Pos132 + 1;
   end if;
end;

--  End tok_code




if Token_Pos227 /= No_Token_Index then

   Row_Pos132 := Token_Pos227;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res228 := Row_Pos132;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res228));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Aliased)
   then
       Token_Pos228 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos132,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos228 := Row_Pos132 + 1;
   end if;
end;

--  End tok_code


if Token_Pos228 = No_Token_Index then

         Opt_Res14 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res14,
            Kind              => Ada_Aliased_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos132,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos228 := Row_Pos132;


else

      Opt_Res14 := Allocate_Aliased_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res14,
         Kind              => Ada_Aliased_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos132,
         Token_End_Index   => Token_Pos228 - 1);

end if;

--  End opt_code




if Token_Pos228 /= No_Token_Index then

   Row_Pos132 := Token_Pos228;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res229 := Row_Pos132;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res229));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Constant)
   then
       Token_Pos229 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos132,
             Expected_Token_Id => Ada_Constant,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos229 := Row_Pos132 + 1;
   end if;
end;

--  End tok_code


if Token_Pos229 = No_Token_Index then

         Opt_Res15 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res15,
            Kind              => Ada_Constant_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos132,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos229 := Row_Pos132;


else

      Opt_Res15 := Allocate_Constant_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res15,
         Kind              => Ada_Constant_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos132,
         Token_End_Index   => Token_Pos229 - 1);

end if;

--  End opt_code




if Token_Pos229 /= No_Token_Index then

   Row_Pos132 := Token_Pos229;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


--  Start opt_code












Defer_Res232 :=
   Mode_Or_Parse0 (Parser, Row_Pos132);
Defer_Pos232 := Parser.Current_Pos;


if Defer_Pos232 = No_Token_Index then

         
   Defer_Res232 := No_Bare_Ada_Node;



       
   Defer_Pos232 := Row_Pos132;



end if;

--  End opt_code




if Defer_Pos232 /= No_Token_Index then

   Row_Pos132 := Defer_Pos232;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


Defer_Res233 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos132);
Defer_Pos233 := Parser.Current_Pos;




if Defer_Pos233 /= No_Token_Index then

   Row_Pos132 := Defer_Pos233;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos133 := Row_Pos132;



--  Start tok_code

Token_Res230 := Row_Pos133;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res230));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos230 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos133 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos133,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos230 := Row_Pos133 + 1;
   end if;
end;

--  End tok_code




if Token_Pos230 /= No_Token_Index then

   Row_Pos133 := Token_Pos230;

else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;

end if;


Defer_Res234 :=
   Expr_Or_Parse0 (Parser, Row_Pos133);
Defer_Pos234 := Parser.Current_Pos;




if Defer_Pos234 /= No_Token_Index then

   Row_Pos133 := Defer_Pos234;

else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row133_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos133 = No_Token_Index then

         
   Defer_Res234 := No_Bare_Ada_Node;



       
   Row_Pos133 := Row_Pos132;



end if;

--  End opt_code




if Row_Pos133 /= No_Token_Index then

   Row_Pos132 := Row_Pos133;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


--  Start opt_code












Defer_Res235 :=
   Renaming_Clause_Transform_Parse0 (Parser, Row_Pos132);
Defer_Pos235 := Parser.Current_Pos;


if Defer_Pos235 = No_Token_Index then

         
   Defer_Res235 := No_Bare_Ada_Node;



       
   Defer_Pos235 := Row_Pos132;



end if;

--  End opt_code




if Defer_Pos235 /= No_Token_Index then

   Row_Pos132 := Defer_Pos235;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;


Defer_Res236 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos132);
Defer_Pos236 := Parser.Current_Pos;




if Defer_Pos236 /= No_Token_Index then

   Row_Pos132 := Defer_Pos236;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row132_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos132 /= No_Token_Index then

   Transform_Res87 := Allocate_Extended_Return_Stmt_Object_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res87,
      Kind => Ada_Extended_Return_Stmt_Object_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos132 = Pos
                            then No_Token_Index
                            else Row_Pos132 - 1));

      Initialize_Fields_For_Extended_Return_Stmt_Object_Decl
        (Self => Transform_Res87, Object_Decl_F_Ids => Defer_Res231, Object_Decl_F_Has_Aliased => Opt_Res14, Object_Decl_F_Has_Constant => Opt_Res15, Object_Decl_F_Mode => Defer_Res232, Object_Decl_F_Type_Expr => Defer_Res233, Object_Decl_F_Default_Expr => Defer_Res234, Object_Decl_F_Renaming_Clause => Defer_Res235, Object_Decl_F_Aspects => Defer_Res236);

         if Defer_Res231 /= null and then Is_Incomplete (Defer_Res231) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res231 /= null and then not Is_Ghost (Defer_Res231) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Opt_Res14 /= null and then Is_Incomplete (Opt_Res14) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Opt_Res14 /= null and then not Is_Ghost (Opt_Res14) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Opt_Res15 /= null and then Is_Incomplete (Opt_Res15) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Opt_Res15 /= null and then not Is_Ghost (Opt_Res15) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Defer_Res232 /= null and then Is_Incomplete (Defer_Res232) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res232 /= null and then not Is_Ghost (Defer_Res232) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Defer_Res233 /= null and then Is_Incomplete (Defer_Res233) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res233 /= null and then not Is_Ghost (Defer_Res233) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Defer_Res234 /= null and then Is_Incomplete (Defer_Res234) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res234 /= null and then not Is_Ghost (Defer_Res234) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Defer_Res235 /= null and then Is_Incomplete (Defer_Res235) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res235 /= null and then not Is_Ghost (Defer_Res235) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Defer_Res236 /= null and then Is_Incomplete (Defer_Res236) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res236 /= null and then not Is_Ghost (Defer_Res236) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos132 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags87);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Ext_Ret_Stmt_Object_Decl_Transform_Parse0_Memo,
      Row_Pos132 /= No_Token_Index,
      Transform_Res87,
      Pos,
      Row_Pos132);


   Parser.Current_Pos := Row_Pos132;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res87;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Ext_Ret_Stmt_Object_Decl_Transform_Parse0;

   


function Ext_Return_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Extended_Return_Stmt
is
   use Bare_Extended_Return_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt12 :
            Boolean
               := False;
      Nobt13 :
            Boolean
               := False;
      Row_Pos134 :
            Token_Index
               := No_Token_Index;
      Token_Pos231 :
            Token_Index
               := No_Token_Index;
      Token_Res231 :
            Token_Index
               := No_Token_Index;
      Defer_Pos237 :
            Token_Index
               := No_Token_Index;
      Defer_Res237 :
            Bare_Extended_Return_Stmt_Object_Decl
               := No_Bare_Ada_Node;
      Row_Pos135 :
            Token_Index
               := No_Token_Index;
      Token_Pos232 :
            Token_Index
               := No_Token_Index;
      Token_Res232 :
            Token_Index
               := No_Token_Index;
      Defer_Pos238 :
            Token_Index
               := No_Token_Index;
      Defer_Res238 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Token_Pos233 :
            Token_Index
               := No_Token_Index;
      Token_Res233 :
            Token_Index
               := No_Token_Index;
      Token_Pos234 :
            Token_Index
               := No_Token_Index;
      Token_Res234 :
            Token_Index
               := No_Token_Index;
      Token_Pos235 :
            Token_Index
               := No_Token_Index;
      Token_Res235 :
            Token_Index
               := No_Token_Index;
      Row_Progress12 :
            Integer
               := 0;
      Transform_Res88 :
            Bare_Extended_Return_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed12 :
            Boolean
               := False;
      Transform_Diags88 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Ext_Return_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res88 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res88;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res88;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags88 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos134 := Pos;



--  Start tok_code

Token_Res231 := Row_Pos134;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res231));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Return)
   then
       Token_Pos231 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos134 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos134,
             Expected_Token_Id => Ada_Return,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos231 := Row_Pos134 + 1;
   end if;
end;

--  End tok_code



Row_Progress12 := 1;

if Token_Pos231 /= No_Token_Index then

   Row_Pos134 := Token_Pos231;

else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;

end if;


Defer_Res237 :=
   Ext_Ret_Stmt_Object_Decl_Transform_Parse0 (Parser, Row_Pos134);
Defer_Pos237 := Parser.Current_Pos;



Row_Progress12 := 2;

if Defer_Pos237 /= No_Token_Index then

   Row_Pos134 := Defer_Pos237;

else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;

end if;

Nobt12 := True;

   Nobt12 := Nobt12;

Row_Progress12 := 3;

if Row_Pos134 /= No_Token_Index then

   Row_Pos134 := Row_Pos134;

else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos135 := Row_Pos134;



--  Start tok_code

Token_Res232 := Row_Pos135;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res232));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Do)
   then
       Token_Pos232 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos135,
             Expected_Token_Id => Ada_Do,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos232 := Row_Pos135 + 1;
   end if;
end;

--  End tok_code




if Token_Pos232 /= No_Token_Index then

   Row_Pos135 := Token_Pos232;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;

Nobt13 := True;

   Nobt13 := Nobt13;


if Row_Pos135 /= No_Token_Index then

   Row_Pos135 := Row_Pos135;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;


Defer_Res238 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos135);
Defer_Pos238 := Parser.Current_Pos;




if Defer_Pos238 /= No_Token_Index then

   Row_Pos135 := Defer_Pos238;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;


--  Start tok_code

Token_Res233 := Row_Pos135;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res233));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos233 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos135,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos233 := Row_Pos135 + 1;
   end if;
end;

--  End tok_code




if Token_Pos233 /= No_Token_Index then

   Row_Pos135 := Token_Pos233;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;


--  Start tok_code

Token_Res234 := Row_Pos135;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res234));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Return)
   then
       Token_Pos234 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos135,
             Expected_Token_Id => Ada_Return,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos234 := Row_Pos135 + 1;
   end if;
end;

--  End tok_code




if Token_Pos234 /= No_Token_Index then

   Row_Pos135 := Token_Pos234;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row135_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos135 = No_Token_Index then

         
   if Nobt13 then
      Row_Pos135 := Parser.Last_Fail.Pos;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Row_Pos135)),
              To_Text ("Cannot parse <ext_return_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;


         if not Nobt13 then
            
   Defer_Res238 := No_Bare_Ada_Node;

         end if;


       if not Nobt13 then
          
   Row_Pos135 := Row_Pos134;

       end if;


end if;

--  End opt_code


   Nobt12 := Nobt13;

Row_Progress12 := 4;

if Row_Pos135 /= No_Token_Index then

   Row_Pos134 := Row_Pos135;

else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;

end if;


--  Start tok_code

Token_Res235 := Row_Pos134;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res235));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos235 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos134 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos134,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos235 := Row_Pos134 + 1;
   end if;
end;

--  End tok_code



Row_Progress12 := 5;

if Token_Pos235 /= No_Token_Index then

   Row_Pos134 := Token_Pos235;

else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row134_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos134 = No_Token_Index and then Nobt12 then

   Row_Pos134 := Parser.Last_Fail.Pos;

   Transform_Has_Failed12 := True;
end if;

if Row_Pos134 /= No_Token_Index then

   Transform_Res88 := Allocate_Extended_Return_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res88,
      Kind => Ada_Extended_Return_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos134 = Pos
                            then No_Token_Index
                            else Row_Pos134 - 1));

      Initialize_Fields_For_Extended_Return_Stmt
        (Self => Transform_Res88, Extended_Return_Stmt_F_Decl => Defer_Res237, Extended_Return_Stmt_F_Stmts => Defer_Res238);

         if Defer_Res237 /= null and then Is_Incomplete (Defer_Res237) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif Defer_Res237 /= null and then not Is_Ghost (Defer_Res237) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;
         if Defer_Res238 /= null and then Is_Incomplete (Defer_Res238) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif Defer_Res238 /= null and then not Is_Ghost (Defer_Res238) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed12 then
      Transform_Res88.Last_Attempted_Child :=
         Row_Progress12;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <ext_return_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos134 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags88);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Ext_Return_Stmt_Transform_Parse0_Memo,
      Row_Pos134 /= No_Token_Index,
      Transform_Res88,
      Pos,
      Row_Pos134);


   Parser.Current_Pos := Row_Pos134;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res88;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Ext_Return_Stmt_Transform_Parse0;

   


function Factor_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt14 :
            Boolean
               := False;
      Nobt15 :
            Boolean
               := False;
      Row_Pos136 :
            Token_Index
               := No_Token_Index;
      Row_Pos137 :
            Token_Index
               := No_Token_Index;
      Token_Pos236 :
            Token_Index
               := No_Token_Index;
      Token_Res236 :
            Token_Index
               := No_Token_Index;
      Transform_Res89 :
            Bare_Op_Abs
               := No_Bare_Ada_Node;
      Transform_Diags89 :
            Ada.Containers.Count_Type;
      Row_Pos138 :
            Token_Index
               := No_Token_Index;
      Token_Pos237 :
            Token_Index
               := No_Token_Index;
      Token_Res237 :
            Token_Index
               := No_Token_Index;
      Transform_Res90 :
            Bare_Op_Not
               := No_Bare_Ada_Node;
      Transform_Diags90 :
            Ada.Containers.Count_Type;
      Or_Pos53 :
            Token_Index
               := No_Token_Index;
      Or_Res53 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos239 :
            Token_Index
               := No_Token_Index;
      Defer_Res239 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress13 :
            Integer
               := 0;
      Transform_Res91 :
            Bare_Un_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed13 :
            Boolean
               := False;
      Transform_Diags91 :
            Ada.Containers.Count_Type;
      Row_Pos139 :
            Token_Index
               := No_Token_Index;
      Defer_Pos240 :
            Token_Index
               := No_Token_Index;
      Defer_Res240 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Pos140 :
            Token_Index
               := No_Token_Index;
      Token_Pos238 :
            Token_Index
               := No_Token_Index;
      Token_Res238 :
            Token_Index
               := No_Token_Index;
      Transform_Res92 :
            Bare_Op_Pow
               := No_Bare_Ada_Node;
      Transform_Diags92 :
            Ada.Containers.Count_Type;
      Defer_Pos241 :
            Token_Index
               := No_Token_Index;
      Defer_Res241 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress14 :
            Integer
               := 0;
      Transform_Res93 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed14 :
            Boolean
               := False;
      Transform_Diags93 :
            Ada.Containers.Count_Type;
      Defer_Pos242 :
            Token_Index
               := No_Token_Index;
      Defer_Res242 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos54 :
            Token_Index
               := No_Token_Index;
      Or_Res54 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Factor_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res54 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res54;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res54;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos54 := No_Token_Index;
Or_Res54 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags91 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos136 := Pos;



--  Start or_code

Or_Pos53 := No_Token_Index;
Or_Res53 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags89 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos137 := Row_Pos136;



--  Start tok_code

Token_Res236 := Row_Pos137;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res236));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Abs)
   then
       Token_Pos236 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos137 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos137,
             Expected_Token_Id => Ada_Abs,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos236 := Row_Pos137 + 1;
   end if;
end;

--  End tok_code




if Token_Pos236 /= No_Token_Index then

   Row_Pos137 := Token_Pos236;

else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row137_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos137 /= No_Token_Index then

   Transform_Res89 := Allocate_Op_Abs (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res89,
      Kind => Ada_Op_Abs,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos136,
      Token_End_Index   => (if Row_Pos137 = Row_Pos136
                            then No_Token_Index
                            else Row_Pos137 - 1));

      Initialize_Fields_For_Op_Abs
        (Self => Transform_Res89);



elsif Row_Pos137 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags89);
end if;

--  End transform_code

    if Row_Pos137 /= No_Token_Index then
        Or_Pos53 := Row_Pos137;
        Or_Res53 := Transform_Res89;
        goto Exit_Or55;
    end if;
    
--  Start transform_code

Transform_Diags90 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos138 := Row_Pos136;



--  Start tok_code

Token_Res237 := Row_Pos138;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res237));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos237 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos138 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos138,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos237 := Row_Pos138 + 1;
   end if;
end;

--  End tok_code




if Token_Pos237 /= No_Token_Index then

   Row_Pos138 := Token_Pos237;

else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row138_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos138 /= No_Token_Index then

   Transform_Res90 := Allocate_Op_Not (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res90,
      Kind => Ada_Op_Not,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos136,
      Token_End_Index   => (if Row_Pos138 = Row_Pos136
                            then No_Token_Index
                            else Row_Pos138 - 1));

      Initialize_Fields_For_Op_Not
        (Self => Transform_Res90);



elsif Row_Pos138 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags90);
end if;

--  End transform_code

    if Row_Pos138 /= No_Token_Index then
        Or_Pos53 := Row_Pos138;
        Or_Res53 := Transform_Res90;
        goto Exit_Or55;
    end if;
<<Exit_Or55>>

--  End or_code



Row_Progress13 := 1;

if Or_Pos53 /= No_Token_Index then

   Row_Pos136 := Or_Pos53;

else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;

end if;

Nobt14 := True;

   Nobt14 := Nobt14;

Row_Progress13 := 2;

if Row_Pos136 /= No_Token_Index then

   Row_Pos136 := Row_Pos136;

else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;

end if;


Defer_Res239 :=
   Primary_Or_Parse0 (Parser, Row_Pos136);
Defer_Pos239 := Parser.Current_Pos;



Row_Progress13 := 3;

if Defer_Pos239 /= No_Token_Index then

   Row_Pos136 := Defer_Pos239;

else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row136_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos136 = No_Token_Index and then Nobt14 then

   Row_Pos136 := Parser.Last_Fail.Pos;

   Transform_Has_Failed13 := True;
end if;

if Row_Pos136 /= No_Token_Index then

   Transform_Res91 := Allocate_Un_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res91,
      Kind => Ada_Un_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos136 = Pos
                            then No_Token_Index
                            else Row_Pos136 - 1));

      Initialize_Fields_For_Un_Op
        (Self => Transform_Res91, Un_Op_F_Op => Or_Res53, Un_Op_F_Expr => Defer_Res239);

         if Or_Res53 /= null and then Is_Incomplete (Or_Res53) then
            Transform_Res91.Last_Attempted_Child := 0;
         elsif Or_Res53 /= null and then not Is_Ghost (Or_Res53) then
            Transform_Res91.Last_Attempted_Child := -1;
         end if;
         if Defer_Res239 /= null and then Is_Incomplete (Defer_Res239) then
            Transform_Res91.Last_Attempted_Child := 0;
         elsif Defer_Res239 /= null and then not Is_Ghost (Defer_Res239) then
            Transform_Res91.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed13 then
      Transform_Res91.Last_Attempted_Child :=
         Row_Progress13;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <factor>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos136 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags91);
end if;

--  End transform_code

    if Row_Pos136 /= No_Token_Index then
        Or_Pos54 := Row_Pos136;
        Or_Res54 := Transform_Res91;
        goto Exit_Or54;
    end if;
    
--  Start transform_code

Transform_Diags93 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos139 := Pos;



Defer_Res240 :=
   Primary_Or_Parse0 (Parser, Row_Pos139);
Defer_Pos240 := Parser.Current_Pos;



Row_Progress14 := 1;

if Defer_Pos240 /= No_Token_Index then

   Row_Pos139 := Defer_Pos240;

else
   Row_Pos139 := No_Token_Index;
   goto Exit_Row139_0;

end if;


--  Start transform_code

Transform_Diags92 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos140 := Row_Pos139;



--  Start tok_code

Token_Res238 := Row_Pos140;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res238));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Power)
   then
       Token_Pos238 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos140,
             Expected_Token_Id => Ada_Power,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos238 := Row_Pos140 + 1;
   end if;
end;

--  End tok_code




if Token_Pos238 /= No_Token_Index then

   Row_Pos140 := Token_Pos238;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row140_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos140 /= No_Token_Index then

   Transform_Res92 := Allocate_Op_Pow (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res92,
      Kind => Ada_Op_Pow,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos139,
      Token_End_Index   => (if Row_Pos140 = Row_Pos139
                            then No_Token_Index
                            else Row_Pos140 - 1));

      Initialize_Fields_For_Op_Pow
        (Self => Transform_Res92);



elsif Row_Pos140 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags92);
end if;

--  End transform_code



Row_Progress14 := 2;

if Row_Pos140 /= No_Token_Index then

   Row_Pos139 := Row_Pos140;

else
   Row_Pos139 := No_Token_Index;
   goto Exit_Row139_0;

end if;

Nobt15 := True;

   Nobt15 := Nobt15;

Row_Progress14 := 3;

if Row_Pos139 /= No_Token_Index then

   Row_Pos139 := Row_Pos139;

else
   Row_Pos139 := No_Token_Index;
   goto Exit_Row139_0;

end if;


Defer_Res241 :=
   Primary_Or_Parse0 (Parser, Row_Pos139);
Defer_Pos241 := Parser.Current_Pos;



Row_Progress14 := 4;

if Defer_Pos241 /= No_Token_Index then

   Row_Pos139 := Defer_Pos241;

else
   Row_Pos139 := No_Token_Index;
   goto Exit_Row139_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row139_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos139 = No_Token_Index and then Nobt15 then

   Row_Pos139 := Parser.Last_Fail.Pos;

   Transform_Has_Failed14 := True;
end if;

if Row_Pos139 /= No_Token_Index then

   Transform_Res93 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res93,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos139 = Pos
                            then No_Token_Index
                            else Row_Pos139 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res93, Bin_Op_F_Left => Defer_Res240, Bin_Op_F_Op => Transform_Res92, Bin_Op_F_Right => Defer_Res241);

         if Defer_Res240 /= null and then Is_Incomplete (Defer_Res240) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Defer_Res240 /= null and then not Is_Ghost (Defer_Res240) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;
         if Transform_Res92 /= null and then Is_Incomplete (Transform_Res92) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Transform_Res92 /= null and then not Is_Ghost (Transform_Res92) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;
         if Defer_Res241 /= null and then Is_Incomplete (Defer_Res241) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Defer_Res241 /= null and then not Is_Ghost (Defer_Res241) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed14 then
      Transform_Res93.Last_Attempted_Child :=
         Row_Progress14;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <factor>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos139 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags93);
end if;

--  End transform_code

    if Row_Pos139 /= No_Token_Index then
        Or_Pos54 := Row_Pos139;
        Or_Res54 := Transform_Res93;
        goto Exit_Or54;
    end if;
    
Defer_Res242 :=
   Primary_Or_Parse0 (Parser, Pos);
Defer_Pos242 := Parser.Current_Pos;

    if Defer_Pos242 /= No_Token_Index then
        Or_Pos54 := Defer_Pos242;
        Or_Res54 := Defer_Res242;
        goto Exit_Or54;
    end if;
<<Exit_Or54>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Factor_Or_Parse1_Memo,
      Or_Pos54 /= No_Token_Index,
      Or_Res54,
      Pos,
      Or_Pos54);


   Parser.Current_Pos := Or_Pos54;

   Exit_Call (Parser, Call_Depth);
   return Or_Res54;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Factor_Or_Parse1;

   


function Floating_Point_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Floating_Point_Def
is
   use Bare_Floating_Point_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos141 :
            Token_Index
               := No_Token_Index;
      Token_Pos239 :
            Token_Index
               := No_Token_Index;
      Token_Res239 :
            Token_Index
               := No_Token_Index;
      Defer_Pos243 :
            Token_Index
               := No_Token_Index;
      Defer_Res243 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos244 :
            Token_Index
               := No_Token_Index;
      Defer_Res244 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Res94 :
            Bare_Floating_Point_Def
               := No_Bare_Ada_Node;
      Transform_Diags94 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Floating_Point_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res94 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res94;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res94;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags94 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos141 := Pos;



--  Start tok_code

Token_Res239 := Row_Pos141;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res239));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Digits)
   then
       Token_Pos239 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos141 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos141,
             Expected_Token_Id => Ada_Digits,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos239 := Row_Pos141 + 1;
   end if;
end;

--  End tok_code




if Token_Pos239 /= No_Token_Index then

   Row_Pos141 := Token_Pos239;

else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;

end if;


Defer_Res243 :=
   Sexpr_Or_Box_Or_Parse0 (Parser, Row_Pos141);
Defer_Pos243 := Parser.Current_Pos;




if Defer_Pos243 /= No_Token_Index then

   Row_Pos141 := Defer_Pos243;

else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;

end if;


--  Start opt_code












Defer_Res244 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos141);
Defer_Pos244 := Parser.Current_Pos;


if Defer_Pos244 = No_Token_Index then

         
   Defer_Res244 := No_Bare_Ada_Node;



       
   Defer_Pos244 := Row_Pos141;



end if;

--  End opt_code




if Defer_Pos244 /= No_Token_Index then

   Row_Pos141 := Defer_Pos244;

else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row141_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos141 /= No_Token_Index then

   Transform_Res94 := Allocate_Floating_Point_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res94,
      Kind => Ada_Floating_Point_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos141 = Pos
                            then No_Token_Index
                            else Row_Pos141 - 1));

      Initialize_Fields_For_Floating_Point_Def
        (Self => Transform_Res94, Floating_Point_Def_F_Num_Digits => Defer_Res243, Floating_Point_Def_F_Range => Defer_Res244);

         if Defer_Res243 /= null and then Is_Incomplete (Defer_Res243) then
            Transform_Res94.Last_Attempted_Child := 0;
         elsif Defer_Res243 /= null and then not Is_Ghost (Defer_Res243) then
            Transform_Res94.Last_Attempted_Child := -1;
         end if;
         if Defer_Res244 /= null and then Is_Incomplete (Defer_Res244) then
            Transform_Res94.Last_Attempted_Child := 0;
         elsif Defer_Res244 /= null and then not Is_Ghost (Defer_Res244) then
            Transform_Res94.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos141 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags94);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Floating_Point_Def_Transform_Parse0_Memo,
      Row_Pos141 /= No_Token_Index,
      Transform_Res94,
      Pos,
      Row_Pos141);


   Parser.Current_Pos := Row_Pos141;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res94;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Floating_Point_Def_Transform_Parse0;

   


function For_Loop_Param_Spec_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_For_Loop_Spec
is
   use Bare_For_Loop_Spec_Memos;

   Call_Depth : aliased Natural;

      Row_Pos142 :
            Token_Index
               := No_Token_Index;
      Row_Pos143 :
            Token_Index
               := No_Token_Index;
      Defer_Pos245 :
            Token_Index
               := No_Token_Index;
      Defer_Res245 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Row_Pos144 :
            Token_Index
               := No_Token_Index;
      Token_Pos240 :
            Token_Index
               := No_Token_Index;
      Token_Res240 :
            Token_Index
               := No_Token_Index;
      Defer_Pos246 :
            Token_Index
               := No_Token_Index;
      Defer_Res246 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Transform_Res95 :
            Bare_For_Loop_Var_Decl
               := No_Bare_Ada_Node;
      Transform_Diags95 :
            Ada.Containers.Count_Type;
      Row_Pos145 :
            Token_Index
               := No_Token_Index;
      Token_Pos241 :
            Token_Index
               := No_Token_Index;
      Token_Res241 :
            Token_Index
               := No_Token_Index;
      Transform_Res96 :
            Bare_Iter_Type_In
               := No_Bare_Ada_Node;
      Transform_Diags96 :
            Ada.Containers.Count_Type;
      Row_Pos146 :
            Token_Index
               := No_Token_Index;
      Token_Pos242 :
            Token_Index
               := No_Token_Index;
      Token_Res242 :
            Token_Index
               := No_Token_Index;
      Transform_Res97 :
            Bare_Iter_Type_Of
               := No_Bare_Ada_Node;
      Transform_Diags97 :
            Ada.Containers.Count_Type;
      Or_Pos55 :
            Token_Index
               := No_Token_Index;
      Or_Res55 :
            Bare_Iter_Type
               := No_Bare_Ada_Node;
      Token_Pos243 :
            Token_Index
               := No_Token_Index;
      Token_Res243 :
            Token_Index
               := No_Token_Index;
      Opt_Res16 :
            Bare_Reverse_Node
               := No_Bare_Ada_Node;
      Defer_Pos247 :
            Token_Index
               := No_Token_Index;
      Defer_Res247 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos248 :
            Token_Index
               := No_Token_Index;
      Defer_Res248 :
            Bare_Discrete_Subtype_Indication
               := No_Bare_Ada_Node;
      Defer_Pos249 :
            Token_Index
               := No_Token_Index;
      Defer_Res249 :
            Bare_Name
               := No_Bare_Ada_Node;
      Or_Pos56 :
            Token_Index
               := No_Token_Index;
      Or_Res56 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Row_Pos147 :
            Token_Index
               := No_Token_Index;
      Token_Pos244 :
            Token_Index
               := No_Token_Index;
      Token_Res244 :
            Token_Index
               := No_Token_Index;
      Defer_Pos250 :
            Token_Index
               := No_Token_Index;
      Defer_Res250 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res98 :
            Bare_For_Loop_Spec
               := No_Bare_Ada_Node;
      Transform_Diags98 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.For_Loop_Param_Spec_Transform_Parse3_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res98 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res98;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res98;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags98 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos142 := Pos;



--  Start transform_code

Transform_Diags95 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos143 := Row_Pos142;



Defer_Res245 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos143);
Defer_Pos245 := Parser.Current_Pos;




if Defer_Pos245 /= No_Token_Index then

   Row_Pos143 := Defer_Pos245;

else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos144 := Row_Pos143;



--  Start tok_code

Token_Res240 := Row_Pos144;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res240));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos240 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos144 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos144,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos240 := Row_Pos144 + 1;
   end if;
end;

--  End tok_code




if Token_Pos240 /= No_Token_Index then

   Row_Pos144 := Token_Pos240;

else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;

end if;


Defer_Res246 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos144);
Defer_Pos246 := Parser.Current_Pos;




if Defer_Pos246 /= No_Token_Index then

   Row_Pos144 := Defer_Pos246;

else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row144_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos144 = No_Token_Index then

         
   Defer_Res246 := No_Bare_Ada_Node;



       
   Row_Pos144 := Row_Pos143;



end if;

--  End opt_code




if Row_Pos144 /= No_Token_Index then

   Row_Pos143 := Row_Pos144;

else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row143_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos143 /= No_Token_Index then

   Transform_Res95 := Allocate_For_Loop_Var_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res95,
      Kind => Ada_For_Loop_Var_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos142,
      Token_End_Index   => (if Row_Pos143 = Row_Pos142
                            then No_Token_Index
                            else Row_Pos143 - 1));

      Initialize_Fields_For_For_Loop_Var_Decl
        (Self => Transform_Res95, For_Loop_Var_Decl_F_Id => Defer_Res245, For_Loop_Var_Decl_F_Id_Type => Defer_Res246);

         if Defer_Res245 /= null and then Is_Incomplete (Defer_Res245) then
            Transform_Res95.Last_Attempted_Child := 0;
         elsif Defer_Res245 /= null and then not Is_Ghost (Defer_Res245) then
            Transform_Res95.Last_Attempted_Child := -1;
         end if;
         if Defer_Res246 /= null and then Is_Incomplete (Defer_Res246) then
            Transform_Res95.Last_Attempted_Child := 0;
         elsif Defer_Res246 /= null and then not Is_Ghost (Defer_Res246) then
            Transform_Res95.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos143 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags95);
end if;

--  End transform_code




if Row_Pos143 /= No_Token_Index then

   Row_Pos142 := Row_Pos143;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  Start or_code

Or_Pos55 := No_Token_Index;
Or_Res55 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags96 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos145 := Row_Pos142;



--  Start tok_code

Token_Res241 := Row_Pos145;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res241));
begin
   if
      T.Kind /= From_Token_Kind (Ada_In)
   then
       Token_Pos241 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos145 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos145,
             Expected_Token_Id => Ada_In,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos241 := Row_Pos145 + 1;
   end if;
end;

--  End tok_code




if Token_Pos241 /= No_Token_Index then

   Row_Pos145 := Token_Pos241;

else
   Row_Pos145 := No_Token_Index;
   goto Exit_Row145_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row145_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos145 /= No_Token_Index then

   Transform_Res96 := Allocate_Iter_Type_In (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res96,
      Kind => Ada_Iter_Type_In,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos142,
      Token_End_Index   => (if Row_Pos145 = Row_Pos142
                            then No_Token_Index
                            else Row_Pos145 - 1));




elsif Row_Pos145 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags96);
end if;

--  End transform_code

    if Row_Pos145 /= No_Token_Index then
        Or_Pos55 := Row_Pos145;
        Or_Res55 := Transform_Res96;
        goto Exit_Or56;
    end if;
    
--  Start transform_code

Transform_Diags97 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos146 := Row_Pos142;



--  Start tok_code

Token_Res242 := Row_Pos146;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res242));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Of)
   then
       Token_Pos242 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos146 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos146,
             Expected_Token_Id => Ada_Of,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos242 := Row_Pos146 + 1;
   end if;
end;

--  End tok_code




if Token_Pos242 /= No_Token_Index then

   Row_Pos146 := Token_Pos242;

else
   Row_Pos146 := No_Token_Index;
   goto Exit_Row146_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row146_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos146 /= No_Token_Index then

   Transform_Res97 := Allocate_Iter_Type_Of (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res97,
      Kind => Ada_Iter_Type_Of,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos142,
      Token_End_Index   => (if Row_Pos146 = Row_Pos142
                            then No_Token_Index
                            else Row_Pos146 - 1));




elsif Row_Pos146 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags97);
end if;

--  End transform_code

    if Row_Pos146 /= No_Token_Index then
        Or_Pos55 := Row_Pos146;
        Or_Res55 := Transform_Res97;
        goto Exit_Or56;
    end if;
<<Exit_Or56>>

--  End or_code




if Or_Pos55 /= No_Token_Index then

   Row_Pos142 := Or_Pos55;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res243 := Row_Pos142;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res243));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Reverse)
   then
       Token_Pos243 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos142,
             Expected_Token_Id => Ada_Reverse,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos243 := Row_Pos142 + 1;
   end if;
end;

--  End tok_code


if Token_Pos243 = No_Token_Index then

         Opt_Res16 := Allocate_Reverse_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res16,
            Kind              => Ada_Reverse_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos142,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos243 := Row_Pos142;


else

      Opt_Res16 := Allocate_Reverse_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res16,
         Kind              => Ada_Reverse_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos142,
         Token_End_Index   => Token_Pos243 - 1);

end if;

--  End opt_code




if Token_Pos243 /= No_Token_Index then

   Row_Pos142 := Token_Pos243;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  Start or_code

Or_Pos56 := No_Token_Index;
Or_Res56 := No_Bare_Ada_Node;
    
Defer_Res247 :=
   Discrete_Range_Or_Parse0 (Parser, Row_Pos142);
Defer_Pos247 := Parser.Current_Pos;

    if Defer_Pos247 /= No_Token_Index then
        Or_Pos56 := Defer_Pos247;
        Or_Res56 := Defer_Res247;
        goto Exit_Or57;
    end if;
    
Defer_Res248 :=
   Discrete_Subtype_Indication_Transform_Parse0 (Parser, Row_Pos142);
Defer_Pos248 := Parser.Current_Pos;

    if Defer_Pos248 /= No_Token_Index then
        Or_Pos56 := Defer_Pos248;
        Or_Res56 := Defer_Res248;
        goto Exit_Or57;
    end if;
    
Defer_Res249 :=
   Name_Or_Parse2 (Parser, Row_Pos142);
Defer_Pos249 := Parser.Current_Pos;

    if Defer_Pos249 /= No_Token_Index then
        Or_Pos56 := Defer_Pos249;
        Or_Res56 := Defer_Res249;
        goto Exit_Or57;
    end if;
<<Exit_Or57>>

--  End or_code




if Or_Pos56 /= No_Token_Index then

   Row_Pos142 := Or_Pos56;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos147 := Row_Pos142;



--  Start tok_code

Token_Res244 := Row_Pos147;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res244));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos244 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos147 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos147,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos244 := Row_Pos147 + 1;
   end if;
end;

--  End tok_code




if Token_Pos244 /= No_Token_Index then

   Row_Pos147 := Token_Pos244;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


Defer_Res250 :=
   Expr_Or_Parse0 (Parser, Row_Pos147);
Defer_Pos250 := Parser.Current_Pos;




if Defer_Pos250 /= No_Token_Index then

   Row_Pos147 := Defer_Pos250;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row147_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos147 = No_Token_Index then

         
   Defer_Res250 := No_Bare_Ada_Node;



       
   Row_Pos147 := Row_Pos142;



end if;

--  End opt_code




if Row_Pos147 /= No_Token_Index then

   Row_Pos142 := Row_Pos147;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row142_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos142 /= No_Token_Index then

   Transform_Res98 := Allocate_For_Loop_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res98,
      Kind => Ada_For_Loop_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos142 = Pos
                            then No_Token_Index
                            else Row_Pos142 - 1));

      Initialize_Fields_For_For_Loop_Spec
        (Self => Transform_Res98, For_Loop_Spec_F_Var_Decl => Transform_Res95, For_Loop_Spec_F_Loop_Type => Or_Res55, For_Loop_Spec_F_Has_Reverse => Opt_Res16, For_Loop_Spec_F_Iter_Expr => Or_Res56, For_Loop_Spec_F_Iter_Filter => Defer_Res250);

         if Transform_Res95 /= null and then Is_Incomplete (Transform_Res95) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Transform_Res95 /= null and then not Is_Ghost (Transform_Res95) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
         if Or_Res55 /= null and then Is_Incomplete (Or_Res55) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Or_Res55 /= null and then not Is_Ghost (Or_Res55) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
         if Opt_Res16 /= null and then Is_Incomplete (Opt_Res16) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Opt_Res16 /= null and then not Is_Ghost (Opt_Res16) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
         if Or_Res56 /= null and then Is_Incomplete (Or_Res56) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Or_Res56 /= null and then not Is_Ghost (Or_Res56) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
         if Defer_Res250 /= null and then Is_Incomplete (Defer_Res250) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Defer_Res250 /= null and then not Is_Ghost (Defer_Res250) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos142 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags98);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.For_Loop_Param_Spec_Transform_Parse3_Memo,
      Row_Pos142 /= No_Token_Index,
      Transform_Res98,
      Pos,
      Row_Pos142);


   Parser.Current_Pos := Row_Pos142;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res98;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end For_Loop_Param_Spec_Transform_Parse3;

   


function Formal_Discrete_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Formal_Discrete_Type_Def
is
   use Bare_Formal_Discrete_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos148 :
            Token_Index
               := No_Token_Index;
      Token_Pos245 :
            Token_Index
               := No_Token_Index;
      Token_Res245 :
            Token_Index
               := No_Token_Index;
      Token_Pos246 :
            Token_Index
               := No_Token_Index;
      Token_Res246 :
            Token_Index
               := No_Token_Index;
      Token_Pos247 :
            Token_Index
               := No_Token_Index;
      Token_Res247 :
            Token_Index
               := No_Token_Index;
      Transform_Res99 :
            Bare_Formal_Discrete_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags99 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Formal_Discrete_Type_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res99 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res99;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res99;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags99 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos148 := Pos;



--  Start tok_code

Token_Res245 := Row_Pos148;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res245));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos245 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos148 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos148,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos245 := Row_Pos148 + 1;
   end if;
end;

--  End tok_code




if Token_Pos245 /= No_Token_Index then

   Row_Pos148 := Token_Pos245;

else
   Row_Pos148 := No_Token_Index;
   goto Exit_Row148_0;

end if;


--  Start tok_code

Token_Res246 := Row_Pos148;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res246));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Diamond)
   then
       Token_Pos246 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos148 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos148,
             Expected_Token_Id => Ada_Diamond,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos246 := Row_Pos148 + 1;
   end if;
end;

--  End tok_code




if Token_Pos246 /= No_Token_Index then

   Row_Pos148 := Token_Pos246;

else
   Row_Pos148 := No_Token_Index;
   goto Exit_Row148_0;

end if;


--  Start tok_code

Token_Res247 := Row_Pos148;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res247));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos247 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos148 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos148,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos247 := Row_Pos148 + 1;
   end if;
end;

--  End tok_code




if Token_Pos247 /= No_Token_Index then

   Row_Pos148 := Token_Pos247;

else
   Row_Pos148 := No_Token_Index;
   goto Exit_Row148_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row148_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos148 /= No_Token_Index then

   Transform_Res99 := Allocate_Formal_Discrete_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res99,
      Kind => Ada_Formal_Discrete_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos148 = Pos
                            then No_Token_Index
                            else Row_Pos148 - 1));




elsif Row_Pos148 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags99);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Formal_Discrete_Type_Def_Transform_Parse0_Memo,
      Row_Pos148 /= No_Token_Index,
      Transform_Res99,
      Pos,
      Row_Pos148);


   Parser.Current_Pos := Row_Pos148;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res99;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Formal_Discrete_Type_Def_Transform_Parse0;

   


function Formal_Subp_Decl_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Formal_Subp_Decl
is
   use Bare_Formal_Subp_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos149 :
            Token_Index
               := No_Token_Index;
      Token_Pos248 :
            Token_Index
               := No_Token_Index;
      Token_Res248 :
            Token_Index
               := No_Token_Index;
      Row_Pos150 :
            Token_Index
               := No_Token_Index;
      Transform_Res100 :
            Bare_Overriding_Unspecified
               := No_Bare_Ada_Node;
      Transform_Diags100 :
            Ada.Containers.Count_Type;
      Defer_Pos251 :
            Token_Index
               := No_Token_Index;
      Defer_Res251 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Token_Pos249 :
            Token_Index
               := No_Token_Index;
      Token_Res249 :
            Token_Index
               := No_Token_Index;
      Token_Pos250 :
            Token_Index
               := No_Token_Index;
      Token_Res250 :
            Token_Index
               := No_Token_Index;
      Defer_Pos252 :
            Token_Index
               := No_Token_Index;
      Defer_Res252 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Defer_Pos253 :
            Token_Index
               := No_Token_Index;
      Defer_Res253 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos254 :
            Token_Index
               := No_Token_Index;
      Defer_Res254 :
            Bare_Null_Literal
               := No_Bare_Ada_Node;
      Or_Pos57 :
            Token_Index
               := No_Token_Index;
      Or_Res57 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos255 :
            Token_Index
               := No_Token_Index;
      Defer_Res255 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos251 :
            Token_Index
               := No_Token_Index;
      Token_Res251 :
            Token_Index
               := No_Token_Index;
      Transform_Res101 :
            Bare_Abstract_Formal_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags101 :
            Ada.Containers.Count_Type;
      Row_Pos151 :
            Token_Index
               := No_Token_Index;
      Token_Pos252 :
            Token_Index
               := No_Token_Index;
      Token_Res252 :
            Token_Index
               := No_Token_Index;
      Row_Pos152 :
            Token_Index
               := No_Token_Index;
      Transform_Res102 :
            Bare_Overriding_Unspecified
               := No_Bare_Ada_Node;
      Transform_Diags102 :
            Ada.Containers.Count_Type;
      Defer_Pos256 :
            Token_Index
               := No_Token_Index;
      Defer_Res256 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Row_Pos153 :
            Token_Index
               := No_Token_Index;
      Token_Pos253 :
            Token_Index
               := No_Token_Index;
      Token_Res253 :
            Token_Index
               := No_Token_Index;
      Defer_Pos257 :
            Token_Index
               := No_Token_Index;
      Defer_Res257 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Defer_Pos258 :
            Token_Index
               := No_Token_Index;
      Defer_Res258 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos259 :
            Token_Index
               := No_Token_Index;
      Defer_Res259 :
            Bare_Null_Literal
               := No_Bare_Ada_Node;
      Or_Pos58 :
            Token_Index
               := No_Token_Index;
      Or_Res58 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos260 :
            Token_Index
               := No_Token_Index;
      Defer_Res260 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos254 :
            Token_Index
               := No_Token_Index;
      Token_Res254 :
            Token_Index
               := No_Token_Index;
      Transform_Res103 :
            Bare_Concrete_Formal_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags103 :
            Ada.Containers.Count_Type;
      Or_Pos59 :
            Token_Index
               := No_Token_Index;
      Or_Res59 :
            Bare_Formal_Subp_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Formal_Subp_Decl_Or_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res59 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res59;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res59;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos59 := No_Token_Index;
Or_Res59 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags101 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos149 := Pos;



--  Start tok_code

Token_Res248 := Row_Pos149;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res248));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos248 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos149,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos248 := Row_Pos149 + 1;
   end if;
end;

--  End tok_code




if Token_Pos248 /= No_Token_Index then

   Row_Pos149 := Token_Pos248;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


--  Start transform_code

Transform_Diags100 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos150 := Row_Pos149;


pragma Warnings (Off, "referenced");
<<Exit_Row150_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos150 /= No_Token_Index then

   Transform_Res100 := Allocate_Overriding_Unspecified (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res100,
      Kind => Ada_Overriding_Unspecified,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos149,
      Token_End_Index   => (if Row_Pos150 = Row_Pos149
                            then No_Token_Index
                            else Row_Pos150 - 1));




elsif Row_Pos150 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags100);
end if;

--  End transform_code




if Row_Pos150 /= No_Token_Index then

   Row_Pos149 := Row_Pos150;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


Defer_Res251 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos149);
Defer_Pos251 := Parser.Current_Pos;




if Defer_Pos251 /= No_Token_Index then

   Row_Pos149 := Defer_Pos251;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


--  Start tok_code

Token_Res249 := Row_Pos149;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res249));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos249 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos149,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos249 := Row_Pos149 + 1;
   end if;
end;

--  End tok_code




if Token_Pos249 /= No_Token_Index then

   Row_Pos149 := Token_Pos249;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


--  Start tok_code

Token_Res250 := Row_Pos149;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res250));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos250 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos149,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos250 := Row_Pos149 + 1;
   end if;
end;

--  End tok_code




if Token_Pos250 /= No_Token_Index then

   Row_Pos149 := Token_Pos250;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


--  Start opt_code












--  Start or_code

Or_Pos57 := No_Token_Index;
Or_Res57 := No_Bare_Ada_Node;
    
Defer_Res252 :=
   Box_Expr_Transform_Parse0 (Parser, Row_Pos149);
Defer_Pos252 := Parser.Current_Pos;

    if Defer_Pos252 /= No_Token_Index then
        Or_Pos57 := Defer_Pos252;
        Or_Res57 := Defer_Res252;
        goto Exit_Or59;
    end if;
    
Defer_Res253 :=
   Name_Or_Parse2 (Parser, Row_Pos149);
Defer_Pos253 := Parser.Current_Pos;

    if Defer_Pos253 /= No_Token_Index then
        Or_Pos57 := Defer_Pos253;
        Or_Res57 := Defer_Res253;
        goto Exit_Or59;
    end if;
    
Defer_Res254 :=
   Null_Literal_Transform_Parse0 (Parser, Row_Pos149);
Defer_Pos254 := Parser.Current_Pos;

    if Defer_Pos254 /= No_Token_Index then
        Or_Pos57 := Defer_Pos254;
        Or_Res57 := Defer_Res254;
        goto Exit_Or59;
    end if;
<<Exit_Or59>>

--  End or_code


if Or_Pos57 = No_Token_Index then

         
   Or_Res57 := No_Bare_Ada_Node;



       
   Or_Pos57 := Row_Pos149;



end if;

--  End opt_code




if Or_Pos57 /= No_Token_Index then

   Row_Pos149 := Or_Pos57;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


Defer_Res255 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos149);
Defer_Pos255 := Parser.Current_Pos;




if Defer_Pos255 /= No_Token_Index then

   Row_Pos149 := Defer_Pos255;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res251 := Row_Pos149;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res251));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos251 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos149,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos251 := Row_Pos149 + 1;
   end if;
end;

--  End tok_code


if Token_Pos251 = No_Token_Index then

         
   Token_Res251 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos149)),
                To_Text ("Missing ';'"));

       
   Token_Pos251 := Row_Pos149;



end if;

--  End opt_code




if Token_Pos251 /= No_Token_Index then

   Row_Pos149 := Token_Pos251;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row149_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos149 /= No_Token_Index then

   Transform_Res101 := Allocate_Abstract_Formal_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res101,
      Kind => Ada_Abstract_Formal_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos149 = Pos
                            then No_Token_Index
                            else Row_Pos149 - 1));

      Initialize_Fields_For_Abstract_Formal_Subp_Decl
        (Self => Transform_Res101, Classic_Subp_Decl_F_Overriding => Transform_Res100, Classic_Subp_Decl_F_Subp_Spec => Defer_Res251, Formal_Subp_Decl_F_Default_Expr => Or_Res57, Formal_Subp_Decl_F_Aspects => Defer_Res255);

         if Transform_Res100 /= null and then Is_Incomplete (Transform_Res100) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Transform_Res100 /= null and then not Is_Ghost (Transform_Res100) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res251 /= null and then Is_Incomplete (Defer_Res251) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Defer_Res251 /= null and then not Is_Ghost (Defer_Res251) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if Or_Res57 /= null and then Is_Incomplete (Or_Res57) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Or_Res57 /= null and then not Is_Ghost (Or_Res57) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res255 /= null and then Is_Incomplete (Defer_Res255) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Defer_Res255 /= null and then not Is_Ghost (Defer_Res255) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos149 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags101);
end if;

--  End transform_code

    if Row_Pos149 /= No_Token_Index then
        Or_Pos59 := Row_Pos149;
        Or_Res59 := Transform_Res101;
        goto Exit_Or58;
    end if;
    
--  Start transform_code

Transform_Diags103 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos151 := Pos;



--  Start tok_code

Token_Res252 := Row_Pos151;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res252));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos252 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos151 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos151,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos252 := Row_Pos151 + 1;
   end if;
end;

--  End tok_code




if Token_Pos252 /= No_Token_Index then

   Row_Pos151 := Token_Pos252;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;


--  Start transform_code

Transform_Diags102 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos152 := Row_Pos151;


pragma Warnings (Off, "referenced");
<<Exit_Row152_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos152 /= No_Token_Index then

   Transform_Res102 := Allocate_Overriding_Unspecified (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res102,
      Kind => Ada_Overriding_Unspecified,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos151,
      Token_End_Index   => (if Row_Pos152 = Row_Pos151
                            then No_Token_Index
                            else Row_Pos152 - 1));




elsif Row_Pos152 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags102);
end if;

--  End transform_code




if Row_Pos152 /= No_Token_Index then

   Row_Pos151 := Row_Pos152;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;


Defer_Res256 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos151);
Defer_Pos256 := Parser.Current_Pos;




if Defer_Pos256 /= No_Token_Index then

   Row_Pos151 := Defer_Pos256;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos153 := Row_Pos151;



--  Start tok_code

Token_Res253 := Row_Pos153;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res253));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos253 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos153 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos153,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos253 := Row_Pos153 + 1;
   end if;
end;

--  End tok_code




if Token_Pos253 /= No_Token_Index then

   Row_Pos153 := Token_Pos253;

else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;

end if;


--  Start or_code

Or_Pos58 := No_Token_Index;
Or_Res58 := No_Bare_Ada_Node;
    
Defer_Res257 :=
   Box_Expr_Transform_Parse0 (Parser, Row_Pos153);
Defer_Pos257 := Parser.Current_Pos;

    if Defer_Pos257 /= No_Token_Index then
        Or_Pos58 := Defer_Pos257;
        Or_Res58 := Defer_Res257;
        goto Exit_Or60;
    end if;
    
Defer_Res258 :=
   Name_Or_Parse2 (Parser, Row_Pos153);
Defer_Pos258 := Parser.Current_Pos;

    if Defer_Pos258 /= No_Token_Index then
        Or_Pos58 := Defer_Pos258;
        Or_Res58 := Defer_Res258;
        goto Exit_Or60;
    end if;
    
Defer_Res259 :=
   Null_Literal_Transform_Parse0 (Parser, Row_Pos153);
Defer_Pos259 := Parser.Current_Pos;

    if Defer_Pos259 /= No_Token_Index then
        Or_Pos58 := Defer_Pos259;
        Or_Res58 := Defer_Res259;
        goto Exit_Or60;
    end if;
<<Exit_Or60>>

--  End or_code




if Or_Pos58 /= No_Token_Index then

   Row_Pos153 := Or_Pos58;

else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row153_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos153 = No_Token_Index then

         
   Or_Res58 := No_Bare_Ada_Node;



       
   Row_Pos153 := Row_Pos151;



end if;

--  End opt_code




if Row_Pos153 /= No_Token_Index then

   Row_Pos151 := Row_Pos153;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;


Defer_Res260 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos151);
Defer_Pos260 := Parser.Current_Pos;




if Defer_Pos260 /= No_Token_Index then

   Row_Pos151 := Defer_Pos260;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;


--  Start tok_code

Token_Res254 := Row_Pos151;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res254));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos254 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos151 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos151,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos254 := Row_Pos151 + 1;
   end if;
end;

--  End tok_code




if Token_Pos254 /= No_Token_Index then

   Row_Pos151 := Token_Pos254;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row151_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos151 /= No_Token_Index then

   Transform_Res103 := Allocate_Concrete_Formal_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res103,
      Kind => Ada_Concrete_Formal_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos151 = Pos
                            then No_Token_Index
                            else Row_Pos151 - 1));

      Initialize_Fields_For_Concrete_Formal_Subp_Decl
        (Self => Transform_Res103, Classic_Subp_Decl_F_Overriding => Transform_Res102, Classic_Subp_Decl_F_Subp_Spec => Defer_Res256, Formal_Subp_Decl_F_Default_Expr => Or_Res58, Formal_Subp_Decl_F_Aspects => Defer_Res260);

         if Transform_Res102 /= null and then Is_Incomplete (Transform_Res102) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Transform_Res102 /= null and then not Is_Ghost (Transform_Res102) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;
         if Defer_Res256 /= null and then Is_Incomplete (Defer_Res256) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Defer_Res256 /= null and then not Is_Ghost (Defer_Res256) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;
         if Or_Res58 /= null and then Is_Incomplete (Or_Res58) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Or_Res58 /= null and then not Is_Ghost (Or_Res58) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;
         if Defer_Res260 /= null and then Is_Incomplete (Defer_Res260) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Defer_Res260 /= null and then not Is_Ghost (Defer_Res260) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos151 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags103);
end if;

--  End transform_code

    if Row_Pos151 /= No_Token_Index then
        Or_Pos59 := Row_Pos151;
        Or_Res59 := Transform_Res103;
        goto Exit_Or58;
    end if;
<<Exit_Or58>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Formal_Subp_Decl_Or_Parse2_Memo,
      Or_Pos59 /= No_Token_Index,
      Or_Res59,
      Pos,
      Or_Pos59);


   Parser.Current_Pos := Or_Pos59;

   Exit_Call (Parser, Call_Depth);
   return Or_Res59;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Formal_Subp_Decl_Or_Parse2;

   


function Formal_Type_Decl_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Type_Decl
is
   use Bare_Base_Type_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos154 :
            Token_Index
               := No_Token_Index;
      Token_Pos255 :
            Token_Index
               := No_Token_Index;
      Token_Res255 :
            Token_Index
               := No_Token_Index;
      Defer_Pos261 :
            Token_Index
               := No_Token_Index;
      Defer_Res261 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos262 :
            Token_Index
               := No_Token_Index;
      Defer_Res262 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Token_Pos256 :
            Token_Index
               := No_Token_Index;
      Token_Res256 :
            Token_Index
               := No_Token_Index;
      Defer_Pos263 :
            Token_Index
               := No_Token_Index;
      Defer_Res263 :
            Bare_Type_Def
               := No_Bare_Ada_Node;
      Row_Pos155 :
            Token_Index
               := No_Token_Index;
      Token_Pos257 :
            Token_Index
               := No_Token_Index;
      Token_Res257 :
            Token_Index
               := No_Token_Index;
      Opt_Res17 :
            Bare_Abstract_Node
               := No_Bare_Ada_Node;
      Token_Pos258 :
            Token_Index
               := No_Token_Index;
      Token_Res258 :
            Token_Index
               := No_Token_Index;
      Opt_Res18 :
            Bare_Tagged_Node
               := No_Bare_Ada_Node;
      Token_Pos259 :
            Token_Index
               := No_Token_Index;
      Token_Res259 :
            Token_Index
               := No_Token_Index;
      Opt_Res19 :
            Bare_Limited_Node
               := No_Bare_Ada_Node;
      Token_Pos260 :
            Token_Index
               := No_Token_Index;
      Token_Res260 :
            Token_Index
               := No_Token_Index;
      Transform_Res104 :
            Bare_Private_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags104 :
            Ada.Containers.Count_Type;
      Or_Pos60 :
            Token_Index
               := No_Token_Index;
      Or_Res60 :
            Bare_Type_Def
               := No_Bare_Ada_Node;
      Row_Pos156 :
            Token_Index
               := No_Token_Index;
      Token_Pos261 :
            Token_Index
               := No_Token_Index;
      Token_Res261 :
            Token_Index
               := No_Token_Index;
      Token_Pos262 :
            Token_Index
               := No_Token_Index;
      Token_Res262 :
            Token_Index
               := No_Token_Index;
      Defer_Pos264 :
            Token_Index
               := No_Token_Index;
      Defer_Res264 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos265 :
            Token_Index
               := No_Token_Index;
      Defer_Res265 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos263 :
            Token_Index
               := No_Token_Index;
      Token_Res263 :
            Token_Index
               := No_Token_Index;
      Transform_Res105 :
            Bare_Formal_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags105 :
            Ada.Containers.Count_Type;
      Row_Pos157 :
            Token_Index
               := No_Token_Index;
      Token_Pos264 :
            Token_Index
               := No_Token_Index;
      Token_Res264 :
            Token_Index
               := No_Token_Index;
      Defer_Pos266 :
            Token_Index
               := No_Token_Index;
      Defer_Res266 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos267 :
            Token_Index
               := No_Token_Index;
      Defer_Res267 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Row_Pos158 :
            Token_Index
               := No_Token_Index;
      Token_Pos265 :
            Token_Index
               := No_Token_Index;
      Token_Res265 :
            Token_Index
               := No_Token_Index;
      Token_Pos266 :
            Token_Index
               := No_Token_Index;
      Token_Res266 :
            Token_Index
               := No_Token_Index;
      Opt_Res20 :
            Bare_Tagged_Node
               := No_Bare_Ada_Node;
      Row_Pos159 :
            Token_Index
               := No_Token_Index;
      Token_Pos267 :
            Token_Index
               := No_Token_Index;
      Token_Res267 :
            Token_Index
               := No_Token_Index;
      Token_Pos268 :
            Token_Index
               := No_Token_Index;
      Token_Res268 :
            Token_Index
               := No_Token_Index;
      Defer_Pos268 :
            Token_Index
               := No_Token_Index;
      Defer_Res268 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos269 :
            Token_Index
               := No_Token_Index;
      Token_Res269 :
            Token_Index
               := No_Token_Index;
      Transform_Res106 :
            Bare_Incomplete_Formal_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags106 :
            Ada.Containers.Count_Type;
      Or_Pos61 :
            Token_Index
               := No_Token_Index;
      Or_Res61 :
            Bare_Base_Type_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Formal_Type_Decl_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res61 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res61;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res61;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos61 := No_Token_Index;
Or_Res61 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags105 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos154 := Pos;



--  Start tok_code

Token_Res255 := Row_Pos154;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res255));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos255 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos154 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos154,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos255 := Row_Pos154 + 1;
   end if;
end;

--  End tok_code




if Token_Pos255 /= No_Token_Index then

   Row_Pos154 := Token_Pos255;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


Defer_Res261 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos154);
Defer_Pos261 := Parser.Current_Pos;




if Defer_Pos261 /= No_Token_Index then

   Row_Pos154 := Defer_Pos261;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  Start opt_code












Defer_Res262 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos154);
Defer_Pos262 := Parser.Current_Pos;


if Defer_Pos262 = No_Token_Index then

         
   Defer_Res262 := No_Bare_Ada_Node;



       
   Defer_Pos262 := Row_Pos154;



end if;

--  End opt_code




if Defer_Pos262 /= No_Token_Index then

   Row_Pos154 := Defer_Pos262;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  Start tok_code

Token_Res256 := Row_Pos154;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res256));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos256 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos154 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos154,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos256 := Row_Pos154 + 1;
   end if;
end;

--  End tok_code




if Token_Pos256 /= No_Token_Index then

   Row_Pos154 := Token_Pos256;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  Start or_code

Or_Pos60 := No_Token_Index;
Or_Res60 := No_Bare_Ada_Node;
    
Defer_Res263 :=
   Type_Def_Or_Parse0 (Parser, Row_Pos154);
Defer_Pos263 := Parser.Current_Pos;

    if Defer_Pos263 /= No_Token_Index then
        Or_Pos60 := Defer_Pos263;
        Or_Res60 := Defer_Res263;
        goto Exit_Or62;
    end if;
    
--  Start transform_code

Transform_Diags104 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos155 := Row_Pos154;



--  Start opt_code












--  Start tok_code

Token_Res257 := Row_Pos155;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res257));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos257 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos155,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos257 := Row_Pos155 + 1;
   end if;
end;

--  End tok_code


if Token_Pos257 = No_Token_Index then

         Opt_Res17 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res17,
            Kind              => Ada_Abstract_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos155,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos257 := Row_Pos155;


else

      Opt_Res17 := Allocate_Abstract_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res17,
         Kind              => Ada_Abstract_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos155,
         Token_End_Index   => Token_Pos257 - 1);

end if;

--  End opt_code




if Token_Pos257 /= No_Token_Index then

   Row_Pos155 := Token_Pos257;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res258 := Row_Pos155;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res258));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Tagged)
   then
       Token_Pos258 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos155,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos258 := Row_Pos155 + 1;
   end if;
end;

--  End tok_code


if Token_Pos258 = No_Token_Index then

         Opt_Res18 := Allocate_Tagged_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res18,
            Kind              => Ada_Tagged_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos155,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos258 := Row_Pos155;


else

      Opt_Res18 := Allocate_Tagged_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res18,
         Kind              => Ada_Tagged_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos155,
         Token_End_Index   => Token_Pos258 - 1);

end if;

--  End opt_code




if Token_Pos258 /= No_Token_Index then

   Row_Pos155 := Token_Pos258;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res259 := Row_Pos155;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res259));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Limited)
   then
       Token_Pos259 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos155,
             Expected_Token_Id => Ada_Limited,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos259 := Row_Pos155 + 1;
   end if;
end;

--  End tok_code


if Token_Pos259 = No_Token_Index then

         Opt_Res19 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res19,
            Kind              => Ada_Limited_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos155,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos259 := Row_Pos155;


else

      Opt_Res19 := Allocate_Limited_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res19,
         Kind              => Ada_Limited_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos155,
         Token_End_Index   => Token_Pos259 - 1);

end if;

--  End opt_code




if Token_Pos259 /= No_Token_Index then

   Row_Pos155 := Token_Pos259;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;


--  Start tok_code

Token_Res260 := Row_Pos155;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res260));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos260 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos155,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos260 := Row_Pos155 + 1;
   end if;
end;

--  End tok_code




if Token_Pos260 /= No_Token_Index then

   Row_Pos155 := Token_Pos260;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row155_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos155 /= No_Token_Index then

   Transform_Res104 := Allocate_Private_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res104,
      Kind => Ada_Private_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos154,
      Token_End_Index   => (if Row_Pos155 = Row_Pos154
                            then No_Token_Index
                            else Row_Pos155 - 1));

      Initialize_Fields_For_Private_Type_Def
        (Self => Transform_Res104, Private_Type_Def_F_Has_Abstract => Opt_Res17, Private_Type_Def_F_Has_Tagged => Opt_Res18, Private_Type_Def_F_Has_Limited => Opt_Res19);

         if Opt_Res17 /= null and then Is_Incomplete (Opt_Res17) then
            Transform_Res104.Last_Attempted_Child := 0;
         elsif Opt_Res17 /= null and then not Is_Ghost (Opt_Res17) then
            Transform_Res104.Last_Attempted_Child := -1;
         end if;
         if Opt_Res18 /= null and then Is_Incomplete (Opt_Res18) then
            Transform_Res104.Last_Attempted_Child := 0;
         elsif Opt_Res18 /= null and then not Is_Ghost (Opt_Res18) then
            Transform_Res104.Last_Attempted_Child := -1;
         end if;
         if Opt_Res19 /= null and then Is_Incomplete (Opt_Res19) then
            Transform_Res104.Last_Attempted_Child := 0;
         elsif Opt_Res19 /= null and then not Is_Ghost (Opt_Res19) then
            Transform_Res104.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos155 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags104);
end if;

--  End transform_code

    if Row_Pos155 /= No_Token_Index then
        Or_Pos60 := Row_Pos155;
        Or_Res60 := Transform_Res104;
        goto Exit_Or62;
    end if;
<<Exit_Or62>>

--  End or_code




if Or_Pos60 /= No_Token_Index then

   Row_Pos154 := Or_Pos60;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos156 := Row_Pos154;



--  Start tok_code

Token_Res261 := Row_Pos156;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res261));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Or)
   then
       Token_Pos261 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos156 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos156,
             Expected_Token_Id => Ada_Or,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos261 := Row_Pos156 + 1;
   end if;
end;

--  End tok_code




if Token_Pos261 /= No_Token_Index then

   Row_Pos156 := Token_Pos261;

else
   Row_Pos156 := No_Token_Index;
   goto Exit_Row156_0;

end if;


--  Start tok_code

Token_Res262 := Row_Pos156;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res262));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos262 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos156 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos156,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos262 := Row_Pos156 + 1;
   end if;
end;

--  End tok_code




if Token_Pos262 /= No_Token_Index then

   Row_Pos156 := Token_Pos262;

else
   Row_Pos156 := No_Token_Index;
   goto Exit_Row156_0;

end if;


Defer_Res264 :=
   Name_Or_Parse2 (Parser, Row_Pos156);
Defer_Pos264 := Parser.Current_Pos;




if Defer_Pos264 /= No_Token_Index then

   Row_Pos156 := Defer_Pos264;

else
   Row_Pos156 := No_Token_Index;
   goto Exit_Row156_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row156_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos156 = No_Token_Index then

         
   Defer_Res264 := No_Bare_Ada_Node;



       
   Row_Pos156 := Row_Pos154;



end if;

--  End opt_code




if Row_Pos156 /= No_Token_Index then

   Row_Pos154 := Row_Pos156;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


Defer_Res265 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos154);
Defer_Pos265 := Parser.Current_Pos;




if Defer_Pos265 /= No_Token_Index then

   Row_Pos154 := Defer_Pos265;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res263 := Row_Pos154;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res263));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos263 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos154 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos154,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos263 := Row_Pos154 + 1;
   end if;
end;

--  End tok_code


if Token_Pos263 = No_Token_Index then

         
   Token_Res263 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos154)),
                To_Text ("Missing ';'"));

       
   Token_Pos263 := Row_Pos154;



end if;

--  End opt_code




if Token_Pos263 /= No_Token_Index then

   Row_Pos154 := Token_Pos263;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row154_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos154 /= No_Token_Index then

   Transform_Res105 := Allocate_Formal_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res105,
      Kind => Ada_Formal_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos154 = Pos
                            then No_Token_Index
                            else Row_Pos154 - 1));

      Initialize_Fields_For_Formal_Type_Decl
        (Self => Transform_Res105, Base_Type_Decl_F_Name => Defer_Res261, Type_Decl_F_Discriminants => Defer_Res262, Type_Decl_F_Type_Def => Or_Res60, Formal_Type_Decl_F_Default_Type => Defer_Res264, Formal_Type_Decl_F_Aspects => Defer_Res265);

         if Defer_Res261 /= null and then Is_Incomplete (Defer_Res261) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Defer_Res261 /= null and then not Is_Ghost (Defer_Res261) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res262 /= null and then Is_Incomplete (Defer_Res262) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Defer_Res262 /= null and then not Is_Ghost (Defer_Res262) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
         if Or_Res60 /= null and then Is_Incomplete (Or_Res60) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Or_Res60 /= null and then not Is_Ghost (Or_Res60) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res264 /= null and then Is_Incomplete (Defer_Res264) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Defer_Res264 /= null and then not Is_Ghost (Defer_Res264) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res265 /= null and then Is_Incomplete (Defer_Res265) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Defer_Res265 /= null and then not Is_Ghost (Defer_Res265) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos154 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags105);
end if;

--  End transform_code

    if Row_Pos154 /= No_Token_Index then
        Or_Pos61 := Row_Pos154;
        Or_Res61 := Transform_Res105;
        goto Exit_Or61;
    end if;
    
--  Start transform_code

Transform_Diags106 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos157 := Pos;



--  Start tok_code

Token_Res264 := Row_Pos157;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res264));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos264 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos157 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos157,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos264 := Row_Pos157 + 1;
   end if;
end;

--  End tok_code




if Token_Pos264 /= No_Token_Index then

   Row_Pos157 := Token_Pos264;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


Defer_Res266 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos157);
Defer_Pos266 := Parser.Current_Pos;




if Defer_Pos266 /= No_Token_Index then

   Row_Pos157 := Defer_Pos266;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  Start opt_code












Defer_Res267 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos157);
Defer_Pos267 := Parser.Current_Pos;


if Defer_Pos267 = No_Token_Index then

         
   Defer_Res267 := No_Bare_Ada_Node;



       
   Defer_Pos267 := Row_Pos157;



end if;

--  End opt_code




if Defer_Pos267 /= No_Token_Index then

   Row_Pos157 := Defer_Pos267;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos158 := Row_Pos157;



--  Start tok_code

Token_Res265 := Row_Pos158;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res265));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos265 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos158 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos158,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos265 := Row_Pos158 + 1;
   end if;
end;

--  End tok_code




if Token_Pos265 /= No_Token_Index then

   Row_Pos158 := Token_Pos265;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res266 := Row_Pos158;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res266));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Tagged)
   then
       Token_Pos266 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos158 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos158,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos266 := Row_Pos158 + 1;
   end if;
end;

--  End tok_code


if Token_Pos266 = No_Token_Index then

         Opt_Res20 := Allocate_Tagged_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res20,
            Kind              => Ada_Tagged_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos158,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos266 := Row_Pos158;


else

      Opt_Res20 := Allocate_Tagged_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res20,
         Kind              => Ada_Tagged_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos158,
         Token_End_Index   => Token_Pos266 - 1);

end if;

--  End opt_code




if Token_Pos266 /= No_Token_Index then

   Row_Pos158 := Token_Pos266;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row158_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos158 = No_Token_Index then

         
   Opt_Res20 := No_Bare_Ada_Node;



       
   Row_Pos158 := Row_Pos157;



end if;

--  End opt_code




if Row_Pos158 /= No_Token_Index then

   Row_Pos157 := Row_Pos158;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos159 := Row_Pos157;



--  Start tok_code

Token_Res267 := Row_Pos159;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res267));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Or)
   then
       Token_Pos267 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos159 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos159,
             Expected_Token_Id => Ada_Or,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos267 := Row_Pos159 + 1;
   end if;
end;

--  End tok_code




if Token_Pos267 /= No_Token_Index then

   Row_Pos159 := Token_Pos267;

else
   Row_Pos159 := No_Token_Index;
   goto Exit_Row159_0;

end if;


--  Start tok_code

Token_Res268 := Row_Pos159;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res268));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos268 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos159 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos159,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos268 := Row_Pos159 + 1;
   end if;
end;

--  End tok_code




if Token_Pos268 /= No_Token_Index then

   Row_Pos159 := Token_Pos268;

else
   Row_Pos159 := No_Token_Index;
   goto Exit_Row159_0;

end if;


Defer_Res268 :=
   Name_Or_Parse2 (Parser, Row_Pos159);
Defer_Pos268 := Parser.Current_Pos;




if Defer_Pos268 /= No_Token_Index then

   Row_Pos159 := Defer_Pos268;

else
   Row_Pos159 := No_Token_Index;
   goto Exit_Row159_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row159_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos159 = No_Token_Index then

         
   Defer_Res268 := No_Bare_Ada_Node;



       
   Row_Pos159 := Row_Pos157;



end if;

--  End opt_code




if Row_Pos159 /= No_Token_Index then

   Row_Pos157 := Row_Pos159;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  Start tok_code

Token_Res269 := Row_Pos157;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res269));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos269 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos157 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos157,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos269 := Row_Pos157 + 1;
   end if;
end;

--  End tok_code




if Token_Pos269 /= No_Token_Index then

   Row_Pos157 := Token_Pos269;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row157_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos157 /= No_Token_Index then

   Transform_Res106 := Allocate_Incomplete_Formal_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res106,
      Kind => Ada_Incomplete_Formal_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos157 = Pos
                            then No_Token_Index
                            else Row_Pos157 - 1));

      Initialize_Fields_For_Incomplete_Formal_Type_Decl
        (Self => Transform_Res106, Base_Type_Decl_F_Name => Defer_Res266, Incomplete_Type_Decl_F_Discriminants => Defer_Res267, Incomplete_Formal_Type_Decl_F_Is_Tagged => Opt_Res20, Incomplete_Formal_Type_Decl_F_Default_Type => Defer_Res268);

         if Defer_Res266 /= null and then Is_Incomplete (Defer_Res266) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Defer_Res266 /= null and then not Is_Ghost (Defer_Res266) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;
         if Defer_Res267 /= null and then Is_Incomplete (Defer_Res267) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Defer_Res267 /= null and then not Is_Ghost (Defer_Res267) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;
         if Opt_Res20 /= null and then Is_Incomplete (Opt_Res20) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Opt_Res20 /= null and then not Is_Ghost (Opt_Res20) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;
         if Defer_Res268 /= null and then Is_Incomplete (Defer_Res268) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Defer_Res268 /= null and then not Is_Ghost (Defer_Res268) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos157 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags106);
end if;

--  End transform_code

    if Row_Pos157 /= No_Token_Index then
        Or_Pos61 := Row_Pos157;
        Or_Res61 := Transform_Res106;
        goto Exit_Or61;
    end if;
<<Exit_Or61>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Formal_Type_Decl_Or_Parse1_Memo,
      Or_Pos61 /= No_Token_Index,
      Or_Res61,
      Pos,
      Or_Pos61);


   Parser.Current_Pos := Or_Pos61;

   Exit_Call (Parser, Call_Depth);
   return Or_Res61;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Formal_Type_Decl_Or_Parse1;

   


function Generic_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Decl
is
   use Bare_Generic_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos160 :
            Token_Index
               := No_Token_Index;
      Defer_Pos269 :
            Token_Index
               := No_Token_Index;
      Defer_Res269 :
            Bare_Generic_Formal_Part
               := No_Bare_Ada_Node;
      Row_Pos161 :
            Token_Index
               := No_Token_Index;
      Defer_Pos270 :
            Token_Index
               := No_Token_Index;
      Defer_Res270 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Defer_Pos271 :
            Token_Index
               := No_Token_Index;
      Defer_Res271 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Transform_Res107 :
            Bare_Generic_Subp_Internal
               := No_Bare_Ada_Node;
      Transform_Diags107 :
            Ada.Containers.Count_Type;
      Token_Pos270 :
            Token_Index
               := No_Token_Index;
      Token_Res270 :
            Token_Index
               := No_Token_Index;
      Transform_Res108 :
            Bare_Generic_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags108 :
            Ada.Containers.Count_Type;
      Row_Pos162 :
            Token_Index
               := No_Token_Index;
      Defer_Pos272 :
            Token_Index
               := No_Token_Index;
      Defer_Res272 :
            Bare_Generic_Formal_Part
               := No_Bare_Ada_Node;
      Row_Pos163 :
            Token_Index
               := No_Token_Index;
      Token_Pos271 :
            Token_Index
               := No_Token_Index;
      Token_Res271 :
            Token_Index
               := No_Token_Index;
      Defer_Pos273 :
            Token_Index
               := No_Token_Index;
      Defer_Res273 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos274 :
            Token_Index
               := No_Token_Index;
      Defer_Res274 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos272 :
            Token_Index
               := No_Token_Index;
      Token_Res272 :
            Token_Index
               := No_Token_Index;
      Row_Pos164 :
            Token_Index
               := No_Token_Index;
      Defer_Pos275 :
            Token_Index
               := No_Token_Index;
      Defer_Res275 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res109 :
            Bare_Public_Part
               := No_Bare_Ada_Node;
      Transform_Diags109 :
            Ada.Containers.Count_Type;
      Row_Pos165 :
            Token_Index
               := No_Token_Index;
      Token_Pos273 :
            Token_Index
               := No_Token_Index;
      Token_Res273 :
            Token_Index
               := No_Token_Index;
      Row_Pos166 :
            Token_Index
               := No_Token_Index;
      Defer_Pos276 :
            Token_Index
               := No_Token_Index;
      Defer_Res276 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res110 :
            Bare_Private_Part
               := No_Bare_Ada_Node;
      Transform_Diags110 :
            Ada.Containers.Count_Type;
      Row_Pos167 :
            Token_Index
               := No_Token_Index;
      Token_Pos274 :
            Token_Index
               := No_Token_Index;
      Token_Res274 :
            Token_Index
               := No_Token_Index;
      Row_Pos168 :
            Token_Index
               := No_Token_Index;
      Defer_Pos277 :
            Token_Index
               := No_Token_Index;
      Defer_Res277 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res111 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags111 :
            Ada.Containers.Count_Type;
      Token_Pos275 :
            Token_Index
               := No_Token_Index;
      Token_Res275 :
            Token_Index
               := No_Token_Index;
      Transform_Res112 :
            Bare_Generic_Package_Internal
               := No_Bare_Ada_Node;
      Transform_Diags112 :
            Ada.Containers.Count_Type;
      Transform_Res113 :
            Bare_Generic_Package_Decl
               := No_Bare_Ada_Node;
      Transform_Diags113 :
            Ada.Containers.Count_Type;
      Or_Pos62 :
            Token_Index
               := No_Token_Index;
      Or_Res62 :
            Bare_Generic_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Generic_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res62 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res62;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res62;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos62 := No_Token_Index;
Or_Res62 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags108 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos160 := Pos;



Defer_Res269 :=
   Generic_Formal_Part_Transform_Parse0 (Parser, Row_Pos160);
Defer_Pos269 := Parser.Current_Pos;




if Defer_Pos269 /= No_Token_Index then

   Row_Pos160 := Defer_Pos269;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;


--  Start transform_code

Transform_Diags107 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos161 := Row_Pos160;



Defer_Res270 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos161);
Defer_Pos270 := Parser.Current_Pos;




if Defer_Pos270 /= No_Token_Index then

   Row_Pos161 := Defer_Pos270;

else
   Row_Pos161 := No_Token_Index;
   goto Exit_Row161_0;

end if;


Defer_Res271 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos161);
Defer_Pos271 := Parser.Current_Pos;




if Defer_Pos271 /= No_Token_Index then

   Row_Pos161 := Defer_Pos271;

else
   Row_Pos161 := No_Token_Index;
   goto Exit_Row161_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row161_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos161 /= No_Token_Index then

   Transform_Res107 := Allocate_Generic_Subp_Internal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res107,
      Kind => Ada_Generic_Subp_Internal,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos160,
      Token_End_Index   => (if Row_Pos161 = Row_Pos160
                            then No_Token_Index
                            else Row_Pos161 - 1));

      Initialize_Fields_For_Generic_Subp_Internal
        (Self => Transform_Res107, Generic_Subp_Internal_F_Subp_Spec => Defer_Res270, Generic_Subp_Internal_F_Aspects => Defer_Res271);

         if Defer_Res270 /= null and then Is_Incomplete (Defer_Res270) then
            Transform_Res107.Last_Attempted_Child := 0;
         elsif Defer_Res270 /= null and then not Is_Ghost (Defer_Res270) then
            Transform_Res107.Last_Attempted_Child := -1;
         end if;
         if Defer_Res271 /= null and then Is_Incomplete (Defer_Res271) then
            Transform_Res107.Last_Attempted_Child := 0;
         elsif Defer_Res271 /= null and then not Is_Ghost (Defer_Res271) then
            Transform_Res107.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos161 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags107);
end if;

--  End transform_code




if Row_Pos161 /= No_Token_Index then

   Row_Pos160 := Row_Pos161;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res270 := Row_Pos160;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res270));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos270 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos160 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos160,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos270 := Row_Pos160 + 1;
   end if;
end;

--  End tok_code


if Token_Pos270 = No_Token_Index then

         
   Token_Res270 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos160)),
                To_Text ("Missing ';'"));

       
   Token_Pos270 := Row_Pos160;



end if;

--  End opt_code




if Token_Pos270 /= No_Token_Index then

   Row_Pos160 := Token_Pos270;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row160_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos160 /= No_Token_Index then

   Transform_Res108 := Allocate_Generic_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res108,
      Kind => Ada_Generic_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos160 = Pos
                            then No_Token_Index
                            else Row_Pos160 - 1));

      Initialize_Fields_For_Generic_Subp_Decl
        (Self => Transform_Res108, Generic_Decl_F_Formal_Part => Defer_Res269, Generic_Subp_Decl_F_Subp_Decl => Transform_Res107);

         if Defer_Res269 /= null and then Is_Incomplete (Defer_Res269) then
            Transform_Res108.Last_Attempted_Child := 0;
         elsif Defer_Res269 /= null and then not Is_Ghost (Defer_Res269) then
            Transform_Res108.Last_Attempted_Child := -1;
         end if;
         if Transform_Res107 /= null and then Is_Incomplete (Transform_Res107) then
            Transform_Res108.Last_Attempted_Child := 0;
         elsif Transform_Res107 /= null and then not Is_Ghost (Transform_Res107) then
            Transform_Res108.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos160 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags108);
end if;

--  End transform_code

    if Row_Pos160 /= No_Token_Index then
        Or_Pos62 := Row_Pos160;
        Or_Res62 := Transform_Res108;
        goto Exit_Or63;
    end if;
    
--  Start transform_code

Transform_Diags113 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos162 := Pos;



Defer_Res272 :=
   Generic_Formal_Part_Transform_Parse0 (Parser, Row_Pos162);
Defer_Pos272 := Parser.Current_Pos;




if Defer_Pos272 /= No_Token_Index then

   Row_Pos162 := Defer_Pos272;

else
   Row_Pos162 := No_Token_Index;
   goto Exit_Row162_0;

end if;


--  Start transform_code

Transform_Diags112 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos163 := Row_Pos162;



--  Start tok_code

Token_Res271 := Row_Pos163;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res271));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos271 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos163 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos163,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos271 := Row_Pos163 + 1;
   end if;
end;

--  End tok_code




if Token_Pos271 /= No_Token_Index then

   Row_Pos163 := Token_Pos271;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


Defer_Res273 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos163);
Defer_Pos273 := Parser.Current_Pos;




if Defer_Pos273 /= No_Token_Index then

   Row_Pos163 := Defer_Pos273;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


Defer_Res274 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos163);
Defer_Pos274 := Parser.Current_Pos;




if Defer_Pos274 /= No_Token_Index then

   Row_Pos163 := Defer_Pos274;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


--  Start tok_code

Token_Res272 := Row_Pos163;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res272));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos272 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos163 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos163,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos272 := Row_Pos163 + 1;
   end if;
end;

--  End tok_code




if Token_Pos272 /= No_Token_Index then

   Row_Pos163 := Token_Pos272;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


--  Start transform_code

Transform_Diags109 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos164 := Row_Pos163;



        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Generic_Decl0_Extract_Parse0'Access);
        
Defer_Res275 :=
   Basic_Decls_List_Parse0 (Parser, Row_Pos164);
Defer_Pos275 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos275 /= No_Token_Index then

   Row_Pos164 := Defer_Pos275;

else
   Row_Pos164 := No_Token_Index;
   goto Exit_Row164_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row164_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos164 /= No_Token_Index then

   Transform_Res109 := Allocate_Public_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res109,
      Kind => Ada_Public_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos163,
      Token_End_Index   => (if Row_Pos164 = Row_Pos163
                            then No_Token_Index
                            else Row_Pos164 - 1));

      Initialize_Fields_For_Public_Part
        (Self => Transform_Res109, Declarative_Part_F_Decls => Defer_Res275);

         if Defer_Res275 /= null and then Is_Incomplete (Defer_Res275) then
            Transform_Res109.Last_Attempted_Child := 0;
         elsif Defer_Res275 /= null and then not Is_Ghost (Defer_Res275) then
            Transform_Res109.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos164 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags109);
end if;

--  End transform_code




if Row_Pos164 /= No_Token_Index then

   Row_Pos163 := Row_Pos164;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos165 := Row_Pos163;



--  Start tok_code

Token_Res273 := Row_Pos165;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res273));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos273 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos165 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos165,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos273 := Row_Pos165 + 1;
   end if;
end;

--  End tok_code




if Token_Pos273 /= No_Token_Index then

   Row_Pos165 := Token_Pos273;

else
   Row_Pos165 := No_Token_Index;
   goto Exit_Row165_0;

end if;


--  Start transform_code

Transform_Diags110 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos166 := Row_Pos165;



        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Generic_Decl1_Extract_Parse0'Access);
        
Defer_Res276 :=
   Basic_Decls_List_Parse0 (Parser, Row_Pos166);
Defer_Pos276 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos276 /= No_Token_Index then

   Row_Pos166 := Defer_Pos276;

else
   Row_Pos166 := No_Token_Index;
   goto Exit_Row166_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row166_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos166 /= No_Token_Index then

   Transform_Res110 := Allocate_Private_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res110,
      Kind => Ada_Private_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos165,
      Token_End_Index   => (if Row_Pos166 = Row_Pos165
                            then No_Token_Index
                            else Row_Pos166 - 1));

      Initialize_Fields_For_Private_Part
        (Self => Transform_Res110, Declarative_Part_F_Decls => Defer_Res276);

         if Defer_Res276 /= null and then Is_Incomplete (Defer_Res276) then
            Transform_Res110.Last_Attempted_Child := 0;
         elsif Defer_Res276 /= null and then not Is_Ghost (Defer_Res276) then
            Transform_Res110.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos166 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags110);
end if;

--  End transform_code




if Row_Pos166 /= No_Token_Index then

   Row_Pos165 := Row_Pos166;

else
   Row_Pos165 := No_Token_Index;
   goto Exit_Row165_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row165_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos165 = No_Token_Index then

         
   Transform_Res110 := No_Bare_Ada_Node;



       
   Row_Pos165 := Row_Pos163;



end if;

--  End opt_code




if Row_Pos165 /= No_Token_Index then

   Row_Pos163 := Row_Pos165;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


--  Start row_code

Row_Pos167 := Row_Pos163;



--  Start tok_code

Token_Res274 := Row_Pos167;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res274));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos274 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos167 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos167,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos274 := Row_Pos167 + 1;
   end if;
end;

--  End tok_code




if Token_Pos274 /= No_Token_Index then

   Row_Pos167 := Token_Pos274;

else
   Row_Pos167 := No_Token_Index;
   goto Exit_Row167_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags111 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos168 := Row_Pos167;



Defer_Res277 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos168);
Defer_Pos277 := Parser.Current_Pos;




if Defer_Pos277 /= No_Token_Index then

   Row_Pos168 := Defer_Pos277;

else
   Row_Pos168 := No_Token_Index;
   goto Exit_Row168_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row168_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos168 /= No_Token_Index then

   Transform_Res111 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res111,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos167,
      Token_End_Index   => (if Row_Pos168 = Row_Pos167
                            then No_Token_Index
                            else Row_Pos168 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res111, End_Name_F_Name => Defer_Res277);

         if Defer_Res277 /= null and then Is_Incomplete (Defer_Res277) then
            Transform_Res111.Last_Attempted_Child := 0;
         elsif Defer_Res277 /= null and then not Is_Ghost (Defer_Res277) then
            Transform_Res111.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos168 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags111);
end if;

--  End transform_code


if Row_Pos168 = No_Token_Index then

         
   Transform_Res111 := No_Bare_Ada_Node;



       
   Row_Pos168 := Row_Pos167;



end if;

--  End opt_code




if Row_Pos168 /= No_Token_Index then

   Row_Pos167 := Row_Pos168;

else
   Row_Pos167 := No_Token_Index;
   goto Exit_Row167_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row167_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos167 /= No_Token_Index then

   Row_Pos163 := Row_Pos167;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res275 := Row_Pos163;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res275));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos275 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos163 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos163,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos275 := Row_Pos163 + 1;
   end if;
end;

--  End tok_code


if Token_Pos275 = No_Token_Index then

         
   Token_Res275 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos163)),
                To_Text ("Missing ';'"));

       
   Token_Pos275 := Row_Pos163;



end if;

--  End opt_code




if Token_Pos275 /= No_Token_Index then

   Row_Pos163 := Token_Pos275;

else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row163_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos163 /= No_Token_Index then

   Transform_Res112 := Allocate_Generic_Package_Internal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res112,
      Kind => Ada_Generic_Package_Internal,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos162,
      Token_End_Index   => (if Row_Pos163 = Row_Pos162
                            then No_Token_Index
                            else Row_Pos163 - 1));

      Initialize_Fields_For_Generic_Package_Internal
        (Self => Transform_Res112, Base_Package_Decl_F_Package_Name => Defer_Res273, Base_Package_Decl_F_Aspects => Defer_Res274, Base_Package_Decl_F_Public_Part => Transform_Res109, Base_Package_Decl_F_Private_Part => Transform_Res110, Base_Package_Decl_F_End_Name => Transform_Res111);

         if Defer_Res273 /= null and then Is_Incomplete (Defer_Res273) then
            Transform_Res112.Last_Attempted_Child := 0;
         elsif Defer_Res273 /= null and then not Is_Ghost (Defer_Res273) then
            Transform_Res112.Last_Attempted_Child := -1;
         end if;
         if Defer_Res274 /= null and then Is_Incomplete (Defer_Res274) then
            Transform_Res112.Last_Attempted_Child := 0;
         elsif Defer_Res274 /= null and then not Is_Ghost (Defer_Res274) then
            Transform_Res112.Last_Attempted_Child := -1;
         end if;
         if Transform_Res109 /= null and then Is_Incomplete (Transform_Res109) then
            Transform_Res112.Last_Attempted_Child := 0;
         elsif Transform_Res109 /= null and then not Is_Ghost (Transform_Res109) then
            Transform_Res112.Last_Attempted_Child := -1;
         end if;
         if Transform_Res110 /= null and then Is_Incomplete (Transform_Res110) then
            Transform_Res112.Last_Attempted_Child := 0;
         elsif Transform_Res110 /= null and then not Is_Ghost (Transform_Res110) then
            Transform_Res112.Last_Attempted_Child := -1;
         end if;
         if Transform_Res111 /= null and then Is_Incomplete (Transform_Res111) then
            Transform_Res112.Last_Attempted_Child := 0;
         elsif Transform_Res111 /= null and then not Is_Ghost (Transform_Res111) then
            Transform_Res112.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos163 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags112);
end if;

--  End transform_code




if Row_Pos163 /= No_Token_Index then

   Row_Pos162 := Row_Pos163;

else
   Row_Pos162 := No_Token_Index;
   goto Exit_Row162_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row162_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos162 /= No_Token_Index then

   Transform_Res113 := Allocate_Generic_Package_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res113,
      Kind => Ada_Generic_Package_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos162 = Pos
                            then No_Token_Index
                            else Row_Pos162 - 1));

      Initialize_Fields_For_Generic_Package_Decl
        (Self => Transform_Res113, Generic_Decl_F_Formal_Part => Defer_Res272, Generic_Package_Decl_F_Package_Decl => Transform_Res112);

         if Defer_Res272 /= null and then Is_Incomplete (Defer_Res272) then
            Transform_Res113.Last_Attempted_Child := 0;
         elsif Defer_Res272 /= null and then not Is_Ghost (Defer_Res272) then
            Transform_Res113.Last_Attempted_Child := -1;
         end if;
         if Transform_Res112 /= null and then Is_Incomplete (Transform_Res112) then
            Transform_Res113.Last_Attempted_Child := 0;
         elsif Transform_Res112 /= null and then not Is_Ghost (Transform_Res112) then
            Transform_Res113.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos162 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags113);
end if;

--  End transform_code

    if Row_Pos162 /= No_Token_Index then
        Or_Pos62 := Row_Pos162;
        Or_Res62 := Transform_Res113;
        goto Exit_Or63;
    end if;
<<Exit_Or63>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Generic_Decl_Or_Parse0_Memo,
      Or_Pos62 /= No_Token_Index,
      Or_Res62,
      Pos,
      Or_Pos62);


   Parser.Current_Pos := Or_Pos62;

   Exit_Call (Parser, Call_Depth);
   return Or_Res62;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Generic_Decl_Or_Parse0;

   


function Generic_Formal_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos278 :
            Token_Index
               := No_Token_Index;
      Defer_Res278 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Row_Pos169 :
            Token_Index
               := No_Token_Index;
      Defer_Pos279 :
            Token_Index
               := No_Token_Index;
      Defer_Res279 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;
      Transform_Res114 :
            Bare_Generic_Formal_Obj_Decl
               := No_Bare_Ada_Node;
      Transform_Diags114 :
            Ada.Containers.Count_Type;
      Row_Pos170 :
            Token_Index
               := No_Token_Index;
      Defer_Pos280 :
            Token_Index
               := No_Token_Index;
      Defer_Res280 :
            Bare_Base_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Res115 :
            Bare_Generic_Formal_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags115 :
            Ada.Containers.Count_Type;
      Row_Pos171 :
            Token_Index
               := No_Token_Index;
      Defer_Pos281 :
            Token_Index
               := No_Token_Index;
      Defer_Res281 :
            Bare_Formal_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Res116 :
            Bare_Generic_Formal_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags116 :
            Ada.Containers.Count_Type;
      Row_Pos172 :
            Token_Index
               := No_Token_Index;
      Token_Pos276 :
            Token_Index
               := No_Token_Index;
      Token_Res276 :
            Token_Index
               := No_Token_Index;
      Defer_Pos282 :
            Token_Index
               := No_Token_Index;
      Defer_Res282 :
            Bare_Generic_Instantiation
               := No_Bare_Ada_Node;
      Transform_Res117 :
            Bare_Generic_Formal_Package
               := No_Bare_Ada_Node;
      Transform_Diags117 :
            Ada.Containers.Count_Type;
      Or_Pos63 :
            Token_Index
               := No_Token_Index;
      Or_Res63 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Generic_Formal_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res63 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res63;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res63;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos63 := No_Token_Index;
Or_Res63 := No_Bare_Ada_Node;
    
Defer_Res278 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos278 := Parser.Current_Pos;

    if Defer_Pos278 /= No_Token_Index then
        Or_Pos63 := Defer_Pos278;
        Or_Res63 := Defer_Res278;
        goto Exit_Or64;
    end if;
    
--  Start transform_code

Transform_Diags114 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos169 := Pos;



Defer_Res279 :=
   Object_Decl_Or_Parse0 (Parser, Row_Pos169);
Defer_Pos279 := Parser.Current_Pos;




if Defer_Pos279 /= No_Token_Index then

   Row_Pos169 := Defer_Pos279;

else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row169_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos169 /= No_Token_Index then

   Transform_Res114 := Allocate_Generic_Formal_Obj_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res114,
      Kind => Ada_Generic_Formal_Obj_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos169 = Pos
                            then No_Token_Index
                            else Row_Pos169 - 1));

      Initialize_Fields_For_Generic_Formal_Obj_Decl
        (Self => Transform_Res114, Generic_Formal_F_Decl => Defer_Res279);

         if Defer_Res279 /= null and then Is_Incomplete (Defer_Res279) then
            Transform_Res114.Last_Attempted_Child := 0;
         elsif Defer_Res279 /= null and then not Is_Ghost (Defer_Res279) then
            Transform_Res114.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos169 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags114);
end if;

--  End transform_code

    if Row_Pos169 /= No_Token_Index then
        Or_Pos63 := Row_Pos169;
        Or_Res63 := Transform_Res114;
        goto Exit_Or64;
    end if;
    
--  Start transform_code

Transform_Diags115 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos170 := Pos;



Defer_Res280 :=
   Formal_Type_Decl_Or_Parse1 (Parser, Row_Pos170);
Defer_Pos280 := Parser.Current_Pos;




if Defer_Pos280 /= No_Token_Index then

   Row_Pos170 := Defer_Pos280;

else
   Row_Pos170 := No_Token_Index;
   goto Exit_Row170_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row170_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos170 /= No_Token_Index then

   Transform_Res115 := Allocate_Generic_Formal_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res115,
      Kind => Ada_Generic_Formal_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos170 = Pos
                            then No_Token_Index
                            else Row_Pos170 - 1));

      Initialize_Fields_For_Generic_Formal_Type_Decl
        (Self => Transform_Res115, Generic_Formal_F_Decl => Defer_Res280);

         if Defer_Res280 /= null and then Is_Incomplete (Defer_Res280) then
            Transform_Res115.Last_Attempted_Child := 0;
         elsif Defer_Res280 /= null and then not Is_Ghost (Defer_Res280) then
            Transform_Res115.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos170 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags115);
end if;

--  End transform_code

    if Row_Pos170 /= No_Token_Index then
        Or_Pos63 := Row_Pos170;
        Or_Res63 := Transform_Res115;
        goto Exit_Or64;
    end if;
    
--  Start transform_code

Transform_Diags116 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos171 := Pos;



Defer_Res281 :=
   Formal_Subp_Decl_Or_Parse2 (Parser, Row_Pos171);
Defer_Pos281 := Parser.Current_Pos;




if Defer_Pos281 /= No_Token_Index then

   Row_Pos171 := Defer_Pos281;

else
   Row_Pos171 := No_Token_Index;
   goto Exit_Row171_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row171_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos171 /= No_Token_Index then

   Transform_Res116 := Allocate_Generic_Formal_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res116,
      Kind => Ada_Generic_Formal_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos171 = Pos
                            then No_Token_Index
                            else Row_Pos171 - 1));

      Initialize_Fields_For_Generic_Formal_Subp_Decl
        (Self => Transform_Res116, Generic_Formal_F_Decl => Defer_Res281);

         if Defer_Res281 /= null and then Is_Incomplete (Defer_Res281) then
            Transform_Res116.Last_Attempted_Child := 0;
         elsif Defer_Res281 /= null and then not Is_Ghost (Defer_Res281) then
            Transform_Res116.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos171 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags116);
end if;

--  End transform_code

    if Row_Pos171 /= No_Token_Index then
        Or_Pos63 := Row_Pos171;
        Or_Res63 := Transform_Res116;
        goto Exit_Or64;
    end if;
    
--  Start transform_code

Transform_Diags117 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos172 := Pos;



--  Start tok_code

Token_Res276 := Row_Pos172;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res276));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos276 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos172 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos172,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos276 := Row_Pos172 + 1;
   end if;
end;

--  End tok_code




if Token_Pos276 /= No_Token_Index then

   Row_Pos172 := Token_Pos276;

else
   Row_Pos172 := No_Token_Index;
   goto Exit_Row172_0;

end if;


Defer_Res282 :=
   Generic_Instantiation_Or_Parse1 (Parser, Row_Pos172);
Defer_Pos282 := Parser.Current_Pos;




if Defer_Pos282 /= No_Token_Index then

   Row_Pos172 := Defer_Pos282;

else
   Row_Pos172 := No_Token_Index;
   goto Exit_Row172_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row172_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos172 /= No_Token_Index then

   Transform_Res117 := Allocate_Generic_Formal_Package (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res117,
      Kind => Ada_Generic_Formal_Package,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos172 = Pos
                            then No_Token_Index
                            else Row_Pos172 - 1));

      Initialize_Fields_For_Generic_Formal_Package
        (Self => Transform_Res117, Generic_Formal_F_Decl => Defer_Res282);

         if Defer_Res282 /= null and then Is_Incomplete (Defer_Res282) then
            Transform_Res117.Last_Attempted_Child := 0;
         elsif Defer_Res282 /= null and then not Is_Ghost (Defer_Res282) then
            Transform_Res117.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos172 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags117);
end if;

--  End transform_code

    if Row_Pos172 /= No_Token_Index then
        Or_Pos63 := Row_Pos172;
        Or_Res63 := Transform_Res117;
        goto Exit_Or64;
    end if;
<<Exit_Or64>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Generic_Formal_Decl_Or_Parse0_Memo,
      Or_Pos63 /= No_Token_Index,
      Or_Res63,
      Pos,
      Or_Pos63);


   Parser.Current_Pos := Or_Pos63;

   Exit_Call (Parser, Call_Depth);
   return Or_Res63;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Generic_Formal_Decl_Or_Parse0;

   


function Generic_Formal_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Formal_Part
is
   use Bare_Generic_Formal_Part_Memos;

   Call_Depth : aliased Natural;

      Row_Pos173 :
            Token_Index
               := No_Token_Index;
      Token_Pos277 :
            Token_Index
               := No_Token_Index;
      Token_Res277 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos29 :
            Token_Index
               := No_Token_Index;
      Tmp_List29 :
            Free_Parse_List;
      Defer_Pos283 :
            Token_Index
               := No_Token_Index;
      Defer_Res283 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Defer_Pos284 :
            Token_Index
               := No_Token_Index;
      Defer_Res284 :
            Bare_Use_Clause
               := No_Bare_Ada_Node;
      Or_Pos64 :
            Token_Index
               := No_Token_Index;
      Or_Res64 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos29 :
            Token_Index
               := No_Token_Index;
      List_Res29 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res118 :
            Bare_Generic_Formal_Part
               := No_Bare_Ada_Node;
      Transform_Diags118 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Generic_Formal_Part_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res118 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res118;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res118;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags118 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos173 := Pos;



--  Start tok_code

Token_Res277 := Row_Pos173;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res277));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Generic)
   then
       Token_Pos277 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos173 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos173,
             Expected_Token_Id => Ada_Generic,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos277 := Row_Pos173 + 1;
   end if;
end;

--  End tok_code




if Token_Pos277 /= No_Token_Index then

   Row_Pos173 := Token_Pos277;

else
   Row_Pos173 := No_Token_Index;
   goto Exit_Row173_0;

end if;


--  Start list_code

    List_Pos29 := Row_Pos173;



Lst_Cpos29 := Row_Pos173;
Tmp_List29 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos64 := No_Token_Index;
Or_Res64 := No_Bare_Ada_Node;
    
Defer_Res283 :=
   Generic_Formal_Decl_Or_Parse0 (Parser, Lst_Cpos29);
Defer_Pos283 := Parser.Current_Pos;

    if Defer_Pos283 /= No_Token_Index then
        Or_Pos64 := Defer_Pos283;
        Or_Res64 := Defer_Res283;
        goto Exit_Or65;
    end if;
    
Defer_Res284 :=
   Use_Clause_Or_Parse0 (Parser, Lst_Cpos29);
Defer_Pos284 := Parser.Current_Pos;

    if Defer_Pos284 /= No_Token_Index then
        Or_Pos64 := Defer_Pos284;
        Or_Res64 := Defer_Res284;
        goto Exit_Or65;
    end if;
<<Exit_Or65>>

--  End or_code


   exit when Or_Pos64 = No_Token_Index;

   List_Pos29 := Or_Pos64;
   Lst_Cpos29 := List_Pos29;

   Tmp_List29.Nodes.Append (Or_Res64);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List29.Nodes.Length;
begin
   List_Res29 :=
      Allocate_Ada_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos173;
      Token_End := (if Lst_Cpos29 = Row_Pos173
                    then Row_Pos173
                    else Lst_Cpos29 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos173, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res29,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res29,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List29.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res29.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List29);

--  End list_code




if List_Pos29 /= No_Token_Index then

   Row_Pos173 := List_Pos29;

else
   Row_Pos173 := No_Token_Index;
   goto Exit_Row173_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row173_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos173 /= No_Token_Index then

   Transform_Res118 := Allocate_Generic_Formal_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res118,
      Kind => Ada_Generic_Formal_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos173 = Pos
                            then No_Token_Index
                            else Row_Pos173 - 1));

      Initialize_Fields_For_Generic_Formal_Part
        (Self => Transform_Res118, Generic_Formal_Part_F_Decls => List_Res29);

         if List_Res29 /= null and then Is_Incomplete (List_Res29) then
            Transform_Res118.Last_Attempted_Child := 0;
         elsif List_Res29 /= null and then not Is_Ghost (List_Res29) then
            Transform_Res118.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos173 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags118);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Generic_Formal_Part_Transform_Parse0_Memo,
      Row_Pos173 /= No_Token_Index,
      Transform_Res118,
      Pos,
      Row_Pos173);


   Parser.Current_Pos := Row_Pos173;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res118;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Generic_Formal_Part_Transform_Parse0;

   


function Generic_Instantiation_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Instantiation
is
   use Bare_Generic_Instantiation_Memos;

   Call_Depth : aliased Natural;

      Nobt16 :
            Boolean
               := False;
      Nobt17 :
            Boolean
               := False;
      Nobt18 :
            Boolean
               := False;
      Nobt19 :
            Boolean
               := False;
      Row_Pos174 :
            Token_Index
               := No_Token_Index;
      Token_Pos278 :
            Token_Index
               := No_Token_Index;
      Token_Res278 :
            Token_Index
               := No_Token_Index;
      Defer_Pos285 :
            Token_Index
               := No_Token_Index;
      Defer_Res285 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos279 :
            Token_Index
               := No_Token_Index;
      Token_Res279 :
            Token_Index
               := No_Token_Index;
      Token_Pos280 :
            Token_Index
               := No_Token_Index;
      Token_Res280 :
            Token_Index
               := No_Token_Index;
      Defer_Pos286 :
            Token_Index
               := No_Token_Index;
      Defer_Res286 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos175 :
            Token_Index
               := No_Token_Index;
      Token_Pos281 :
            Token_Index
               := No_Token_Index;
      Token_Res281 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos30 :
            Token_Index
               := No_Token_Index;
      Tmp_List30 :
            Free_Parse_List;
      Defer_Pos287 :
            Token_Index
               := No_Token_Index;
      Defer_Res287 :
            Bare_Param_Assoc
               := No_Bare_Ada_Node;
      Token_Pos282 :
            Token_Index
               := No_Token_Index;
      Token_Res282 :
            Token_Index
               := No_Token_Index;
      List_Pos30 :
            Token_Index
               := No_Token_Index;
      List_Res30 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos283 :
            Token_Index
               := No_Token_Index;
      Token_Res283 :
            Token_Index
               := No_Token_Index;
      Defer_Pos288 :
            Token_Index
               := No_Token_Index;
      Defer_Res288 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos284 :
            Token_Index
               := No_Token_Index;
      Token_Res284 :
            Token_Index
               := No_Token_Index;
      Row_Progress15 :
            Integer
               := 0;
      Transform_Res119 :
            Bare_Generic_Package_Instantiation
               := No_Bare_Ada_Node;
      Transform_Has_Failed15 :
            Boolean
               := False;
      Transform_Diags119 :
            Ada.Containers.Count_Type;
      Row_Pos176 :
            Token_Index
               := No_Token_Index;
      Defer_Pos289 :
            Token_Index
               := No_Token_Index;
      Defer_Res289 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Row_Pos177 :
            Token_Index
               := No_Token_Index;
      Token_Pos285 :
            Token_Index
               := No_Token_Index;
      Token_Res285 :
            Token_Index
               := No_Token_Index;
      Transform_Res120 :
            Bare_Subp_Kind_Procedure
               := No_Bare_Ada_Node;
      Transform_Diags120 :
            Ada.Containers.Count_Type;
      Row_Pos178 :
            Token_Index
               := No_Token_Index;
      Token_Pos286 :
            Token_Index
               := No_Token_Index;
      Token_Res286 :
            Token_Index
               := No_Token_Index;
      Transform_Res121 :
            Bare_Subp_Kind_Function
               := No_Bare_Ada_Node;
      Transform_Diags121 :
            Ada.Containers.Count_Type;
      Or_Pos65 :
            Token_Index
               := No_Token_Index;
      Or_Res65 :
            Bare_Subp_Kind
               := No_Bare_Ada_Node;
      Defer_Pos290 :
            Token_Index
               := No_Token_Index;
      Defer_Res290 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos287 :
            Token_Index
               := No_Token_Index;
      Token_Res287 :
            Token_Index
               := No_Token_Index;
      Token_Pos288 :
            Token_Index
               := No_Token_Index;
      Token_Res288 :
            Token_Index
               := No_Token_Index;
      Defer_Pos291 :
            Token_Index
               := No_Token_Index;
      Defer_Res291 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos179 :
            Token_Index
               := No_Token_Index;
      Token_Pos289 :
            Token_Index
               := No_Token_Index;
      Token_Res289 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos31 :
            Token_Index
               := No_Token_Index;
      Tmp_List31 :
            Free_Parse_List;
      Defer_Pos292 :
            Token_Index
               := No_Token_Index;
      Defer_Res292 :
            Bare_Param_Assoc
               := No_Bare_Ada_Node;
      Token_Pos290 :
            Token_Index
               := No_Token_Index;
      Token_Res290 :
            Token_Index
               := No_Token_Index;
      List_Pos31 :
            Token_Index
               := No_Token_Index;
      List_Res31 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos291 :
            Token_Index
               := No_Token_Index;
      Token_Res291 :
            Token_Index
               := No_Token_Index;
      Defer_Pos293 :
            Token_Index
               := No_Token_Index;
      Defer_Res293 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos292 :
            Token_Index
               := No_Token_Index;
      Token_Res292 :
            Token_Index
               := No_Token_Index;
      Row_Progress16 :
            Integer
               := 0;
      Transform_Res122 :
            Bare_Generic_Subp_Instantiation
               := No_Bare_Ada_Node;
      Transform_Has_Failed16 :
            Boolean
               := False;
      Transform_Diags122 :
            Ada.Containers.Count_Type;
      Or_Pos66 :
            Token_Index
               := No_Token_Index;
      Or_Res66 :
            Bare_Generic_Instantiation
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Generic_Instantiation_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res66 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res66;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res66;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos66 := No_Token_Index;
Or_Res66 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags119 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos174 := Pos;



--  Start tok_code

Token_Res278 := Row_Pos174;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res278));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos278 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos174 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos174,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos278 := Row_Pos174 + 1;
   end if;
end;

--  End tok_code



Row_Progress15 := 1;

if Token_Pos278 /= No_Token_Index then

   Row_Pos174 := Token_Pos278;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


Defer_Res285 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos174);
Defer_Pos285 := Parser.Current_Pos;



Row_Progress15 := 2;

if Defer_Pos285 /= No_Token_Index then

   Row_Pos174 := Defer_Pos285;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


--  Start tok_code

Token_Res279 := Row_Pos174;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res279));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos279 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos174 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos174,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos279 := Row_Pos174 + 1;
   end if;
end;

--  End tok_code



Row_Progress15 := 3;

if Token_Pos279 /= No_Token_Index then

   Row_Pos174 := Token_Pos279;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


--  Start tok_code

Token_Res280 := Row_Pos174;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res280));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos280 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos174 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos174,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos280 := Row_Pos174 + 1;
   end if;
end;

--  End tok_code



Row_Progress15 := 4;

if Token_Pos280 /= No_Token_Index then

   Row_Pos174 := Token_Pos280;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;

Nobt16 := True;

   Nobt16 := Nobt16;

Row_Progress15 := 5;

if Row_Pos174 /= No_Token_Index then

   Row_Pos174 := Row_Pos174;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


Defer_Res286 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos174);
Defer_Pos286 := Parser.Current_Pos;



Row_Progress15 := 6;

if Defer_Pos286 /= No_Token_Index then

   Row_Pos174 := Defer_Pos286;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos175 := Row_Pos174;



--  Start tok_code

Token_Res281 := Row_Pos175;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res281));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos281 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos175 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos175,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos281 := Row_Pos175 + 1;
   end if;
end;

--  End tok_code




if Token_Pos281 /= No_Token_Index then

   Row_Pos175 := Token_Pos281;

else
   Row_Pos175 := No_Token_Index;
   goto Exit_Row175_0;

end if;

Nobt17 := True;

   Nobt17 := Nobt17;


if Row_Pos175 /= No_Token_Index then

   Row_Pos175 := Row_Pos175;

else
   Row_Pos175 := No_Token_Index;
   goto Exit_Row175_0;

end if;


--  Start list_code

    List_Pos30 := No_Token_Index;



Lst_Cpos30 := Row_Pos175;
Tmp_List30 := Get_Parse_List (Parser);

loop
   
Defer_Res287 :=
   Param_Assoc_Transform_Parse0 (Parser, Lst_Cpos30);
Defer_Pos287 := Parser.Current_Pos;


   exit when Defer_Pos287 = No_Token_Index;

   List_Pos30 := Defer_Pos287;
   Lst_Cpos30 := List_Pos30;

   Tmp_List30.Nodes.Append (Defer_Res287);

      
--  Start tok_code

Token_Res282 := Lst_Cpos30;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res282));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos282 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos30 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos30,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos282 := Lst_Cpos30 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos282 /= No_Token_Index then
          Lst_Cpos30 := Token_Pos282;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List30.Nodes.Length;
begin
   List_Res30 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos175;
      Token_End := (if Lst_Cpos30 = Row_Pos175
                    then Row_Pos175
                    else Lst_Cpos30 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos175, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res30,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res30,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List30.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res30.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List30);

--  End list_code




if List_Pos30 /= No_Token_Index then

   Row_Pos175 := List_Pos30;

else
   Row_Pos175 := No_Token_Index;
   goto Exit_Row175_0;

end if;


--  Start tok_code

Token_Res283 := Row_Pos175;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res283));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos283 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos175 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos175,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos283 := Row_Pos175 + 1;
   end if;
end;

--  End tok_code




if Token_Pos283 /= No_Token_Index then

   Row_Pos175 := Token_Pos283;

else
   Row_Pos175 := No_Token_Index;
   goto Exit_Row175_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row175_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos175 = No_Token_Index then

         
   if Nobt17 then
      Row_Pos175 := Parser.Last_Fail.Pos;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Row_Pos175)),
              To_Text ("Cannot parse <generic_instantiation>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;


         if List_Res30 = No_Bare_Ada_Node then
            
   List_Res30 :=
     Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => List_Res30,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos174 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => List_Res30,
      Parser => Parser,
      Count  => 0);

         end if;


       if not Nobt17 then
          
   Row_Pos175 := Row_Pos174;

       end if;


end if;

--  End opt_code


   Nobt16 := Nobt17;

Row_Progress15 := 7;

if Row_Pos175 /= No_Token_Index then

   Row_Pos174 := Row_Pos175;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


Defer_Res288 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos174);
Defer_Pos288 := Parser.Current_Pos;



Row_Progress15 := 8;

if Defer_Pos288 /= No_Token_Index then

   Row_Pos174 := Defer_Pos288;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res284 := Row_Pos174;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res284));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos284 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos174 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos174,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos284 := Row_Pos174 + 1;
   end if;
end;

--  End tok_code


if Token_Pos284 = No_Token_Index then

         
   Token_Res284 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos174)),
                To_Text ("Missing ';'"));

       
   Token_Pos284 := Row_Pos174;



end if;

--  End opt_code



Row_Progress15 := 9;

if Token_Pos284 /= No_Token_Index then

   Row_Pos174 := Token_Pos284;

else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row174_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos174 = No_Token_Index and then Nobt16 then

   Row_Pos174 := Parser.Last_Fail.Pos;

   Transform_Has_Failed15 := True;
end if;

if Row_Pos174 /= No_Token_Index then

   Transform_Res119 := Allocate_Generic_Package_Instantiation (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res119,
      Kind => Ada_Generic_Package_Instantiation,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos174 = Pos
                            then No_Token_Index
                            else Row_Pos174 - 1));

      Initialize_Fields_For_Generic_Package_Instantiation
        (Self => Transform_Res119, Generic_Package_Instantiation_F_Name => Defer_Res285, Generic_Package_Instantiation_F_Generic_Pkg_Name => Defer_Res286, Generic_Package_Instantiation_F_Params => List_Res30, Generic_Package_Instantiation_F_Aspects => Defer_Res288);

         if Defer_Res285 /= null and then Is_Incomplete (Defer_Res285) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res285 /= null and then not Is_Ghost (Defer_Res285) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;
         if Defer_Res286 /= null and then Is_Incomplete (Defer_Res286) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res286 /= null and then not Is_Ghost (Defer_Res286) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;
         if List_Res30 /= null and then Is_Incomplete (List_Res30) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif List_Res30 /= null and then not Is_Ghost (List_Res30) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;
         if Defer_Res288 /= null and then Is_Incomplete (Defer_Res288) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res288 /= null and then not Is_Ghost (Defer_Res288) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed15 then
      Transform_Res119.Last_Attempted_Child :=
         Row_Progress15;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <generic_instantiation>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos174 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags119);
end if;

--  End transform_code

    if Row_Pos174 /= No_Token_Index then
        Or_Pos66 := Row_Pos174;
        Or_Res66 := Transform_Res119;
        goto Exit_Or66;
    end if;
    
--  Start transform_code

Transform_Diags122 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos176 := Pos;



Defer_Res289 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos176);
Defer_Pos289 := Parser.Current_Pos;



Row_Progress16 := 1;

if Defer_Pos289 /= No_Token_Index then

   Row_Pos176 := Defer_Pos289;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


--  Start or_code

Or_Pos65 := No_Token_Index;
Or_Res65 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags120 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos177 := Row_Pos176;



--  Start tok_code

Token_Res285 := Row_Pos177;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res285));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Procedure)
   then
       Token_Pos285 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos177 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos177,
             Expected_Token_Id => Ada_Procedure,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos285 := Row_Pos177 + 1;
   end if;
end;

--  End tok_code




if Token_Pos285 /= No_Token_Index then

   Row_Pos177 := Token_Pos285;

else
   Row_Pos177 := No_Token_Index;
   goto Exit_Row177_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row177_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos177 /= No_Token_Index then

   Transform_Res120 := Allocate_Subp_Kind_Procedure (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res120,
      Kind => Ada_Subp_Kind_Procedure,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos176,
      Token_End_Index   => (if Row_Pos177 = Row_Pos176
                            then No_Token_Index
                            else Row_Pos177 - 1));




elsif Row_Pos177 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags120);
end if;

--  End transform_code

    if Row_Pos177 /= No_Token_Index then
        Or_Pos65 := Row_Pos177;
        Or_Res65 := Transform_Res120;
        goto Exit_Or67;
    end if;
    
--  Start transform_code

Transform_Diags121 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos178 := Row_Pos176;



--  Start tok_code

Token_Res286 := Row_Pos178;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res286));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Function)
   then
       Token_Pos286 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos178 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos178,
             Expected_Token_Id => Ada_Function,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos286 := Row_Pos178 + 1;
   end if;
end;

--  End tok_code




if Token_Pos286 /= No_Token_Index then

   Row_Pos178 := Token_Pos286;

else
   Row_Pos178 := No_Token_Index;
   goto Exit_Row178_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row178_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos178 /= No_Token_Index then

   Transform_Res121 := Allocate_Subp_Kind_Function (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res121,
      Kind => Ada_Subp_Kind_Function,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos176,
      Token_End_Index   => (if Row_Pos178 = Row_Pos176
                            then No_Token_Index
                            else Row_Pos178 - 1));




elsif Row_Pos178 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags121);
end if;

--  End transform_code

    if Row_Pos178 /= No_Token_Index then
        Or_Pos65 := Row_Pos178;
        Or_Res65 := Transform_Res121;
        goto Exit_Or67;
    end if;
<<Exit_Or67>>

--  End or_code



Row_Progress16 := 2;

if Or_Pos65 /= No_Token_Index then

   Row_Pos176 := Or_Pos65;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


Defer_Res290 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos176);
Defer_Pos290 := Parser.Current_Pos;



Row_Progress16 := 3;

if Defer_Pos290 /= No_Token_Index then

   Row_Pos176 := Defer_Pos290;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


--  Start tok_code

Token_Res287 := Row_Pos176;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res287));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos287 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos176 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos176,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos287 := Row_Pos176 + 1;
   end if;
end;

--  End tok_code



Row_Progress16 := 4;

if Token_Pos287 /= No_Token_Index then

   Row_Pos176 := Token_Pos287;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


--  Start tok_code

Token_Res288 := Row_Pos176;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res288));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos288 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos176 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos176,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos288 := Row_Pos176 + 1;
   end if;
end;

--  End tok_code



Row_Progress16 := 5;

if Token_Pos288 /= No_Token_Index then

   Row_Pos176 := Token_Pos288;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;

Nobt18 := True;

   Nobt18 := Nobt18;

Row_Progress16 := 6;

if Row_Pos176 /= No_Token_Index then

   Row_Pos176 := Row_Pos176;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


Defer_Res291 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos176);
Defer_Pos291 := Parser.Current_Pos;



Row_Progress16 := 7;

if Defer_Pos291 /= No_Token_Index then

   Row_Pos176 := Defer_Pos291;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos179 := Row_Pos176;



--  Start tok_code

Token_Res289 := Row_Pos179;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res289));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos289 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos179 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos179,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos289 := Row_Pos179 + 1;
   end if;
end;

--  End tok_code




if Token_Pos289 /= No_Token_Index then

   Row_Pos179 := Token_Pos289;

else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;

end if;

Nobt19 := True;

   Nobt19 := Nobt19;


if Row_Pos179 /= No_Token_Index then

   Row_Pos179 := Row_Pos179;

else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;

end if;


--  Start list_code

    List_Pos31 := No_Token_Index;



Lst_Cpos31 := Row_Pos179;
Tmp_List31 := Get_Parse_List (Parser);

loop
   
Defer_Res292 :=
   Param_Assoc_Transform_Parse0 (Parser, Lst_Cpos31);
Defer_Pos292 := Parser.Current_Pos;


   exit when Defer_Pos292 = No_Token_Index;

   List_Pos31 := Defer_Pos292;
   Lst_Cpos31 := List_Pos31;

   Tmp_List31.Nodes.Append (Defer_Res292);

      
--  Start tok_code

Token_Res290 := Lst_Cpos31;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res290));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos290 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos31 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos31,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos290 := Lst_Cpos31 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos290 /= No_Token_Index then
          Lst_Cpos31 := Token_Pos290;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List31.Nodes.Length;
begin
   List_Res31 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos179;
      Token_End := (if Lst_Cpos31 = Row_Pos179
                    then Row_Pos179
                    else Lst_Cpos31 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos179, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res31,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res31,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List31.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res31.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List31);

--  End list_code




if List_Pos31 /= No_Token_Index then

   Row_Pos179 := List_Pos31;

else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;

end if;


--  Start tok_code

Token_Res291 := Row_Pos179;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res291));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos291 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos179 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos179,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos291 := Row_Pos179 + 1;
   end if;
end;

--  End tok_code




if Token_Pos291 /= No_Token_Index then

   Row_Pos179 := Token_Pos291;

else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row179_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos179 = No_Token_Index then

         
   if Nobt19 then
      Row_Pos179 := Parser.Last_Fail.Pos;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Row_Pos179)),
              To_Text ("Cannot parse <generic_instantiation>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;


         if List_Res31 = No_Bare_Ada_Node then
            
   List_Res31 :=
     Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => List_Res31,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos176 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => List_Res31,
      Parser => Parser,
      Count  => 0);

         end if;


       if not Nobt19 then
          
   Row_Pos179 := Row_Pos176;

       end if;


end if;

--  End opt_code


   Nobt18 := Nobt19;

Row_Progress16 := 8;

if Row_Pos179 /= No_Token_Index then

   Row_Pos176 := Row_Pos179;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


Defer_Res293 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos176);
Defer_Pos293 := Parser.Current_Pos;



Row_Progress16 := 9;

if Defer_Pos293 /= No_Token_Index then

   Row_Pos176 := Defer_Pos293;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res292 := Row_Pos176;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res292));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos292 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos176 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos176,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos292 := Row_Pos176 + 1;
   end if;
end;

--  End tok_code


if Token_Pos292 = No_Token_Index then

         
   Token_Res292 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos176)),
                To_Text ("Missing ';'"));

       
   Token_Pos292 := Row_Pos176;



end if;

--  End opt_code



Row_Progress16 := 10;

if Token_Pos292 /= No_Token_Index then

   Row_Pos176 := Token_Pos292;

else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row176_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos176 = No_Token_Index and then Nobt18 then

   Row_Pos176 := Parser.Last_Fail.Pos;

   Transform_Has_Failed16 := True;
end if;

if Row_Pos176 /= No_Token_Index then

   Transform_Res122 := Allocate_Generic_Subp_Instantiation (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res122,
      Kind => Ada_Generic_Subp_Instantiation,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos176 = Pos
                            then No_Token_Index
                            else Row_Pos176 - 1));

      Initialize_Fields_For_Generic_Subp_Instantiation
        (Self => Transform_Res122, Generic_Subp_Instantiation_F_Overriding => Defer_Res289, Generic_Subp_Instantiation_F_Kind => Or_Res65, Generic_Subp_Instantiation_F_Subp_Name => Defer_Res290, Generic_Subp_Instantiation_F_Generic_Subp_Name => Defer_Res291, Generic_Subp_Instantiation_F_Params => List_Res31, Generic_Subp_Instantiation_F_Aspects => Defer_Res293);

         if Defer_Res289 /= null and then Is_Incomplete (Defer_Res289) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res289 /= null and then not Is_Ghost (Defer_Res289) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if Or_Res65 /= null and then Is_Incomplete (Or_Res65) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Or_Res65 /= null and then not Is_Ghost (Or_Res65) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res290 /= null and then Is_Incomplete (Defer_Res290) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res290 /= null and then not Is_Ghost (Defer_Res290) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res291 /= null and then Is_Incomplete (Defer_Res291) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res291 /= null and then not Is_Ghost (Defer_Res291) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if List_Res31 /= null and then Is_Incomplete (List_Res31) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif List_Res31 /= null and then not Is_Ghost (List_Res31) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res293 /= null and then Is_Incomplete (Defer_Res293) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res293 /= null and then not Is_Ghost (Defer_Res293) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed16 then
      Transform_Res122.Last_Attempted_Child :=
         Row_Progress16;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <generic_instantiation>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos176 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags122);
end if;

--  End transform_code

    if Row_Pos176 /= No_Token_Index then
        Or_Pos66 := Row_Pos176;
        Or_Res66 := Transform_Res122;
        goto Exit_Or66;
    end if;
<<Exit_Or66>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Generic_Instantiation_Or_Parse1_Memo,
      Or_Pos66 /= No_Token_Index,
      Or_Res66,
      Pos,
      Or_Pos66);


   Parser.Current_Pos := Or_Pos66;

   Exit_Call (Parser, Call_Depth);
   return Or_Res66;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Generic_Instantiation_Or_Parse1;

   


function Generic_Renaming_Decl_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Renaming_Decl
is
   use Bare_Generic_Renaming_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos180 :
            Token_Index
               := No_Token_Index;
      Token_Pos293 :
            Token_Index
               := No_Token_Index;
      Token_Res293 :
            Token_Index
               := No_Token_Index;
      Token_Pos294 :
            Token_Index
               := No_Token_Index;
      Token_Res294 :
            Token_Index
               := No_Token_Index;
      Defer_Pos294 :
            Token_Index
               := No_Token_Index;
      Defer_Res294 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos295 :
            Token_Index
               := No_Token_Index;
      Token_Res295 :
            Token_Index
               := No_Token_Index;
      Defer_Pos295 :
            Token_Index
               := No_Token_Index;
      Defer_Res295 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos296 :
            Token_Index
               := No_Token_Index;
      Defer_Res296 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos296 :
            Token_Index
               := No_Token_Index;
      Token_Res296 :
            Token_Index
               := No_Token_Index;
      Transform_Res123 :
            Bare_Generic_Package_Renaming_Decl
               := No_Bare_Ada_Node;
      Transform_Diags123 :
            Ada.Containers.Count_Type;
      Row_Pos181 :
            Token_Index
               := No_Token_Index;
      Token_Pos297 :
            Token_Index
               := No_Token_Index;
      Token_Res297 :
            Token_Index
               := No_Token_Index;
      Row_Pos182 :
            Token_Index
               := No_Token_Index;
      Token_Pos298 :
            Token_Index
               := No_Token_Index;
      Token_Res298 :
            Token_Index
               := No_Token_Index;
      Transform_Res124 :
            Bare_Subp_Kind_Procedure
               := No_Bare_Ada_Node;
      Transform_Diags124 :
            Ada.Containers.Count_Type;
      Row_Pos183 :
            Token_Index
               := No_Token_Index;
      Token_Pos299 :
            Token_Index
               := No_Token_Index;
      Token_Res299 :
            Token_Index
               := No_Token_Index;
      Transform_Res125 :
            Bare_Subp_Kind_Function
               := No_Bare_Ada_Node;
      Transform_Diags125 :
            Ada.Containers.Count_Type;
      Or_Pos67 :
            Token_Index
               := No_Token_Index;
      Or_Res67 :
            Bare_Subp_Kind
               := No_Bare_Ada_Node;
      Defer_Pos297 :
            Token_Index
               := No_Token_Index;
      Defer_Res297 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos300 :
            Token_Index
               := No_Token_Index;
      Token_Res300 :
            Token_Index
               := No_Token_Index;
      Defer_Pos298 :
            Token_Index
               := No_Token_Index;
      Defer_Res298 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos299 :
            Token_Index
               := No_Token_Index;
      Defer_Res299 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos301 :
            Token_Index
               := No_Token_Index;
      Token_Res301 :
            Token_Index
               := No_Token_Index;
      Transform_Res126 :
            Bare_Generic_Subp_Renaming_Decl
               := No_Bare_Ada_Node;
      Transform_Diags126 :
            Ada.Containers.Count_Type;
      Or_Pos68 :
            Token_Index
               := No_Token_Index;
      Or_Res68 :
            Bare_Generic_Renaming_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Generic_Renaming_Decl_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res68 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res68;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res68;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos68 := No_Token_Index;
Or_Res68 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags123 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos180 := Pos;



--  Start tok_code

Token_Res293 := Row_Pos180;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res293));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Generic)
   then
       Token_Pos293 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos180 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos180,
             Expected_Token_Id => Ada_Generic,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos293 := Row_Pos180 + 1;
   end if;
end;

--  End tok_code




if Token_Pos293 /= No_Token_Index then

   Row_Pos180 := Token_Pos293;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;


--  Start tok_code

Token_Res294 := Row_Pos180;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res294));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos294 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos180 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos180,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos294 := Row_Pos180 + 1;
   end if;
end;

--  End tok_code




if Token_Pos294 /= No_Token_Index then

   Row_Pos180 := Token_Pos294;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;


Defer_Res294 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos180);
Defer_Pos294 := Parser.Current_Pos;




if Defer_Pos294 /= No_Token_Index then

   Row_Pos180 := Defer_Pos294;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;


--  Start tok_code

Token_Res295 := Row_Pos180;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res295));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Renames)
   then
       Token_Pos295 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos180 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos180,
             Expected_Token_Id => Ada_Renames,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos295 := Row_Pos180 + 1;
   end if;
end;

--  End tok_code




if Token_Pos295 /= No_Token_Index then

   Row_Pos180 := Token_Pos295;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;


Defer_Res295 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos180);
Defer_Pos295 := Parser.Current_Pos;




if Defer_Pos295 /= No_Token_Index then

   Row_Pos180 := Defer_Pos295;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;


Defer_Res296 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos180);
Defer_Pos296 := Parser.Current_Pos;




if Defer_Pos296 /= No_Token_Index then

   Row_Pos180 := Defer_Pos296;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;


--  Start tok_code

Token_Res296 := Row_Pos180;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res296));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos296 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos180 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos180,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos296 := Row_Pos180 + 1;
   end if;
end;

--  End tok_code




if Token_Pos296 /= No_Token_Index then

   Row_Pos180 := Token_Pos296;

else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row180_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos180 /= No_Token_Index then

   Transform_Res123 := Allocate_Generic_Package_Renaming_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res123,
      Kind => Ada_Generic_Package_Renaming_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos180 = Pos
                            then No_Token_Index
                            else Row_Pos180 - 1));

      Initialize_Fields_For_Generic_Package_Renaming_Decl
        (Self => Transform_Res123, Generic_Package_Renaming_Decl_F_Name => Defer_Res294, Generic_Package_Renaming_Decl_F_Renames => Defer_Res295, Generic_Package_Renaming_Decl_F_Aspects => Defer_Res296);

         if Defer_Res294 /= null and then Is_Incomplete (Defer_Res294) then
            Transform_Res123.Last_Attempted_Child := 0;
         elsif Defer_Res294 /= null and then not Is_Ghost (Defer_Res294) then
            Transform_Res123.Last_Attempted_Child := -1;
         end if;
         if Defer_Res295 /= null and then Is_Incomplete (Defer_Res295) then
            Transform_Res123.Last_Attempted_Child := 0;
         elsif Defer_Res295 /= null and then not Is_Ghost (Defer_Res295) then
            Transform_Res123.Last_Attempted_Child := -1;
         end if;
         if Defer_Res296 /= null and then Is_Incomplete (Defer_Res296) then
            Transform_Res123.Last_Attempted_Child := 0;
         elsif Defer_Res296 /= null and then not Is_Ghost (Defer_Res296) then
            Transform_Res123.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos180 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags123);
end if;

--  End transform_code

    if Row_Pos180 /= No_Token_Index then
        Or_Pos68 := Row_Pos180;
        Or_Res68 := Transform_Res123;
        goto Exit_Or68;
    end if;
    
--  Start transform_code

Transform_Diags126 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos181 := Pos;



--  Start tok_code

Token_Res297 := Row_Pos181;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res297));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Generic)
   then
       Token_Pos297 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos181 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos181,
             Expected_Token_Id => Ada_Generic,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos297 := Row_Pos181 + 1;
   end if;
end;

--  End tok_code




if Token_Pos297 /= No_Token_Index then

   Row_Pos181 := Token_Pos297;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;


--  Start or_code

Or_Pos67 := No_Token_Index;
Or_Res67 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags124 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos182 := Row_Pos181;



--  Start tok_code

Token_Res298 := Row_Pos182;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res298));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Procedure)
   then
       Token_Pos298 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos182 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos182,
             Expected_Token_Id => Ada_Procedure,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos298 := Row_Pos182 + 1;
   end if;
end;

--  End tok_code




if Token_Pos298 /= No_Token_Index then

   Row_Pos182 := Token_Pos298;

else
   Row_Pos182 := No_Token_Index;
   goto Exit_Row182_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row182_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos182 /= No_Token_Index then

   Transform_Res124 := Allocate_Subp_Kind_Procedure (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res124,
      Kind => Ada_Subp_Kind_Procedure,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos181,
      Token_End_Index   => (if Row_Pos182 = Row_Pos181
                            then No_Token_Index
                            else Row_Pos182 - 1));




elsif Row_Pos182 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags124);
end if;

--  End transform_code

    if Row_Pos182 /= No_Token_Index then
        Or_Pos67 := Row_Pos182;
        Or_Res67 := Transform_Res124;
        goto Exit_Or69;
    end if;
    
--  Start transform_code

Transform_Diags125 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos183 := Row_Pos181;



--  Start tok_code

Token_Res299 := Row_Pos183;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res299));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Function)
   then
       Token_Pos299 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos183 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos183,
             Expected_Token_Id => Ada_Function,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos299 := Row_Pos183 + 1;
   end if;
end;

--  End tok_code




if Token_Pos299 /= No_Token_Index then

   Row_Pos183 := Token_Pos299;

else
   Row_Pos183 := No_Token_Index;
   goto Exit_Row183_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row183_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos183 /= No_Token_Index then

   Transform_Res125 := Allocate_Subp_Kind_Function (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res125,
      Kind => Ada_Subp_Kind_Function,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos181,
      Token_End_Index   => (if Row_Pos183 = Row_Pos181
                            then No_Token_Index
                            else Row_Pos183 - 1));




elsif Row_Pos183 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags125);
end if;

--  End transform_code

    if Row_Pos183 /= No_Token_Index then
        Or_Pos67 := Row_Pos183;
        Or_Res67 := Transform_Res125;
        goto Exit_Or69;
    end if;
<<Exit_Or69>>

--  End or_code




if Or_Pos67 /= No_Token_Index then

   Row_Pos181 := Or_Pos67;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;


Defer_Res297 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos181);
Defer_Pos297 := Parser.Current_Pos;




if Defer_Pos297 /= No_Token_Index then

   Row_Pos181 := Defer_Pos297;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;


--  Start tok_code

Token_Res300 := Row_Pos181;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res300));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Renames)
   then
       Token_Pos300 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos181 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos181,
             Expected_Token_Id => Ada_Renames,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos300 := Row_Pos181 + 1;
   end if;
end;

--  End tok_code




if Token_Pos300 /= No_Token_Index then

   Row_Pos181 := Token_Pos300;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;


Defer_Res298 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos181);
Defer_Pos298 := Parser.Current_Pos;




if Defer_Pos298 /= No_Token_Index then

   Row_Pos181 := Defer_Pos298;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;


Defer_Res299 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos181);
Defer_Pos299 := Parser.Current_Pos;




if Defer_Pos299 /= No_Token_Index then

   Row_Pos181 := Defer_Pos299;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;


--  Start tok_code

Token_Res301 := Row_Pos181;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res301));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos301 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos181 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos181,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos301 := Row_Pos181 + 1;
   end if;
end;

--  End tok_code




if Token_Pos301 /= No_Token_Index then

   Row_Pos181 := Token_Pos301;

else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row181_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos181 /= No_Token_Index then

   Transform_Res126 := Allocate_Generic_Subp_Renaming_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res126,
      Kind => Ada_Generic_Subp_Renaming_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos181 = Pos
                            then No_Token_Index
                            else Row_Pos181 - 1));

      Initialize_Fields_For_Generic_Subp_Renaming_Decl
        (Self => Transform_Res126, Generic_Subp_Renaming_Decl_F_Kind => Or_Res67, Generic_Subp_Renaming_Decl_F_Name => Defer_Res297, Generic_Subp_Renaming_Decl_F_Renames => Defer_Res298, Generic_Subp_Renaming_Decl_F_Aspects => Defer_Res299);

         if Or_Res67 /= null and then Is_Incomplete (Or_Res67) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Or_Res67 /= null and then not Is_Ghost (Or_Res67) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res297 /= null and then Is_Incomplete (Defer_Res297) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res297 /= null and then not Is_Ghost (Defer_Res297) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res298 /= null and then Is_Incomplete (Defer_Res298) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res298 /= null and then not Is_Ghost (Defer_Res298) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res299 /= null and then Is_Incomplete (Defer_Res299) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res299 /= null and then not Is_Ghost (Defer_Res299) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos181 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags126);
end if;

--  End transform_code

    if Row_Pos181 /= No_Token_Index then
        Or_Pos68 := Row_Pos181;
        Or_Res68 := Transform_Res126;
        goto Exit_Or68;
    end if;
<<Exit_Or68>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Generic_Renaming_Decl_Or_Parse1_Memo,
      Or_Pos68 /= No_Token_Index,
      Or_Res68,
      Pos,
      Or_Pos68);


   Parser.Current_Pos := Or_Pos68;

   Exit_Call (Parser, Call_Depth);
   return Or_Res68;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Generic_Renaming_Decl_Or_Parse1;

   


function Goto_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Goto_Stmt
is
   use Bare_Goto_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt20 :
            Boolean
               := False;
      Row_Pos184 :
            Token_Index
               := No_Token_Index;
      Token_Pos302 :
            Token_Index
               := No_Token_Index;
      Token_Res302 :
            Token_Index
               := No_Token_Index;
      Defer_Pos300 :
            Token_Index
               := No_Token_Index;
      Defer_Res300 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos303 :
            Token_Index
               := No_Token_Index;
      Token_Res303 :
            Token_Index
               := No_Token_Index;
      Row_Progress17 :
            Integer
               := 0;
      Transform_Res127 :
            Bare_Goto_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed17 :
            Boolean
               := False;
      Transform_Diags127 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Goto_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res127 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res127;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res127;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags127 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos184 := Pos;



--  Start tok_code

Token_Res302 := Row_Pos184;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res302));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Goto)
   then
       Token_Pos302 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos184 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos184,
             Expected_Token_Id => Ada_Goto,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos302 := Row_Pos184 + 1;
   end if;
end;

--  End tok_code



Row_Progress17 := 1;

if Token_Pos302 /= No_Token_Index then

   Row_Pos184 := Token_Pos302;

else
   Row_Pos184 := No_Token_Index;
   goto Exit_Row184_0;

end if;

Nobt20 := True;

   Nobt20 := Nobt20;

Row_Progress17 := 2;

if Row_Pos184 /= No_Token_Index then

   Row_Pos184 := Row_Pos184;

else
   Row_Pos184 := No_Token_Index;
   goto Exit_Row184_0;

end if;


Defer_Res300 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos184);
Defer_Pos300 := Parser.Current_Pos;



Row_Progress17 := 3;

if Defer_Pos300 /= No_Token_Index then

   Row_Pos184 := Defer_Pos300;

else
   Row_Pos184 := No_Token_Index;
   goto Exit_Row184_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res303 := Row_Pos184;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res303));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos303 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos184 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos184,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos303 := Row_Pos184 + 1;
   end if;
end;

--  End tok_code


if Token_Pos303 = No_Token_Index then

         
   Token_Res303 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos184)),
                To_Text ("Missing ';'"));

       
   Token_Pos303 := Row_Pos184;



end if;

--  End opt_code



Row_Progress17 := 4;

if Token_Pos303 /= No_Token_Index then

   Row_Pos184 := Token_Pos303;

else
   Row_Pos184 := No_Token_Index;
   goto Exit_Row184_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row184_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos184 = No_Token_Index and then Nobt20 then

   Row_Pos184 := Parser.Last_Fail.Pos;

   Transform_Has_Failed17 := True;
end if;

if Row_Pos184 /= No_Token_Index then

   Transform_Res127 := Allocate_Goto_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res127,
      Kind => Ada_Goto_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos184 = Pos
                            then No_Token_Index
                            else Row_Pos184 - 1));

      Initialize_Fields_For_Goto_Stmt
        (Self => Transform_Res127, Goto_Stmt_F_Label_Name => Defer_Res300);

         if Defer_Res300 /= null and then Is_Incomplete (Defer_Res300) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif Defer_Res300 /= null and then not Is_Ghost (Defer_Res300) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed17 then
      Transform_Res127.Last_Attempted_Child :=
         Row_Progress17;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <goto_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos184 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags127);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Goto_Stmt_Transform_Parse0_Memo,
      Row_Pos184 /= No_Token_Index,
      Transform_Res127,
      Pos,
      Row_Pos184);


   Parser.Current_Pos := Row_Pos184;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res127;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Goto_Stmt_Transform_Parse0;

   


function Handled_Stmts_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Handled_Stmts
is
   use Bare_Handled_Stmts_Memos;

   Call_Depth : aliased Natural;

      Row_Pos185 :
            Token_Index
               := No_Token_Index;
      Defer_Pos301 :
            Token_Index
               := No_Token_Index;
      Defer_Res301 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Row_Pos186 :
            Token_Index
               := No_Token_Index;
      Token_Pos304 :
            Token_Index
               := No_Token_Index;
      Token_Res304 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos32 :
            Token_Index
               := No_Token_Index;
      Tmp_List32 :
            Free_Parse_List;
      Defer_Pos302 :
            Token_Index
               := No_Token_Index;
      Defer_Res302 :
            Bare_Exception_Handler
               := No_Bare_Ada_Node;
      Defer_Pos303 :
            Token_Index
               := No_Token_Index;
      Defer_Res303 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos69 :
            Token_Index
               := No_Token_Index;
      Or_Res69 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos32 :
            Token_Index
               := No_Token_Index;
      List_Res32 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res128 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Transform_Diags128 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Handled_Stmts_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res128 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res128;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res128;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags128 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos185 := Pos;



        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Handled_Stmts0_Extract_Parse0'Access);
        
Defer_Res301 :=
   Stmts_List_Parse0 (Parser, Row_Pos185);
Defer_Pos301 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos301 /= No_Token_Index then

   Row_Pos185 := Defer_Pos301;

else
   Row_Pos185 := No_Token_Index;
   goto Exit_Row185_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos186 := Row_Pos185;



--  Start tok_code

Token_Res304 := Row_Pos186;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res304));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Exception)
   then
       Token_Pos304 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos186 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos186,
             Expected_Token_Id => Ada_Exception,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos304 := Row_Pos186 + 1;
   end if;
end;

--  End tok_code




if Token_Pos304 /= No_Token_Index then

   Row_Pos186 := Token_Pos304;

else
   Row_Pos186 := No_Token_Index;
   goto Exit_Row186_0;

end if;


--  Start list_code

    List_Pos32 := No_Token_Index;



Lst_Cpos32 := Row_Pos186;
Tmp_List32 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos69 := No_Token_Index;
Or_Res69 := No_Bare_Ada_Node;
    
Defer_Res302 :=
   Exception_Handler_Transform_Parse0 (Parser, Lst_Cpos32);
Defer_Pos302 := Parser.Current_Pos;

    if Defer_Pos302 /= No_Token_Index then
        Or_Pos69 := Defer_Pos302;
        Or_Res69 := Defer_Res302;
        goto Exit_Or70;
    end if;
    
Defer_Res303 :=
   Pragma_Transform_Parse0 (Parser, Lst_Cpos32);
Defer_Pos303 := Parser.Current_Pos;

    if Defer_Pos303 /= No_Token_Index then
        Or_Pos69 := Defer_Pos303;
        Or_Res69 := Defer_Res303;
        goto Exit_Or70;
    end if;
<<Exit_Or70>>

--  End or_code


   exit when Or_Pos69 = No_Token_Index;

   List_Pos32 := Or_Pos69;
   Lst_Cpos32 := List_Pos32;

   Tmp_List32.Nodes.Append (Or_Res69);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List32.Nodes.Length;
begin
   List_Res32 :=
      Allocate_Ada_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos186;
      Token_End := (if Lst_Cpos32 = Row_Pos186
                    then Row_Pos186
                    else Lst_Cpos32 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos186, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res32,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res32,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List32.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res32.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List32);

--  End list_code




if List_Pos32 /= No_Token_Index then

   Row_Pos186 := List_Pos32;

else
   Row_Pos186 := No_Token_Index;
   goto Exit_Row186_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row186_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos186 = No_Token_Index then

         
   List_Res32 :=
     Allocate_Ada_Node_List (Parser.Mem_Pool);
   Initialize
     (Self              => List_Res32,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos185 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => List_Res32,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos186 := Row_Pos185;



end if;

--  End opt_code




if Row_Pos186 /= No_Token_Index then

   Row_Pos185 := Row_Pos186;

else
   Row_Pos185 := No_Token_Index;
   goto Exit_Row185_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row185_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos185 /= No_Token_Index then

   Transform_Res128 := Allocate_Handled_Stmts (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res128,
      Kind => Ada_Handled_Stmts,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos185 = Pos
                            then No_Token_Index
                            else Row_Pos185 - 1));

      Initialize_Fields_For_Handled_Stmts
        (Self => Transform_Res128, Handled_Stmts_F_Stmts => Defer_Res301, Handled_Stmts_F_Exceptions => List_Res32);

         if Defer_Res301 /= null and then Is_Incomplete (Defer_Res301) then
            Transform_Res128.Last_Attempted_Child := 0;
         elsif Defer_Res301 /= null and then not Is_Ghost (Defer_Res301) then
            Transform_Res128.Last_Attempted_Child := -1;
         end if;
         if List_Res32 /= null and then Is_Incomplete (List_Res32) then
            Transform_Res128.Last_Attempted_Child := 0;
         elsif List_Res32 /= null and then not Is_Ghost (List_Res32) then
            Transform_Res128.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos185 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags128);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Handled_Stmts_Transform_Parse0_Memo,
      Row_Pos185 /= No_Token_Index,
      Transform_Res128,
      Pos,
      Row_Pos185);


   Parser.Current_Pos := Row_Pos185;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res128;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Handled_Stmts_Transform_Parse0;

   


function Iblock_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_Stmt
is
   use Bare_Block_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt21 :
            Boolean
               := False;
      Nobt22 :
            Boolean
               := False;
      Row_Pos187 :
            Token_Index
               := No_Token_Index;
      Token_Pos305 :
            Token_Index
               := No_Token_Index;
      Token_Res305 :
            Token_Index
               := No_Token_Index;
      Defer_Pos304 :
            Token_Index
               := No_Token_Index;
      Defer_Res304 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos188 :
            Token_Index
               := No_Token_Index;
      Token_Pos306 :
            Token_Index
               := No_Token_Index;
      Token_Res306 :
            Token_Index
               := No_Token_Index;
      Row_Pos189 :
            Token_Index
               := No_Token_Index;
      Defer_Pos305 :
            Token_Index
               := No_Token_Index;
      Defer_Res305 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res129 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags129 :
            Ada.Containers.Count_Type;
      Token_Pos307 :
            Token_Index
               := No_Token_Index;
      Token_Res307 :
            Token_Index
               := No_Token_Index;
      Row_Progress18 :
            Integer
               := 0;
      Transform_Res130 :
            Bare_Begin_Block
               := No_Bare_Ada_Node;
      Transform_Has_Failed18 :
            Boolean
               := False;
      Transform_Diags130 :
            Ada.Containers.Count_Type;
      Row_Pos190 :
            Token_Index
               := No_Token_Index;
      Token_Pos308 :
            Token_Index
               := No_Token_Index;
      Token_Res308 :
            Token_Index
               := No_Token_Index;
      Defer_Pos306 :
            Token_Index
               := No_Token_Index;
      Defer_Res306 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Token_Pos309 :
            Token_Index
               := No_Token_Index;
      Token_Res309 :
            Token_Index
               := No_Token_Index;
      Defer_Pos307 :
            Token_Index
               := No_Token_Index;
      Defer_Res307 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos191 :
            Token_Index
               := No_Token_Index;
      Token_Pos310 :
            Token_Index
               := No_Token_Index;
      Token_Res310 :
            Token_Index
               := No_Token_Index;
      Row_Pos192 :
            Token_Index
               := No_Token_Index;
      Defer_Pos308 :
            Token_Index
               := No_Token_Index;
      Defer_Res308 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res131 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags131 :
            Ada.Containers.Count_Type;
      Token_Pos311 :
            Token_Index
               := No_Token_Index;
      Token_Res311 :
            Token_Index
               := No_Token_Index;
      Row_Progress19 :
            Integer
               := 0;
      Transform_Res132 :
            Bare_Decl_Block
               := No_Bare_Ada_Node;
      Transform_Has_Failed19 :
            Boolean
               := False;
      Transform_Diags132 :
            Ada.Containers.Count_Type;
      Or_Pos70 :
            Token_Index
               := No_Token_Index;
      Or_Res70 :
            Bare_Block_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Iblock_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res70 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res70;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res70;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos70 := No_Token_Index;
Or_Res70 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags130 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos187 := Pos;



--  Start tok_code

Token_Res305 := Row_Pos187;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res305));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos305 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos187 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos187,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos305 := Row_Pos187 + 1;
   end if;
end;

--  End tok_code



Row_Progress18 := 1;

if Token_Pos305 /= No_Token_Index then

   Row_Pos187 := Token_Pos305;

else
   Row_Pos187 := No_Token_Index;
   goto Exit_Row187_0;

end if;

Nobt21 := True;

   Nobt21 := Nobt21;

Row_Progress18 := 2;

if Row_Pos187 /= No_Token_Index then

   Row_Pos187 := Row_Pos187;

else
   Row_Pos187 := No_Token_Index;
   goto Exit_Row187_0;

end if;


Defer_Res304 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos187);
Defer_Pos304 := Parser.Current_Pos;



Row_Progress18 := 3;

if Defer_Pos304 /= No_Token_Index then

   Row_Pos187 := Defer_Pos304;

else
   Row_Pos187 := No_Token_Index;
   goto Exit_Row187_0;

end if;


--  Start row_code

Row_Pos188 := Row_Pos187;



--  Start tok_code

Token_Res306 := Row_Pos188;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res306));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos306 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos188 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos188,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos306 := Row_Pos188 + 1;
   end if;
end;

--  End tok_code




if Token_Pos306 /= No_Token_Index then

   Row_Pos188 := Token_Pos306;

else
   Row_Pos188 := No_Token_Index;
   goto Exit_Row188_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags129 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos189 := Row_Pos188;



Defer_Res305 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos189);
Defer_Pos305 := Parser.Current_Pos;




if Defer_Pos305 /= No_Token_Index then

   Row_Pos189 := Defer_Pos305;

else
   Row_Pos189 := No_Token_Index;
   goto Exit_Row189_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row189_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos189 /= No_Token_Index then

   Transform_Res129 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res129,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos188,
      Token_End_Index   => (if Row_Pos189 = Row_Pos188
                            then No_Token_Index
                            else Row_Pos189 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res129, End_Name_F_Name => Defer_Res305);

         if Defer_Res305 /= null and then Is_Incomplete (Defer_Res305) then
            Transform_Res129.Last_Attempted_Child := 0;
         elsif Defer_Res305 /= null and then not Is_Ghost (Defer_Res305) then
            Transform_Res129.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos189 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags129);
end if;

--  End transform_code


if Row_Pos189 = No_Token_Index then

         
   Transform_Res129 := No_Bare_Ada_Node;



       
   Row_Pos189 := Row_Pos188;



end if;

--  End opt_code




if Row_Pos189 /= No_Token_Index then

   Row_Pos188 := Row_Pos189;

else
   Row_Pos188 := No_Token_Index;
   goto Exit_Row188_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row188_0>>
pragma Warnings (On, "referenced");

--  End row_code



Row_Progress18 := 4;

if Row_Pos188 /= No_Token_Index then

   Row_Pos187 := Row_Pos188;

else
   Row_Pos187 := No_Token_Index;
   goto Exit_Row187_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res307 := Row_Pos187;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res307));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos307 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos187 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos187,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos307 := Row_Pos187 + 1;
   end if;
end;

--  End tok_code


if Token_Pos307 = No_Token_Index then

         
   Token_Res307 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos187)),
                To_Text ("Missing ';'"));

       
   Token_Pos307 := Row_Pos187;



end if;

--  End opt_code



Row_Progress18 := 5;

if Token_Pos307 /= No_Token_Index then

   Row_Pos187 := Token_Pos307;

else
   Row_Pos187 := No_Token_Index;
   goto Exit_Row187_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row187_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos187 = No_Token_Index and then Nobt21 then

   Row_Pos187 := Parser.Last_Fail.Pos;

   Transform_Has_Failed18 := True;
end if;

if Row_Pos187 /= No_Token_Index then

   Transform_Res130 := Allocate_Begin_Block (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res130,
      Kind => Ada_Begin_Block,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos187 = Pos
                            then No_Token_Index
                            else Row_Pos187 - 1));

      Initialize_Fields_For_Begin_Block
        (Self => Transform_Res130, Begin_Block_F_Stmts => Defer_Res304, Begin_Block_F_End_Name => Transform_Res129);

         if Defer_Res304 /= null and then Is_Incomplete (Defer_Res304) then
            Transform_Res130.Last_Attempted_Child := 0;
         elsif Defer_Res304 /= null and then not Is_Ghost (Defer_Res304) then
            Transform_Res130.Last_Attempted_Child := -1;
         end if;
         if Transform_Res129 /= null and then Is_Incomplete (Transform_Res129) then
            Transform_Res130.Last_Attempted_Child := 0;
         elsif Transform_Res129 /= null and then not Is_Ghost (Transform_Res129) then
            Transform_Res130.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed18 then
      Transform_Res130.Last_Attempted_Child :=
         Row_Progress18;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <iblock_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos187 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags130);
end if;

--  End transform_code

    if Row_Pos187 /= No_Token_Index then
        Or_Pos70 := Row_Pos187;
        Or_Res70 := Transform_Res130;
        goto Exit_Or71;
    end if;
    
--  Start transform_code

Transform_Diags132 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos190 := Pos;



--  Start tok_code

Token_Res308 := Row_Pos190;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res308));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Declare)
   then
       Token_Pos308 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos190 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos190,
             Expected_Token_Id => Ada_Declare,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos308 := Row_Pos190 + 1;
   end if;
end;

--  End tok_code



Row_Progress19 := 1;

if Token_Pos308 /= No_Token_Index then

   Row_Pos190 := Token_Pos308;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;

Nobt22 := True;

   Nobt22 := Nobt22;

Row_Progress19 := 2;

if Row_Pos190 /= No_Token_Index then

   Row_Pos190 := Row_Pos190;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;


Defer_Res306 :=
   Recov_Decl_Part_Dont_Skip_Parse0 (Parser, Row_Pos190);
Defer_Pos306 := Parser.Current_Pos;



Row_Progress19 := 3;

if Defer_Pos306 /= No_Token_Index then

   Row_Pos190 := Defer_Pos306;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;


--  Start tok_code

Token_Res309 := Row_Pos190;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res309));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos309 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos190 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos190,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos309 := Row_Pos190 + 1;
   end if;
end;

--  End tok_code



Row_Progress19 := 4;

if Token_Pos309 /= No_Token_Index then

   Row_Pos190 := Token_Pos309;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;


Defer_Res307 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos190);
Defer_Pos307 := Parser.Current_Pos;



Row_Progress19 := 5;

if Defer_Pos307 /= No_Token_Index then

   Row_Pos190 := Defer_Pos307;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;


--  Start row_code

Row_Pos191 := Row_Pos190;



--  Start tok_code

Token_Res310 := Row_Pos191;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res310));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos310 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos191 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos191,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos310 := Row_Pos191 + 1;
   end if;
end;

--  End tok_code




if Token_Pos310 /= No_Token_Index then

   Row_Pos191 := Token_Pos310;

else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags131 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos192 := Row_Pos191;



Defer_Res308 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos192);
Defer_Pos308 := Parser.Current_Pos;




if Defer_Pos308 /= No_Token_Index then

   Row_Pos192 := Defer_Pos308;

else
   Row_Pos192 := No_Token_Index;
   goto Exit_Row192_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row192_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos192 /= No_Token_Index then

   Transform_Res131 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res131,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos191,
      Token_End_Index   => (if Row_Pos192 = Row_Pos191
                            then No_Token_Index
                            else Row_Pos192 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res131, End_Name_F_Name => Defer_Res308);

         if Defer_Res308 /= null and then Is_Incomplete (Defer_Res308) then
            Transform_Res131.Last_Attempted_Child := 0;
         elsif Defer_Res308 /= null and then not Is_Ghost (Defer_Res308) then
            Transform_Res131.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos192 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags131);
end if;

--  End transform_code


if Row_Pos192 = No_Token_Index then

         
   Transform_Res131 := No_Bare_Ada_Node;



       
   Row_Pos192 := Row_Pos191;



end if;

--  End opt_code




if Row_Pos192 /= No_Token_Index then

   Row_Pos191 := Row_Pos192;

else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row191_0>>
pragma Warnings (On, "referenced");

--  End row_code



Row_Progress19 := 6;

if Row_Pos191 /= No_Token_Index then

   Row_Pos190 := Row_Pos191;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res311 := Row_Pos190;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res311));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos311 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos190 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos190,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos311 := Row_Pos190 + 1;
   end if;
end;

--  End tok_code


if Token_Pos311 = No_Token_Index then

         
   Token_Res311 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos190)),
                To_Text ("Missing ';'"));

       
   Token_Pos311 := Row_Pos190;



end if;

--  End opt_code



Row_Progress19 := 7;

if Token_Pos311 /= No_Token_Index then

   Row_Pos190 := Token_Pos311;

else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row190_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos190 = No_Token_Index and then Nobt22 then

   Row_Pos190 := Parser.Last_Fail.Pos;

   Transform_Has_Failed19 := True;
end if;

if Row_Pos190 /= No_Token_Index then

   Transform_Res132 := Allocate_Decl_Block (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res132,
      Kind => Ada_Decl_Block,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos190 = Pos
                            then No_Token_Index
                            else Row_Pos190 - 1));

      Initialize_Fields_For_Decl_Block
        (Self => Transform_Res132, Decl_Block_F_Decls => Defer_Res306, Decl_Block_F_Stmts => Defer_Res307, Decl_Block_F_End_Name => Transform_Res131);

         if Defer_Res306 /= null and then Is_Incomplete (Defer_Res306) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res306 /= null and then not Is_Ghost (Defer_Res306) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;
         if Defer_Res307 /= null and then Is_Incomplete (Defer_Res307) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res307 /= null and then not Is_Ghost (Defer_Res307) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;
         if Transform_Res131 /= null and then Is_Incomplete (Transform_Res131) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Transform_Res131 /= null and then not Is_Ghost (Transform_Res131) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed19 then
      Transform_Res132.Last_Attempted_Child :=
         Row_Progress19;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <iblock_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos190 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags132);
end if;

--  End transform_code

    if Row_Pos190 /= No_Token_Index then
        Or_Pos70 := Row_Pos190;
        Or_Res70 := Transform_Res132;
        goto Exit_Or71;
    end if;
<<Exit_Or71>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Iblock_Stmt_Or_Parse0_Memo,
      Or_Pos70 /= No_Token_Index,
      Or_Res70,
      Pos,
      Or_Pos70);


   Parser.Current_Pos := Or_Pos70;

   Exit_Call (Parser, Call_Depth);
   return Or_Res70;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Iblock_Stmt_Or_Parse0;

   


function Identifier_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Identifier
is
   use Bare_Identifier_Memos;

   Call_Depth : aliased Natural;

      Row_Pos193 :
            Token_Index
               := No_Token_Index;
      Token_Pos312 :
            Token_Index
               := No_Token_Index;
      Token_Res312 :
            Token_Index
               := No_Token_Index;
      Transform_Res133 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Diags133 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Identifier_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res133 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res133;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res133;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags133 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos193 := Pos;



--  Start tok_code

Token_Res312 := Row_Pos193;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res312));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
   then
       Token_Pos312 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos193 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos193,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos312 := Row_Pos193 + 1;
   end if;
end;

--  End tok_code




if Token_Pos312 /= No_Token_Index then

   Row_Pos193 := Token_Pos312;

else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row193_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos193 /= No_Token_Index then

   Transform_Res133 := Allocate_Identifier (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res133,
      Kind => Ada_Identifier,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos193 = Pos
                            then No_Token_Index
                            else Row_Pos193 - 1));

      Initialize_Fields_For_Identifier
        (Self => Transform_Res133);



elsif Row_Pos193 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags133);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Identifier_Transform_Parse0_Memo,
      Row_Pos193 /= No_Token_Index,
      Transform_Res133,
      Pos,
      Row_Pos193);


   Parser.Current_Pos := Row_Pos193;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res133;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Identifier_Transform_Parse0;

   


function If_Expr_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Expr
is
   use Bare_If_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos194 :
            Token_Index
               := No_Token_Index;
      Token_Pos313 :
            Token_Index
               := No_Token_Index;
      Token_Res313 :
            Token_Index
               := No_Token_Index;
      Defer_Pos309 :
            Token_Index
               := No_Token_Index;
      Defer_Res309 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos314 :
            Token_Index
               := No_Token_Index;
      Token_Res314 :
            Token_Index
               := No_Token_Index;
      Defer_Pos310 :
            Token_Index
               := No_Token_Index;
      Defer_Res310 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Lst_Cpos33 :
            Token_Index
               := No_Token_Index;
      Tmp_List33 :
            Free_Parse_List;
      Row_Pos195 :
            Token_Index
               := No_Token_Index;
      Token_Pos315 :
            Token_Index
               := No_Token_Index;
      Token_Res315 :
            Token_Index
               := No_Token_Index;
      Defer_Pos311 :
            Token_Index
               := No_Token_Index;
      Defer_Res311 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos316 :
            Token_Index
               := No_Token_Index;
      Token_Res316 :
            Token_Index
               := No_Token_Index;
      Defer_Pos312 :
            Token_Index
               := No_Token_Index;
      Defer_Res312 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res134 :
            Bare_Elsif_Expr_Part
               := No_Bare_Ada_Node;
      Transform_Diags134 :
            Ada.Containers.Count_Type;
      List_Pos33 :
            Token_Index
               := No_Token_Index;
      List_Res33 :
            Bare_Elsif_Expr_Part_List
               := No_Bare_Ada_Node;
      Row_Pos196 :
            Token_Index
               := No_Token_Index;
      Token_Pos317 :
            Token_Index
               := No_Token_Index;
      Token_Res317 :
            Token_Index
               := No_Token_Index;
      Defer_Pos313 :
            Token_Index
               := No_Token_Index;
      Defer_Res313 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res135 :
            Bare_If_Expr
               := No_Bare_Ada_Node;
      Transform_Diags135 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.If_Expr_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res135 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res135;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res135;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags135 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos194 := Pos;



--  Start tok_code

Token_Res313 := Row_Pos194;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res313));
begin
   if
      T.Kind /= From_Token_Kind (Ada_If)
   then
       Token_Pos313 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos194 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos194,
             Expected_Token_Id => Ada_If,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos313 := Row_Pos194 + 1;
   end if;
end;

--  End tok_code




if Token_Pos313 /= No_Token_Index then

   Row_Pos194 := Token_Pos313;

else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;

end if;


Defer_Res309 :=
   Expr_Or_Parse0 (Parser, Row_Pos194);
Defer_Pos309 := Parser.Current_Pos;




if Defer_Pos309 /= No_Token_Index then

   Row_Pos194 := Defer_Pos309;

else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;

end if;


--  Start tok_code

Token_Res314 := Row_Pos194;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res314));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos314 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos194 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos194,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos314 := Row_Pos194 + 1;
   end if;
end;

--  End tok_code




if Token_Pos314 /= No_Token_Index then

   Row_Pos194 := Token_Pos314;

else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;

end if;


Defer_Res310 :=
   Expr_Or_Parse0 (Parser, Row_Pos194);
Defer_Pos310 := Parser.Current_Pos;




if Defer_Pos310 /= No_Token_Index then

   Row_Pos194 := Defer_Pos310;

else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;

end if;


--  Start list_code

    List_Pos33 := Row_Pos194;



Lst_Cpos33 := Row_Pos194;
Tmp_List33 := Get_Parse_List (Parser);

loop
   
--  Start transform_code

Transform_Diags134 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos195 := Lst_Cpos33;



--  Start tok_code

Token_Res315 := Row_Pos195;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res315));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Elsif)
   then
       Token_Pos315 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos195 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos195,
             Expected_Token_Id => Ada_Elsif,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos315 := Row_Pos195 + 1;
   end if;
end;

--  End tok_code




if Token_Pos315 /= No_Token_Index then

   Row_Pos195 := Token_Pos315;

else
   Row_Pos195 := No_Token_Index;
   goto Exit_Row195_0;

end if;


Defer_Res311 :=
   Expr_Or_Parse0 (Parser, Row_Pos195);
Defer_Pos311 := Parser.Current_Pos;




if Defer_Pos311 /= No_Token_Index then

   Row_Pos195 := Defer_Pos311;

else
   Row_Pos195 := No_Token_Index;
   goto Exit_Row195_0;

end if;


--  Start tok_code

Token_Res316 := Row_Pos195;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res316));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos316 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos195 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos195,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos316 := Row_Pos195 + 1;
   end if;
end;

--  End tok_code




if Token_Pos316 /= No_Token_Index then

   Row_Pos195 := Token_Pos316;

else
   Row_Pos195 := No_Token_Index;
   goto Exit_Row195_0;

end if;


Defer_Res312 :=
   Expr_Or_Parse0 (Parser, Row_Pos195);
Defer_Pos312 := Parser.Current_Pos;




if Defer_Pos312 /= No_Token_Index then

   Row_Pos195 := Defer_Pos312;

else
   Row_Pos195 := No_Token_Index;
   goto Exit_Row195_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row195_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos195 /= No_Token_Index then

   Transform_Res134 := Allocate_Elsif_Expr_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res134,
      Kind => Ada_Elsif_Expr_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos33,
      Token_End_Index   => (if Row_Pos195 = Lst_Cpos33
                            then No_Token_Index
                            else Row_Pos195 - 1));

      Initialize_Fields_For_Elsif_Expr_Part
        (Self => Transform_Res134, Elsif_Expr_Part_F_Cond_Expr => Defer_Res311, Elsif_Expr_Part_F_Then_Expr => Defer_Res312);

         if Defer_Res311 /= null and then Is_Incomplete (Defer_Res311) then
            Transform_Res134.Last_Attempted_Child := 0;
         elsif Defer_Res311 /= null and then not Is_Ghost (Defer_Res311) then
            Transform_Res134.Last_Attempted_Child := -1;
         end if;
         if Defer_Res312 /= null and then Is_Incomplete (Defer_Res312) then
            Transform_Res134.Last_Attempted_Child := 0;
         elsif Defer_Res312 /= null and then not Is_Ghost (Defer_Res312) then
            Transform_Res134.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos195 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags134);
end if;

--  End transform_code


   exit when Row_Pos195 = No_Token_Index;

   List_Pos33 := Row_Pos195;
   Lst_Cpos33 := List_Pos33;

   Tmp_List33.Nodes.Append (Transform_Res134);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List33.Nodes.Length;
begin
   List_Res33 :=
      Allocate_Elsif_Expr_Part_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos194;
      Token_End := (if Lst_Cpos33 = Row_Pos194
                    then Row_Pos194
                    else Lst_Cpos33 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos194, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res33,
      Kind              => Ada_Elsif_Expr_Part_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res33,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List33.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res33.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List33);

--  End list_code




if List_Pos33 /= No_Token_Index then

   Row_Pos194 := List_Pos33;

else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos196 := Row_Pos194;



--  Start tok_code

Token_Res317 := Row_Pos196;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res317));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos317 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos196 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos196,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos317 := Row_Pos196 + 1;
   end if;
end;

--  End tok_code




if Token_Pos317 /= No_Token_Index then

   Row_Pos196 := Token_Pos317;

else
   Row_Pos196 := No_Token_Index;
   goto Exit_Row196_0;

end if;


Defer_Res313 :=
   Expr_Or_Parse0 (Parser, Row_Pos196);
Defer_Pos313 := Parser.Current_Pos;




if Defer_Pos313 /= No_Token_Index then

   Row_Pos196 := Defer_Pos313;

else
   Row_Pos196 := No_Token_Index;
   goto Exit_Row196_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row196_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos196 = No_Token_Index then

         
   Defer_Res313 := No_Bare_Ada_Node;



       
   Row_Pos196 := Row_Pos194;



end if;

--  End opt_code




if Row_Pos196 /= No_Token_Index then

   Row_Pos194 := Row_Pos196;

else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row194_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos194 /= No_Token_Index then

   Transform_Res135 := Allocate_If_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res135,
      Kind => Ada_If_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos194 = Pos
                            then No_Token_Index
                            else Row_Pos194 - 1));

      Initialize_Fields_For_If_Expr
        (Self => Transform_Res135, If_Expr_F_Cond_Expr => Defer_Res309, If_Expr_F_Then_Expr => Defer_Res310, If_Expr_F_Alternatives => List_Res33, If_Expr_F_Else_Expr => Defer_Res313);

         if Defer_Res309 /= null and then Is_Incomplete (Defer_Res309) then
            Transform_Res135.Last_Attempted_Child := 0;
         elsif Defer_Res309 /= null and then not Is_Ghost (Defer_Res309) then
            Transform_Res135.Last_Attempted_Child := -1;
         end if;
         if Defer_Res310 /= null and then Is_Incomplete (Defer_Res310) then
            Transform_Res135.Last_Attempted_Child := 0;
         elsif Defer_Res310 /= null and then not Is_Ghost (Defer_Res310) then
            Transform_Res135.Last_Attempted_Child := -1;
         end if;
         if List_Res33 /= null and then Is_Incomplete (List_Res33) then
            Transform_Res135.Last_Attempted_Child := 0;
         elsif List_Res33 /= null and then not Is_Ghost (List_Res33) then
            Transform_Res135.Last_Attempted_Child := -1;
         end if;
         if Defer_Res313 /= null and then Is_Incomplete (Defer_Res313) then
            Transform_Res135.Last_Attempted_Child := 0;
         elsif Defer_Res313 /= null and then not Is_Ghost (Defer_Res313) then
            Transform_Res135.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos194 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags135);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.If_Expr_Transform_Parse1_Memo,
      Row_Pos194 /= No_Token_Index,
      Transform_Res135,
      Pos,
      Row_Pos194);


   Parser.Current_Pos := Row_Pos194;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res135;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end If_Expr_Transform_Parse1;

   


function If_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Stmt
is
   use Bare_If_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt23 :
            Boolean
               := False;
      Row_Pos197 :
            Token_Index
               := No_Token_Index;
      Token_Pos318 :
            Token_Index
               := No_Token_Index;
      Token_Res318 :
            Token_Index
               := No_Token_Index;
      Defer_Pos314 :
            Token_Index
               := No_Token_Index;
      Defer_Res314 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos319 :
            Token_Index
               := No_Token_Index;
      Token_Res319 :
            Token_Index
               := No_Token_Index;
      Defer_Pos315 :
            Token_Index
               := No_Token_Index;
      Defer_Res315 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Lst_Cpos34 :
            Token_Index
               := No_Token_Index;
      Tmp_List34 :
            Free_Parse_List;
      Defer_Pos316 :
            Token_Index
               := No_Token_Index;
      Defer_Res316 :
            Bare_Elsif_Stmt_Part
               := No_Bare_Ada_Node;
      List_Pos34 :
            Token_Index
               := No_Token_Index;
      List_Res34 :
            Bare_Elsif_Stmt_Part_List
               := No_Bare_Ada_Node;
      Row_Pos198 :
            Token_Index
               := No_Token_Index;
      Token_Pos320 :
            Token_Index
               := No_Token_Index;
      Token_Res320 :
            Token_Index
               := No_Token_Index;
      Defer_Pos317 :
            Token_Index
               := No_Token_Index;
      Defer_Res317 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Token_Pos321 :
            Token_Index
               := No_Token_Index;
      Token_Res321 :
            Token_Index
               := No_Token_Index;
      Token_Pos322 :
            Token_Index
               := No_Token_Index;
      Token_Res322 :
            Token_Index
               := No_Token_Index;
      Token_Pos323 :
            Token_Index
               := No_Token_Index;
      Token_Res323 :
            Token_Index
               := No_Token_Index;
      Row_Progress20 :
            Integer
               := 0;
      Transform_Res136 :
            Bare_If_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed20 :
            Boolean
               := False;
      Transform_Diags136 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.If_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res136 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res136;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res136;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags136 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos197 := Pos;



--  Start tok_code

Token_Res318 := Row_Pos197;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res318));
begin
   if
      T.Kind /= From_Token_Kind (Ada_If)
   then
       Token_Pos318 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos197 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos197,
             Expected_Token_Id => Ada_If,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos318 := Row_Pos197 + 1;
   end if;
end;

--  End tok_code



Row_Progress20 := 1;

if Token_Pos318 /= No_Token_Index then

   Row_Pos197 := Token_Pos318;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;

Nobt23 := True;

   Nobt23 := Nobt23;

Row_Progress20 := 2;

if Row_Pos197 /= No_Token_Index then

   Row_Pos197 := Row_Pos197;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


Defer_Res314 :=
   Expr_Or_Parse0 (Parser, Row_Pos197);
Defer_Pos314 := Parser.Current_Pos;



Row_Progress20 := 3;

if Defer_Pos314 /= No_Token_Index then

   Row_Pos197 := Defer_Pos314;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


--  Start tok_code

Token_Res319 := Row_Pos197;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res319));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos319 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos197 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos197,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos319 := Row_Pos197 + 1;
   end if;
end;

--  End tok_code



Row_Progress20 := 4;

if Token_Pos319 /= No_Token_Index then

   Row_Pos197 := Token_Pos319;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_If_Stmt0_Extract_Parse0'Access);
        
Defer_Res315 :=
   Stmts_List_Parse0 (Parser, Row_Pos197);
Defer_Pos315 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        


Row_Progress20 := 5;

if Defer_Pos315 /= No_Token_Index then

   Row_Pos197 := Defer_Pos315;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


--  Start list_code

    List_Pos34 := Row_Pos197;



Lst_Cpos34 := Row_Pos197;
Tmp_List34 := Get_Parse_List (Parser);

loop
   
Defer_Res316 :=
   Elsif_Part_Transform_Parse0 (Parser, Lst_Cpos34);
Defer_Pos316 := Parser.Current_Pos;


   exit when Defer_Pos316 = No_Token_Index;

   List_Pos34 := Defer_Pos316;
   Lst_Cpos34 := List_Pos34;

   Tmp_List34.Nodes.Append (Defer_Res316);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List34.Nodes.Length;
begin
   List_Res34 :=
      Allocate_Elsif_Stmt_Part_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos197;
      Token_End := (if Lst_Cpos34 = Row_Pos197
                    then Row_Pos197
                    else Lst_Cpos34 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos197, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res34,
      Kind              => Ada_Elsif_Stmt_Part_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res34,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List34.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res34.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List34);

--  End list_code



Row_Progress20 := 6;

if List_Pos34 /= No_Token_Index then

   Row_Pos197 := List_Pos34;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos198 := Row_Pos197;



--  Start tok_code

Token_Res320 := Row_Pos198;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res320));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos320 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos198 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos198,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos320 := Row_Pos198 + 1;
   end if;
end;

--  End tok_code




if Token_Pos320 /= No_Token_Index then

   Row_Pos198 := Token_Pos320;

else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_If_Stmt1_Extract_Parse0'Access);
        
Defer_Res317 :=
   Stmts_List_Parse0 (Parser, Row_Pos198);
Defer_Pos317 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos317 /= No_Token_Index then

   Row_Pos198 := Defer_Pos317;

else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row198_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos198 = No_Token_Index then

         
   Defer_Res317 :=
     Allocate_Stmt_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res317,
      Kind              => Ada_Stmt_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos197 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res317,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos198 := Row_Pos197;



end if;

--  End opt_code



Row_Progress20 := 7;

if Row_Pos198 /= No_Token_Index then

   Row_Pos197 := Row_Pos198;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


--  Start tok_code

Token_Res321 := Row_Pos197;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res321));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos321 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos197 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos197,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos321 := Row_Pos197 + 1;
   end if;
end;

--  End tok_code



Row_Progress20 := 8;

if Token_Pos321 /= No_Token_Index then

   Row_Pos197 := Token_Pos321;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


--  Start tok_code

Token_Res322 := Row_Pos197;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res322));
begin
   if
      T.Kind /= From_Token_Kind (Ada_If)
   then
       Token_Pos322 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos197 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos197,
             Expected_Token_Id => Ada_If,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos322 := Row_Pos197 + 1;
   end if;
end;

--  End tok_code



Row_Progress20 := 9;

if Token_Pos322 /= No_Token_Index then

   Row_Pos197 := Token_Pos322;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;


--  Start tok_code

Token_Res323 := Row_Pos197;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res323));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos323 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos197 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos197,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos323 := Row_Pos197 + 1;
   end if;
end;

--  End tok_code



Row_Progress20 := 10;

if Token_Pos323 /= No_Token_Index then

   Row_Pos197 := Token_Pos323;

else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row197_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos197 = No_Token_Index and then Nobt23 then

   Row_Pos197 := Parser.Last_Fail.Pos;

   Transform_Has_Failed20 := True;
end if;

if Row_Pos197 /= No_Token_Index then

   Transform_Res136 := Allocate_If_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res136,
      Kind => Ada_If_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos197 = Pos
                            then No_Token_Index
                            else Row_Pos197 - 1));

      Initialize_Fields_For_If_Stmt
        (Self => Transform_Res136, If_Stmt_F_Cond_Expr => Defer_Res314, If_Stmt_F_Then_Stmts => Defer_Res315, If_Stmt_F_Alternatives => List_Res34, If_Stmt_F_Else_Stmts => Defer_Res317);

         if Defer_Res314 /= null and then Is_Incomplete (Defer_Res314) then
            Transform_Res136.Last_Attempted_Child := 0;
         elsif Defer_Res314 /= null and then not Is_Ghost (Defer_Res314) then
            Transform_Res136.Last_Attempted_Child := -1;
         end if;
         if Defer_Res315 /= null and then Is_Incomplete (Defer_Res315) then
            Transform_Res136.Last_Attempted_Child := 0;
         elsif Defer_Res315 /= null and then not Is_Ghost (Defer_Res315) then
            Transform_Res136.Last_Attempted_Child := -1;
         end if;
         if List_Res34 /= null and then Is_Incomplete (List_Res34) then
            Transform_Res136.Last_Attempted_Child := 0;
         elsif List_Res34 /= null and then not Is_Ghost (List_Res34) then
            Transform_Res136.Last_Attempted_Child := -1;
         end if;
         if Defer_Res317 /= null and then Is_Incomplete (Defer_Res317) then
            Transform_Res136.Last_Attempted_Child := 0;
         elsif Defer_Res317 /= null and then not Is_Ghost (Defer_Res317) then
            Transform_Res136.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed20 then
      Transform_Res136.Last_Attempted_Child :=
         Row_Progress20;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <if_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos197 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags136);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.If_Stmt_Transform_Parse0_Memo,
      Row_Pos197 /= No_Token_Index,
      Transform_Res136,
      Pos,
      Row_Pos197);


   Parser.Current_Pos := Row_Pos197;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res136;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end If_Stmt_Transform_Parse0;

   


function Iloop_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Loop_Stmt
is
   use Bare_Base_Loop_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt24 :
            Boolean
               := False;
      Nobt25 :
            Boolean
               := False;
      Row_Pos199 :
            Token_Index
               := No_Token_Index;
      Token_Pos324 :
            Token_Index
               := No_Token_Index;
      Token_Res324 :
            Token_Index
               := No_Token_Index;
      Defer_Pos318 :
            Token_Index
               := No_Token_Index;
      Defer_Res318 :
            Bare_For_Loop_Spec
               := No_Bare_Ada_Node;
      Token_Pos325 :
            Token_Index
               := No_Token_Index;
      Token_Res325 :
            Token_Index
               := No_Token_Index;
      Defer_Pos319 :
            Token_Index
               := No_Token_Index;
      Defer_Res319 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Token_Pos326 :
            Token_Index
               := No_Token_Index;
      Token_Res326 :
            Token_Index
               := No_Token_Index;
      Token_Pos327 :
            Token_Index
               := No_Token_Index;
      Token_Res327 :
            Token_Index
               := No_Token_Index;
      Row_Pos200 :
            Token_Index
               := No_Token_Index;
      Defer_Pos320 :
            Token_Index
               := No_Token_Index;
      Defer_Res320 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res137 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags137 :
            Ada.Containers.Count_Type;
      Token_Pos328 :
            Token_Index
               := No_Token_Index;
      Token_Res328 :
            Token_Index
               := No_Token_Index;
      Row_Progress21 :
            Integer
               := 0;
      Transform_Res138 :
            Bare_For_Loop_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed21 :
            Boolean
               := False;
      Transform_Diags138 :
            Ada.Containers.Count_Type;
      Row_Pos201 :
            Token_Index
               := No_Token_Index;
      Defer_Pos321 :
            Token_Index
               := No_Token_Index;
      Defer_Res321 :
            Bare_While_Loop_Spec
               := No_Bare_Ada_Node;
      Token_Pos329 :
            Token_Index
               := No_Token_Index;
      Token_Res329 :
            Token_Index
               := No_Token_Index;
      Defer_Pos322 :
            Token_Index
               := No_Token_Index;
      Defer_Res322 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Token_Pos330 :
            Token_Index
               := No_Token_Index;
      Token_Res330 :
            Token_Index
               := No_Token_Index;
      Token_Pos331 :
            Token_Index
               := No_Token_Index;
      Token_Res331 :
            Token_Index
               := No_Token_Index;
      Row_Pos202 :
            Token_Index
               := No_Token_Index;
      Defer_Pos323 :
            Token_Index
               := No_Token_Index;
      Defer_Res323 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res139 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags139 :
            Ada.Containers.Count_Type;
      Token_Pos332 :
            Token_Index
               := No_Token_Index;
      Token_Res332 :
            Token_Index
               := No_Token_Index;
      Transform_Res140 :
            Bare_While_Loop_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags140 :
            Ada.Containers.Count_Type;
      Row_Pos203 :
            Token_Index
               := No_Token_Index;
      Null_Res21 :
            Bare_Loop_Spec
               := No_Bare_Ada_Node;
      Token_Pos333 :
            Token_Index
               := No_Token_Index;
      Token_Res333 :
            Token_Index
               := No_Token_Index;
      Defer_Pos324 :
            Token_Index
               := No_Token_Index;
      Defer_Res324 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Token_Pos334 :
            Token_Index
               := No_Token_Index;
      Token_Res334 :
            Token_Index
               := No_Token_Index;
      Token_Pos335 :
            Token_Index
               := No_Token_Index;
      Token_Res335 :
            Token_Index
               := No_Token_Index;
      Row_Pos204 :
            Token_Index
               := No_Token_Index;
      Defer_Pos325 :
            Token_Index
               := No_Token_Index;
      Defer_Res325 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res141 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags141 :
            Ada.Containers.Count_Type;
      Token_Pos336 :
            Token_Index
               := No_Token_Index;
      Token_Res336 :
            Token_Index
               := No_Token_Index;
      Row_Progress22 :
            Integer
               := 0;
      Transform_Res142 :
            Bare_Loop_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed22 :
            Boolean
               := False;
      Transform_Diags142 :
            Ada.Containers.Count_Type;
      Or_Pos71 :
            Token_Index
               := No_Token_Index;
      Or_Res71 :
            Bare_Base_Loop_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Iloop_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res71 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res71;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res71;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos71 := No_Token_Index;
Or_Res71 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags138 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos199 := Pos;



--  Start tok_code

Token_Res324 := Row_Pos199;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res324));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos324 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos199 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos199,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos324 := Row_Pos199 + 1;
   end if;
end;

--  End tok_code



Row_Progress21 := 1;

if Token_Pos324 /= No_Token_Index then

   Row_Pos199 := Token_Pos324;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;

Nobt24 := True;

   Nobt24 := Nobt24;

Row_Progress21 := 2;

if Row_Pos199 /= No_Token_Index then

   Row_Pos199 := Row_Pos199;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


Defer_Res318 :=
   For_Loop_Param_Spec_Transform_Parse3 (Parser, Row_Pos199);
Defer_Pos318 := Parser.Current_Pos;



Row_Progress21 := 3;

if Defer_Pos318 /= No_Token_Index then

   Row_Pos199 := Defer_Pos318;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


--  Start tok_code

Token_Res325 := Row_Pos199;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res325));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos325 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos199 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos199,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos325 := Row_Pos199 + 1;
   end if;
end;

--  End tok_code



Row_Progress21 := 4;

if Token_Pos325 /= No_Token_Index then

   Row_Pos199 := Token_Pos325;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Iloop_Stmt0_Extract_Parse0'Access);
        
Defer_Res319 :=
   Stmts_List_Parse0 (Parser, Row_Pos199);
Defer_Pos319 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        


Row_Progress21 := 5;

if Defer_Pos319 /= No_Token_Index then

   Row_Pos199 := Defer_Pos319;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


--  Start tok_code

Token_Res326 := Row_Pos199;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res326));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos326 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos199 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos199,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos326 := Row_Pos199 + 1;
   end if;
end;

--  End tok_code



Row_Progress21 := 6;

if Token_Pos326 /= No_Token_Index then

   Row_Pos199 := Token_Pos326;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


--  Start tok_code

Token_Res327 := Row_Pos199;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res327));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos327 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos199 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos199,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos327 := Row_Pos199 + 1;
   end if;
end;

--  End tok_code



Row_Progress21 := 7;

if Token_Pos327 /= No_Token_Index then

   Row_Pos199 := Token_Pos327;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags137 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos200 := Row_Pos199;



Defer_Res320 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos200);
Defer_Pos320 := Parser.Current_Pos;




if Defer_Pos320 /= No_Token_Index then

   Row_Pos200 := Defer_Pos320;

else
   Row_Pos200 := No_Token_Index;
   goto Exit_Row200_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row200_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos200 /= No_Token_Index then

   Transform_Res137 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res137,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos199,
      Token_End_Index   => (if Row_Pos200 = Row_Pos199
                            then No_Token_Index
                            else Row_Pos200 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res137, End_Name_F_Name => Defer_Res320);

         if Defer_Res320 /= null and then Is_Incomplete (Defer_Res320) then
            Transform_Res137.Last_Attempted_Child := 0;
         elsif Defer_Res320 /= null and then not Is_Ghost (Defer_Res320) then
            Transform_Res137.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos200 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags137);
end if;

--  End transform_code


if Row_Pos200 = No_Token_Index then

         
   Transform_Res137 := No_Bare_Ada_Node;



       
   Row_Pos200 := Row_Pos199;



end if;

--  End opt_code



Row_Progress21 := 8;

if Row_Pos200 /= No_Token_Index then

   Row_Pos199 := Row_Pos200;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;


--  Start tok_code

Token_Res328 := Row_Pos199;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res328));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos328 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos199 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos199,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos328 := Row_Pos199 + 1;
   end if;
end;

--  End tok_code



Row_Progress21 := 9;

if Token_Pos328 /= No_Token_Index then

   Row_Pos199 := Token_Pos328;

else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row199_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos199 = No_Token_Index and then Nobt24 then

   Row_Pos199 := Parser.Last_Fail.Pos;

   Transform_Has_Failed21 := True;
end if;

if Row_Pos199 /= No_Token_Index then

   Transform_Res138 := Allocate_For_Loop_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res138,
      Kind => Ada_For_Loop_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos199 = Pos
                            then No_Token_Index
                            else Row_Pos199 - 1));

      Initialize_Fields_For_For_Loop_Stmt
        (Self => Transform_Res138, Base_Loop_Stmt_F_Spec => Defer_Res318, Base_Loop_Stmt_F_Stmts => Defer_Res319, Base_Loop_Stmt_F_End_Name => Transform_Res137);

         if Defer_Res318 /= null and then Is_Incomplete (Defer_Res318) then
            Transform_Res138.Last_Attempted_Child := 0;
         elsif Defer_Res318 /= null and then not Is_Ghost (Defer_Res318) then
            Transform_Res138.Last_Attempted_Child := -1;
         end if;
         if Defer_Res319 /= null and then Is_Incomplete (Defer_Res319) then
            Transform_Res138.Last_Attempted_Child := 0;
         elsif Defer_Res319 /= null and then not Is_Ghost (Defer_Res319) then
            Transform_Res138.Last_Attempted_Child := -1;
         end if;
         if Transform_Res137 /= null and then Is_Incomplete (Transform_Res137) then
            Transform_Res138.Last_Attempted_Child := 0;
         elsif Transform_Res137 /= null and then not Is_Ghost (Transform_Res137) then
            Transform_Res138.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed21 then
      Transform_Res138.Last_Attempted_Child :=
         Row_Progress21;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <iloop_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos199 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags138);
end if;

--  End transform_code

    if Row_Pos199 /= No_Token_Index then
        Or_Pos71 := Row_Pos199;
        Or_Res71 := Transform_Res138;
        goto Exit_Or72;
    end if;
    
--  Start transform_code

Transform_Diags140 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos201 := Pos;



Defer_Res321 :=
   While_Loop_Spec_Transform_Parse0 (Parser, Row_Pos201);
Defer_Pos321 := Parser.Current_Pos;




if Defer_Pos321 /= No_Token_Index then

   Row_Pos201 := Defer_Pos321;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;


--  Start tok_code

Token_Res329 := Row_Pos201;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res329));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos329 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos201,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos329 := Row_Pos201 + 1;
   end if;
end;

--  End tok_code




if Token_Pos329 /= No_Token_Index then

   Row_Pos201 := Token_Pos329;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Iloop_Stmt1_Extract_Parse0'Access);
        
Defer_Res322 :=
   Stmts_List_Parse0 (Parser, Row_Pos201);
Defer_Pos322 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos322 /= No_Token_Index then

   Row_Pos201 := Defer_Pos322;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;


--  Start tok_code

Token_Res330 := Row_Pos201;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res330));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos330 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos201,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos330 := Row_Pos201 + 1;
   end if;
end;

--  End tok_code




if Token_Pos330 /= No_Token_Index then

   Row_Pos201 := Token_Pos330;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;


--  Start tok_code

Token_Res331 := Row_Pos201;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res331));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos331 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos201,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos331 := Row_Pos201 + 1;
   end if;
end;

--  End tok_code




if Token_Pos331 /= No_Token_Index then

   Row_Pos201 := Token_Pos331;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags139 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos202 := Row_Pos201;



Defer_Res323 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos202);
Defer_Pos323 := Parser.Current_Pos;




if Defer_Pos323 /= No_Token_Index then

   Row_Pos202 := Defer_Pos323;

else
   Row_Pos202 := No_Token_Index;
   goto Exit_Row202_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row202_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos202 /= No_Token_Index then

   Transform_Res139 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res139,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos201,
      Token_End_Index   => (if Row_Pos202 = Row_Pos201
                            then No_Token_Index
                            else Row_Pos202 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res139, End_Name_F_Name => Defer_Res323);

         if Defer_Res323 /= null and then Is_Incomplete (Defer_Res323) then
            Transform_Res139.Last_Attempted_Child := 0;
         elsif Defer_Res323 /= null and then not Is_Ghost (Defer_Res323) then
            Transform_Res139.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos202 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags139);
end if;

--  End transform_code


if Row_Pos202 = No_Token_Index then

         
   Transform_Res139 := No_Bare_Ada_Node;



       
   Row_Pos202 := Row_Pos201;



end if;

--  End opt_code




if Row_Pos202 /= No_Token_Index then

   Row_Pos201 := Row_Pos202;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;


--  Start tok_code

Token_Res332 := Row_Pos201;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res332));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos332 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos201,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos332 := Row_Pos201 + 1;
   end if;
end;

--  End tok_code




if Token_Pos332 /= No_Token_Index then

   Row_Pos201 := Token_Pos332;

else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row201_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos201 /= No_Token_Index then

   Transform_Res140 := Allocate_While_Loop_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res140,
      Kind => Ada_While_Loop_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos201 = Pos
                            then No_Token_Index
                            else Row_Pos201 - 1));

      Initialize_Fields_For_While_Loop_Stmt
        (Self => Transform_Res140, Base_Loop_Stmt_F_Spec => Defer_Res321, Base_Loop_Stmt_F_Stmts => Defer_Res322, Base_Loop_Stmt_F_End_Name => Transform_Res139);

         if Defer_Res321 /= null and then Is_Incomplete (Defer_Res321) then
            Transform_Res140.Last_Attempted_Child := 0;
         elsif Defer_Res321 /= null and then not Is_Ghost (Defer_Res321) then
            Transform_Res140.Last_Attempted_Child := -1;
         end if;
         if Defer_Res322 /= null and then Is_Incomplete (Defer_Res322) then
            Transform_Res140.Last_Attempted_Child := 0;
         elsif Defer_Res322 /= null and then not Is_Ghost (Defer_Res322) then
            Transform_Res140.Last_Attempted_Child := -1;
         end if;
         if Transform_Res139 /= null and then Is_Incomplete (Transform_Res139) then
            Transform_Res140.Last_Attempted_Child := 0;
         elsif Transform_Res139 /= null and then not Is_Ghost (Transform_Res139) then
            Transform_Res140.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos201 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags140);
end if;

--  End transform_code

    if Row_Pos201 /= No_Token_Index then
        Or_Pos71 := Row_Pos201;
        Or_Res71 := Transform_Res140;
        goto Exit_Or72;
    end if;
    
--  Start transform_code

Transform_Diags142 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos203 := Pos;



   Null_Res21 := No_Bare_Ada_Node;



Row_Progress22 := 1;

if Row_Pos203 /= No_Token_Index then

   Row_Pos203 := Row_Pos203;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;


--  Start tok_code

Token_Res333 := Row_Pos203;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res333));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos333 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos203,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos333 := Row_Pos203 + 1;
   end if;
end;

--  End tok_code



Row_Progress22 := 2;

if Token_Pos333 /= No_Token_Index then

   Row_Pos203 := Token_Pos333;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;

Nobt25 := True;

   Nobt25 := Nobt25;

Row_Progress22 := 3;

if Row_Pos203 /= No_Token_Index then

   Row_Pos203 := Row_Pos203;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Iloop_Stmt2_Extract_Parse0'Access);
        
Defer_Res324 :=
   Stmts_List_Parse0 (Parser, Row_Pos203);
Defer_Pos324 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        


Row_Progress22 := 4;

if Defer_Pos324 /= No_Token_Index then

   Row_Pos203 := Defer_Pos324;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;


--  Start tok_code

Token_Res334 := Row_Pos203;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res334));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos334 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos203,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos334 := Row_Pos203 + 1;
   end if;
end;

--  End tok_code



Row_Progress22 := 5;

if Token_Pos334 /= No_Token_Index then

   Row_Pos203 := Token_Pos334;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;


--  Start tok_code

Token_Res335 := Row_Pos203;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res335));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Loop)
   then
       Token_Pos335 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos203,
             Expected_Token_Id => Ada_Loop,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos335 := Row_Pos203 + 1;
   end if;
end;

--  End tok_code



Row_Progress22 := 6;

if Token_Pos335 /= No_Token_Index then

   Row_Pos203 := Token_Pos335;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags141 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos204 := Row_Pos203;



Defer_Res325 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos204);
Defer_Pos325 := Parser.Current_Pos;




if Defer_Pos325 /= No_Token_Index then

   Row_Pos204 := Defer_Pos325;

else
   Row_Pos204 := No_Token_Index;
   goto Exit_Row204_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row204_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos204 /= No_Token_Index then

   Transform_Res141 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res141,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos203,
      Token_End_Index   => (if Row_Pos204 = Row_Pos203
                            then No_Token_Index
                            else Row_Pos204 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res141, End_Name_F_Name => Defer_Res325);

         if Defer_Res325 /= null and then Is_Incomplete (Defer_Res325) then
            Transform_Res141.Last_Attempted_Child := 0;
         elsif Defer_Res325 /= null and then not Is_Ghost (Defer_Res325) then
            Transform_Res141.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos204 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags141);
end if;

--  End transform_code


if Row_Pos204 = No_Token_Index then

         
   Transform_Res141 := No_Bare_Ada_Node;



       
   Row_Pos204 := Row_Pos203;



end if;

--  End opt_code



Row_Progress22 := 7;

if Row_Pos204 /= No_Token_Index then

   Row_Pos203 := Row_Pos204;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;


--  Start tok_code

Token_Res336 := Row_Pos203;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res336));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos336 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos203,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos336 := Row_Pos203 + 1;
   end if;
end;

--  End tok_code



Row_Progress22 := 8;

if Token_Pos336 /= No_Token_Index then

   Row_Pos203 := Token_Pos336;

else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row203_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos203 = No_Token_Index and then Nobt25 then

   Row_Pos203 := Parser.Last_Fail.Pos;

   Transform_Has_Failed22 := True;
end if;

if Row_Pos203 /= No_Token_Index then

   Transform_Res142 := Allocate_Loop_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res142,
      Kind => Ada_Loop_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos203 = Pos
                            then No_Token_Index
                            else Row_Pos203 - 1));

      Initialize_Fields_For_Loop_Stmt
        (Self => Transform_Res142, Base_Loop_Stmt_F_Spec => Null_Res21, Base_Loop_Stmt_F_Stmts => Defer_Res324, Base_Loop_Stmt_F_End_Name => Transform_Res141);

         if Null_Res21 /= null and then Is_Incomplete (Null_Res21) then
            Transform_Res142.Last_Attempted_Child := 0;
         elsif Null_Res21 /= null and then not Is_Ghost (Null_Res21) then
            Transform_Res142.Last_Attempted_Child := -1;
         end if;
         if Defer_Res324 /= null and then Is_Incomplete (Defer_Res324) then
            Transform_Res142.Last_Attempted_Child := 0;
         elsif Defer_Res324 /= null and then not Is_Ghost (Defer_Res324) then
            Transform_Res142.Last_Attempted_Child := -1;
         end if;
         if Transform_Res141 /= null and then Is_Incomplete (Transform_Res141) then
            Transform_Res142.Last_Attempted_Child := 0;
         elsif Transform_Res141 /= null and then not Is_Ghost (Transform_Res141) then
            Transform_Res142.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed22 then
      Transform_Res142.Last_Attempted_Child :=
         Row_Progress22;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <iloop_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos203 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags142);
end if;

--  End transform_code

    if Row_Pos203 /= No_Token_Index then
        Or_Pos71 := Row_Pos203;
        Or_Res71 := Transform_Res142;
        goto Exit_Or72;
    end if;
<<Exit_Or72>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Iloop_Stmt_Or_Parse0_Memo,
      Or_Pos71 /= No_Token_Index,
      Or_Res71,
      Pos,
      Or_Pos71);


   Parser.Current_Pos := Or_Pos71;

   Exit_Call (Parser, Call_Depth);
   return Or_Res71;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Iloop_Stmt_Or_Parse0;

   


function Incomplete_Type_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Incomplete_Type_Decl
is
   use Bare_Incomplete_Type_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos205 :
            Token_Index
               := No_Token_Index;
      Token_Pos337 :
            Token_Index
               := No_Token_Index;
      Token_Res337 :
            Token_Index
               := No_Token_Index;
      Defer_Pos326 :
            Token_Index
               := No_Token_Index;
      Defer_Res326 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos327 :
            Token_Index
               := No_Token_Index;
      Defer_Res327 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Token_Pos338 :
            Token_Index
               := No_Token_Index;
      Token_Res338 :
            Token_Index
               := No_Token_Index;
      Token_Pos339 :
            Token_Index
               := No_Token_Index;
      Token_Res339 :
            Token_Index
               := No_Token_Index;
      Opt_Res21 :
            Bare_Abstract_Node
               := No_Bare_Ada_Node;
      Token_Pos340 :
            Token_Index
               := No_Token_Index;
      Token_Res340 :
            Token_Index
               := No_Token_Index;
      Token_Pos341 :
            Token_Index
               := No_Token_Index;
      Token_Res341 :
            Token_Index
               := No_Token_Index;
      Transform_Res143 :
            Bare_Incomplete_Tagged_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags143 :
            Ada.Containers.Count_Type;
      Row_Pos206 :
            Token_Index
               := No_Token_Index;
      Token_Pos342 :
            Token_Index
               := No_Token_Index;
      Token_Res342 :
            Token_Index
               := No_Token_Index;
      Defer_Pos328 :
            Token_Index
               := No_Token_Index;
      Defer_Res328 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos329 :
            Token_Index
               := No_Token_Index;
      Defer_Res329 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Token_Pos343 :
            Token_Index
               := No_Token_Index;
      Token_Res343 :
            Token_Index
               := No_Token_Index;
      Transform_Res144 :
            Bare_Incomplete_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags144 :
            Ada.Containers.Count_Type;
      Or_Pos72 :
            Token_Index
               := No_Token_Index;
      Or_Res72 :
            Bare_Incomplete_Type_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Incomplete_Type_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res72 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res72;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res72;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos72 := No_Token_Index;
Or_Res72 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags143 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos205 := Pos;



--  Start tok_code

Token_Res337 := Row_Pos205;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res337));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos337 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos205 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos205,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos337 := Row_Pos205 + 1;
   end if;
end;

--  End tok_code




if Token_Pos337 /= No_Token_Index then

   Row_Pos205 := Token_Pos337;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;


Defer_Res326 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos205);
Defer_Pos326 := Parser.Current_Pos;




if Defer_Pos326 /= No_Token_Index then

   Row_Pos205 := Defer_Pos326;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;


--  Start opt_code












Defer_Res327 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos205);
Defer_Pos327 := Parser.Current_Pos;


if Defer_Pos327 = No_Token_Index then

         
   Defer_Res327 := No_Bare_Ada_Node;



       
   Defer_Pos327 := Row_Pos205;



end if;

--  End opt_code




if Defer_Pos327 /= No_Token_Index then

   Row_Pos205 := Defer_Pos327;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;


--  Start tok_code

Token_Res338 := Row_Pos205;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res338));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos338 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos205 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos205,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos338 := Row_Pos205 + 1;
   end if;
end;

--  End tok_code




if Token_Pos338 /= No_Token_Index then

   Row_Pos205 := Token_Pos338;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res339 := Row_Pos205;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res339));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos339 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos205 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos205,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos339 := Row_Pos205 + 1;
   end if;
end;

--  End tok_code


if Token_Pos339 = No_Token_Index then

         Opt_Res21 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res21,
            Kind              => Ada_Abstract_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos205,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos339 := Row_Pos205;


else

      Opt_Res21 := Allocate_Abstract_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res21,
         Kind              => Ada_Abstract_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos205,
         Token_End_Index   => Token_Pos339 - 1);

end if;

--  End opt_code




if Token_Pos339 /= No_Token_Index then

   Row_Pos205 := Token_Pos339;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;


--  Start tok_code

Token_Res340 := Row_Pos205;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res340));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Tagged)
   then
       Token_Pos340 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos205 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos205,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos340 := Row_Pos205 + 1;
   end if;
end;

--  End tok_code




if Token_Pos340 /= No_Token_Index then

   Row_Pos205 := Token_Pos340;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;


--  Start tok_code

Token_Res341 := Row_Pos205;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res341));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos341 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos205 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos205,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos341 := Row_Pos205 + 1;
   end if;
end;

--  End tok_code




if Token_Pos341 /= No_Token_Index then

   Row_Pos205 := Token_Pos341;

else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row205_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos205 /= No_Token_Index then

   Transform_Res143 := Allocate_Incomplete_Tagged_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res143,
      Kind => Ada_Incomplete_Tagged_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos205 = Pos
                            then No_Token_Index
                            else Row_Pos205 - 1));

      Initialize_Fields_For_Incomplete_Tagged_Type_Decl
        (Self => Transform_Res143, Base_Type_Decl_F_Name => Defer_Res326, Incomplete_Type_Decl_F_Discriminants => Defer_Res327, Incomplete_Tagged_Type_Decl_F_Has_Abstract => Opt_Res21);

         if Defer_Res326 /= null and then Is_Incomplete (Defer_Res326) then
            Transform_Res143.Last_Attempted_Child := 0;
         elsif Defer_Res326 /= null and then not Is_Ghost (Defer_Res326) then
            Transform_Res143.Last_Attempted_Child := -1;
         end if;
         if Defer_Res327 /= null and then Is_Incomplete (Defer_Res327) then
            Transform_Res143.Last_Attempted_Child := 0;
         elsif Defer_Res327 /= null and then not Is_Ghost (Defer_Res327) then
            Transform_Res143.Last_Attempted_Child := -1;
         end if;
         if Opt_Res21 /= null and then Is_Incomplete (Opt_Res21) then
            Transform_Res143.Last_Attempted_Child := 0;
         elsif Opt_Res21 /= null and then not Is_Ghost (Opt_Res21) then
            Transform_Res143.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos205 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags143);
end if;

--  End transform_code

    if Row_Pos205 /= No_Token_Index then
        Or_Pos72 := Row_Pos205;
        Or_Res72 := Transform_Res143;
        goto Exit_Or73;
    end if;
    
--  Start transform_code

Transform_Diags144 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos206 := Pos;



--  Start tok_code

Token_Res342 := Row_Pos206;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res342));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos342 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos206 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos206,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos342 := Row_Pos206 + 1;
   end if;
end;

--  End tok_code




if Token_Pos342 /= No_Token_Index then

   Row_Pos206 := Token_Pos342;

else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;

end if;


Defer_Res328 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos206);
Defer_Pos328 := Parser.Current_Pos;




if Defer_Pos328 /= No_Token_Index then

   Row_Pos206 := Defer_Pos328;

else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;

end if;


--  Start opt_code












Defer_Res329 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos206);
Defer_Pos329 := Parser.Current_Pos;


if Defer_Pos329 = No_Token_Index then

         
   Defer_Res329 := No_Bare_Ada_Node;



       
   Defer_Pos329 := Row_Pos206;



end if;

--  End opt_code




if Defer_Pos329 /= No_Token_Index then

   Row_Pos206 := Defer_Pos329;

else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;

end if;


--  Start tok_code

Token_Res343 := Row_Pos206;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res343));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos343 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos206 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos206,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos343 := Row_Pos206 + 1;
   end if;
end;

--  End tok_code




if Token_Pos343 /= No_Token_Index then

   Row_Pos206 := Token_Pos343;

else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row206_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos206 /= No_Token_Index then

   Transform_Res144 := Allocate_Incomplete_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res144,
      Kind => Ada_Incomplete_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos206 = Pos
                            then No_Token_Index
                            else Row_Pos206 - 1));

      Initialize_Fields_For_Incomplete_Type_Decl
        (Self => Transform_Res144, Base_Type_Decl_F_Name => Defer_Res328, Incomplete_Type_Decl_F_Discriminants => Defer_Res329);

         if Defer_Res328 /= null and then Is_Incomplete (Defer_Res328) then
            Transform_Res144.Last_Attempted_Child := 0;
         elsif Defer_Res328 /= null and then not Is_Ghost (Defer_Res328) then
            Transform_Res144.Last_Attempted_Child := -1;
         end if;
         if Defer_Res329 /= null and then Is_Incomplete (Defer_Res329) then
            Transform_Res144.Last_Attempted_Child := 0;
         elsif Defer_Res329 /= null and then not Is_Ghost (Defer_Res329) then
            Transform_Res144.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos206 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags144);
end if;

--  End transform_code

    if Row_Pos206 /= No_Token_Index then
        Or_Pos72 := Row_Pos206;
        Or_Res72 := Transform_Res144;
        goto Exit_Or73;
    end if;
<<Exit_Or73>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Incomplete_Type_Decl_Or_Parse0_Memo,
      Or_Pos72 /= No_Token_Index,
      Or_Res72,
      Pos,
      Or_Pos72);


   Parser.Current_Pos := Or_Pos72;

   Exit_Call (Parser, Call_Depth);
   return Or_Res72;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Incomplete_Type_Decl_Or_Parse0;

   


function Int_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Int_Literal
is
   use Bare_Int_Literal_Memos;

   Call_Depth : aliased Natural;

      Row_Pos207 :
            Token_Index
               := No_Token_Index;
      Token_Pos344 :
            Token_Index
               := No_Token_Index;
      Token_Res344 :
            Token_Index
               := No_Token_Index;
      Transform_Res145 :
            Bare_Int_Literal
               := No_Bare_Ada_Node;
      Transform_Diags145 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Int_Literal_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res145 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res145;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res145;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags145 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos207 := Pos;



--  Start tok_code

Token_Res344 := Row_Pos207;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res344));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Integer)
   then
       Token_Pos344 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos207 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos207,
             Expected_Token_Id => Ada_Integer,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos344 := Row_Pos207 + 1;
   end if;
end;

--  End tok_code




if Token_Pos344 /= No_Token_Index then

   Row_Pos207 := Token_Pos344;

else
   Row_Pos207 := No_Token_Index;
   goto Exit_Row207_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row207_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos207 /= No_Token_Index then

   Transform_Res145 := Allocate_Int_Literal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res145,
      Kind => Ada_Int_Literal,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos207 = Pos
                            then No_Token_Index
                            else Row_Pos207 - 1));

      Initialize_Fields_For_Int_Literal
        (Self => Transform_Res145);



elsif Row_Pos207 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags145);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Int_Literal_Transform_Parse0_Memo,
      Row_Pos207 /= No_Token_Index,
      Transform_Res145,
      Pos,
      Row_Pos207);


   Parser.Current_Pos := Row_Pos207;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res145;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Int_Literal_Transform_Parse0;

   


function Interface_Type_Def_Transform_Parse4
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Interface_Type_Def
is
   use Bare_Interface_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos208 :
            Token_Index
               := No_Token_Index;
      Row_Pos209 :
            Token_Index
               := No_Token_Index;
      Token_Pos345 :
            Token_Index
               := No_Token_Index;
      Token_Res345 :
            Token_Index
               := No_Token_Index;
      Transform_Res146 :
            Bare_Interface_Kind_Limited
               := No_Bare_Ada_Node;
      Transform_Diags146 :
            Ada.Containers.Count_Type;
      Row_Pos210 :
            Token_Index
               := No_Token_Index;
      Token_Pos346 :
            Token_Index
               := No_Token_Index;
      Token_Res346 :
            Token_Index
               := No_Token_Index;
      Transform_Res147 :
            Bare_Interface_Kind_Task
               := No_Bare_Ada_Node;
      Transform_Diags147 :
            Ada.Containers.Count_Type;
      Row_Pos211 :
            Token_Index
               := No_Token_Index;
      Token_Pos347 :
            Token_Index
               := No_Token_Index;
      Token_Res347 :
            Token_Index
               := No_Token_Index;
      Transform_Res148 :
            Bare_Interface_Kind_Protected
               := No_Bare_Ada_Node;
      Transform_Diags148 :
            Ada.Containers.Count_Type;
      Row_Pos212 :
            Token_Index
               := No_Token_Index;
      Token_Pos348 :
            Token_Index
               := No_Token_Index;
      Token_Res348 :
            Token_Index
               := No_Token_Index;
      Transform_Res149 :
            Bare_Interface_Kind_Synchronized
               := No_Bare_Ada_Node;
      Transform_Diags149 :
            Ada.Containers.Count_Type;
      Or_Pos73 :
            Token_Index
               := No_Token_Index;
      Or_Res73 :
            Bare_Interface_Kind
               := No_Bare_Ada_Node;
      Token_Pos349 :
            Token_Index
               := No_Token_Index;
      Token_Res349 :
            Token_Index
               := No_Token_Index;
      Row_Pos213 :
            Token_Index
               := No_Token_Index;
      Token_Pos350 :
            Token_Index
               := No_Token_Index;
      Token_Res350 :
            Token_Index
               := No_Token_Index;
      Defer_Pos330 :
            Token_Index
               := No_Token_Index;
      Defer_Res330 :
            Bare_Parent_List
               := No_Bare_Ada_Node;
      Transform_Res150 :
            Bare_Interface_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags150 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Interface_Type_Def_Transform_Parse4_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res150 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res150;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res150;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags150 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos208 := Pos;



--  Start opt_code












--  Start or_code

Or_Pos73 := No_Token_Index;
Or_Res73 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags146 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos209 := Row_Pos208;



--  Start tok_code

Token_Res345 := Row_Pos209;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res345));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Limited)
   then
       Token_Pos345 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos209 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos209,
             Expected_Token_Id => Ada_Limited,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos345 := Row_Pos209 + 1;
   end if;
end;

--  End tok_code




if Token_Pos345 /= No_Token_Index then

   Row_Pos209 := Token_Pos345;

else
   Row_Pos209 := No_Token_Index;
   goto Exit_Row209_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row209_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos209 /= No_Token_Index then

   Transform_Res146 := Allocate_Interface_Kind_Limited (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res146,
      Kind => Ada_Interface_Kind_Limited,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos208,
      Token_End_Index   => (if Row_Pos209 = Row_Pos208
                            then No_Token_Index
                            else Row_Pos209 - 1));




elsif Row_Pos209 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags146);
end if;

--  End transform_code

    if Row_Pos209 /= No_Token_Index then
        Or_Pos73 := Row_Pos209;
        Or_Res73 := Transform_Res146;
        goto Exit_Or74;
    end if;
    
--  Start transform_code

Transform_Diags147 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos210 := Row_Pos208;



--  Start tok_code

Token_Res346 := Row_Pos210;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res346));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Task)
   then
       Token_Pos346 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos210 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos210,
             Expected_Token_Id => Ada_Task,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos346 := Row_Pos210 + 1;
   end if;
end;

--  End tok_code




if Token_Pos346 /= No_Token_Index then

   Row_Pos210 := Token_Pos346;

else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row210_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos210 /= No_Token_Index then

   Transform_Res147 := Allocate_Interface_Kind_Task (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res147,
      Kind => Ada_Interface_Kind_Task,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos208,
      Token_End_Index   => (if Row_Pos210 = Row_Pos208
                            then No_Token_Index
                            else Row_Pos210 - 1));




elsif Row_Pos210 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags147);
end if;

--  End transform_code

    if Row_Pos210 /= No_Token_Index then
        Or_Pos73 := Row_Pos210;
        Or_Res73 := Transform_Res147;
        goto Exit_Or74;
    end if;
    
--  Start transform_code

Transform_Diags148 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos211 := Row_Pos208;



--  Start tok_code

Token_Res347 := Row_Pos211;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res347));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Protected)
   then
       Token_Pos347 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos211 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos211,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos347 := Row_Pos211 + 1;
   end if;
end;

--  End tok_code




if Token_Pos347 /= No_Token_Index then

   Row_Pos211 := Token_Pos347;

else
   Row_Pos211 := No_Token_Index;
   goto Exit_Row211_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row211_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos211 /= No_Token_Index then

   Transform_Res148 := Allocate_Interface_Kind_Protected (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res148,
      Kind => Ada_Interface_Kind_Protected,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos208,
      Token_End_Index   => (if Row_Pos211 = Row_Pos208
                            then No_Token_Index
                            else Row_Pos211 - 1));




elsif Row_Pos211 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags148);
end if;

--  End transform_code

    if Row_Pos211 /= No_Token_Index then
        Or_Pos73 := Row_Pos211;
        Or_Res73 := Transform_Res148;
        goto Exit_Or74;
    end if;
    
--  Start transform_code

Transform_Diags149 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos212 := Row_Pos208;



--  Start tok_code

Token_Res348 := Row_Pos212;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res348));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Synchronized)
   then
       Token_Pos348 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos212 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos212,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos348 := Row_Pos212 + 1;
   end if;
end;

--  End tok_code




if Token_Pos348 /= No_Token_Index then

   Row_Pos212 := Token_Pos348;

else
   Row_Pos212 := No_Token_Index;
   goto Exit_Row212_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row212_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos212 /= No_Token_Index then

   Transform_Res149 := Allocate_Interface_Kind_Synchronized (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res149,
      Kind => Ada_Interface_Kind_Synchronized,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos208,
      Token_End_Index   => (if Row_Pos212 = Row_Pos208
                            then No_Token_Index
                            else Row_Pos212 - 1));




elsif Row_Pos212 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags149);
end if;

--  End transform_code

    if Row_Pos212 /= No_Token_Index then
        Or_Pos73 := Row_Pos212;
        Or_Res73 := Transform_Res149;
        goto Exit_Or74;
    end if;
<<Exit_Or74>>

--  End or_code


if Or_Pos73 = No_Token_Index then

         
   Or_Res73 := No_Bare_Ada_Node;



       
   Or_Pos73 := Row_Pos208;



end if;

--  End opt_code




if Or_Pos73 /= No_Token_Index then

   Row_Pos208 := Or_Pos73;

else
   Row_Pos208 := No_Token_Index;
   goto Exit_Row208_0;

end if;


--  Start tok_code

Token_Res349 := Row_Pos208;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res349));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Interface_306)
   then
       Token_Pos349 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos208 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos208,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos349 := Row_Pos208 + 1;
   end if;
end;

--  End tok_code




if Token_Pos349 /= No_Token_Index then

   Row_Pos208 := Token_Pos349;

else
   Row_Pos208 := No_Token_Index;
   goto Exit_Row208_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos213 := Row_Pos208;



--  Start tok_code

Token_Res350 := Row_Pos213;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res350));
begin
   if
      T.Kind /= From_Token_Kind (Ada_And)
   then
       Token_Pos350 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos213 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos213,
             Expected_Token_Id => Ada_And,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos350 := Row_Pos213 + 1;
   end if;
end;

--  End tok_code




if Token_Pos350 /= No_Token_Index then

   Row_Pos213 := Token_Pos350;

else
   Row_Pos213 := No_Token_Index;
   goto Exit_Row213_0;

end if;


Defer_Res330 :=
   Parent_List_List_Parse0 (Parser, Row_Pos213);
Defer_Pos330 := Parser.Current_Pos;




if Defer_Pos330 /= No_Token_Index then

   Row_Pos213 := Defer_Pos330;

else
   Row_Pos213 := No_Token_Index;
   goto Exit_Row213_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row213_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos213 = No_Token_Index then

         
   Defer_Res330 :=
     Allocate_Parent_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res330,
      Kind              => Ada_Parent_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos208 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res330,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos213 := Row_Pos208;



end if;

--  End opt_code




if Row_Pos213 /= No_Token_Index then

   Row_Pos208 := Row_Pos213;

else
   Row_Pos208 := No_Token_Index;
   goto Exit_Row208_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row208_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos208 /= No_Token_Index then

   Transform_Res150 := Allocate_Interface_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res150,
      Kind => Ada_Interface_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos208 = Pos
                            then No_Token_Index
                            else Row_Pos208 - 1));

      Initialize_Fields_For_Interface_Type_Def
        (Self => Transform_Res150, Interface_Type_Def_F_Interface_Kind => Or_Res73, Interface_Type_Def_F_Interfaces => Defer_Res330);

         if Or_Res73 /= null and then Is_Incomplete (Or_Res73) then
            Transform_Res150.Last_Attempted_Child := 0;
         elsif Or_Res73 /= null and then not Is_Ghost (Or_Res73) then
            Transform_Res150.Last_Attempted_Child := -1;
         end if;
         if Defer_Res330 /= null and then Is_Incomplete (Defer_Res330) then
            Transform_Res150.Last_Attempted_Child := 0;
         elsif Defer_Res330 /= null and then not Is_Ghost (Defer_Res330) then
            Transform_Res150.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos208 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags150);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Interface_Type_Def_Transform_Parse4_Memo,
      Row_Pos208 /= No_Token_Index,
      Transform_Res150,
      Pos,
      Row_Pos208);


   Parser.Current_Pos := Row_Pos208;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res150;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Interface_Type_Def_Transform_Parse4;

   


function Iterated_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Iterated_Assoc
is
   use Bare_Iterated_Assoc_Memos;

   Call_Depth : aliased Natural;

      Nobt26 :
            Boolean
               := False;
      Row_Pos214 :
            Token_Index
               := No_Token_Index;
      Token_Pos351 :
            Token_Index
               := No_Token_Index;
      Token_Res351 :
            Token_Index
               := No_Token_Index;
      Defer_Pos331 :
            Token_Index
               := No_Token_Index;
      Defer_Res331 :
            Bare_For_Loop_Spec
               := No_Bare_Ada_Node;
      Token_Pos352 :
            Token_Index
               := No_Token_Index;
      Token_Res352 :
            Token_Index
               := No_Token_Index;
      Defer_Pos332 :
            Token_Index
               := No_Token_Index;
      Defer_Res332 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress23 :
            Integer
               := 0;
      Transform_Res151 :
            Bare_Iterated_Assoc
               := No_Bare_Ada_Node;
      Transform_Has_Failed23 :
            Boolean
               := False;
      Transform_Diags151 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Iterated_Assoc_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res151 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res151;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res151;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags151 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos214 := Pos;



--  Start tok_code

Token_Res351 := Row_Pos214;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res351));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos351 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos214 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos214,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos351 := Row_Pos214 + 1;
   end if;
end;

--  End tok_code



Row_Progress23 := 1;

if Token_Pos351 /= No_Token_Index then

   Row_Pos214 := Token_Pos351;

else
   Row_Pos214 := No_Token_Index;
   goto Exit_Row214_0;

end if;

Nobt26 := True;

   Nobt26 := Nobt26;

Row_Progress23 := 2;

if Row_Pos214 /= No_Token_Index then

   Row_Pos214 := Row_Pos214;

else
   Row_Pos214 := No_Token_Index;
   goto Exit_Row214_0;

end if;


Defer_Res331 :=
   For_Loop_Param_Spec_Transform_Parse3 (Parser, Row_Pos214);
Defer_Pos331 := Parser.Current_Pos;



Row_Progress23 := 3;

if Defer_Pos331 /= No_Token_Index then

   Row_Pos214 := Defer_Pos331;

else
   Row_Pos214 := No_Token_Index;
   goto Exit_Row214_0;

end if;


--  Start tok_code

Token_Res352 := Row_Pos214;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res352));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos352 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos214 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos214,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos352 := Row_Pos214 + 1;
   end if;
end;

--  End tok_code



Row_Progress23 := 4;

if Token_Pos352 /= No_Token_Index then

   Row_Pos214 := Token_Pos352;

else
   Row_Pos214 := No_Token_Index;
   goto Exit_Row214_0;

end if;


Defer_Res332 :=
   Expr_Or_Parse0 (Parser, Row_Pos214);
Defer_Pos332 := Parser.Current_Pos;



Row_Progress23 := 5;

if Defer_Pos332 /= No_Token_Index then

   Row_Pos214 := Defer_Pos332;

else
   Row_Pos214 := No_Token_Index;
   goto Exit_Row214_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row214_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos214 = No_Token_Index and then Nobt26 then

   Row_Pos214 := Parser.Last_Fail.Pos;

   Transform_Has_Failed23 := True;
end if;

if Row_Pos214 /= No_Token_Index then

   Transform_Res151 := Allocate_Iterated_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res151,
      Kind => Ada_Iterated_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos214 = Pos
                            then No_Token_Index
                            else Row_Pos214 - 1));

      Initialize_Fields_For_Iterated_Assoc
        (Self => Transform_Res151, Iterated_Assoc_F_Spec => Defer_Res331, Iterated_Assoc_F_R_Expr => Defer_Res332);

         if Defer_Res331 /= null and then Is_Incomplete (Defer_Res331) then
            Transform_Res151.Last_Attempted_Child := 0;
         elsif Defer_Res331 /= null and then not Is_Ghost (Defer_Res331) then
            Transform_Res151.Last_Attempted_Child := -1;
         end if;
         if Defer_Res332 /= null and then Is_Incomplete (Defer_Res332) then
            Transform_Res151.Last_Attempted_Child := 0;
         elsif Defer_Res332 /= null and then not Is_Ghost (Defer_Res332) then
            Transform_Res151.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed23 then
      Transform_Res151.Last_Attempted_Child :=
         Row_Progress23;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <iterated_assoc>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos214 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags151);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Iterated_Assoc_Transform_Parse0_Memo,
      Row_Pos214 /= No_Token_Index,
      Transform_Res151,
      Pos,
      Row_Pos214);


   Parser.Current_Pos := Row_Pos214;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res151;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Iterated_Assoc_Transform_Parse0;

   


function Label_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Label
is
   use Bare_Label_Memos;

   Call_Depth : aliased Natural;

      Nobt27 :
            Boolean
               := False;
      Row_Pos215 :
            Token_Index
               := No_Token_Index;
      Token_Pos353 :
            Token_Index
               := No_Token_Index;
      Token_Res353 :
            Token_Index
               := No_Token_Index;
      Row_Pos216 :
            Token_Index
               := No_Token_Index;
      Defer_Pos333 :
            Token_Index
               := No_Token_Index;
      Defer_Res333 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Res152 :
            Bare_Label_Decl
               := No_Bare_Ada_Node;
      Transform_Diags152 :
            Ada.Containers.Count_Type;
      Token_Pos354 :
            Token_Index
               := No_Token_Index;
      Token_Res354 :
            Token_Index
               := No_Token_Index;
      Row_Progress24 :
            Integer
               := 0;
      Transform_Res153 :
            Bare_Label
               := No_Bare_Ada_Node;
      Transform_Has_Failed24 :
            Boolean
               := False;
      Transform_Diags153 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Label_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res153 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res153;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res153;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags153 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos215 := Pos;



--  Start tok_code

Token_Res353 := Row_Pos215;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res353));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Label_Start)
   then
       Token_Pos353 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos215 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos215,
             Expected_Token_Id => Ada_Label_Start,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos353 := Row_Pos215 + 1;
   end if;
end;

--  End tok_code



Row_Progress24 := 1;

if Token_Pos353 /= No_Token_Index then

   Row_Pos215 := Token_Pos353;

else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;

end if;

Nobt27 := True;

   Nobt27 := Nobt27;

Row_Progress24 := 2;

if Row_Pos215 /= No_Token_Index then

   Row_Pos215 := Row_Pos215;

else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;

end if;


--  Start transform_code

Transform_Diags152 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos216 := Row_Pos215;



Defer_Res333 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos216);
Defer_Pos333 := Parser.Current_Pos;




if Defer_Pos333 /= No_Token_Index then

   Row_Pos216 := Defer_Pos333;

else
   Row_Pos216 := No_Token_Index;
   goto Exit_Row216_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row216_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos216 /= No_Token_Index then

   Transform_Res152 := Allocate_Label_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res152,
      Kind => Ada_Label_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos215,
      Token_End_Index   => (if Row_Pos216 = Row_Pos215
                            then No_Token_Index
                            else Row_Pos216 - 1));

      Initialize_Fields_For_Label_Decl
        (Self => Transform_Res152, Label_Decl_F_Name => Defer_Res333);

         if Defer_Res333 /= null and then Is_Incomplete (Defer_Res333) then
            Transform_Res152.Last_Attempted_Child := 0;
         elsif Defer_Res333 /= null and then not Is_Ghost (Defer_Res333) then
            Transform_Res152.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos216 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags152);
end if;

--  End transform_code



Row_Progress24 := 3;

if Row_Pos216 /= No_Token_Index then

   Row_Pos215 := Row_Pos216;

else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;

end if;


--  Start tok_code

Token_Res354 := Row_Pos215;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res354));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Label_End)
   then
       Token_Pos354 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos215 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos215,
             Expected_Token_Id => Ada_Label_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos354 := Row_Pos215 + 1;
   end if;
end;

--  End tok_code



Row_Progress24 := 4;

if Token_Pos354 /= No_Token_Index then

   Row_Pos215 := Token_Pos354;

else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row215_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos215 = No_Token_Index and then Nobt27 then

   Row_Pos215 := Parser.Last_Fail.Pos;

   Transform_Has_Failed24 := True;
end if;

if Row_Pos215 /= No_Token_Index then

   Transform_Res153 := Allocate_Label (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res153,
      Kind => Ada_Label,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos215 = Pos
                            then No_Token_Index
                            else Row_Pos215 - 1));

      Initialize_Fields_For_Label
        (Self => Transform_Res153, Label_F_Decl => Transform_Res152);

         if Transform_Res152 /= null and then Is_Incomplete (Transform_Res152) then
            Transform_Res153.Last_Attempted_Child := 0;
         elsif Transform_Res152 /= null and then not Is_Ghost (Transform_Res152) then
            Transform_Res153.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed24 then
      Transform_Res153.Last_Attempted_Child :=
         Row_Progress24;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <label>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos215 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags153);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Label_Transform_Parse1_Memo,
      Row_Pos215 /= No_Token_Index,
      Transform_Res153,
      Pos,
      Row_Pos215);


   Parser.Current_Pos := Row_Pos215;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res153;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Label_Transform_Parse1;

   


function Library_Item_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Library_Item
is
   use Bare_Library_Item_Memos;

   Call_Depth : aliased Natural;

      Row_Pos217 :
            Token_Index
               := No_Token_Index;
      Token_Pos355 :
            Token_Index
               := No_Token_Index;
      Token_Res355 :
            Token_Index
               := No_Token_Index;
      Opt_Res22 :
            Bare_Private_Node
               := No_Bare_Ada_Node;
      Defer_Pos334 :
            Token_Index
               := No_Token_Index;
      Defer_Res334 :
            Bare_Null_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos335 :
            Token_Index
               := No_Token_Index;
      Defer_Res335 :
            Bare_Abstract_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos336 :
            Token_Index
               := No_Token_Index;
      Defer_Res336 :
            Bare_Expr_Function
               := No_Bare_Ada_Node;
      Defer_Pos337 :
            Token_Index
               := No_Token_Index;
      Defer_Res337 :
            Bare_Subp_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos338 :
            Token_Index
               := No_Token_Index;
      Defer_Res338 :
            Bare_Generic_Instantiation
               := No_Bare_Ada_Node;
      Defer_Pos339 :
            Token_Index
               := No_Token_Index;
      Defer_Res339 :
            Bare_Body_Node
               := No_Bare_Ada_Node;
      Defer_Pos340 :
            Token_Index
               := No_Token_Index;
      Defer_Res340 :
            Bare_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos341 :
            Token_Index
               := No_Token_Index;
      Defer_Res341 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;
      Defer_Pos342 :
            Token_Index
               := No_Token_Index;
      Defer_Res342 :
            Bare_Generic_Decl
               := No_Bare_Ada_Node;
      Defer_Pos343 :
            Token_Index
               := No_Token_Index;
      Defer_Res343 :
            Bare_Package_Decl
               := No_Bare_Ada_Node;
      Row_Pos218 :
            Token_Index
               := No_Token_Index;
      Transform_Res154 :
            Bare_Error_Decl
               := No_Bare_Ada_Node;
      Transform_Diags154 :
            Ada.Containers.Count_Type;
      Skip_Pos1 :
            Token_Index
               := No_Token_Index;
      Skip_Dummy1 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Or_Pos74 :
            Token_Index
               := No_Token_Index;
      Or_Res74 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;
      Transform_Res155 :
            Bare_Library_Item
               := No_Bare_Ada_Node;
      Transform_Diags155 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Library_Item_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res155 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res155;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res155;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags155 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos217 := Pos;



--  Start opt_code












--  Start tok_code

Token_Res355 := Row_Pos217;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res355));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos355 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos217 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos217,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos355 := Row_Pos217 + 1;
   end if;
end;

--  End tok_code


if Token_Pos355 = No_Token_Index then

         Opt_Res22 := Allocate_Private_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res22,
            Kind              => Ada_Private_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos217,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos355 := Row_Pos217;


else

      Opt_Res22 := Allocate_Private_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res22,
         Kind              => Ada_Private_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos217,
         Token_End_Index   => Token_Pos355 - 1);

end if;

--  End opt_code




if Token_Pos355 /= No_Token_Index then

   Row_Pos217 := Token_Pos355;

else
   Row_Pos217 := No_Token_Index;
   goto Exit_Row217_0;

end if;


--  Start or_code

Or_Pos74 := No_Token_Index;
Or_Res74 := No_Bare_Ada_Node;
    
Defer_Res334 :=
   Null_Subp_Decl_Transform_Parse0 (Parser, Row_Pos217);
Defer_Pos334 := Parser.Current_Pos;

    if Defer_Pos334 /= No_Token_Index then
        Or_Pos74 := Defer_Pos334;
        Or_Res74 := Defer_Res334;
        goto Exit_Or75;
    end if;
    
Defer_Res335 :=
   Abstract_Subp_Decl_Transform_Parse0 (Parser, Row_Pos217);
Defer_Pos335 := Parser.Current_Pos;

    if Defer_Pos335 /= No_Token_Index then
        Or_Pos74 := Defer_Pos335;
        Or_Res74 := Defer_Res335;
        goto Exit_Or75;
    end if;
    
Defer_Res336 :=
   Expr_Fn_Transform_Parse0 (Parser, Row_Pos217);
Defer_Pos336 := Parser.Current_Pos;

    if Defer_Pos336 /= No_Token_Index then
        Or_Pos74 := Defer_Pos336;
        Or_Res74 := Defer_Res336;
        goto Exit_Or75;
    end if;
    
Defer_Res337 :=
   Subp_Renaming_Decl_Transform_Parse0 (Parser, Row_Pos217);
Defer_Pos337 := Parser.Current_Pos;

    if Defer_Pos337 /= No_Token_Index then
        Or_Pos74 := Defer_Pos337;
        Or_Res74 := Defer_Res337;
        goto Exit_Or75;
    end if;
    
Defer_Res338 :=
   Generic_Instantiation_Or_Parse1 (Parser, Row_Pos217);
Defer_Pos338 := Parser.Current_Pos;

    if Defer_Pos338 /= No_Token_Index then
        Or_Pos74 := Defer_Pos338;
        Or_Res74 := Defer_Res338;
        goto Exit_Or75;
    end if;
    
Defer_Res339 :=
   Library_Unit_Body_Or_Parse0 (Parser, Row_Pos217);
Defer_Pos339 := Parser.Current_Pos;

    if Defer_Pos339 /= No_Token_Index then
        Or_Pos74 := Defer_Pos339;
        Or_Res74 := Defer_Res339;
        goto Exit_Or75;
    end if;
    
Defer_Res340 :=
   Simple_Subp_Decl_Transform_Parse0 (Parser, Row_Pos217);
Defer_Pos340 := Parser.Current_Pos;

    if Defer_Pos340 /= No_Token_Index then
        Or_Pos74 := Defer_Pos340;
        Or_Res74 := Defer_Res340;
        goto Exit_Or75;
    end if;
    
Defer_Res341 :=
   Library_Unit_Renaming_Decl_Or_Parse0 (Parser, Row_Pos217);
Defer_Pos341 := Parser.Current_Pos;

    if Defer_Pos341 /= No_Token_Index then
        Or_Pos74 := Defer_Pos341;
        Or_Res74 := Defer_Res341;
        goto Exit_Or75;
    end if;
    
Defer_Res342 :=
   Generic_Decl_Or_Parse0 (Parser, Row_Pos217);
Defer_Pos342 := Parser.Current_Pos;

    if Defer_Pos342 /= No_Token_Index then
        Or_Pos74 := Defer_Pos342;
        Or_Res74 := Defer_Res342;
        goto Exit_Or75;
    end if;
    
Defer_Res343 :=
   Package_Decl_Transform_Parse3 (Parser, Row_Pos217);
Defer_Pos343 := Parser.Current_Pos;

    if Defer_Pos343 /= No_Token_Index then
        Or_Pos74 := Defer_Pos343;
        Or_Res74 := Defer_Res343;
        goto Exit_Or75;
    end if;
    
if Get_Token (Parser.TDH.all, Row_Pos217).Kind
   = From_Token_Kind (Ada_Termination)
then
   Skip_Pos1 := No_Token_Index;
   goto Exit_Or76;
end if;

for Fn of Parser.Private_Part.Dont_Skip loop
   Skip_Dummy1 := Fn (Parser, Row_Pos217);

   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos1 := No_Token_Index;
      goto Exit_Or76;
   end if;
end loop;

Skip_Pos1 := Row_Pos217 + 1;

--  Start transform_code

Transform_Diags154 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos218 := Row_Pos217;


pragma Warnings (Off, "referenced");
<<Exit_Row218_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos218 /= No_Token_Index then

   Transform_Res154 := Allocate_Error_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res154,
      Kind => Ada_Error_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos217,
      Token_End_Index   => (if Row_Pos218 = Row_Pos217
                            then No_Token_Index
                            else Row_Pos218 - 1));




elsif Row_Pos218 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags154);
end if;

--  End transform_code

Transform_Res154.Token_End_Index := Row_Pos217;

Append (Parser.Diagnostics,
        Sloc_Range (Parser.TDH.all,
                    Get_Token (Parser.TDH.all, Row_Pos217)),
        To_Text ("Skipped token ")
        & Common.Text
            (Wrap_Token_Reference
               (Parser.Unit.Context,
                Parser.TDH,
                (Row_Pos217, No_Token_Index))));

<<Exit_Or76>>

    if Skip_Pos1 /= No_Token_Index then
        Or_Pos74 := Skip_Pos1;
        Or_Res74 := Transform_Res154;
        goto Exit_Or75;
    end if;
<<Exit_Or75>>

--  End or_code




if Or_Pos74 /= No_Token_Index then

   Row_Pos217 := Or_Pos74;

else
   Row_Pos217 := No_Token_Index;
   goto Exit_Row217_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row217_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos217 /= No_Token_Index then

   Transform_Res155 := Allocate_Library_Item (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res155,
      Kind => Ada_Library_Item,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos217 = Pos
                            then No_Token_Index
                            else Row_Pos217 - 1));

      Initialize_Fields_For_Library_Item
        (Self => Transform_Res155, Library_Item_F_Has_Private => Opt_Res22, Library_Item_F_Item => Or_Res74);

         if Opt_Res22 /= null and then Is_Incomplete (Opt_Res22) then
            Transform_Res155.Last_Attempted_Child := 0;
         elsif Opt_Res22 /= null and then not Is_Ghost (Opt_Res22) then
            Transform_Res155.Last_Attempted_Child := -1;
         end if;
         if Or_Res74 /= null and then Is_Incomplete (Or_Res74) then
            Transform_Res155.Last_Attempted_Child := 0;
         elsif Or_Res74 /= null and then not Is_Ghost (Or_Res74) then
            Transform_Res155.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos217 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags155);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Library_Item_Transform_Parse1_Memo,
      Row_Pos217 /= No_Token_Index,
      Transform_Res155,
      Pos,
      Row_Pos217);


   Parser.Current_Pos := Row_Pos217;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res155;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Library_Item_Transform_Parse1;

   


function Library_Unit_Body_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Body_Node
is
   use Bare_Body_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos344 :
            Token_Index
               := No_Token_Index;
      Defer_Res344 :
            Bare_Subp_Body
               := No_Bare_Ada_Node;
      Defer_Pos345 :
            Token_Index
               := No_Token_Index;
      Defer_Res345 :
            Bare_Package_Body
               := No_Bare_Ada_Node;
      Or_Pos75 :
            Token_Index
               := No_Token_Index;
      Or_Res75 :
            Bare_Body_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Library_Unit_Body_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res75 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res75;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res75;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos75 := No_Token_Index;
Or_Res75 := No_Bare_Ada_Node;
    
Defer_Res344 :=
   Subp_Body_Transform_Parse1 (Parser, Pos);
Defer_Pos344 := Parser.Current_Pos;

    if Defer_Pos344 /= No_Token_Index then
        Or_Pos75 := Defer_Pos344;
        Or_Res75 := Defer_Res344;
        goto Exit_Or77;
    end if;
    
Defer_Res345 :=
   Package_Body_Transform_Parse1 (Parser, Pos);
Defer_Pos345 := Parser.Current_Pos;

    if Defer_Pos345 /= No_Token_Index then
        Or_Pos75 := Defer_Pos345;
        Or_Res75 := Defer_Res345;
        goto Exit_Or77;
    end if;
<<Exit_Or77>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Library_Unit_Body_Or_Parse0_Memo,
      Or_Pos75 /= No_Token_Index,
      Or_Res75,
      Pos,
      Or_Pos75);


   Parser.Current_Pos := Or_Pos75;

   Exit_Call (Parser, Call_Depth);
   return Or_Res75;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Library_Unit_Body_Or_Parse0;

   


function Library_Unit_Renaming_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Decl
is
   use Bare_Basic_Decl_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos346 :
            Token_Index
               := No_Token_Index;
      Defer_Res346 :
            Bare_Package_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos347 :
            Token_Index
               := No_Token_Index;
      Defer_Res347 :
            Bare_Generic_Renaming_Decl
               := No_Bare_Ada_Node;
      Or_Pos76 :
            Token_Index
               := No_Token_Index;
      Or_Res76 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Library_Unit_Renaming_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res76 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res76;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res76;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos76 := No_Token_Index;
Or_Res76 := No_Bare_Ada_Node;
    
Defer_Res346 :=
   Package_Renaming_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos346 := Parser.Current_Pos;

    if Defer_Pos346 /= No_Token_Index then
        Or_Pos76 := Defer_Pos346;
        Or_Res76 := Defer_Res346;
        goto Exit_Or78;
    end if;
    
Defer_Res347 :=
   Generic_Renaming_Decl_Or_Parse1 (Parser, Pos);
Defer_Pos347 := Parser.Current_Pos;

    if Defer_Pos347 /= No_Token_Index then
        Or_Pos76 := Defer_Pos347;
        Or_Res76 := Defer_Res347;
        goto Exit_Or78;
    end if;
<<Exit_Or78>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Library_Unit_Renaming_Decl_Or_Parse0_Memo,
      Or_Pos76 /= No_Token_Index,
      Or_Res76,
      Pos,
      Or_Pos76);


   Parser.Current_Pos := Or_Pos76;

   Exit_Call (Parser, Call_Depth);
   return Or_Res76;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Library_Unit_Renaming_Decl_Or_Parse0;

   


function Loop_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Composite_Stmt
is
   use Bare_Composite_Stmt_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos348 :
            Token_Index
               := No_Token_Index;
      Defer_Res348 :
            Bare_Base_Loop_Stmt
               := No_Bare_Ada_Node;
      Row_Pos219 :
            Token_Index
               := No_Token_Index;
      Row_Pos220 :
            Token_Index
               := No_Token_Index;
      Defer_Pos349 :
            Token_Index
               := No_Token_Index;
      Defer_Res349 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Transform_Res156 :
            Bare_Named_Stmt_Decl
               := No_Bare_Ada_Node;
      Transform_Diags156 :
            Ada.Containers.Count_Type;
      Token_Pos356 :
            Token_Index
               := No_Token_Index;
      Token_Res356 :
            Token_Index
               := No_Token_Index;
      Defer_Pos350 :
            Token_Index
               := No_Token_Index;
      Defer_Res350 :
            Bare_Base_Loop_Stmt
               := No_Bare_Ada_Node;
      Transform_Res157 :
            Bare_Named_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags157 :
            Ada.Containers.Count_Type;
      Or_Pos77 :
            Token_Index
               := No_Token_Index;
      Or_Res77 :
            Bare_Composite_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Loop_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res77 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res77;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res77;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos77 := No_Token_Index;
Or_Res77 := No_Bare_Ada_Node;
    
Defer_Res348 :=
   Iloop_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos348 := Parser.Current_Pos;

    if Defer_Pos348 /= No_Token_Index then
        Or_Pos77 := Defer_Pos348;
        Or_Res77 := Defer_Res348;
        goto Exit_Or79;
    end if;
    
--  Start transform_code

Transform_Diags157 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos219 := Pos;



--  Start transform_code

Transform_Diags156 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos220 := Row_Pos219;



Defer_Res349 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos220);
Defer_Pos349 := Parser.Current_Pos;




if Defer_Pos349 /= No_Token_Index then

   Row_Pos220 := Defer_Pos349;

else
   Row_Pos220 := No_Token_Index;
   goto Exit_Row220_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row220_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos220 /= No_Token_Index then

   Transform_Res156 := Allocate_Named_Stmt_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res156,
      Kind => Ada_Named_Stmt_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos219,
      Token_End_Index   => (if Row_Pos220 = Row_Pos219
                            then No_Token_Index
                            else Row_Pos220 - 1));

      Initialize_Fields_For_Named_Stmt_Decl
        (Self => Transform_Res156, Named_Stmt_Decl_F_Name => Defer_Res349);

         if Defer_Res349 /= null and then Is_Incomplete (Defer_Res349) then
            Transform_Res156.Last_Attempted_Child := 0;
         elsif Defer_Res349 /= null and then not Is_Ghost (Defer_Res349) then
            Transform_Res156.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos220 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags156);
end if;

--  End transform_code




if Row_Pos220 /= No_Token_Index then

   Row_Pos219 := Row_Pos220;

else
   Row_Pos219 := No_Token_Index;
   goto Exit_Row219_0;

end if;


--  Start tok_code

Token_Res356 := Row_Pos219;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res356));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos356 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos219 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos219,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos356 := Row_Pos219 + 1;
   end if;
end;

--  End tok_code




if Token_Pos356 /= No_Token_Index then

   Row_Pos219 := Token_Pos356;

else
   Row_Pos219 := No_Token_Index;
   goto Exit_Row219_0;

end if;


Defer_Res350 :=
   Iloop_Stmt_Or_Parse0 (Parser, Row_Pos219);
Defer_Pos350 := Parser.Current_Pos;




if Defer_Pos350 /= No_Token_Index then

   Row_Pos219 := Defer_Pos350;

else
   Row_Pos219 := No_Token_Index;
   goto Exit_Row219_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row219_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos219 /= No_Token_Index then

   Transform_Res157 := Allocate_Named_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res157,
      Kind => Ada_Named_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos219 = Pos
                            then No_Token_Index
                            else Row_Pos219 - 1));

      Initialize_Fields_For_Named_Stmt
        (Self => Transform_Res157, Named_Stmt_F_Decl => Transform_Res156, Named_Stmt_F_Stmt => Defer_Res350);

         if Transform_Res156 /= null and then Is_Incomplete (Transform_Res156) then
            Transform_Res157.Last_Attempted_Child := 0;
         elsif Transform_Res156 /= null and then not Is_Ghost (Transform_Res156) then
            Transform_Res157.Last_Attempted_Child := -1;
         end if;
         if Defer_Res350 /= null and then Is_Incomplete (Defer_Res350) then
            Transform_Res157.Last_Attempted_Child := 0;
         elsif Defer_Res350 /= null and then not Is_Ghost (Defer_Res350) then
            Transform_Res157.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos219 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags157);
end if;

--  End transform_code

    if Row_Pos219 /= No_Token_Index then
        Or_Pos77 := Row_Pos219;
        Or_Res77 := Transform_Res157;
        goto Exit_Or79;
    end if;
<<Exit_Or79>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Loop_Stmt_Or_Parse0_Memo,
      Or_Pos77 /= No_Token_Index,
      Or_Res77,
      Pos,
      Or_Pos77);


   Parser.Current_Pos := Or_Pos77;

   Exit_Call (Parser, Call_Depth);
   return Or_Res77;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Loop_Stmt_Or_Parse0;

   


function Membership_Choice_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos351 :
            Token_Index
               := No_Token_Index;
      Defer_Res351 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Pos221 :
            Token_Index
               := No_Token_Index;
      Defer_Pos352 :
            Token_Index
               := No_Token_Index;
      Defer_Res352 :
            Bare_Discrete_Subtype_Indication
               := No_Bare_Ada_Node;
      Transform_Res158 :
            Bare_Discrete_Subtype_Name
               := No_Bare_Ada_Node;
      Transform_Diags158 :
            Ada.Containers.Count_Type;
      Defer_Pos353 :
            Token_Index
               := No_Token_Index;
      Defer_Res353 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos78 :
            Token_Index
               := No_Token_Index;
      Or_Res78 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Membership_Choice_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res78 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res78;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res78;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos78 := No_Token_Index;
Or_Res78 := No_Bare_Ada_Node;
    
Defer_Res351 :=
   Discrete_Range_Or_Parse0 (Parser, Pos);
Defer_Pos351 := Parser.Current_Pos;

    if Defer_Pos351 /= No_Token_Index then
        Or_Pos78 := Defer_Pos351;
        Or_Res78 := Defer_Res351;
        goto Exit_Or80;
    end if;
    
--  Start transform_code

Transform_Diags158 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos221 := Pos;



Defer_Res352 :=
   Discrete_Subtype_Indication_Transform_Parse0 (Parser, Row_Pos221);
Defer_Pos352 := Parser.Current_Pos;




if Defer_Pos352 /= No_Token_Index then

   Row_Pos221 := Defer_Pos352;

else
   Row_Pos221 := No_Token_Index;
   goto Exit_Row221_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row221_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos221 /= No_Token_Index then

   Transform_Res158 := Allocate_Discrete_Subtype_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res158,
      Kind => Ada_Discrete_Subtype_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos221 = Pos
                            then No_Token_Index
                            else Row_Pos221 - 1));

      Initialize_Fields_For_Discrete_Subtype_Name
        (Self => Transform_Res158, Discrete_Subtype_Name_F_Subtype => Defer_Res352);

         if Defer_Res352 /= null and then Is_Incomplete (Defer_Res352) then
            Transform_Res158.Last_Attempted_Child := 0;
         elsif Defer_Res352 /= null and then not Is_Ghost (Defer_Res352) then
            Transform_Res158.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos221 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags158);
end if;

--  End transform_code

    if Row_Pos221 /= No_Token_Index then
        Or_Pos78 := Row_Pos221;
        Or_Res78 := Transform_Res158;
        goto Exit_Or80;
    end if;
    
Defer_Res353 :=
   Simple_Expr_Or_Parse1 (Parser, Pos);
Defer_Pos353 := Parser.Current_Pos;

    if Defer_Pos353 /= No_Token_Index then
        Or_Pos78 := Defer_Pos353;
        Or_Res78 := Defer_Res353;
        goto Exit_Or80;
    end if;
<<Exit_Or80>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Membership_Choice_Or_Parse0_Memo,
      Or_Pos78 /= No_Token_Index,
      Or_Res78,
      Pos,
      Or_Pos78);


   Parser.Current_Pos := Or_Pos78;

   Exit_Call (Parser, Call_Depth);
   return Or_Res78;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Membership_Choice_Or_Parse0;

   


function Membership_Choice_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr_Alternatives_List
is
   use Bare_Expr_Alternatives_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos35 :
            Token_Index
               := No_Token_Index;
      Tmp_List35 :
            Free_Parse_List;
      Defer_Pos354 :
            Token_Index
               := No_Token_Index;
      Defer_Res354 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos357 :
            Token_Index
               := No_Token_Index;
      Token_Res357 :
            Token_Index
               := No_Token_Index;
      List_Pos35 :
            Token_Index
               := No_Token_Index;
      List_Res35 :
            Bare_Expr_Alternatives_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Membership_Choice_List_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res35 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res35;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res35;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos35 := No_Token_Index;



Lst_Cpos35 := Pos;
Tmp_List35 := Get_Parse_List (Parser);

loop
   
Defer_Res354 :=
   Membership_Choice_Or_Parse0 (Parser, Lst_Cpos35);
Defer_Pos354 := Parser.Current_Pos;


   exit when Defer_Pos354 = No_Token_Index;

   List_Pos35 := Defer_Pos354;
   Lst_Cpos35 := List_Pos35;

   Tmp_List35.Nodes.Append (Defer_Res354);

      
--  Start tok_code

Token_Res357 := Lst_Cpos35;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res357));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pipe)
   then
       Token_Pos357 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos35 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos35,
             Expected_Token_Id => Ada_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos357 := Lst_Cpos35 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos357 /= No_Token_Index then
          Lst_Cpos35 := Token_Pos357;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List35.Nodes.Length;
begin
   List_Res35 :=
      Allocate_Expr_Alternatives_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos35 = Pos
                    then Pos
                    else Lst_Cpos35 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res35,
      Kind              => Ada_Expr_Alternatives_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res35,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List35.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res35.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List35);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Membership_Choice_List_List_Parse0_Memo,
      List_Pos35 /= No_Token_Index,
      List_Res35,
      Pos,
      List_Pos35);


   Parser.Current_Pos := List_Pos35;

   Exit_Call (Parser, Call_Depth);
   return List_Res35;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Membership_Choice_List_List_Parse0;

   


function Mod_Int_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Mod_Int_Type_Def
is
   use Bare_Mod_Int_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos222 :
            Token_Index
               := No_Token_Index;
      Token_Pos358 :
            Token_Index
               := No_Token_Index;
      Token_Res358 :
            Token_Index
               := No_Token_Index;
      Defer_Pos355 :
            Token_Index
               := No_Token_Index;
      Defer_Res355 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res159 :
            Bare_Mod_Int_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags159 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Mod_Int_Type_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res159 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res159;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res159;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags159 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos222 := Pos;



--  Start tok_code

Token_Res358 := Row_Pos222;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res358));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Mod)
   then
       Token_Pos358 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos222 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos222,
             Expected_Token_Id => Ada_Mod,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos358 := Row_Pos222 + 1;
   end if;
end;

--  End tok_code




if Token_Pos358 /= No_Token_Index then

   Row_Pos222 := Token_Pos358;

else
   Row_Pos222 := No_Token_Index;
   goto Exit_Row222_0;

end if;


Defer_Res355 :=
   Sexpr_Or_Box_Or_Parse0 (Parser, Row_Pos222);
Defer_Pos355 := Parser.Current_Pos;




if Defer_Pos355 /= No_Token_Index then

   Row_Pos222 := Defer_Pos355;

else
   Row_Pos222 := No_Token_Index;
   goto Exit_Row222_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row222_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos222 /= No_Token_Index then

   Transform_Res159 := Allocate_Mod_Int_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res159,
      Kind => Ada_Mod_Int_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos222 = Pos
                            then No_Token_Index
                            else Row_Pos222 - 1));

      Initialize_Fields_For_Mod_Int_Type_Def
        (Self => Transform_Res159, Mod_Int_Type_Def_F_Expr => Defer_Res355);

         if Defer_Res355 /= null and then Is_Incomplete (Defer_Res355) then
            Transform_Res159.Last_Attempted_Child := 0;
         elsif Defer_Res355 /= null and then not Is_Ghost (Defer_Res355) then
            Transform_Res159.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos222 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags159);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Mod_Int_Type_Def_Transform_Parse0_Memo,
      Row_Pos222 /= No_Token_Index,
      Transform_Res159,
      Pos,
      Row_Pos222);


   Parser.Current_Pos := Row_Pos222;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res159;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Mod_Int_Type_Def_Transform_Parse0;

   


function Mode_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Mode
is
   use Bare_Mode_Memos;

   Call_Depth : aliased Natural;

      Row_Pos223 :
            Token_Index
               := No_Token_Index;
      Token_Pos359 :
            Token_Index
               := No_Token_Index;
      Token_Res359 :
            Token_Index
               := No_Token_Index;
      Token_Pos360 :
            Token_Index
               := No_Token_Index;
      Token_Res360 :
            Token_Index
               := No_Token_Index;
      Transform_Res160 :
            Bare_Mode_In_Out
               := No_Bare_Ada_Node;
      Transform_Diags160 :
            Ada.Containers.Count_Type;
      Row_Pos224 :
            Token_Index
               := No_Token_Index;
      Token_Pos361 :
            Token_Index
               := No_Token_Index;
      Token_Res361 :
            Token_Index
               := No_Token_Index;
      Transform_Res161 :
            Bare_Mode_In
               := No_Bare_Ada_Node;
      Transform_Diags161 :
            Ada.Containers.Count_Type;
      Row_Pos225 :
            Token_Index
               := No_Token_Index;
      Token_Pos362 :
            Token_Index
               := No_Token_Index;
      Token_Res362 :
            Token_Index
               := No_Token_Index;
      Transform_Res162 :
            Bare_Mode_Out
               := No_Bare_Ada_Node;
      Transform_Diags162 :
            Ada.Containers.Count_Type;
      Row_Pos226 :
            Token_Index
               := No_Token_Index;
      Transform_Res163 :
            Bare_Mode_Default
               := No_Bare_Ada_Node;
      Transform_Diags163 :
            Ada.Containers.Count_Type;
      Or_Pos79 :
            Token_Index
               := No_Token_Index;
      Or_Res79 :
            Bare_Mode
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Mode_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res79 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res79;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res79;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos79 := No_Token_Index;
Or_Res79 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags160 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos223 := Pos;



--  Start tok_code

Token_Res359 := Row_Pos223;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res359));
begin
   if
      T.Kind /= From_Token_Kind (Ada_In)
   then
       Token_Pos359 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos223 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos223,
             Expected_Token_Id => Ada_In,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos359 := Row_Pos223 + 1;
   end if;
end;

--  End tok_code




if Token_Pos359 /= No_Token_Index then

   Row_Pos223 := Token_Pos359;

else
   Row_Pos223 := No_Token_Index;
   goto Exit_Row223_0;

end if;


--  Start tok_code

Token_Res360 := Row_Pos223;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res360));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Out)
   then
       Token_Pos360 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos223 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos223,
             Expected_Token_Id => Ada_Out,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos360 := Row_Pos223 + 1;
   end if;
end;

--  End tok_code




if Token_Pos360 /= No_Token_Index then

   Row_Pos223 := Token_Pos360;

else
   Row_Pos223 := No_Token_Index;
   goto Exit_Row223_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row223_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos223 /= No_Token_Index then

   Transform_Res160 := Allocate_Mode_In_Out (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res160,
      Kind => Ada_Mode_In_Out,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos223 = Pos
                            then No_Token_Index
                            else Row_Pos223 - 1));




elsif Row_Pos223 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags160);
end if;

--  End transform_code

    if Row_Pos223 /= No_Token_Index then
        Or_Pos79 := Row_Pos223;
        Or_Res79 := Transform_Res160;
        goto Exit_Or81;
    end if;
    
--  Start transform_code

Transform_Diags161 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos224 := Pos;



--  Start tok_code

Token_Res361 := Row_Pos224;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res361));
begin
   if
      T.Kind /= From_Token_Kind (Ada_In)
   then
       Token_Pos361 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos224 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos224,
             Expected_Token_Id => Ada_In,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos361 := Row_Pos224 + 1;
   end if;
end;

--  End tok_code




if Token_Pos361 /= No_Token_Index then

   Row_Pos224 := Token_Pos361;

else
   Row_Pos224 := No_Token_Index;
   goto Exit_Row224_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row224_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos224 /= No_Token_Index then

   Transform_Res161 := Allocate_Mode_In (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res161,
      Kind => Ada_Mode_In,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos224 = Pos
                            then No_Token_Index
                            else Row_Pos224 - 1));




elsif Row_Pos224 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags161);
end if;

--  End transform_code

    if Row_Pos224 /= No_Token_Index then
        Or_Pos79 := Row_Pos224;
        Or_Res79 := Transform_Res161;
        goto Exit_Or81;
    end if;
    
--  Start transform_code

Transform_Diags162 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos225 := Pos;



--  Start tok_code

Token_Res362 := Row_Pos225;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res362));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Out)
   then
       Token_Pos362 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos225 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos225,
             Expected_Token_Id => Ada_Out,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos362 := Row_Pos225 + 1;
   end if;
end;

--  End tok_code




if Token_Pos362 /= No_Token_Index then

   Row_Pos225 := Token_Pos362;

else
   Row_Pos225 := No_Token_Index;
   goto Exit_Row225_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row225_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos225 /= No_Token_Index then

   Transform_Res162 := Allocate_Mode_Out (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res162,
      Kind => Ada_Mode_Out,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos225 = Pos
                            then No_Token_Index
                            else Row_Pos225 - 1));




elsif Row_Pos225 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags162);
end if;

--  End transform_code

    if Row_Pos225 /= No_Token_Index then
        Or_Pos79 := Row_Pos225;
        Or_Res79 := Transform_Res162;
        goto Exit_Or81;
    end if;
    
--  Start transform_code

Transform_Diags163 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos226 := Pos;


pragma Warnings (Off, "referenced");
<<Exit_Row226_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos226 /= No_Token_Index then

   Transform_Res163 := Allocate_Mode_Default (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res163,
      Kind => Ada_Mode_Default,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos226 = Pos
                            then No_Token_Index
                            else Row_Pos226 - 1));




elsif Row_Pos226 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags163);
end if;

--  End transform_code

    if Row_Pos226 /= No_Token_Index then
        Or_Pos79 := Row_Pos226;
        Or_Res79 := Transform_Res163;
        goto Exit_Or81;
    end if;
<<Exit_Or81>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Mode_Or_Parse0_Memo,
      Or_Pos79 /= No_Token_Index,
      Or_Res79,
      Pos,
      Or_Pos79);


   Parser.Current_Pos := Or_Pos79;

   Exit_Call (Parser, Call_Depth);
   return Or_Res79;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Mode_Or_Parse0;

   


function Multi_Abstract_State_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos356 :
            Token_Index
               := No_Token_Index;
      Defer_Res356 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Row_Pos227 :
            Token_Index
               := No_Token_Index;
      Token_Pos363 :
            Token_Index
               := No_Token_Index;
      Token_Res363 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos36 :
            Token_Index
               := No_Token_Index;
      Tmp_List36 :
            Free_Parse_List;
      Defer_Pos357 :
            Token_Index
               := No_Token_Index;
      Defer_Res357 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos364 :
            Token_Index
               := No_Token_Index;
      Token_Res364 :
            Token_Index
               := No_Token_Index;
      List_Pos36 :
            Token_Index
               := No_Token_Index;
      List_Res36 :
            Bare_Abstract_State_Decl_List
               := No_Bare_Ada_Node;
      Token_Pos365 :
            Token_Index
               := No_Token_Index;
      Token_Res365 :
            Token_Index
               := No_Token_Index;
      Transform_Res164 :
            Bare_Multi_Abstract_State_Decl
               := No_Bare_Ada_Node;
      Transform_Diags164 :
            Ada.Containers.Count_Type;
      Or_Pos80 :
            Token_Index
               := No_Token_Index;
      Or_Res80 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Multi_Abstract_State_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res80 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res80;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res80;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos80 := No_Token_Index;
Or_Res80 := No_Bare_Ada_Node;
    
Defer_Res356 :=
   Abstract_State_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos356 := Parser.Current_Pos;

    if Defer_Pos356 /= No_Token_Index then
        Or_Pos80 := Defer_Pos356;
        Or_Res80 := Defer_Res356;
        goto Exit_Or82;
    end if;
    
--  Start transform_code

Transform_Diags164 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos227 := Pos;



--  Start tok_code

Token_Res363 := Row_Pos227;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res363));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos363 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos227 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos227,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos363 := Row_Pos227 + 1;
   end if;
end;

--  End tok_code




if Token_Pos363 /= No_Token_Index then

   Row_Pos227 := Token_Pos363;

else
   Row_Pos227 := No_Token_Index;
   goto Exit_Row227_0;

end if;


--  Start list_code

    List_Pos36 := No_Token_Index;



Lst_Cpos36 := Row_Pos227;
Tmp_List36 := Get_Parse_List (Parser);

loop
   
Defer_Res357 :=
   Abstract_State_Decl_Or_Parse0 (Parser, Lst_Cpos36);
Defer_Pos357 := Parser.Current_Pos;


   exit when Defer_Pos357 = No_Token_Index;

   List_Pos36 := Defer_Pos357;
   Lst_Cpos36 := List_Pos36;

   Tmp_List36.Nodes.Append (Defer_Res357);

      
--  Start tok_code

Token_Res364 := Lst_Cpos36;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res364));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos364 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos36 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos36,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos364 := Lst_Cpos36 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos364 /= No_Token_Index then
          Lst_Cpos36 := Token_Pos364;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List36.Nodes.Length;
begin
   List_Res36 :=
      Allocate_Abstract_State_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos227;
      Token_End := (if Lst_Cpos36 = Row_Pos227
                    then Row_Pos227
                    else Lst_Cpos36 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos227, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res36,
      Kind              => Ada_Abstract_State_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res36,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List36.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res36.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List36);

--  End list_code




if List_Pos36 /= No_Token_Index then

   Row_Pos227 := List_Pos36;

else
   Row_Pos227 := No_Token_Index;
   goto Exit_Row227_0;

end if;


--  Start tok_code

Token_Res365 := Row_Pos227;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res365));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos365 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos227 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos227,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos365 := Row_Pos227 + 1;
   end if;
end;

--  End tok_code




if Token_Pos365 /= No_Token_Index then

   Row_Pos227 := Token_Pos365;

else
   Row_Pos227 := No_Token_Index;
   goto Exit_Row227_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row227_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos227 /= No_Token_Index then

   Transform_Res164 := Allocate_Multi_Abstract_State_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res164,
      Kind => Ada_Multi_Abstract_State_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos227 = Pos
                            then No_Token_Index
                            else Row_Pos227 - 1));

      Initialize_Fields_For_Multi_Abstract_State_Decl
        (Self => Transform_Res164, Multi_Abstract_State_Decl_F_Decls => List_Res36);

         if List_Res36 /= null and then Is_Incomplete (List_Res36) then
            Transform_Res164.Last_Attempted_Child := 0;
         elsif List_Res36 /= null and then not Is_Ghost (List_Res36) then
            Transform_Res164.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos227 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags164);
end if;

--  End transform_code

    if Row_Pos227 /= No_Token_Index then
        Or_Pos80 := Row_Pos227;
        Or_Res80 := Transform_Res164;
        goto Exit_Or82;
    end if;
<<Exit_Or82>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Multi_Abstract_State_Decl_Or_Parse0_Memo,
      Or_Pos80 /= No_Token_Index,
      Or_Res80,
      Pos,
      Or_Pos80);


   Parser.Current_Pos := Or_Pos80;

   Exit_Call (Parser, Call_Depth);
   return Or_Res80;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Multi_Abstract_State_Decl_Or_Parse0;

   


function Multidim_Array_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Multi_Dim_Array_Assoc
is
   use Bare_Multi_Dim_Array_Assoc_Memos;

   Call_Depth : aliased Natural;

      Row_Pos228 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos37 :
            Token_Index
               := No_Token_Index;
      Tmp_List37 :
            Free_Parse_List;
      Defer_Pos358 :
            Token_Index
               := No_Token_Index;
      Defer_Res358 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Token_Pos366 :
            Token_Index
               := No_Token_Index;
      Token_Res366 :
            Token_Index
               := No_Token_Index;
      List_Pos37 :
            Token_Index
               := No_Token_Index;
      List_Res37 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;
      Token_Pos367 :
            Token_Index
               := No_Token_Index;
      Token_Res367 :
            Token_Index
               := No_Token_Index;
      Defer_Pos359 :
            Token_Index
               := No_Token_Index;
      Defer_Res359 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res165 :
            Bare_Multi_Dim_Array_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags165 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Multidim_Array_Assoc_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res165 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res165;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res165;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags165 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos228 := Pos;



--  Start list_code

    List_Pos37 := No_Token_Index;



Lst_Cpos37 := Row_Pos228;
Tmp_List37 := Get_Parse_List (Parser);

loop
   
Defer_Res358 :=
   Aggregate_Or_Parse0 (Parser, Lst_Cpos37);
Defer_Pos358 := Parser.Current_Pos;


   exit when Defer_Pos358 = No_Token_Index;

   List_Pos37 := Defer_Pos358;
   Lst_Cpos37 := List_Pos37;

   Tmp_List37.Nodes.Append (Defer_Res358);

      
--  Start tok_code

Token_Res366 := Lst_Cpos37;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res366));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pipe)
   then
       Token_Pos366 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos37 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos37,
             Expected_Token_Id => Ada_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos366 := Lst_Cpos37 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos366 /= No_Token_Index then
          Lst_Cpos37 := Token_Pos366;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List37.Nodes.Length;
begin
   List_Res37 :=
      Allocate_Alternatives_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos228;
      Token_End := (if Lst_Cpos37 = Row_Pos228
                    then Row_Pos228
                    else Lst_Cpos37 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos228, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res37,
      Kind              => Ada_Alternatives_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res37,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List37.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res37.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List37);

--  End list_code




if List_Pos37 /= No_Token_Index then

   Row_Pos228 := List_Pos37;

else
   Row_Pos228 := No_Token_Index;
   goto Exit_Row228_0;

end if;


--  Start tok_code

Token_Res367 := Row_Pos228;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res367));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos367 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos228 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos228,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos367 := Row_Pos228 + 1;
   end if;
end;

--  End tok_code




if Token_Pos367 /= No_Token_Index then

   Row_Pos228 := Token_Pos367;

else
   Row_Pos228 := No_Token_Index;
   goto Exit_Row228_0;

end if;


Defer_Res359 :=
   Expr_Or_Parse0 (Parser, Row_Pos228);
Defer_Pos359 := Parser.Current_Pos;




if Defer_Pos359 /= No_Token_Index then

   Row_Pos228 := Defer_Pos359;

else
   Row_Pos228 := No_Token_Index;
   goto Exit_Row228_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row228_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos228 /= No_Token_Index then

   Transform_Res165 := Allocate_Multi_Dim_Array_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res165,
      Kind => Ada_Multi_Dim_Array_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos228 = Pos
                            then No_Token_Index
                            else Row_Pos228 - 1));

      Initialize_Fields_For_Multi_Dim_Array_Assoc
        (Self => Transform_Res165, Aggregate_Assoc_F_Designators => List_Res37, Aggregate_Assoc_F_R_Expr => Defer_Res359);

         if List_Res37 /= null and then Is_Incomplete (List_Res37) then
            Transform_Res165.Last_Attempted_Child := 0;
         elsif List_Res37 /= null and then not Is_Ghost (List_Res37) then
            Transform_Res165.Last_Attempted_Child := -1;
         end if;
         if Defer_Res359 /= null and then Is_Incomplete (Defer_Res359) then
            Transform_Res165.Last_Attempted_Child := 0;
         elsif Defer_Res359 /= null and then not Is_Ghost (Defer_Res359) then
            Transform_Res165.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos228 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags165);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Multidim_Array_Assoc_Transform_Parse0_Memo,
      Row_Pos228 /= No_Token_Index,
      Transform_Res165,
      Pos,
      Row_Pos228);


   Parser.Current_Pos := Row_Pos228;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res165;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Multidim_Array_Assoc_Transform_Parse0;

   


function Name_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name
is
   use Bare_Name_Memos;

   Call_Depth : aliased Natural;

      Nobt28 :
            Boolean
               := False;
      Nobt29 :
            Boolean
               := False;
      Row_Pos229 :
            Token_Index
               := No_Token_Index;
      Defer_Pos360 :
            Token_Index
               := No_Token_Index;
      Defer_Res360 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos368 :
            Token_Index
               := No_Token_Index;
      Token_Res368 :
            Token_Index
               := No_Token_Index;
      Defer_Pos361 :
            Token_Index
               := No_Token_Index;
      Defer_Res361 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos369 :
            Token_Index
               := No_Token_Index;
      Token_Res369 :
            Token_Index
               := No_Token_Index;
      Row_Progress25 :
            Integer
               := 0;
      Transform_Res166 :
            Bare_Call_Expr
               := No_Bare_Ada_Node;
      Transform_Has_Failed25 :
            Boolean
               := False;
      Transform_Diags166 :
            Ada.Containers.Count_Type;
      Row_Pos230 :
            Token_Index
               := No_Token_Index;
      Defer_Pos362 :
            Token_Index
               := No_Token_Index;
      Defer_Res362 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos370 :
            Token_Index
               := No_Token_Index;
      Token_Res370 :
            Token_Index
               := No_Token_Index;
      Token_Pos371 :
            Token_Index
               := No_Token_Index;
      Token_Res371 :
            Token_Index
               := No_Token_Index;
      Transform_Res167 :
            Bare_Explicit_Deref
               := No_Bare_Ada_Node;
      Transform_Diags167 :
            Ada.Containers.Count_Type;
      Row_Pos231 :
            Token_Index
               := No_Token_Index;
      Defer_Pos363 :
            Token_Index
               := No_Token_Index;
      Defer_Res363 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos372 :
            Token_Index
               := No_Token_Index;
      Token_Res372 :
            Token_Index
               := No_Token_Index;
      Defer_Pos364 :
            Token_Index
               := No_Token_Index;
      Defer_Res364 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Row_Progress26 :
            Integer
               := 0;
      Transform_Res168 :
            Bare_Dotted_Name
               := No_Bare_Ada_Node;
      Transform_Has_Failed26 :
            Boolean
               := False;
      Transform_Diags168 :
            Ada.Containers.Count_Type;
      Row_Pos232 :
            Token_Index
               := No_Token_Index;
      Defer_Pos365 :
            Token_Index
               := No_Token_Index;
      Defer_Res365 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos373 :
            Token_Index
               := No_Token_Index;
      Token_Res373 :
            Token_Index
               := No_Token_Index;
      Row_Pos233 :
            Token_Index
               := No_Token_Index;
      Token_Pos374 :
            Token_Index
               := No_Token_Index;
      Token_Res374 :
            Token_Index
               := No_Token_Index;
      Transform_Res169 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Diags169 :
            Ada.Containers.Count_Type;
      Defer_Pos366 :
            Token_Index
               := No_Token_Index;
      Defer_Res366 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Transform_Res170 :
            Bare_Update_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags170 :
            Ada.Containers.Count_Type;
      Row_Pos234 :
            Token_Index
               := No_Token_Index;
      Defer_Pos367 :
            Token_Index
               := No_Token_Index;
      Defer_Res367 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos368 :
            Token_Index
               := No_Token_Index;
      Defer_Res368 :
            Bare_Value_Sequence
               := No_Bare_Ada_Node;
      Or_Pos81 :
            Token_Index
               := No_Token_Index;
      Or_Res81 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos375 :
            Token_Index
               := No_Token_Index;
      Token_Res375 :
            Token_Index
               := No_Token_Index;
      Row_Pos235 :
            Token_Index
               := No_Token_Index;
      Token_Pos376 :
            Token_Index
               := No_Token_Index;
      Token_Res376 :
            Token_Index
               := No_Token_Index;
      Transform_Res171 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Diags171 :
            Ada.Containers.Count_Type;
      Token_Pos377 :
            Token_Index
               := No_Token_Index;
      Token_Res377 :
            Token_Index
               := No_Token_Index;
      Defer_Pos369 :
            Token_Index
               := No_Token_Index;
      Defer_Res369 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos378 :
            Token_Index
               := No_Token_Index;
      Token_Res378 :
            Token_Index
               := No_Token_Index;
      Transform_Res172 :
            Bare_Reduce_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags172 :
            Ada.Containers.Count_Type;
      Row_Pos236 :
            Token_Index
               := No_Token_Index;
      Defer_Pos370 :
            Token_Index
               := No_Token_Index;
      Defer_Res370 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos379 :
            Token_Index
               := No_Token_Index;
      Token_Res379 :
            Token_Index
               := No_Token_Index;
      Defer_Pos371 :
            Token_Index
               := No_Token_Index;
      Defer_Res371 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Predicate_Pos1 :
            Token_Index
               := No_Token_Index;
      Predicate_Res1 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Row_Pos237 :
            Token_Index
               := No_Token_Index;
      Token_Pos380 :
            Token_Index
               := No_Token_Index;
      Token_Res380 :
            Token_Index
               := No_Token_Index;
      Defer_Pos372 :
            Token_Index
               := No_Token_Index;
      Defer_Res372 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos381 :
            Token_Index
               := No_Token_Index;
      Token_Res381 :
            Token_Index
               := No_Token_Index;
      Transform_Res173 :
            Bare_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags173 :
            Ada.Containers.Count_Type;
      Row_Pos238 :
            Token_Index
               := No_Token_Index;
      Defer_Pos373 :
            Token_Index
               := No_Token_Index;
      Defer_Res373 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos382 :
            Token_Index
               := No_Token_Index;
      Token_Res382 :
            Token_Index
               := No_Token_Index;
      Defer_Pos374 :
            Token_Index
               := No_Token_Index;
      Defer_Res374 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Null_Res22 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Transform_Res174 :
            Bare_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags174 :
            Ada.Containers.Count_Type;
      Row_Pos239 :
            Token_Index
               := No_Token_Index;
      Defer_Pos375 :
            Token_Index
               := No_Token_Index;
      Defer_Res375 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos383 :
            Token_Index
               := No_Token_Index;
      Token_Res383 :
            Token_Index
               := No_Token_Index;
      Defer_Pos376 :
            Token_Index
               := No_Token_Index;
      Defer_Res376 :
            Bare_Paren_Expr
               := No_Bare_Ada_Node;
      Defer_Pos377 :
            Token_Index
               := No_Token_Index;
      Defer_Res377 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Or_Pos82 :
            Token_Index
               := No_Token_Index;
      Or_Res82 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res175 :
            Bare_Qual_Expr
               := No_Bare_Ada_Node;
      Transform_Diags175 :
            Ada.Containers.Count_Type;
      Defer_Pos378 :
            Token_Index
               := No_Token_Index;
      Defer_Res378 :
            Bare_Name
               := No_Bare_Ada_Node;
      Or_Pos83 :
            Token_Index
               := No_Token_Index;
      Or_Res83 :
            Bare_Name
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Name_Or_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res83 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res83;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res83;
   end if;

       Set (Parser.Private_Part.Name_Or_Parse2_Memo, False, Or_Res83, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt28 := False;
      Nobt29 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos83 := No_Token_Index;
Or_Res83 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags166 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos229 := Pos;



Defer_Res360 :=
   Name_Or_Parse2 (Parser, Row_Pos229);
Defer_Pos360 := Parser.Current_Pos;



Row_Progress25 := 1;

if Defer_Pos360 /= No_Token_Index then

   Row_Pos229 := Defer_Pos360;

else
   Row_Pos229 := No_Token_Index;
   goto Exit_Row229_0;

end if;


--  Start tok_code

Token_Res368 := Row_Pos229;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res368));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos368 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos229 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos229,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos368 := Row_Pos229 + 1;
   end if;
end;

--  End tok_code



Row_Progress25 := 2;

if Token_Pos368 /= No_Token_Index then

   Row_Pos229 := Token_Pos368;

else
   Row_Pos229 := No_Token_Index;
   goto Exit_Row229_0;

end if;

Nobt28 := True;

   Nobt28 := Nobt28;

Row_Progress25 := 3;

if Row_Pos229 /= No_Token_Index then

   Row_Pos229 := Row_Pos229;

else
   Row_Pos229 := No_Token_Index;
   goto Exit_Row229_0;

end if;


Defer_Res361 :=
   Call_Suffix_Or_Parse0 (Parser, Row_Pos229);
Defer_Pos361 := Parser.Current_Pos;



Row_Progress25 := 4;

if Defer_Pos361 /= No_Token_Index then

   Row_Pos229 := Defer_Pos361;

else
   Row_Pos229 := No_Token_Index;
   goto Exit_Row229_0;

end if;


--  Start tok_code

Token_Res369 := Row_Pos229;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res369));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos369 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos229 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos229,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos369 := Row_Pos229 + 1;
   end if;
end;

--  End tok_code



Row_Progress25 := 5;

if Token_Pos369 /= No_Token_Index then

   Row_Pos229 := Token_Pos369;

else
   Row_Pos229 := No_Token_Index;
   goto Exit_Row229_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row229_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos229 = No_Token_Index and then Nobt28 then

   Row_Pos229 := Parser.Last_Fail.Pos;

   Transform_Has_Failed25 := True;
end if;

if Row_Pos229 /= No_Token_Index then

   Transform_Res166 := Allocate_Call_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res166,
      Kind => Ada_Call_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos229 = Pos
                            then No_Token_Index
                            else Row_Pos229 - 1));

      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res166, Call_Expr_F_Name => Defer_Res360, Call_Expr_F_Suffix => Defer_Res361);

         if Defer_Res360 /= null and then Is_Incomplete (Defer_Res360) then
            Transform_Res166.Last_Attempted_Child := 0;
         elsif Defer_Res360 /= null and then not Is_Ghost (Defer_Res360) then
            Transform_Res166.Last_Attempted_Child := -1;
         end if;
         if Defer_Res361 /= null and then Is_Incomplete (Defer_Res361) then
            Transform_Res166.Last_Attempted_Child := 0;
         elsif Defer_Res361 /= null and then not Is_Ghost (Defer_Res361) then
            Transform_Res166.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed25 then
      Transform_Res166.Last_Attempted_Child :=
         Row_Progress25;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <name>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos229 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags166);
end if;

--  End transform_code

    if Row_Pos229 /= No_Token_Index then
        Or_Pos83 := Row_Pos229;
        Or_Res83 := Transform_Res166;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags167 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos230 := Pos;



Defer_Res362 :=
   Name_Or_Parse2 (Parser, Row_Pos230);
Defer_Pos362 := Parser.Current_Pos;




if Defer_Pos362 /= No_Token_Index then

   Row_Pos230 := Defer_Pos362;

else
   Row_Pos230 := No_Token_Index;
   goto Exit_Row230_0;

end if;


--  Start tok_code

Token_Res370 := Row_Pos230;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res370));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Dot)
   then
       Token_Pos370 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos230 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos230,
             Expected_Token_Id => Ada_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos370 := Row_Pos230 + 1;
   end if;
end;

--  End tok_code




if Token_Pos370 /= No_Token_Index then

   Row_Pos230 := Token_Pos370;

else
   Row_Pos230 := No_Token_Index;
   goto Exit_Row230_0;

end if;


--  Start tok_code

Token_Res371 := Row_Pos230;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res371));
begin
   if
      T.Kind /= From_Token_Kind (Ada_All)
   then
       Token_Pos371 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos230 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos230,
             Expected_Token_Id => Ada_All,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos371 := Row_Pos230 + 1;
   end if;
end;

--  End tok_code




if Token_Pos371 /= No_Token_Index then

   Row_Pos230 := Token_Pos371;

else
   Row_Pos230 := No_Token_Index;
   goto Exit_Row230_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row230_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos230 /= No_Token_Index then

   Transform_Res167 := Allocate_Explicit_Deref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res167,
      Kind => Ada_Explicit_Deref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos230 = Pos
                            then No_Token_Index
                            else Row_Pos230 - 1));

      Initialize_Fields_For_Explicit_Deref
        (Self => Transform_Res167, Explicit_Deref_F_Prefix => Defer_Res362);

         if Defer_Res362 /= null and then Is_Incomplete (Defer_Res362) then
            Transform_Res167.Last_Attempted_Child := 0;
         elsif Defer_Res362 /= null and then not Is_Ghost (Defer_Res362) then
            Transform_Res167.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos230 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags167);
end if;

--  End transform_code

    if Row_Pos230 /= No_Token_Index then
        Or_Pos83 := Row_Pos230;
        Or_Res83 := Transform_Res167;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags168 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos231 := Pos;



Defer_Res363 :=
   Name_Or_Parse2 (Parser, Row_Pos231);
Defer_Pos363 := Parser.Current_Pos;



Row_Progress26 := 1;

if Defer_Pos363 /= No_Token_Index then

   Row_Pos231 := Defer_Pos363;

else
   Row_Pos231 := No_Token_Index;
   goto Exit_Row231_0;

end if;


--  Start tok_code

Token_Res372 := Row_Pos231;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res372));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Dot)
   then
       Token_Pos372 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos231 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos231,
             Expected_Token_Id => Ada_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos372 := Row_Pos231 + 1;
   end if;
end;

--  End tok_code



Row_Progress26 := 2;

if Token_Pos372 /= No_Token_Index then

   Row_Pos231 := Token_Pos372;

else
   Row_Pos231 := No_Token_Index;
   goto Exit_Row231_0;

end if;

Nobt29 := True;

   Nobt29 := Nobt29;

Row_Progress26 := 3;

if Row_Pos231 /= No_Token_Index then

   Row_Pos231 := Row_Pos231;

else
   Row_Pos231 := No_Token_Index;
   goto Exit_Row231_0;

end if;


Defer_Res364 :=
   Direct_Name_Or_Parse0 (Parser, Row_Pos231);
Defer_Pos364 := Parser.Current_Pos;



Row_Progress26 := 4;

if Defer_Pos364 /= No_Token_Index then

   Row_Pos231 := Defer_Pos364;

else
   Row_Pos231 := No_Token_Index;
   goto Exit_Row231_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row231_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos231 = No_Token_Index and then Nobt29 then

   Row_Pos231 := Parser.Last_Fail.Pos;

   Transform_Has_Failed26 := True;
end if;

if Row_Pos231 /= No_Token_Index then

   Transform_Res168 := Allocate_Dotted_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res168,
      Kind => Ada_Dotted_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos231 = Pos
                            then No_Token_Index
                            else Row_Pos231 - 1));

      Initialize_Fields_For_Dotted_Name
        (Self => Transform_Res168, Dotted_Name_F_Prefix => Defer_Res363, Dotted_Name_F_Suffix => Defer_Res364);

         if Defer_Res363 /= null and then Is_Incomplete (Defer_Res363) then
            Transform_Res168.Last_Attempted_Child := 0;
         elsif Defer_Res363 /= null and then not Is_Ghost (Defer_Res363) then
            Transform_Res168.Last_Attempted_Child := -1;
         end if;
         if Defer_Res364 /= null and then Is_Incomplete (Defer_Res364) then
            Transform_Res168.Last_Attempted_Child := 0;
         elsif Defer_Res364 /= null and then not Is_Ghost (Defer_Res364) then
            Transform_Res168.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed26 then
      Transform_Res168.Last_Attempted_Child :=
         Row_Progress26;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <name>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos231 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags168);
end if;

--  End transform_code

    if Row_Pos231 /= No_Token_Index then
        Or_Pos83 := Row_Pos231;
        Or_Res83 := Transform_Res168;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags170 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos232 := Pos;



Defer_Res365 :=
   Name_Or_Parse2 (Parser, Row_Pos232);
Defer_Pos365 := Parser.Current_Pos;




if Defer_Pos365 /= No_Token_Index then

   Row_Pos232 := Defer_Pos365;

else
   Row_Pos232 := No_Token_Index;
   goto Exit_Row232_0;

end if;


--  Start tok_code

Token_Res373 := Row_Pos232;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res373));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos373 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos232 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos232,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos373 := Row_Pos232 + 1;
   end if;
end;

--  End tok_code




if Token_Pos373 /= No_Token_Index then

   Row_Pos232 := Token_Pos373;

else
   Row_Pos232 := No_Token_Index;
   goto Exit_Row232_0;

end if;


--  Start transform_code

Transform_Diags169 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos233 := Row_Pos232;



--  Start tok_code

Token_Res374 := Row_Pos233;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res374));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Update)
   then
       Token_Pos374 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos233 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos233,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos374 := Row_Pos233 + 1;
   end if;
end;

--  End tok_code




if Token_Pos374 /= No_Token_Index then

   Row_Pos233 := Token_Pos374;

else
   Row_Pos233 := No_Token_Index;
   goto Exit_Row233_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row233_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos233 /= No_Token_Index then

   Transform_Res169 := Allocate_Identifier (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res169,
      Kind => Ada_Identifier,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos232,
      Token_End_Index   => (if Row_Pos233 = Row_Pos232
                            then No_Token_Index
                            else Row_Pos233 - 1));

      Initialize_Fields_For_Identifier
        (Self => Transform_Res169);



elsif Row_Pos233 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags169);
end if;

--  End transform_code




if Row_Pos233 /= No_Token_Index then

   Row_Pos232 := Row_Pos233;

else
   Row_Pos232 := No_Token_Index;
   goto Exit_Row232_0;

end if;


Defer_Res366 :=
   Update_Attr_Aggregate_Or_Parse0 (Parser, Row_Pos232);
Defer_Pos366 := Parser.Current_Pos;




if Defer_Pos366 /= No_Token_Index then

   Row_Pos232 := Defer_Pos366;

else
   Row_Pos232 := No_Token_Index;
   goto Exit_Row232_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row232_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos232 /= No_Token_Index then

   Transform_Res170 := Allocate_Update_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res170,
      Kind => Ada_Update_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos232 = Pos
                            then No_Token_Index
                            else Row_Pos232 - 1));

      Initialize_Fields_For_Update_Attribute_Ref
        (Self => Transform_Res170, Update_Attribute_Ref_F_Prefix => Defer_Res365, Update_Attribute_Ref_F_Attribute => Transform_Res169, Update_Attribute_Ref_F_Values => Defer_Res366);

         if Defer_Res365 /= null and then Is_Incomplete (Defer_Res365) then
            Transform_Res170.Last_Attempted_Child := 0;
         elsif Defer_Res365 /= null and then not Is_Ghost (Defer_Res365) then
            Transform_Res170.Last_Attempted_Child := -1;
         end if;
         if Transform_Res169 /= null and then Is_Incomplete (Transform_Res169) then
            Transform_Res170.Last_Attempted_Child := 0;
         elsif Transform_Res169 /= null and then not Is_Ghost (Transform_Res169) then
            Transform_Res170.Last_Attempted_Child := -1;
         end if;
         if Defer_Res366 /= null and then Is_Incomplete (Defer_Res366) then
            Transform_Res170.Last_Attempted_Child := 0;
         elsif Defer_Res366 /= null and then not Is_Ghost (Defer_Res366) then
            Transform_Res170.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos232 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags170);
end if;

--  End transform_code

    if Row_Pos232 /= No_Token_Index then
        Or_Pos83 := Row_Pos232;
        Or_Res83 := Transform_Res170;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags172 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos234 := Pos;



--  Start or_code

Or_Pos81 := No_Token_Index;
Or_Res81 := No_Bare_Ada_Node;
    
Defer_Res367 :=
   Name_Or_Parse2 (Parser, Row_Pos234);
Defer_Pos367 := Parser.Current_Pos;

    if Defer_Pos367 /= No_Token_Index then
        Or_Pos81 := Defer_Pos367;
        Or_Res81 := Defer_Res367;
        goto Exit_Or84;
    end if;
    
Defer_Res368 :=
   Value_Sequence_Transform_Parse0 (Parser, Row_Pos234);
Defer_Pos368 := Parser.Current_Pos;

    if Defer_Pos368 /= No_Token_Index then
        Or_Pos81 := Defer_Pos368;
        Or_Res81 := Defer_Res368;
        goto Exit_Or84;
    end if;
<<Exit_Or84>>

--  End or_code




if Or_Pos81 /= No_Token_Index then

   Row_Pos234 := Or_Pos81;

else
   Row_Pos234 := No_Token_Index;
   goto Exit_Row234_0;

end if;


--  Start tok_code

Token_Res375 := Row_Pos234;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res375));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos375 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos234 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos234,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos375 := Row_Pos234 + 1;
   end if;
end;

--  End tok_code




if Token_Pos375 /= No_Token_Index then

   Row_Pos234 := Token_Pos375;

else
   Row_Pos234 := No_Token_Index;
   goto Exit_Row234_0;

end if;


--  Start transform_code

Transform_Diags171 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos235 := Row_Pos234;



--  Start tok_code

Token_Res376 := Row_Pos235;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res376));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Reduce)
   then
       Token_Pos376 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos235 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos235,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos376 := Row_Pos235 + 1;
   end if;
end;

--  End tok_code




if Token_Pos376 /= No_Token_Index then

   Row_Pos235 := Token_Pos376;

else
   Row_Pos235 := No_Token_Index;
   goto Exit_Row235_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row235_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos235 /= No_Token_Index then

   Transform_Res171 := Allocate_Identifier (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res171,
      Kind => Ada_Identifier,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos234,
      Token_End_Index   => (if Row_Pos235 = Row_Pos234
                            then No_Token_Index
                            else Row_Pos235 - 1));

      Initialize_Fields_For_Identifier
        (Self => Transform_Res171);



elsif Row_Pos235 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags171);
end if;

--  End transform_code




if Row_Pos235 /= No_Token_Index then

   Row_Pos234 := Row_Pos235;

else
   Row_Pos234 := No_Token_Index;
   goto Exit_Row234_0;

end if;


--  Start tok_code

Token_Res377 := Row_Pos234;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res377));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos377 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos234 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos234,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos377 := Row_Pos234 + 1;
   end if;
end;

--  End tok_code




if Token_Pos377 /= No_Token_Index then

   Row_Pos234 := Token_Pos377;

else
   Row_Pos234 := No_Token_Index;
   goto Exit_Row234_0;

end if;


Defer_Res369 :=
   Attr_Suffix_List_Parse0 (Parser, Row_Pos234);
Defer_Pos369 := Parser.Current_Pos;




if Defer_Pos369 /= No_Token_Index then

   Row_Pos234 := Defer_Pos369;

else
   Row_Pos234 := No_Token_Index;
   goto Exit_Row234_0;

end if;


--  Start tok_code

Token_Res378 := Row_Pos234;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res378));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos378 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos234 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos234,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos378 := Row_Pos234 + 1;
   end if;
end;

--  End tok_code




if Token_Pos378 /= No_Token_Index then

   Row_Pos234 := Token_Pos378;

else
   Row_Pos234 := No_Token_Index;
   goto Exit_Row234_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row234_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos234 /= No_Token_Index then

   Transform_Res172 := Allocate_Reduce_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res172,
      Kind => Ada_Reduce_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos234 = Pos
                            then No_Token_Index
                            else Row_Pos234 - 1));

      Initialize_Fields_For_Reduce_Attribute_Ref
        (Self => Transform_Res172, Reduce_Attribute_Ref_F_Prefix => Or_Res81, Reduce_Attribute_Ref_F_Attribute => Transform_Res171, Reduce_Attribute_Ref_F_Args => Defer_Res369);

         if Or_Res81 /= null and then Is_Incomplete (Or_Res81) then
            Transform_Res172.Last_Attempted_Child := 0;
         elsif Or_Res81 /= null and then not Is_Ghost (Or_Res81) then
            Transform_Res172.Last_Attempted_Child := -1;
         end if;
         if Transform_Res171 /= null and then Is_Incomplete (Transform_Res171) then
            Transform_Res172.Last_Attempted_Child := 0;
         elsif Transform_Res171 /= null and then not Is_Ghost (Transform_Res171) then
            Transform_Res172.Last_Attempted_Child := -1;
         end if;
         if Defer_Res369 /= null and then Is_Incomplete (Defer_Res369) then
            Transform_Res172.Last_Attempted_Child := 0;
         elsif Defer_Res369 /= null and then not Is_Ghost (Defer_Res369) then
            Transform_Res172.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos234 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags172);
end if;

--  End transform_code

    if Row_Pos234 /= No_Token_Index then
        Or_Pos83 := Row_Pos234;
        Or_Res83 := Transform_Res172;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags173 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos236 := Pos;



Defer_Res370 :=
   Name_Or_Parse2 (Parser, Row_Pos236);
Defer_Pos370 := Parser.Current_Pos;




if Defer_Pos370 /= No_Token_Index then

   Row_Pos236 := Defer_Pos370;

else
   Row_Pos236 := No_Token_Index;
   goto Exit_Row236_0;

end if;


--  Start tok_code

Token_Res379 := Row_Pos236;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res379));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos379 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos236 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos236,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos379 := Row_Pos236 + 1;
   end if;
end;

--  End tok_code




if Token_Pos379 /= No_Token_Index then

   Row_Pos236 := Token_Pos379;

else
   Row_Pos236 := No_Token_Index;
   goto Exit_Row236_0;

end if;


--  Start predicate_code


Defer_Res371 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos236);
Defer_Pos371 := Parser.Current_Pos;


if Defer_Res371 /= null
   and then Identifier_P_Is_Attr_With_Args (Defer_Res371)
then
    Predicate_Res1 := Defer_Res371;
    Predicate_Pos1 := Defer_Pos371;
else
    Predicate_Pos1 := No_Token_Index;
    Predicate_Res1 := null;

    if Parser.Last_Fail.Pos <= Row_Pos236 then
       Parser.Last_Fail :=
         (Kind           => Custom_Fail,
          Pos            => Row_Pos236,
          Custom_Message => Generic_Parsing_Error_Message_Access);
    end if;
end if;

--  End predicate_code




if Predicate_Pos1 /= No_Token_Index then

   Row_Pos236 := Predicate_Pos1;

else
   Row_Pos236 := No_Token_Index;
   goto Exit_Row236_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos237 := Row_Pos236;



--  Start tok_code

Token_Res380 := Row_Pos237;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res380));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos380 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos237 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos237,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos380 := Row_Pos237 + 1;
   end if;
end;

--  End tok_code




if Token_Pos380 /= No_Token_Index then

   Row_Pos237 := Token_Pos380;

else
   Row_Pos237 := No_Token_Index;
   goto Exit_Row237_0;

end if;


Defer_Res372 :=
   Attr_Suffix_List_Parse0 (Parser, Row_Pos237);
Defer_Pos372 := Parser.Current_Pos;




if Defer_Pos372 /= No_Token_Index then

   Row_Pos237 := Defer_Pos372;

else
   Row_Pos237 := No_Token_Index;
   goto Exit_Row237_0;

end if;


--  Start tok_code

Token_Res381 := Row_Pos237;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res381));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos381 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos237 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos237,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos381 := Row_Pos237 + 1;
   end if;
end;

--  End tok_code




if Token_Pos381 /= No_Token_Index then

   Row_Pos237 := Token_Pos381;

else
   Row_Pos237 := No_Token_Index;
   goto Exit_Row237_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row237_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos237 = No_Token_Index then

         
   Defer_Res372 :=
     Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res372,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos236 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res372,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos237 := Row_Pos236;



end if;

--  End opt_code




if Row_Pos237 /= No_Token_Index then

   Row_Pos236 := Row_Pos237;

else
   Row_Pos236 := No_Token_Index;
   goto Exit_Row236_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row236_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos236 /= No_Token_Index then

   Transform_Res173 := Allocate_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res173,
      Kind => Ada_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos236 = Pos
                            then No_Token_Index
                            else Row_Pos236 - 1));

      Initialize_Fields_For_Attribute_Ref
        (Self => Transform_Res173, Attribute_Ref_F_Prefix => Defer_Res370, Attribute_Ref_F_Attribute => Predicate_Res1, Attribute_Ref_F_Args => Defer_Res372);

         if Defer_Res370 /= null and then Is_Incomplete (Defer_Res370) then
            Transform_Res173.Last_Attempted_Child := 0;
         elsif Defer_Res370 /= null and then not Is_Ghost (Defer_Res370) then
            Transform_Res173.Last_Attempted_Child := -1;
         end if;
         if Predicate_Res1 /= null and then Is_Incomplete (Predicate_Res1) then
            Transform_Res173.Last_Attempted_Child := 0;
         elsif Predicate_Res1 /= null and then not Is_Ghost (Predicate_Res1) then
            Transform_Res173.Last_Attempted_Child := -1;
         end if;
         if Defer_Res372 /= null and then Is_Incomplete (Defer_Res372) then
            Transform_Res173.Last_Attempted_Child := 0;
         elsif Defer_Res372 /= null and then not Is_Ghost (Defer_Res372) then
            Transform_Res173.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos236 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags173);
end if;

--  End transform_code

    if Row_Pos236 /= No_Token_Index then
        Or_Pos83 := Row_Pos236;
        Or_Res83 := Transform_Res173;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags174 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos238 := Pos;



Defer_Res373 :=
   Name_Or_Parse2 (Parser, Row_Pos238);
Defer_Pos373 := Parser.Current_Pos;




if Defer_Pos373 /= No_Token_Index then

   Row_Pos238 := Defer_Pos373;

else
   Row_Pos238 := No_Token_Index;
   goto Exit_Row238_0;

end if;


--  Start tok_code

Token_Res382 := Row_Pos238;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res382));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos382 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos238 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos238,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos382 := Row_Pos238 + 1;
   end if;
end;

--  End tok_code




if Token_Pos382 /= No_Token_Index then

   Row_Pos238 := Token_Pos382;

else
   Row_Pos238 := No_Token_Index;
   goto Exit_Row238_0;

end if;


Defer_Res374 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos238);
Defer_Pos374 := Parser.Current_Pos;




if Defer_Pos374 /= No_Token_Index then

   Row_Pos238 := Defer_Pos374;

else
   Row_Pos238 := No_Token_Index;
   goto Exit_Row238_0;

end if;


   Null_Res22 := Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res22,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos238, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res22,
      Parser => Parser,
      Count  => 0);





if Row_Pos238 /= No_Token_Index then

   Row_Pos238 := Row_Pos238;

else
   Row_Pos238 := No_Token_Index;
   goto Exit_Row238_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row238_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos238 /= No_Token_Index then

   Transform_Res174 := Allocate_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res174,
      Kind => Ada_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos238 = Pos
                            then No_Token_Index
                            else Row_Pos238 - 1));

      Initialize_Fields_For_Attribute_Ref
        (Self => Transform_Res174, Attribute_Ref_F_Prefix => Defer_Res373, Attribute_Ref_F_Attribute => Defer_Res374, Attribute_Ref_F_Args => Null_Res22);

         if Defer_Res373 /= null and then Is_Incomplete (Defer_Res373) then
            Transform_Res174.Last_Attempted_Child := 0;
         elsif Defer_Res373 /= null and then not Is_Ghost (Defer_Res373) then
            Transform_Res174.Last_Attempted_Child := -1;
         end if;
         if Defer_Res374 /= null and then Is_Incomplete (Defer_Res374) then
            Transform_Res174.Last_Attempted_Child := 0;
         elsif Defer_Res374 /= null and then not Is_Ghost (Defer_Res374) then
            Transform_Res174.Last_Attempted_Child := -1;
         end if;
         if Null_Res22 /= null and then Is_Incomplete (Null_Res22) then
            Transform_Res174.Last_Attempted_Child := 0;
         elsif Null_Res22 /= null and then not Is_Ghost (Null_Res22) then
            Transform_Res174.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos238 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags174);
end if;

--  End transform_code

    if Row_Pos238 /= No_Token_Index then
        Or_Pos83 := Row_Pos238;
        Or_Res83 := Transform_Res174;
        goto Exit_Or83;
    end if;
    
--  Start transform_code

Transform_Diags175 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos239 := Pos;



Defer_Res375 :=
   Name_Or_Parse2 (Parser, Row_Pos239);
Defer_Pos375 := Parser.Current_Pos;




if Defer_Pos375 /= No_Token_Index then

   Row_Pos239 := Defer_Pos375;

else
   Row_Pos239 := No_Token_Index;
   goto Exit_Row239_0;

end if;


--  Start tok_code

Token_Res383 := Row_Pos239;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res383));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos383 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos239 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos239,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos383 := Row_Pos239 + 1;
   end if;
end;

--  End tok_code




if Token_Pos383 /= No_Token_Index then

   Row_Pos239 := Token_Pos383;

else
   Row_Pos239 := No_Token_Index;
   goto Exit_Row239_0;

end if;


--  Start or_code

Or_Pos82 := No_Token_Index;
Or_Res82 := No_Bare_Ada_Node;
    
Defer_Res376 :=
   Paren_Expr_Transform_Parse0 (Parser, Row_Pos239);
Defer_Pos376 := Parser.Current_Pos;

    if Defer_Pos376 /= No_Token_Index then
        Or_Pos82 := Defer_Pos376;
        Or_Res82 := Defer_Res376;
        goto Exit_Or85;
    end if;
    
Defer_Res377 :=
   Aggregate_Or_Parse0 (Parser, Row_Pos239);
Defer_Pos377 := Parser.Current_Pos;

    if Defer_Pos377 /= No_Token_Index then
        Or_Pos82 := Defer_Pos377;
        Or_Res82 := Defer_Res377;
        goto Exit_Or85;
    end if;
<<Exit_Or85>>

--  End or_code




if Or_Pos82 /= No_Token_Index then

   Row_Pos239 := Or_Pos82;

else
   Row_Pos239 := No_Token_Index;
   goto Exit_Row239_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row239_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos239 /= No_Token_Index then

   Transform_Res175 := Allocate_Qual_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res175,
      Kind => Ada_Qual_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos239 = Pos
                            then No_Token_Index
                            else Row_Pos239 - 1));

      Initialize_Fields_For_Qual_Expr
        (Self => Transform_Res175, Qual_Expr_F_Prefix => Defer_Res375, Qual_Expr_F_Suffix => Or_Res82);

         if Defer_Res375 /= null and then Is_Incomplete (Defer_Res375) then
            Transform_Res175.Last_Attempted_Child := 0;
         elsif Defer_Res375 /= null and then not Is_Ghost (Defer_Res375) then
            Transform_Res175.Last_Attempted_Child := -1;
         end if;
         if Or_Res82 /= null and then Is_Incomplete (Or_Res82) then
            Transform_Res175.Last_Attempted_Child := 0;
         elsif Or_Res82 /= null and then not Is_Ghost (Or_Res82) then
            Transform_Res175.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos239 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags175);
end if;

--  End transform_code

    if Row_Pos239 /= No_Token_Index then
        Or_Pos83 := Row_Pos239;
        Or_Res83 := Transform_Res175;
        goto Exit_Or83;
    end if;
    
Defer_Res378 :=
   Direct_Name_Or_Target_Name_Or_Parse0 (Parser, Pos);
Defer_Pos378 := Parser.Current_Pos;

    if Defer_Pos378 /= No_Token_Index then
        Or_Pos83 := Defer_Pos378;
        Or_Res83 := Defer_Res378;
        goto Exit_Or83;
    end if;
<<Exit_Or83>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos83 > Mem_Pos then
         Mem_Pos := Or_Pos83;
         Mem_Res := Or_Res83;
         Set
           (Parser.Private_Part.Name_Or_Parse2_Memo,
            Or_Pos83 /= No_Token_Index,
            Or_Res83,
            Pos,
            Or_Pos83);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res83 := Mem_Res;
         Or_Pos83 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Name_Or_Parse2_Memo,
      Or_Pos83 /= No_Token_Index,
      Or_Res83,
      Pos,
      Or_Pos83);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos83;

   Exit_Call (Parser, Call_Depth);
   return Or_Res83;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Name_Or_Parse2;

   


function No_Type_Object_Renaming_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_No_Type_Object_Renaming_Decl
is
   use Bare_No_Type_Object_Renaming_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos240 :
            Token_Index
               := No_Token_Index;
      Defer_Pos379 :
            Token_Index
               := No_Token_Index;
      Defer_Res379 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Null_Res23 :
            Bare_Aliased_Node
               := No_Bare_Ada_Node;
      Null_Res24 :
            Bare_Constant_Node
               := No_Bare_Ada_Node;
      Null_Res25 :
            Bare_Mode
               := No_Bare_Ada_Node;
      Null_Res26 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Null_Res27 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos380 :
            Token_Index
               := No_Token_Index;
      Defer_Res380 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Defer_Pos381 :
            Token_Index
               := No_Token_Index;
      Defer_Res381 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos384 :
            Token_Index
               := No_Token_Index;
      Token_Res384 :
            Token_Index
               := No_Token_Index;
      Transform_Res176 :
            Bare_No_Type_Object_Renaming_Decl
               := No_Bare_Ada_Node;
      Transform_Diags176 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.No_Type_Object_Renaming_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res176 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res176;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res176;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags176 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos240 := Pos;



Defer_Res379 :=
   Defining_Id_List_List_Parse0 (Parser, Row_Pos240);
Defer_Pos379 := Parser.Current_Pos;




if Defer_Pos379 /= No_Token_Index then

   Row_Pos240 := Defer_Pos379;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


   Null_Res23 := No_Bare_Ada_Node;




if Row_Pos240 /= No_Token_Index then

   Row_Pos240 := Row_Pos240;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


   Null_Res24 := No_Bare_Ada_Node;




if Row_Pos240 /= No_Token_Index then

   Row_Pos240 := Row_Pos240;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


   Null_Res25 := No_Bare_Ada_Node;




if Row_Pos240 /= No_Token_Index then

   Row_Pos240 := Row_Pos240;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


   Null_Res26 := No_Bare_Ada_Node;




if Row_Pos240 /= No_Token_Index then

   Row_Pos240 := Row_Pos240;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


   Null_Res27 := No_Bare_Ada_Node;




if Row_Pos240 /= No_Token_Index then

   Row_Pos240 := Row_Pos240;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


Defer_Res380 :=
   Renaming_Clause_Transform_Parse0 (Parser, Row_Pos240);
Defer_Pos380 := Parser.Current_Pos;




if Defer_Pos380 /= No_Token_Index then

   Row_Pos240 := Defer_Pos380;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


Defer_Res381 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos240);
Defer_Pos381 := Parser.Current_Pos;




if Defer_Pos381 /= No_Token_Index then

   Row_Pos240 := Defer_Pos381;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;


--  Start tok_code

Token_Res384 := Row_Pos240;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res384));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos384 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos240 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos240,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos384 := Row_Pos240 + 1;
   end if;
end;

--  End tok_code




if Token_Pos384 /= No_Token_Index then

   Row_Pos240 := Token_Pos384;

else
   Row_Pos240 := No_Token_Index;
   goto Exit_Row240_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row240_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos240 /= No_Token_Index then

   Transform_Res176 := Allocate_No_Type_Object_Renaming_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res176,
      Kind => Ada_No_Type_Object_Renaming_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos240 = Pos
                            then No_Token_Index
                            else Row_Pos240 - 1));

      Initialize_Fields_For_No_Type_Object_Renaming_Decl
        (Self => Transform_Res176, Object_Decl_F_Ids => Defer_Res379, Object_Decl_F_Has_Aliased => Null_Res23, Object_Decl_F_Has_Constant => Null_Res24, Object_Decl_F_Mode => Null_Res25, Object_Decl_F_Type_Expr => Null_Res26, Object_Decl_F_Default_Expr => Null_Res27, Object_Decl_F_Renaming_Clause => Defer_Res380, Object_Decl_F_Aspects => Defer_Res381);

         if Defer_Res379 /= null and then Is_Incomplete (Defer_Res379) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Defer_Res379 /= null and then not Is_Ghost (Defer_Res379) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Null_Res23 /= null and then Is_Incomplete (Null_Res23) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Null_Res23 /= null and then not Is_Ghost (Null_Res23) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Null_Res24 /= null and then Is_Incomplete (Null_Res24) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Null_Res24 /= null and then not Is_Ghost (Null_Res24) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Null_Res25 /= null and then Is_Incomplete (Null_Res25) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Null_Res25 /= null and then not Is_Ghost (Null_Res25) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Null_Res26 /= null and then Is_Incomplete (Null_Res26) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Null_Res26 /= null and then not Is_Ghost (Null_Res26) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Null_Res27 /= null and then Is_Incomplete (Null_Res27) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Null_Res27 /= null and then not Is_Ghost (Null_Res27) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Defer_Res380 /= null and then Is_Incomplete (Defer_Res380) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Defer_Res380 /= null and then not Is_Ghost (Defer_Res380) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;
         if Defer_Res381 /= null and then Is_Incomplete (Defer_Res381) then
            Transform_Res176.Last_Attempted_Child := 0;
         elsif Defer_Res381 /= null and then not Is_Ghost (Defer_Res381) then
            Transform_Res176.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos240 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags176);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.No_Type_Object_Renaming_Decl_Transform_Parse0_Memo,
      Row_Pos240 /= No_Token_Index,
      Transform_Res176,
      Pos,
      Row_Pos240);


   Parser.Current_Pos := Row_Pos240;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res176;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end No_Type_Object_Renaming_Decl_Transform_Parse0;

   


function Null_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Literal
is
   use Bare_Null_Literal_Memos;

   Call_Depth : aliased Natural;

      Row_Pos241 :
            Token_Index
               := No_Token_Index;
      Token_Pos385 :
            Token_Index
               := No_Token_Index;
      Token_Res385 :
            Token_Index
               := No_Token_Index;
      Transform_Res177 :
            Bare_Null_Literal
               := No_Bare_Ada_Node;
      Transform_Diags177 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Null_Literal_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res177 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res177;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res177;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags177 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos241 := Pos;



--  Start tok_code

Token_Res385 := Row_Pos241;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res385));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos385 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos241 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos241,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos385 := Row_Pos241 + 1;
   end if;
end;

--  End tok_code




if Token_Pos385 /= No_Token_Index then

   Row_Pos241 := Token_Pos385;

else
   Row_Pos241 := No_Token_Index;
   goto Exit_Row241_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row241_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos241 /= No_Token_Index then

   Transform_Res177 := Allocate_Null_Literal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res177,
      Kind => Ada_Null_Literal,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos241 = Pos
                            then No_Token_Index
                            else Row_Pos241 - 1));

      Initialize_Fields_For_Null_Literal
        (Self => Transform_Res177);



elsif Row_Pos241 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags177);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Null_Literal_Transform_Parse0_Memo,
      Row_Pos241 /= No_Token_Index,
      Transform_Res177,
      Pos,
      Row_Pos241);


   Parser.Current_Pos := Row_Pos241;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res177;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Null_Literal_Transform_Parse0;

   


function Null_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Stmt
is
   use Bare_Null_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos242 :
            Token_Index
               := No_Token_Index;
      Token_Pos386 :
            Token_Index
               := No_Token_Index;
      Token_Res386 :
            Token_Index
               := No_Token_Index;
      Token_Pos387 :
            Token_Index
               := No_Token_Index;
      Token_Res387 :
            Token_Index
               := No_Token_Index;
      Transform_Res178 :
            Bare_Null_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags178 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Null_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res178 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res178;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res178;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags178 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos242 := Pos;



--  Start tok_code

Token_Res386 := Row_Pos242;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res386));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos386 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos242 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos242,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos386 := Row_Pos242 + 1;
   end if;
end;

--  End tok_code




if Token_Pos386 /= No_Token_Index then

   Row_Pos242 := Token_Pos386;

else
   Row_Pos242 := No_Token_Index;
   goto Exit_Row242_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res387 := Row_Pos242;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res387));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos387 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos242 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos242,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos387 := Row_Pos242 + 1;
   end if;
end;

--  End tok_code


if Token_Pos387 = No_Token_Index then

         
   Token_Res387 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos242)),
                To_Text ("Missing ';'"));

       
   Token_Pos387 := Row_Pos242;



end if;

--  End opt_code




if Token_Pos387 /= No_Token_Index then

   Row_Pos242 := Token_Pos387;

else
   Row_Pos242 := No_Token_Index;
   goto Exit_Row242_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row242_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos242 /= No_Token_Index then

   Transform_Res178 := Allocate_Null_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res178,
      Kind => Ada_Null_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos242 = Pos
                            then No_Token_Index
                            else Row_Pos242 - 1));




elsif Row_Pos242 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags178);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Null_Stmt_Transform_Parse0_Memo,
      Row_Pos242 /= No_Token_Index,
      Transform_Res178,
      Pos,
      Row_Pos242);


   Parser.Current_Pos := Row_Pos242;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res178;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Null_Stmt_Transform_Parse0;

   


function Null_Subp_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Subp_Decl
is
   use Bare_Null_Subp_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos243 :
            Token_Index
               := No_Token_Index;
      Defer_Pos382 :
            Token_Index
               := No_Token_Index;
      Defer_Res382 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos383 :
            Token_Index
               := No_Token_Index;
      Defer_Res383 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Token_Pos388 :
            Token_Index
               := No_Token_Index;
      Token_Res388 :
            Token_Index
               := No_Token_Index;
      Token_Pos389 :
            Token_Index
               := No_Token_Index;
      Token_Res389 :
            Token_Index
               := No_Token_Index;
      Defer_Pos384 :
            Token_Index
               := No_Token_Index;
      Defer_Res384 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos390 :
            Token_Index
               := No_Token_Index;
      Token_Res390 :
            Token_Index
               := No_Token_Index;
      Transform_Res179 :
            Bare_Null_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags179 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Null_Subp_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res179 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res179;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res179;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags179 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos243 := Pos;



Defer_Res382 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos243);
Defer_Pos382 := Parser.Current_Pos;




if Defer_Pos382 /= No_Token_Index then

   Row_Pos243 := Defer_Pos382;

else
   Row_Pos243 := No_Token_Index;
   goto Exit_Row243_0;

end if;


Defer_Res383 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos243);
Defer_Pos383 := Parser.Current_Pos;




if Defer_Pos383 /= No_Token_Index then

   Row_Pos243 := Defer_Pos383;

else
   Row_Pos243 := No_Token_Index;
   goto Exit_Row243_0;

end if;


--  Start tok_code

Token_Res388 := Row_Pos243;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res388));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos388 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos243 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos243,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos388 := Row_Pos243 + 1;
   end if;
end;

--  End tok_code




if Token_Pos388 /= No_Token_Index then

   Row_Pos243 := Token_Pos388;

else
   Row_Pos243 := No_Token_Index;
   goto Exit_Row243_0;

end if;


--  Start tok_code

Token_Res389 := Row_Pos243;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res389));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos389 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos243 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos243,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos389 := Row_Pos243 + 1;
   end if;
end;

--  End tok_code




if Token_Pos389 /= No_Token_Index then

   Row_Pos243 := Token_Pos389;

else
   Row_Pos243 := No_Token_Index;
   goto Exit_Row243_0;

end if;


Defer_Res384 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos243);
Defer_Pos384 := Parser.Current_Pos;




if Defer_Pos384 /= No_Token_Index then

   Row_Pos243 := Defer_Pos384;

else
   Row_Pos243 := No_Token_Index;
   goto Exit_Row243_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res390 := Row_Pos243;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res390));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos390 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos243 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos243,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos390 := Row_Pos243 + 1;
   end if;
end;

--  End tok_code


if Token_Pos390 = No_Token_Index then

         
   Token_Res390 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos243)),
                To_Text ("Missing ';'"));

       
   Token_Pos390 := Row_Pos243;



end if;

--  End opt_code




if Token_Pos390 /= No_Token_Index then

   Row_Pos243 := Token_Pos390;

else
   Row_Pos243 := No_Token_Index;
   goto Exit_Row243_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row243_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos243 /= No_Token_Index then

   Transform_Res179 := Allocate_Null_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res179,
      Kind => Ada_Null_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos243 = Pos
                            then No_Token_Index
                            else Row_Pos243 - 1));

      Initialize_Fields_For_Null_Subp_Decl
        (Self => Transform_Res179, Base_Subp_Body_F_Overriding => Defer_Res382, Base_Subp_Body_F_Subp_Spec => Defer_Res383, Null_Subp_Decl_F_Aspects => Defer_Res384);

         if Defer_Res382 /= null and then Is_Incomplete (Defer_Res382) then
            Transform_Res179.Last_Attempted_Child := 0;
         elsif Defer_Res382 /= null and then not Is_Ghost (Defer_Res382) then
            Transform_Res179.Last_Attempted_Child := -1;
         end if;
         if Defer_Res383 /= null and then Is_Incomplete (Defer_Res383) then
            Transform_Res179.Last_Attempted_Child := 0;
         elsif Defer_Res383 /= null and then not Is_Ghost (Defer_Res383) then
            Transform_Res179.Last_Attempted_Child := -1;
         end if;
         if Defer_Res384 /= null and then Is_Incomplete (Defer_Res384) then
            Transform_Res179.Last_Attempted_Child := 0;
         elsif Defer_Res384 /= null and then not Is_Ghost (Defer_Res384) then
            Transform_Res179.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos243 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags179);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Null_Subp_Decl_Transform_Parse0_Memo,
      Row_Pos243 /= No_Token_Index,
      Transform_Res179,
      Pos,
      Row_Pos243);


   Parser.Current_Pos := Row_Pos243;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res179;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Null_Subp_Decl_Transform_Parse0;

   


function Num_Literal_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Num_Literal
is
   use Bare_Num_Literal_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos385 :
            Token_Index
               := No_Token_Index;
      Defer_Res385 :
            Bare_Real_Literal
               := No_Bare_Ada_Node;
      Defer_Pos386 :
            Token_Index
               := No_Token_Index;
      Defer_Res386 :
            Bare_Int_Literal
               := No_Bare_Ada_Node;
      Or_Pos84 :
            Token_Index
               := No_Token_Index;
      Or_Res84 :
            Bare_Num_Literal
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Num_Literal_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res84 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res84;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res84;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos84 := No_Token_Index;
Or_Res84 := No_Bare_Ada_Node;
    
Defer_Res385 :=
   Dec_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos385 := Parser.Current_Pos;

    if Defer_Pos385 /= No_Token_Index then
        Or_Pos84 := Defer_Pos385;
        Or_Res84 := Defer_Res385;
        goto Exit_Or86;
    end if;
    
Defer_Res386 :=
   Int_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos386 := Parser.Current_Pos;

    if Defer_Pos386 /= No_Token_Index then
        Or_Pos84 := Defer_Pos386;
        Or_Res84 := Defer_Res386;
        goto Exit_Or86;
    end if;
<<Exit_Or86>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Num_Literal_Or_Parse0_Memo,
      Or_Pos84 /= No_Token_Index,
      Or_Res84,
      Pos,
      Or_Pos84);


   Parser.Current_Pos := Or_Pos84;

   Exit_Call (Parser, Call_Depth);
   return Or_Res84;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Num_Literal_Or_Parse0;

   


function Number_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Number_Decl
is
   use Bare_Number_Decl_Memos;

   Call_Depth : aliased Natural;

      Nobt30 :
            Boolean
               := False;
      Row_Pos244 :
            Token_Index
               := No_Token_Index;
      Defer_Pos387 :
            Token_Index
               := No_Token_Index;
      Defer_Res387 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos391 :
            Token_Index
               := No_Token_Index;
      Token_Res391 :
            Token_Index
               := No_Token_Index;
      Token_Pos392 :
            Token_Index
               := No_Token_Index;
      Token_Res392 :
            Token_Index
               := No_Token_Index;
      Token_Pos393 :
            Token_Index
               := No_Token_Index;
      Token_Res393 :
            Token_Index
               := No_Token_Index;
      Defer_Pos388 :
            Token_Index
               := No_Token_Index;
      Defer_Res388 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos394 :
            Token_Index
               := No_Token_Index;
      Token_Res394 :
            Token_Index
               := No_Token_Index;
      Row_Progress27 :
            Integer
               := 0;
      Transform_Res180 :
            Bare_Number_Decl
               := No_Bare_Ada_Node;
      Transform_Has_Failed27 :
            Boolean
               := False;
      Transform_Diags180 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Number_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res180 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res180;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res180;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags180 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos244 := Pos;



Defer_Res387 :=
   Defining_Id_List_List_Parse0 (Parser, Row_Pos244);
Defer_Pos387 := Parser.Current_Pos;



Row_Progress27 := 1;

if Defer_Pos387 /= No_Token_Index then

   Row_Pos244 := Defer_Pos387;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;


--  Start tok_code

Token_Res391 := Row_Pos244;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res391));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos391 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos244 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos244,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos391 := Row_Pos244 + 1;
   end if;
end;

--  End tok_code



Row_Progress27 := 2;

if Token_Pos391 /= No_Token_Index then

   Row_Pos244 := Token_Pos391;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;


--  Start tok_code

Token_Res392 := Row_Pos244;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res392));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Constant)
   then
       Token_Pos392 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos244 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos244,
             Expected_Token_Id => Ada_Constant,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos392 := Row_Pos244 + 1;
   end if;
end;

--  End tok_code



Row_Progress27 := 3;

if Token_Pos392 /= No_Token_Index then

   Row_Pos244 := Token_Pos392;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;

Nobt30 := True;

   Nobt30 := Nobt30;

Row_Progress27 := 4;

if Row_Pos244 /= No_Token_Index then

   Row_Pos244 := Row_Pos244;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;


--  Start tok_code

Token_Res393 := Row_Pos244;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res393));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos393 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos244 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos244,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos393 := Row_Pos244 + 1;
   end if;
end;

--  End tok_code



Row_Progress27 := 5;

if Token_Pos393 /= No_Token_Index then

   Row_Pos244 := Token_Pos393;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;


Defer_Res388 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos244);
Defer_Pos388 := Parser.Current_Pos;



Row_Progress27 := 6;

if Defer_Pos388 /= No_Token_Index then

   Row_Pos244 := Defer_Pos388;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res394 := Row_Pos244;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res394));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos394 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos244 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos244,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos394 := Row_Pos244 + 1;
   end if;
end;

--  End tok_code


if Token_Pos394 = No_Token_Index then

         
   Token_Res394 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos244)),
                To_Text ("Missing ';'"));

       
   Token_Pos394 := Row_Pos244;



end if;

--  End opt_code



Row_Progress27 := 7;

if Token_Pos394 /= No_Token_Index then

   Row_Pos244 := Token_Pos394;

else
   Row_Pos244 := No_Token_Index;
   goto Exit_Row244_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row244_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos244 = No_Token_Index and then Nobt30 then

   Row_Pos244 := Parser.Last_Fail.Pos;

   Transform_Has_Failed27 := True;
end if;

if Row_Pos244 /= No_Token_Index then

   Transform_Res180 := Allocate_Number_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res180,
      Kind => Ada_Number_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos244 = Pos
                            then No_Token_Index
                            else Row_Pos244 - 1));

      Initialize_Fields_For_Number_Decl
        (Self => Transform_Res180, Number_Decl_F_Ids => Defer_Res387, Number_Decl_F_Expr => Defer_Res388);

         if Defer_Res387 /= null and then Is_Incomplete (Defer_Res387) then
            Transform_Res180.Last_Attempted_Child := 0;
         elsif Defer_Res387 /= null and then not Is_Ghost (Defer_Res387) then
            Transform_Res180.Last_Attempted_Child := -1;
         end if;
         if Defer_Res388 /= null and then Is_Incomplete (Defer_Res388) then
            Transform_Res180.Last_Attempted_Child := 0;
         elsif Defer_Res388 /= null and then not Is_Ghost (Defer_Res388) then
            Transform_Res180.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed27 then
      Transform_Res180.Last_Attempted_Child :=
         Row_Progress27;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <number_decl>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos244 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags180);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Number_Decl_Transform_Parse0_Memo,
      Row_Pos244 /= No_Token_Index,
      Transform_Res180,
      Pos,
      Row_Pos244);


   Parser.Current_Pos := Row_Pos244;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res180;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Number_Decl_Transform_Parse0;

   


function Object_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Decl
is
   use Bare_Basic_Decl_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos389 :
            Token_Index
               := No_Token_Index;
      Defer_Res389 :
            Bare_Object_Decl
               := No_Bare_Ada_Node;
      Defer_Pos390 :
            Token_Index
               := No_Token_Index;
      Defer_Res390 :
            Bare_No_Type_Object_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos391 :
            Token_Index
               := No_Token_Index;
      Defer_Res391 :
            Bare_Single_Task_Decl
               := No_Bare_Ada_Node;
      Defer_Pos392 :
            Token_Index
               := No_Token_Index;
      Defer_Res392 :
            Bare_Single_Protected_Decl
               := No_Bare_Ada_Node;
      Defer_Pos393 :
            Token_Index
               := No_Token_Index;
      Defer_Res393 :
            Bare_Number_Decl
               := No_Bare_Ada_Node;
      Or_Pos85 :
            Token_Index
               := No_Token_Index;
      Or_Res85 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Object_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res85 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res85;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res85;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos85 := No_Token_Index;
Or_Res85 := No_Bare_Ada_Node;
    
Defer_Res389 :=
   Sub_Object_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos389 := Parser.Current_Pos;

    if Defer_Pos389 /= No_Token_Index then
        Or_Pos85 := Defer_Pos389;
        Or_Res85 := Defer_Res389;
        goto Exit_Or87;
    end if;
    
Defer_Res390 :=
   No_Type_Object_Renaming_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos390 := Parser.Current_Pos;

    if Defer_Pos390 /= No_Token_Index then
        Or_Pos85 := Defer_Pos390;
        Or_Res85 := Defer_Res390;
        goto Exit_Or87;
    end if;
    
Defer_Res391 :=
   Single_Task_Decl_Transform_Parse1 (Parser, Pos);
Defer_Pos391 := Parser.Current_Pos;

    if Defer_Pos391 /= No_Token_Index then
        Or_Pos85 := Defer_Pos391;
        Or_Res85 := Defer_Res391;
        goto Exit_Or87;
    end if;
    
Defer_Res392 :=
   Protected_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos392 := Parser.Current_Pos;

    if Defer_Pos392 /= No_Token_Index then
        Or_Pos85 := Defer_Pos392;
        Or_Res85 := Defer_Res392;
        goto Exit_Or87;
    end if;
    
Defer_Res393 :=
   Number_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos393 := Parser.Current_Pos;

    if Defer_Pos393 /= No_Token_Index then
        Or_Pos85 := Defer_Pos393;
        Or_Res85 := Defer_Res393;
        goto Exit_Or87;
    end if;
<<Exit_Or87>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Object_Decl_Or_Parse0_Memo,
      Or_Pos85 /= No_Token_Index,
      Or_Res85,
      Pos,
      Or_Pos85);


   Parser.Current_Pos := Or_Pos85;

   Exit_Call (Parser, Call_Depth);
   return Or_Res85;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Object_Decl_Or_Parse0;

   


function Ordinary_Fixed_Point_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ordinary_Fixed_Point_Def
is
   use Bare_Ordinary_Fixed_Point_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos245 :
            Token_Index
               := No_Token_Index;
      Token_Pos395 :
            Token_Index
               := No_Token_Index;
      Token_Res395 :
            Token_Index
               := No_Token_Index;
      Defer_Pos394 :
            Token_Index
               := No_Token_Index;
      Defer_Res394 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos395 :
            Token_Index
               := No_Token_Index;
      Defer_Res395 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Res181 :
            Bare_Ordinary_Fixed_Point_Def
               := No_Bare_Ada_Node;
      Transform_Diags181 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Ordinary_Fixed_Point_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res181 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res181;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res181;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags181 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos245 := Pos;



--  Start tok_code

Token_Res395 := Row_Pos245;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res395));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Delta)
   then
       Token_Pos395 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos245 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos245,
             Expected_Token_Id => Ada_Delta,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos395 := Row_Pos245 + 1;
   end if;
end;

--  End tok_code




if Token_Pos395 /= No_Token_Index then

   Row_Pos245 := Token_Pos395;

else
   Row_Pos245 := No_Token_Index;
   goto Exit_Row245_0;

end if;


Defer_Res394 :=
   Sexpr_Or_Box_Or_Parse0 (Parser, Row_Pos245);
Defer_Pos394 := Parser.Current_Pos;




if Defer_Pos394 /= No_Token_Index then

   Row_Pos245 := Defer_Pos394;

else
   Row_Pos245 := No_Token_Index;
   goto Exit_Row245_0;

end if;


--  Start opt_code












Defer_Res395 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos245);
Defer_Pos395 := Parser.Current_Pos;


if Defer_Pos395 = No_Token_Index then

         
   Defer_Res395 := No_Bare_Ada_Node;



       
   Defer_Pos395 := Row_Pos245;



end if;

--  End opt_code




if Defer_Pos395 /= No_Token_Index then

   Row_Pos245 := Defer_Pos395;

else
   Row_Pos245 := No_Token_Index;
   goto Exit_Row245_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row245_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos245 /= No_Token_Index then

   Transform_Res181 := Allocate_Ordinary_Fixed_Point_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res181,
      Kind => Ada_Ordinary_Fixed_Point_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos245 = Pos
                            then No_Token_Index
                            else Row_Pos245 - 1));

      Initialize_Fields_For_Ordinary_Fixed_Point_Def
        (Self => Transform_Res181, Ordinary_Fixed_Point_Def_F_Delta => Defer_Res394, Ordinary_Fixed_Point_Def_F_Range => Defer_Res395);

         if Defer_Res394 /= null and then Is_Incomplete (Defer_Res394) then
            Transform_Res181.Last_Attempted_Child := 0;
         elsif Defer_Res394 /= null and then not Is_Ghost (Defer_Res394) then
            Transform_Res181.Last_Attempted_Child := -1;
         end if;
         if Defer_Res395 /= null and then Is_Incomplete (Defer_Res395) then
            Transform_Res181.Last_Attempted_Child := 0;
         elsif Defer_Res395 /= null and then not Is_Ghost (Defer_Res395) then
            Transform_Res181.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos245 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags181);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Ordinary_Fixed_Point_Def_Transform_Parse0_Memo,
      Row_Pos245 /= No_Token_Index,
      Transform_Res181,
      Pos,
      Row_Pos245);


   Parser.Current_Pos := Row_Pos245;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res181;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Ordinary_Fixed_Point_Def_Transform_Parse0;

   


function Others_Designator_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Others_Designator
is
   use Bare_Others_Designator_Memos;

   Call_Depth : aliased Natural;

      Row_Pos246 :
            Token_Index
               := No_Token_Index;
      Token_Pos396 :
            Token_Index
               := No_Token_Index;
      Token_Res396 :
            Token_Index
               := No_Token_Index;
      Transform_Res182 :
            Bare_Others_Designator
               := No_Bare_Ada_Node;
      Transform_Diags182 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Others_Designator_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res182 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res182;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res182;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags182 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos246 := Pos;



--  Start tok_code

Token_Res396 := Row_Pos246;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res396));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Others)
   then
       Token_Pos396 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos246 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos246,
             Expected_Token_Id => Ada_Others,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos396 := Row_Pos246 + 1;
   end if;
end;

--  End tok_code




if Token_Pos396 /= No_Token_Index then

   Row_Pos246 := Token_Pos396;

else
   Row_Pos246 := No_Token_Index;
   goto Exit_Row246_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row246_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos246 /= No_Token_Index then

   Transform_Res182 := Allocate_Others_Designator (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res182,
      Kind => Ada_Others_Designator,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos246 = Pos
                            then No_Token_Index
                            else Row_Pos246 - 1));




elsif Row_Pos246 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags182);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Others_Designator_Transform_Parse0_Memo,
      Row_Pos246 /= No_Token_Index,
      Transform_Res182,
      Pos,
      Row_Pos246);


   Parser.Current_Pos := Row_Pos246;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res182;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Others_Designator_Transform_Parse0;

   


function Overriding_Indicator_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Overriding_Node
is
   use Bare_Overriding_Node_Memos;

   Call_Depth : aliased Natural;

      Row_Pos247 :
            Token_Index
               := No_Token_Index;
      Token_Pos397 :
            Token_Index
               := No_Token_Index;
      Token_Res397 :
            Token_Index
               := No_Token_Index;
      Transform_Res183 :
            Bare_Overriding_Overriding
               := No_Bare_Ada_Node;
      Transform_Diags183 :
            Ada.Containers.Count_Type;
      Row_Pos248 :
            Token_Index
               := No_Token_Index;
      Token_Pos398 :
            Token_Index
               := No_Token_Index;
      Token_Res398 :
            Token_Index
               := No_Token_Index;
      Token_Pos399 :
            Token_Index
               := No_Token_Index;
      Token_Res399 :
            Token_Index
               := No_Token_Index;
      Transform_Res184 :
            Bare_Overriding_Not_Overriding
               := No_Bare_Ada_Node;
      Transform_Diags184 :
            Ada.Containers.Count_Type;
      Row_Pos249 :
            Token_Index
               := No_Token_Index;
      Transform_Res185 :
            Bare_Overriding_Unspecified
               := No_Bare_Ada_Node;
      Transform_Diags185 :
            Ada.Containers.Count_Type;
      Or_Pos86 :
            Token_Index
               := No_Token_Index;
      Or_Res86 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Overriding_Indicator_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res86 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res86;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res86;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos86 := No_Token_Index;
Or_Res86 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags183 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos247 := Pos;



--  Start tok_code

Token_Res397 := Row_Pos247;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res397));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Overriding)
   then
       Token_Pos397 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos247 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos247,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos397 := Row_Pos247 + 1;
   end if;
end;

--  End tok_code




if Token_Pos397 /= No_Token_Index then

   Row_Pos247 := Token_Pos397;

else
   Row_Pos247 := No_Token_Index;
   goto Exit_Row247_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row247_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos247 /= No_Token_Index then

   Transform_Res183 := Allocate_Overriding_Overriding (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res183,
      Kind => Ada_Overriding_Overriding,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos247 = Pos
                            then No_Token_Index
                            else Row_Pos247 - 1));




elsif Row_Pos247 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags183);
end if;

--  End transform_code

    if Row_Pos247 /= No_Token_Index then
        Or_Pos86 := Row_Pos247;
        Or_Res86 := Transform_Res183;
        goto Exit_Or88;
    end if;
    
--  Start transform_code

Transform_Diags184 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos248 := Pos;



--  Start tok_code

Token_Res398 := Row_Pos248;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res398));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos398 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos248 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos248,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos398 := Row_Pos248 + 1;
   end if;
end;

--  End tok_code




if Token_Pos398 /= No_Token_Index then

   Row_Pos248 := Token_Pos398;

else
   Row_Pos248 := No_Token_Index;
   goto Exit_Row248_0;

end if;


--  Start tok_code

Token_Res399 := Row_Pos248;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res399));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Overriding)
   then
       Token_Pos399 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos248 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos248,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos399 := Row_Pos248 + 1;
   end if;
end;

--  End tok_code




if Token_Pos399 /= No_Token_Index then

   Row_Pos248 := Token_Pos399;

else
   Row_Pos248 := No_Token_Index;
   goto Exit_Row248_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row248_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos248 /= No_Token_Index then

   Transform_Res184 := Allocate_Overriding_Not_Overriding (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res184,
      Kind => Ada_Overriding_Not_Overriding,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos248 = Pos
                            then No_Token_Index
                            else Row_Pos248 - 1));




elsif Row_Pos248 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags184);
end if;

--  End transform_code

    if Row_Pos248 /= No_Token_Index then
        Or_Pos86 := Row_Pos248;
        Or_Res86 := Transform_Res184;
        goto Exit_Or88;
    end if;
    
--  Start transform_code

Transform_Diags185 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos249 := Pos;


pragma Warnings (Off, "referenced");
<<Exit_Row249_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos249 /= No_Token_Index then

   Transform_Res185 := Allocate_Overriding_Unspecified (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res185,
      Kind => Ada_Overriding_Unspecified,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos249 = Pos
                            then No_Token_Index
                            else Row_Pos249 - 1));




elsif Row_Pos249 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags185);
end if;

--  End transform_code

    if Row_Pos249 /= No_Token_Index then
        Or_Pos86 := Row_Pos249;
        Or_Res86 := Transform_Res185;
        goto Exit_Or88;
    end if;
<<Exit_Or88>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Overriding_Indicator_Or_Parse0_Memo,
      Or_Pos86 /= No_Token_Index,
      Or_Res86,
      Pos,
      Or_Pos86);


   Parser.Current_Pos := Or_Pos86;

   Exit_Call (Parser, Call_Depth);
   return Or_Res86;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Overriding_Indicator_Or_Parse0;

   


function Package_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Body
is
   use Bare_Package_Body_Memos;

   Call_Depth : aliased Natural;

      Nobt31 :
            Boolean
               := False;
      Row_Pos250 :
            Token_Index
               := No_Token_Index;
      Token_Pos400 :
            Token_Index
               := No_Token_Index;
      Token_Res400 :
            Token_Index
               := No_Token_Index;
      Token_Pos401 :
            Token_Index
               := No_Token_Index;
      Token_Res401 :
            Token_Index
               := No_Token_Index;
      Defer_Pos396 :
            Token_Index
               := No_Token_Index;
      Defer_Res396 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos397 :
            Token_Index
               := No_Token_Index;
      Defer_Res397 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos402 :
            Token_Index
               := No_Token_Index;
      Token_Res402 :
            Token_Index
               := No_Token_Index;
      Defer_Pos398 :
            Token_Index
               := No_Token_Index;
      Defer_Res398 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Row_Pos251 :
            Token_Index
               := No_Token_Index;
      Token_Pos403 :
            Token_Index
               := No_Token_Index;
      Token_Res403 :
            Token_Index
               := No_Token_Index;
      Defer_Pos399 :
            Token_Index
               := No_Token_Index;
      Defer_Res399 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos252 :
            Token_Index
               := No_Token_Index;
      Token_Pos404 :
            Token_Index
               := No_Token_Index;
      Token_Res404 :
            Token_Index
               := No_Token_Index;
      Row_Pos253 :
            Token_Index
               := No_Token_Index;
      Defer_Pos400 :
            Token_Index
               := No_Token_Index;
      Defer_Res400 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res186 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags186 :
            Ada.Containers.Count_Type;
      Token_Pos405 :
            Token_Index
               := No_Token_Index;
      Token_Res405 :
            Token_Index
               := No_Token_Index;
      Row_Progress28 :
            Integer
               := 0;
      Transform_Res187 :
            Bare_Package_Body
               := No_Bare_Ada_Node;
      Transform_Has_Failed28 :
            Boolean
               := False;
      Transform_Diags187 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Package_Body_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res187 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res187;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res187;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags187 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos250 := Pos;



--  Start tok_code

Token_Res400 := Row_Pos250;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res400));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos400 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos250 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos250,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos400 := Row_Pos250 + 1;
   end if;
end;

--  End tok_code



Row_Progress28 := 1;

if Token_Pos400 /= No_Token_Index then

   Row_Pos250 := Token_Pos400;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


--  Start tok_code

Token_Res401 := Row_Pos250;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res401));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Body)
   then
       Token_Pos401 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos250 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos250,
             Expected_Token_Id => Ada_Body,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos401 := Row_Pos250 + 1;
   end if;
end;

--  End tok_code



Row_Progress28 := 2;

if Token_Pos401 /= No_Token_Index then

   Row_Pos250 := Token_Pos401;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;

Nobt31 := True;

   Nobt31 := Nobt31;

Row_Progress28 := 3;

if Row_Pos250 /= No_Token_Index then

   Row_Pos250 := Row_Pos250;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


Defer_Res396 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos250);
Defer_Pos396 := Parser.Current_Pos;



Row_Progress28 := 4;

if Defer_Pos396 /= No_Token_Index then

   Row_Pos250 := Defer_Pos396;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


Defer_Res397 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos250);
Defer_Pos397 := Parser.Current_Pos;



Row_Progress28 := 5;

if Defer_Pos397 /= No_Token_Index then

   Row_Pos250 := Defer_Pos397;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


--  Start tok_code

Token_Res402 := Row_Pos250;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res402));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos402 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos250 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos250,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos402 := Row_Pos250 + 1;
   end if;
end;

--  End tok_code



Row_Progress28 := 6;

if Token_Pos402 /= No_Token_Index then

   Row_Pos250 := Token_Pos402;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Package_Body0_Extract_Parse0'Access);
        
Defer_Res398 :=
   Decl_Part_Transform_Parse0 (Parser, Row_Pos250);
Defer_Pos398 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        


Row_Progress28 := 7;

if Defer_Pos398 /= No_Token_Index then

   Row_Pos250 := Defer_Pos398;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos251 := Row_Pos250;



--  Start tok_code

Token_Res403 := Row_Pos251;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res403));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos403 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos251 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos251,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos403 := Row_Pos251 + 1;
   end if;
end;

--  End tok_code




if Token_Pos403 /= No_Token_Index then

   Row_Pos251 := Token_Pos403;

else
   Row_Pos251 := No_Token_Index;
   goto Exit_Row251_0;

end if;


Defer_Res399 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos251);
Defer_Pos399 := Parser.Current_Pos;




if Defer_Pos399 /= No_Token_Index then

   Row_Pos251 := Defer_Pos399;

else
   Row_Pos251 := No_Token_Index;
   goto Exit_Row251_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row251_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos251 = No_Token_Index then

         
   Defer_Res399 := No_Bare_Ada_Node;



       
   Row_Pos251 := Row_Pos250;



end if;

--  End opt_code



Row_Progress28 := 8;

if Row_Pos251 /= No_Token_Index then

   Row_Pos250 := Row_Pos251;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


--  Start row_code

Row_Pos252 := Row_Pos250;



--  Start tok_code

Token_Res404 := Row_Pos252;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res404));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos404 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos252 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos252,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos404 := Row_Pos252 + 1;
   end if;
end;

--  End tok_code




if Token_Pos404 /= No_Token_Index then

   Row_Pos252 := Token_Pos404;

else
   Row_Pos252 := No_Token_Index;
   goto Exit_Row252_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags186 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos253 := Row_Pos252;



Defer_Res400 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos253);
Defer_Pos400 := Parser.Current_Pos;




if Defer_Pos400 /= No_Token_Index then

   Row_Pos253 := Defer_Pos400;

else
   Row_Pos253 := No_Token_Index;
   goto Exit_Row253_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row253_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos253 /= No_Token_Index then

   Transform_Res186 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res186,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos252,
      Token_End_Index   => (if Row_Pos253 = Row_Pos252
                            then No_Token_Index
                            else Row_Pos253 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res186, End_Name_F_Name => Defer_Res400);

         if Defer_Res400 /= null and then Is_Incomplete (Defer_Res400) then
            Transform_Res186.Last_Attempted_Child := 0;
         elsif Defer_Res400 /= null and then not Is_Ghost (Defer_Res400) then
            Transform_Res186.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos253 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags186);
end if;

--  End transform_code


if Row_Pos253 = No_Token_Index then

         
   Transform_Res186 := No_Bare_Ada_Node;



       
   Row_Pos253 := Row_Pos252;



end if;

--  End opt_code




if Row_Pos253 /= No_Token_Index then

   Row_Pos252 := Row_Pos253;

else
   Row_Pos252 := No_Token_Index;
   goto Exit_Row252_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row252_0>>
pragma Warnings (On, "referenced");

--  End row_code



Row_Progress28 := 9;

if Row_Pos252 /= No_Token_Index then

   Row_Pos250 := Row_Pos252;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;


--  Start tok_code

Token_Res405 := Row_Pos250;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res405));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos405 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos250 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos250,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos405 := Row_Pos250 + 1;
   end if;
end;

--  End tok_code



Row_Progress28 := 10;

if Token_Pos405 /= No_Token_Index then

   Row_Pos250 := Token_Pos405;

else
   Row_Pos250 := No_Token_Index;
   goto Exit_Row250_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row250_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos250 = No_Token_Index and then Nobt31 then

   Row_Pos250 := Parser.Last_Fail.Pos;

   Transform_Has_Failed28 := True;
end if;

if Row_Pos250 /= No_Token_Index then

   Transform_Res187 := Allocate_Package_Body (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res187,
      Kind => Ada_Package_Body,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos250 = Pos
                            then No_Token_Index
                            else Row_Pos250 - 1));

      Initialize_Fields_For_Package_Body
        (Self => Transform_Res187, Package_Body_F_Package_Name => Defer_Res396, Package_Body_F_Aspects => Defer_Res397, Package_Body_F_Decls => Defer_Res398, Package_Body_F_Stmts => Defer_Res399, Package_Body_F_End_Name => Transform_Res186);

         if Defer_Res396 /= null and then Is_Incomplete (Defer_Res396) then
            Transform_Res187.Last_Attempted_Child := 0;
         elsif Defer_Res396 /= null and then not Is_Ghost (Defer_Res396) then
            Transform_Res187.Last_Attempted_Child := -1;
         end if;
         if Defer_Res397 /= null and then Is_Incomplete (Defer_Res397) then
            Transform_Res187.Last_Attempted_Child := 0;
         elsif Defer_Res397 /= null and then not Is_Ghost (Defer_Res397) then
            Transform_Res187.Last_Attempted_Child := -1;
         end if;
         if Defer_Res398 /= null and then Is_Incomplete (Defer_Res398) then
            Transform_Res187.Last_Attempted_Child := 0;
         elsif Defer_Res398 /= null and then not Is_Ghost (Defer_Res398) then
            Transform_Res187.Last_Attempted_Child := -1;
         end if;
         if Defer_Res399 /= null and then Is_Incomplete (Defer_Res399) then
            Transform_Res187.Last_Attempted_Child := 0;
         elsif Defer_Res399 /= null and then not Is_Ghost (Defer_Res399) then
            Transform_Res187.Last_Attempted_Child := -1;
         end if;
         if Transform_Res186 /= null and then Is_Incomplete (Transform_Res186) then
            Transform_Res187.Last_Attempted_Child := 0;
         elsif Transform_Res186 /= null and then not Is_Ghost (Transform_Res186) then
            Transform_Res187.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed28 then
      Transform_Res187.Last_Attempted_Child :=
         Row_Progress28;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <package_body>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos250 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags187);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Package_Body_Transform_Parse1_Memo,
      Row_Pos250 /= No_Token_Index,
      Transform_Res187,
      Pos,
      Row_Pos250);


   Parser.Current_Pos := Row_Pos250;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res187;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Package_Body_Transform_Parse1;

   


function Package_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Body_Stub
is
   use Bare_Package_Body_Stub_Memos;

   Call_Depth : aliased Natural;

      Row_Pos254 :
            Token_Index
               := No_Token_Index;
      Token_Pos406 :
            Token_Index
               := No_Token_Index;
      Token_Res406 :
            Token_Index
               := No_Token_Index;
      Token_Pos407 :
            Token_Index
               := No_Token_Index;
      Token_Res407 :
            Token_Index
               := No_Token_Index;
      Defer_Pos401 :
            Token_Index
               := No_Token_Index;
      Defer_Res401 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos408 :
            Token_Index
               := No_Token_Index;
      Token_Res408 :
            Token_Index
               := No_Token_Index;
      Token_Pos409 :
            Token_Index
               := No_Token_Index;
      Token_Res409 :
            Token_Index
               := No_Token_Index;
      Defer_Pos402 :
            Token_Index
               := No_Token_Index;
      Defer_Res402 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos410 :
            Token_Index
               := No_Token_Index;
      Token_Res410 :
            Token_Index
               := No_Token_Index;
      Transform_Res188 :
            Bare_Package_Body_Stub
               := No_Bare_Ada_Node;
      Transform_Diags188 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Package_Body_Stub_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res188 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res188;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res188;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags188 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos254 := Pos;



--  Start tok_code

Token_Res406 := Row_Pos254;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res406));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos406 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos254 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos254,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos406 := Row_Pos254 + 1;
   end if;
end;

--  End tok_code




if Token_Pos406 /= No_Token_Index then

   Row_Pos254 := Token_Pos406;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;


--  Start tok_code

Token_Res407 := Row_Pos254;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res407));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Body)
   then
       Token_Pos407 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos254 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos254,
             Expected_Token_Id => Ada_Body,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos407 := Row_Pos254 + 1;
   end if;
end;

--  End tok_code




if Token_Pos407 /= No_Token_Index then

   Row_Pos254 := Token_Pos407;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;


Defer_Res401 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos254);
Defer_Pos401 := Parser.Current_Pos;




if Defer_Pos401 /= No_Token_Index then

   Row_Pos254 := Defer_Pos401;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;


--  Start tok_code

Token_Res408 := Row_Pos254;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res408));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos408 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos254 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos254,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos408 := Row_Pos254 + 1;
   end if;
end;

--  End tok_code




if Token_Pos408 /= No_Token_Index then

   Row_Pos254 := Token_Pos408;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;


--  Start tok_code

Token_Res409 := Row_Pos254;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res409));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Separate)
   then
       Token_Pos409 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos254 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos254,
             Expected_Token_Id => Ada_Separate,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos409 := Row_Pos254 + 1;
   end if;
end;

--  End tok_code




if Token_Pos409 /= No_Token_Index then

   Row_Pos254 := Token_Pos409;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;


Defer_Res402 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos254);
Defer_Pos402 := Parser.Current_Pos;




if Defer_Pos402 /= No_Token_Index then

   Row_Pos254 := Defer_Pos402;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res410 := Row_Pos254;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res410));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos410 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos254 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos254,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos410 := Row_Pos254 + 1;
   end if;
end;

--  End tok_code


if Token_Pos410 = No_Token_Index then

         
   Token_Res410 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos254)),
                To_Text ("Missing ';'"));

       
   Token_Pos410 := Row_Pos254;



end if;

--  End opt_code




if Token_Pos410 /= No_Token_Index then

   Row_Pos254 := Token_Pos410;

else
   Row_Pos254 := No_Token_Index;
   goto Exit_Row254_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row254_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos254 /= No_Token_Index then

   Transform_Res188 := Allocate_Package_Body_Stub (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res188,
      Kind => Ada_Package_Body_Stub,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos254 = Pos
                            then No_Token_Index
                            else Row_Pos254 - 1));

      Initialize_Fields_For_Package_Body_Stub
        (Self => Transform_Res188, Package_Body_Stub_F_Name => Defer_Res401, Package_Body_Stub_F_Aspects => Defer_Res402);

         if Defer_Res401 /= null and then Is_Incomplete (Defer_Res401) then
            Transform_Res188.Last_Attempted_Child := 0;
         elsif Defer_Res401 /= null and then not Is_Ghost (Defer_Res401) then
            Transform_Res188.Last_Attempted_Child := -1;
         end if;
         if Defer_Res402 /= null and then Is_Incomplete (Defer_Res402) then
            Transform_Res188.Last_Attempted_Child := 0;
         elsif Defer_Res402 /= null and then not Is_Ghost (Defer_Res402) then
            Transform_Res188.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos254 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags188);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Package_Body_Stub_Transform_Parse0_Memo,
      Row_Pos254 /= No_Token_Index,
      Transform_Res188,
      Pos,
      Row_Pos254);


   Parser.Current_Pos := Row_Pos254;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res188;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Package_Body_Stub_Transform_Parse0;

   


function Package_Decl_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Decl
is
   use Bare_Package_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos255 :
            Token_Index
               := No_Token_Index;
      Token_Pos411 :
            Token_Index
               := No_Token_Index;
      Token_Res411 :
            Token_Index
               := No_Token_Index;
      Defer_Pos403 :
            Token_Index
               := No_Token_Index;
      Defer_Res403 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos404 :
            Token_Index
               := No_Token_Index;
      Defer_Res404 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos412 :
            Token_Index
               := No_Token_Index;
      Token_Res412 :
            Token_Index
               := No_Token_Index;
      Row_Pos256 :
            Token_Index
               := No_Token_Index;
      Defer_Pos405 :
            Token_Index
               := No_Token_Index;
      Defer_Res405 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res189 :
            Bare_Public_Part
               := No_Bare_Ada_Node;
      Transform_Diags189 :
            Ada.Containers.Count_Type;
      Row_Pos257 :
            Token_Index
               := No_Token_Index;
      Token_Pos413 :
            Token_Index
               := No_Token_Index;
      Token_Res413 :
            Token_Index
               := No_Token_Index;
      Row_Pos258 :
            Token_Index
               := No_Token_Index;
      Defer_Pos406 :
            Token_Index
               := No_Token_Index;
      Defer_Res406 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Transform_Res190 :
            Bare_Private_Part
               := No_Bare_Ada_Node;
      Transform_Diags190 :
            Ada.Containers.Count_Type;
      Row_Pos259 :
            Token_Index
               := No_Token_Index;
      Token_Pos414 :
            Token_Index
               := No_Token_Index;
      Token_Res414 :
            Token_Index
               := No_Token_Index;
      Row_Pos260 :
            Token_Index
               := No_Token_Index;
      Defer_Pos407 :
            Token_Index
               := No_Token_Index;
      Defer_Res407 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res191 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags191 :
            Ada.Containers.Count_Type;
      Token_Pos415 :
            Token_Index
               := No_Token_Index;
      Token_Res415 :
            Token_Index
               := No_Token_Index;
      Transform_Res192 :
            Bare_Package_Decl
               := No_Bare_Ada_Node;
      Transform_Diags192 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Package_Decl_Transform_Parse3_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res192 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res192;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res192;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags192 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos255 := Pos;



--  Start tok_code

Token_Res411 := Row_Pos255;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res411));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos411 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos255 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos255,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos411 := Row_Pos255 + 1;
   end if;
end;

--  End tok_code




if Token_Pos411 /= No_Token_Index then

   Row_Pos255 := Token_Pos411;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


Defer_Res403 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos255);
Defer_Pos403 := Parser.Current_Pos;




if Defer_Pos403 /= No_Token_Index then

   Row_Pos255 := Defer_Pos403;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


Defer_Res404 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos255);
Defer_Pos404 := Parser.Current_Pos;




if Defer_Pos404 /= No_Token_Index then

   Row_Pos255 := Defer_Pos404;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


--  Start tok_code

Token_Res412 := Row_Pos255;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res412));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos412 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos255 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos255,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos412 := Row_Pos255 + 1;
   end if;
end;

--  End tok_code




if Token_Pos412 /= No_Token_Index then

   Row_Pos255 := Token_Pos412;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


--  Start transform_code

Transform_Diags189 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos256 := Row_Pos255;



        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Package_Decl0_Extract_Parse0'Access);
        
Defer_Res405 :=
   Basic_Decls_List_Parse0 (Parser, Row_Pos256);
Defer_Pos405 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos405 /= No_Token_Index then

   Row_Pos256 := Defer_Pos405;

else
   Row_Pos256 := No_Token_Index;
   goto Exit_Row256_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row256_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos256 /= No_Token_Index then

   Transform_Res189 := Allocate_Public_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res189,
      Kind => Ada_Public_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos255,
      Token_End_Index   => (if Row_Pos256 = Row_Pos255
                            then No_Token_Index
                            else Row_Pos256 - 1));

      Initialize_Fields_For_Public_Part
        (Self => Transform_Res189, Declarative_Part_F_Decls => Defer_Res405);

         if Defer_Res405 /= null and then Is_Incomplete (Defer_Res405) then
            Transform_Res189.Last_Attempted_Child := 0;
         elsif Defer_Res405 /= null and then not Is_Ghost (Defer_Res405) then
            Transform_Res189.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos256 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags189);
end if;

--  End transform_code




if Row_Pos256 /= No_Token_Index then

   Row_Pos255 := Row_Pos256;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos257 := Row_Pos255;



--  Start tok_code

Token_Res413 := Row_Pos257;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res413));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos413 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos257 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos257,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos413 := Row_Pos257 + 1;
   end if;
end;

--  End tok_code




if Token_Pos413 /= No_Token_Index then

   Row_Pos257 := Token_Pos413;

else
   Row_Pos257 := No_Token_Index;
   goto Exit_Row257_0;

end if;


--  Start transform_code

Transform_Diags190 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos258 := Row_Pos257;



        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Package_Decl1_Extract_Parse0'Access);
        
Defer_Res406 :=
   Basic_Decls_List_Parse0 (Parser, Row_Pos258);
Defer_Pos406 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos406 /= No_Token_Index then

   Row_Pos258 := Defer_Pos406;

else
   Row_Pos258 := No_Token_Index;
   goto Exit_Row258_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row258_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos258 /= No_Token_Index then

   Transform_Res190 := Allocate_Private_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res190,
      Kind => Ada_Private_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos257,
      Token_End_Index   => (if Row_Pos258 = Row_Pos257
                            then No_Token_Index
                            else Row_Pos258 - 1));

      Initialize_Fields_For_Private_Part
        (Self => Transform_Res190, Declarative_Part_F_Decls => Defer_Res406);

         if Defer_Res406 /= null and then Is_Incomplete (Defer_Res406) then
            Transform_Res190.Last_Attempted_Child := 0;
         elsif Defer_Res406 /= null and then not Is_Ghost (Defer_Res406) then
            Transform_Res190.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos258 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags190);
end if;

--  End transform_code




if Row_Pos258 /= No_Token_Index then

   Row_Pos257 := Row_Pos258;

else
   Row_Pos257 := No_Token_Index;
   goto Exit_Row257_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row257_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos257 = No_Token_Index then

         
   Transform_Res190 := No_Bare_Ada_Node;



       
   Row_Pos257 := Row_Pos255;



end if;

--  End opt_code




if Row_Pos257 /= No_Token_Index then

   Row_Pos255 := Row_Pos257;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


--  Start row_code

Row_Pos259 := Row_Pos255;



--  Start tok_code

Token_Res414 := Row_Pos259;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res414));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos414 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos259 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos259,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos414 := Row_Pos259 + 1;
   end if;
end;

--  End tok_code




if Token_Pos414 /= No_Token_Index then

   Row_Pos259 := Token_Pos414;

else
   Row_Pos259 := No_Token_Index;
   goto Exit_Row259_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags191 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos260 := Row_Pos259;



Defer_Res407 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos260);
Defer_Pos407 := Parser.Current_Pos;




if Defer_Pos407 /= No_Token_Index then

   Row_Pos260 := Defer_Pos407;

else
   Row_Pos260 := No_Token_Index;
   goto Exit_Row260_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row260_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos260 /= No_Token_Index then

   Transform_Res191 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res191,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos259,
      Token_End_Index   => (if Row_Pos260 = Row_Pos259
                            then No_Token_Index
                            else Row_Pos260 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res191, End_Name_F_Name => Defer_Res407);

         if Defer_Res407 /= null and then Is_Incomplete (Defer_Res407) then
            Transform_Res191.Last_Attempted_Child := 0;
         elsif Defer_Res407 /= null and then not Is_Ghost (Defer_Res407) then
            Transform_Res191.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos260 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags191);
end if;

--  End transform_code


if Row_Pos260 = No_Token_Index then

         
   Transform_Res191 := No_Bare_Ada_Node;



       
   Row_Pos260 := Row_Pos259;



end if;

--  End opt_code




if Row_Pos260 /= No_Token_Index then

   Row_Pos259 := Row_Pos260;

else
   Row_Pos259 := No_Token_Index;
   goto Exit_Row259_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row259_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos259 /= No_Token_Index then

   Row_Pos255 := Row_Pos259;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res415 := Row_Pos255;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res415));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos415 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos255 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos255,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos415 := Row_Pos255 + 1;
   end if;
end;

--  End tok_code


if Token_Pos415 = No_Token_Index then

         
   Token_Res415 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos255)),
                To_Text ("Missing ';'"));

       
   Token_Pos415 := Row_Pos255;



end if;

--  End opt_code




if Token_Pos415 /= No_Token_Index then

   Row_Pos255 := Token_Pos415;

else
   Row_Pos255 := No_Token_Index;
   goto Exit_Row255_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row255_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos255 /= No_Token_Index then

   Transform_Res192 := Allocate_Package_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res192,
      Kind => Ada_Package_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos255 = Pos
                            then No_Token_Index
                            else Row_Pos255 - 1));

      Initialize_Fields_For_Package_Decl
        (Self => Transform_Res192, Base_Package_Decl_F_Package_Name => Defer_Res403, Base_Package_Decl_F_Aspects => Defer_Res404, Base_Package_Decl_F_Public_Part => Transform_Res189, Base_Package_Decl_F_Private_Part => Transform_Res190, Base_Package_Decl_F_End_Name => Transform_Res191);

         if Defer_Res403 /= null and then Is_Incomplete (Defer_Res403) then
            Transform_Res192.Last_Attempted_Child := 0;
         elsif Defer_Res403 /= null and then not Is_Ghost (Defer_Res403) then
            Transform_Res192.Last_Attempted_Child := -1;
         end if;
         if Defer_Res404 /= null and then Is_Incomplete (Defer_Res404) then
            Transform_Res192.Last_Attempted_Child := 0;
         elsif Defer_Res404 /= null and then not Is_Ghost (Defer_Res404) then
            Transform_Res192.Last_Attempted_Child := -1;
         end if;
         if Transform_Res189 /= null and then Is_Incomplete (Transform_Res189) then
            Transform_Res192.Last_Attempted_Child := 0;
         elsif Transform_Res189 /= null and then not Is_Ghost (Transform_Res189) then
            Transform_Res192.Last_Attempted_Child := -1;
         end if;
         if Transform_Res190 /= null and then Is_Incomplete (Transform_Res190) then
            Transform_Res192.Last_Attempted_Child := 0;
         elsif Transform_Res190 /= null and then not Is_Ghost (Transform_Res190) then
            Transform_Res192.Last_Attempted_Child := -1;
         end if;
         if Transform_Res191 /= null and then Is_Incomplete (Transform_Res191) then
            Transform_Res192.Last_Attempted_Child := 0;
         elsif Transform_Res191 /= null and then not Is_Ghost (Transform_Res191) then
            Transform_Res192.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos255 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags192);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Package_Decl_Transform_Parse3_Memo,
      Row_Pos255 /= No_Token_Index,
      Transform_Res192,
      Pos,
      Row_Pos255);


   Parser.Current_Pos := Row_Pos255;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res192;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Package_Decl_Transform_Parse3;

   


function Package_Renaming_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Package_Renaming_Decl
is
   use Bare_Package_Renaming_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos261 :
            Token_Index
               := No_Token_Index;
      Token_Pos416 :
            Token_Index
               := No_Token_Index;
      Token_Res416 :
            Token_Index
               := No_Token_Index;
      Defer_Pos408 :
            Token_Index
               := No_Token_Index;
      Defer_Res408 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos409 :
            Token_Index
               := No_Token_Index;
      Defer_Res409 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Defer_Pos410 :
            Token_Index
               := No_Token_Index;
      Defer_Res410 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos417 :
            Token_Index
               := No_Token_Index;
      Token_Res417 :
            Token_Index
               := No_Token_Index;
      Transform_Res193 :
            Bare_Package_Renaming_Decl
               := No_Bare_Ada_Node;
      Transform_Diags193 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Package_Renaming_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res193 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res193;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res193;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags193 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos261 := Pos;



--  Start tok_code

Token_Res416 := Row_Pos261;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res416));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Package)
   then
       Token_Pos416 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos261 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos261,
             Expected_Token_Id => Ada_Package,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos416 := Row_Pos261 + 1;
   end if;
end;

--  End tok_code




if Token_Pos416 /= No_Token_Index then

   Row_Pos261 := Token_Pos416;

else
   Row_Pos261 := No_Token_Index;
   goto Exit_Row261_0;

end if;


Defer_Res408 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos261);
Defer_Pos408 := Parser.Current_Pos;




if Defer_Pos408 /= No_Token_Index then

   Row_Pos261 := Defer_Pos408;

else
   Row_Pos261 := No_Token_Index;
   goto Exit_Row261_0;

end if;


Defer_Res409 :=
   Renaming_Clause_Transform_Parse0 (Parser, Row_Pos261);
Defer_Pos409 := Parser.Current_Pos;




if Defer_Pos409 /= No_Token_Index then

   Row_Pos261 := Defer_Pos409;

else
   Row_Pos261 := No_Token_Index;
   goto Exit_Row261_0;

end if;


Defer_Res410 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos261);
Defer_Pos410 := Parser.Current_Pos;




if Defer_Pos410 /= No_Token_Index then

   Row_Pos261 := Defer_Pos410;

else
   Row_Pos261 := No_Token_Index;
   goto Exit_Row261_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res417 := Row_Pos261;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res417));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos417 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos261 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos261,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos417 := Row_Pos261 + 1;
   end if;
end;

--  End tok_code


if Token_Pos417 = No_Token_Index then

         
   Token_Res417 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos261)),
                To_Text ("Missing ';'"));

       
   Token_Pos417 := Row_Pos261;



end if;

--  End opt_code




if Token_Pos417 /= No_Token_Index then

   Row_Pos261 := Token_Pos417;

else
   Row_Pos261 := No_Token_Index;
   goto Exit_Row261_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row261_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos261 /= No_Token_Index then

   Transform_Res193 := Allocate_Package_Renaming_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res193,
      Kind => Ada_Package_Renaming_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos261 = Pos
                            then No_Token_Index
                            else Row_Pos261 - 1));

      Initialize_Fields_For_Package_Renaming_Decl
        (Self => Transform_Res193, Package_Renaming_Decl_F_Name => Defer_Res408, Package_Renaming_Decl_F_Renames => Defer_Res409, Package_Renaming_Decl_F_Aspects => Defer_Res410);

         if Defer_Res408 /= null and then Is_Incomplete (Defer_Res408) then
            Transform_Res193.Last_Attempted_Child := 0;
         elsif Defer_Res408 /= null and then not Is_Ghost (Defer_Res408) then
            Transform_Res193.Last_Attempted_Child := -1;
         end if;
         if Defer_Res409 /= null and then Is_Incomplete (Defer_Res409) then
            Transform_Res193.Last_Attempted_Child := 0;
         elsif Defer_Res409 /= null and then not Is_Ghost (Defer_Res409) then
            Transform_Res193.Last_Attempted_Child := -1;
         end if;
         if Defer_Res410 /= null and then Is_Incomplete (Defer_Res410) then
            Transform_Res193.Last_Attempted_Child := 0;
         elsif Defer_Res410 /= null and then not Is_Ghost (Defer_Res410) then
            Transform_Res193.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos261 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags193);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Package_Renaming_Decl_Transform_Parse0_Memo,
      Row_Pos261 /= No_Token_Index,
      Transform_Res193,
      Pos,
      Row_Pos261);


   Parser.Current_Pos := Row_Pos261;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res193;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Package_Renaming_Decl_Transform_Parse0;

   


function Param_Assoc_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param_Assoc
is
   use Bare_Param_Assoc_Memos;

   Call_Depth : aliased Natural;

      Nobt32 :
            Boolean
               := False;
      Nobt33 :
            Boolean
               := False;
      Row_Pos262 :
            Token_Index
               := No_Token_Index;
      Row_Pos263 :
            Token_Index
               := No_Token_Index;
      Defer_Pos411 :
            Token_Index
               := No_Token_Index;
      Defer_Res411 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Defer_Pos412 :
            Token_Index
               := No_Token_Index;
      Defer_Res412 :
            Bare_Others_Designator
               := No_Bare_Ada_Node;
      Defer_Pos413 :
            Token_Index
               := No_Token_Index;
      Defer_Res413 :
            Bare_String_Literal
               := No_Bare_Ada_Node;
      Or_Pos87 :
            Token_Index
               := No_Token_Index;
      Or_Res87 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Token_Pos418 :
            Token_Index
               := No_Token_Index;
      Token_Res418 :
            Token_Index
               := No_Token_Index;
      Defer_Pos414 :
            Token_Index
               := No_Token_Index;
      Defer_Res414 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos415 :
            Token_Index
               := No_Token_Index;
      Defer_Res415 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Or_Pos88 :
            Token_Index
               := No_Token_Index;
      Or_Res88 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress29 :
            Integer
               := 0;
      Transform_Res194 :
            Bare_Param_Assoc
               := No_Bare_Ada_Node;
      Transform_Has_Failed29 :
            Boolean
               := False;
      Transform_Diags194 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Param_Assoc_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res194 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res194;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res194;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags194 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos262 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos263 := Row_Pos262;



--  Start or_code

Or_Pos87 := No_Token_Index;
Or_Res87 := No_Bare_Ada_Node;
    
Defer_Res411 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos263);
Defer_Pos411 := Parser.Current_Pos;

    if Defer_Pos411 /= No_Token_Index then
        Or_Pos87 := Defer_Pos411;
        Or_Res87 := Defer_Res411;
        goto Exit_Or89;
    end if;
    
Defer_Res412 :=
   Others_Designator_Transform_Parse0 (Parser, Row_Pos263);
Defer_Pos412 := Parser.Current_Pos;

    if Defer_Pos412 /= No_Token_Index then
        Or_Pos87 := Defer_Pos412;
        Or_Res87 := Defer_Res412;
        goto Exit_Or89;
    end if;
    
Defer_Res413 :=
   String_Literal_Transform_Parse0 (Parser, Row_Pos263);
Defer_Pos413 := Parser.Current_Pos;

    if Defer_Pos413 /= No_Token_Index then
        Or_Pos87 := Defer_Pos413;
        Or_Res87 := Defer_Res413;
        goto Exit_Or89;
    end if;
<<Exit_Or89>>

--  End or_code




if Or_Pos87 /= No_Token_Index then

   Row_Pos263 := Or_Pos87;

else
   Row_Pos263 := No_Token_Index;
   goto Exit_Row263_0;

end if;


--  Start tok_code

Token_Res418 := Row_Pos263;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res418));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos418 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos263 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos263,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos418 := Row_Pos263 + 1;
   end if;
end;

--  End tok_code




if Token_Pos418 /= No_Token_Index then

   Row_Pos263 := Token_Pos418;

else
   Row_Pos263 := No_Token_Index;
   goto Exit_Row263_0;

end if;

Nobt32 := True;

   Nobt32 := Nobt32;


if Row_Pos263 /= No_Token_Index then

   Row_Pos263 := Row_Pos263;

else
   Row_Pos263 := No_Token_Index;
   goto Exit_Row263_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row263_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos263 = No_Token_Index then

         
   if Nobt32 then
      Row_Pos263 := Parser.Last_Fail.Pos;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Row_Pos263)),
              To_Text ("Cannot parse <param_assoc>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;


         if not Nobt32 then
            
   Or_Res87 := No_Bare_Ada_Node;

         end if;


       if not Nobt32 then
          
   Row_Pos263 := Row_Pos262;

       end if;


end if;

--  End opt_code


   Nobt33 := Nobt32;

Row_Progress29 := 1;

if Row_Pos263 /= No_Token_Index then

   Row_Pos262 := Row_Pos263;

else
   Row_Pos262 := No_Token_Index;
   goto Exit_Row262_0;

end if;


--  Start or_code

Or_Pos88 := No_Token_Index;
Or_Res88 := No_Bare_Ada_Node;
    
Defer_Res414 :=
   Expr_Or_Parse0 (Parser, Row_Pos262);
Defer_Pos414 := Parser.Current_Pos;

    if Defer_Pos414 /= No_Token_Index then
        Or_Pos88 := Defer_Pos414;
        Or_Res88 := Defer_Res414;
        goto Exit_Or90;
    end if;
    
Defer_Res415 :=
   Box_Expr_Transform_Parse0 (Parser, Row_Pos262);
Defer_Pos415 := Parser.Current_Pos;

    if Defer_Pos415 /= No_Token_Index then
        Or_Pos88 := Defer_Pos415;
        Or_Res88 := Defer_Res415;
        goto Exit_Or90;
    end if;
<<Exit_Or90>>

--  End or_code



Row_Progress29 := 2;

if Or_Pos88 /= No_Token_Index then

   Row_Pos262 := Or_Pos88;

else
   Row_Pos262 := No_Token_Index;
   goto Exit_Row262_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row262_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos262 = No_Token_Index and then Nobt33 then

   Row_Pos262 := Parser.Last_Fail.Pos;

   Transform_Has_Failed29 := True;
end if;

if Row_Pos262 /= No_Token_Index then

   Transform_Res194 := Allocate_Param_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res194,
      Kind => Ada_Param_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos262 = Pos
                            then No_Token_Index
                            else Row_Pos262 - 1));

      Initialize_Fields_For_Param_Assoc
        (Self => Transform_Res194, Param_Assoc_F_Designator => Or_Res87, Param_Assoc_F_R_Expr => Or_Res88);

         if Or_Res87 /= null and then Is_Incomplete (Or_Res87) then
            Transform_Res194.Last_Attempted_Child := 0;
         elsif Or_Res87 /= null and then not Is_Ghost (Or_Res87) then
            Transform_Res194.Last_Attempted_Child := -1;
         end if;
         if Or_Res88 /= null and then Is_Incomplete (Or_Res88) then
            Transform_Res194.Last_Attempted_Child := 0;
         elsif Or_Res88 /= null and then not Is_Ghost (Or_Res88) then
            Transform_Res194.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed29 then
      Transform_Res194.Last_Attempted_Child :=
         Row_Progress29;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <param_assoc>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos262 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags194);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Param_Assoc_Transform_Parse0_Memo,
      Row_Pos262 /= No_Token_Index,
      Transform_Res194,
      Pos,
      Row_Pos262);


   Parser.Current_Pos := Row_Pos262;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res194;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Param_Assoc_Transform_Parse0;

   


function Param_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param_Spec
is
   use Bare_Param_Spec_Memos;

   Call_Depth : aliased Natural;

      Row_Pos264 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos38 :
            Token_Index
               := No_Token_Index;
      Tmp_List38 :
            Free_Parse_List;
      Defer_Pos416 :
            Token_Index
               := No_Token_Index;
      Defer_Res416 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos419 :
            Token_Index
               := No_Token_Index;
      Token_Res419 :
            Token_Index
               := No_Token_Index;
      List_Pos38 :
            Token_Index
               := No_Token_Index;
      List_Res38 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos420 :
            Token_Index
               := No_Token_Index;
      Token_Res420 :
            Token_Index
               := No_Token_Index;
      Token_Pos421 :
            Token_Index
               := No_Token_Index;
      Token_Res421 :
            Token_Index
               := No_Token_Index;
      Opt_Res23 :
            Bare_Aliased_Node
               := No_Bare_Ada_Node;
      Defer_Pos417 :
            Token_Index
               := No_Token_Index;
      Defer_Res417 :
            Bare_Mode
               := No_Bare_Ada_Node;
      Defer_Pos418 :
            Token_Index
               := No_Token_Index;
      Defer_Res418 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Row_Pos265 :
            Token_Index
               := No_Token_Index;
      Token_Pos422 :
            Token_Index
               := No_Token_Index;
      Token_Res422 :
            Token_Index
               := No_Token_Index;
      Defer_Pos419 :
            Token_Index
               := No_Token_Index;
      Defer_Res419 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos420 :
            Token_Index
               := No_Token_Index;
      Defer_Res420 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Transform_Res195 :
            Bare_Param_Spec
               := No_Bare_Ada_Node;
      Transform_Diags195 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Param_Spec_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res195 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res195;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res195;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags195 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos264 := Pos;



--  Start list_code

    List_Pos38 := No_Token_Index;



Lst_Cpos38 := Row_Pos264;
Tmp_List38 := Get_Parse_List (Parser);

loop
   
Defer_Res416 :=
   Defining_Id_Transform_Parse0 (Parser, Lst_Cpos38);
Defer_Pos416 := Parser.Current_Pos;


   exit when Defer_Pos416 = No_Token_Index;

   List_Pos38 := Defer_Pos416;
   Lst_Cpos38 := List_Pos38;

   Tmp_List38.Nodes.Append (Defer_Res416);

      
--  Start tok_code

Token_Res419 := Lst_Cpos38;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res419));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos419 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos38 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos38,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos419 := Lst_Cpos38 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos419 /= No_Token_Index then
          Lst_Cpos38 := Token_Pos419;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List38.Nodes.Length;
begin
   List_Res38 :=
      Allocate_Defining_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos264;
      Token_End := (if Lst_Cpos38 = Row_Pos264
                    then Row_Pos264
                    else Lst_Cpos38 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos264, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res38,
      Kind              => Ada_Defining_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res38,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List38.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res38.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List38);

--  End list_code




if List_Pos38 /= No_Token_Index then

   Row_Pos264 := List_Pos38;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;


--  Start tok_code

Token_Res420 := Row_Pos264;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res420));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos420 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos264 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos264,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos420 := Row_Pos264 + 1;
   end if;
end;

--  End tok_code




if Token_Pos420 /= No_Token_Index then

   Row_Pos264 := Token_Pos420;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res421 := Row_Pos264;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res421));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Aliased)
   then
       Token_Pos421 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos264 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos264,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos421 := Row_Pos264 + 1;
   end if;
end;

--  End tok_code


if Token_Pos421 = No_Token_Index then

         Opt_Res23 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res23,
            Kind              => Ada_Aliased_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos264,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos421 := Row_Pos264;


else

      Opt_Res23 := Allocate_Aliased_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res23,
         Kind              => Ada_Aliased_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos264,
         Token_End_Index   => Token_Pos421 - 1);

end if;

--  End opt_code




if Token_Pos421 /= No_Token_Index then

   Row_Pos264 := Token_Pos421;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;


--  Start opt_code












Defer_Res417 :=
   Mode_Or_Parse0 (Parser, Row_Pos264);
Defer_Pos417 := Parser.Current_Pos;


if Defer_Pos417 = No_Token_Index then

         
   Defer_Res417 := No_Bare_Ada_Node;



       
   Defer_Pos417 := Row_Pos264;



end if;

--  End opt_code




if Defer_Pos417 /= No_Token_Index then

   Row_Pos264 := Defer_Pos417;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;


Defer_Res418 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos264);
Defer_Pos418 := Parser.Current_Pos;




if Defer_Pos418 /= No_Token_Index then

   Row_Pos264 := Defer_Pos418;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos265 := Row_Pos264;



--  Start tok_code

Token_Res422 := Row_Pos265;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res422));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos422 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos265 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos265,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos422 := Row_Pos265 + 1;
   end if;
end;

--  End tok_code




if Token_Pos422 /= No_Token_Index then

   Row_Pos265 := Token_Pos422;

else
   Row_Pos265 := No_Token_Index;
   goto Exit_Row265_0;

end if;


Defer_Res419 :=
   Expr_Or_Parse0 (Parser, Row_Pos265);
Defer_Pos419 := Parser.Current_Pos;




if Defer_Pos419 /= No_Token_Index then

   Row_Pos265 := Defer_Pos419;

else
   Row_Pos265 := No_Token_Index;
   goto Exit_Row265_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row265_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos265 = No_Token_Index then

         
   Defer_Res419 := No_Bare_Ada_Node;



       
   Row_Pos265 := Row_Pos264;



end if;

--  End opt_code




if Row_Pos265 /= No_Token_Index then

   Row_Pos264 := Row_Pos265;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;


Defer_Res420 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos264);
Defer_Pos420 := Parser.Current_Pos;




if Defer_Pos420 /= No_Token_Index then

   Row_Pos264 := Defer_Pos420;

else
   Row_Pos264 := No_Token_Index;
   goto Exit_Row264_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row264_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos264 /= No_Token_Index then

   Transform_Res195 := Allocate_Param_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res195,
      Kind => Ada_Param_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos264 = Pos
                            then No_Token_Index
                            else Row_Pos264 - 1));

      Initialize_Fields_For_Param_Spec
        (Self => Transform_Res195, Param_Spec_F_Ids => List_Res38, Param_Spec_F_Has_Aliased => Opt_Res23, Param_Spec_F_Mode => Defer_Res417, Param_Spec_F_Type_Expr => Defer_Res418, Param_Spec_F_Default_Expr => Defer_Res419, Param_Spec_F_Aspects => Defer_Res420);

         if List_Res38 /= null and then Is_Incomplete (List_Res38) then
            Transform_Res195.Last_Attempted_Child := 0;
         elsif List_Res38 /= null and then not Is_Ghost (List_Res38) then
            Transform_Res195.Last_Attempted_Child := -1;
         end if;
         if Opt_Res23 /= null and then Is_Incomplete (Opt_Res23) then
            Transform_Res195.Last_Attempted_Child := 0;
         elsif Opt_Res23 /= null and then not Is_Ghost (Opt_Res23) then
            Transform_Res195.Last_Attempted_Child := -1;
         end if;
         if Defer_Res417 /= null and then Is_Incomplete (Defer_Res417) then
            Transform_Res195.Last_Attempted_Child := 0;
         elsif Defer_Res417 /= null and then not Is_Ghost (Defer_Res417) then
            Transform_Res195.Last_Attempted_Child := -1;
         end if;
         if Defer_Res418 /= null and then Is_Incomplete (Defer_Res418) then
            Transform_Res195.Last_Attempted_Child := 0;
         elsif Defer_Res418 /= null and then not Is_Ghost (Defer_Res418) then
            Transform_Res195.Last_Attempted_Child := -1;
         end if;
         if Defer_Res419 /= null and then Is_Incomplete (Defer_Res419) then
            Transform_Res195.Last_Attempted_Child := 0;
         elsif Defer_Res419 /= null and then not Is_Ghost (Defer_Res419) then
            Transform_Res195.Last_Attempted_Child := -1;
         end if;
         if Defer_Res420 /= null and then Is_Incomplete (Defer_Res420) then
            Transform_Res195.Last_Attempted_Child := 0;
         elsif Defer_Res420 /= null and then not Is_Ghost (Defer_Res420) then
            Transform_Res195.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos264 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags195);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Param_Spec_Transform_Parse0_Memo,
      Row_Pos264 /= No_Token_Index,
      Transform_Res195,
      Pos,
      Row_Pos264);


   Parser.Current_Pos := Row_Pos264;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res195;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Param_Spec_Transform_Parse0;

   


function Param_Specs_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Params
is
   use Bare_Params_Memos;

   Call_Depth : aliased Natural;

      Nobt34 :
            Boolean
               := False;
      Row_Pos266 :
            Token_Index
               := No_Token_Index;
      Token_Pos423 :
            Token_Index
               := No_Token_Index;
      Token_Res423 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos39 :
            Token_Index
               := No_Token_Index;
      Tmp_List39 :
            Free_Parse_List;
      Defer_Pos421 :
            Token_Index
               := No_Token_Index;
      Defer_Res421 :
            Bare_Param_Spec
               := No_Bare_Ada_Node;
      Token_Pos424 :
            Token_Index
               := No_Token_Index;
      Token_Res424 :
            Token_Index
               := No_Token_Index;
      List_Pos39 :
            Token_Index
               := No_Token_Index;
      List_Res39 :
            Bare_Param_Spec_List
               := No_Bare_Ada_Node;
      Token_Pos425 :
            Token_Index
               := No_Token_Index;
      Token_Res425 :
            Token_Index
               := No_Token_Index;
      Row_Progress30 :
            Integer
               := 0;
      Transform_Res196 :
            Bare_Params
               := No_Bare_Ada_Node;
      Transform_Has_Failed30 :
            Boolean
               := False;
      Transform_Diags196 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Param_Specs_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res196 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res196;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res196;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags196 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos266 := Pos;



--  Start tok_code

Token_Res423 := Row_Pos266;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res423));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos423 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos266 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos266,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos423 := Row_Pos266 + 1;
   end if;
end;

--  End tok_code



Row_Progress30 := 1;

if Token_Pos423 /= No_Token_Index then

   Row_Pos266 := Token_Pos423;

else
   Row_Pos266 := No_Token_Index;
   goto Exit_Row266_0;

end if;

Nobt34 := True;

   Nobt34 := Nobt34;

Row_Progress30 := 2;

if Row_Pos266 /= No_Token_Index then

   Row_Pos266 := Row_Pos266;

else
   Row_Pos266 := No_Token_Index;
   goto Exit_Row266_0;

end if;


--  Start list_code

    List_Pos39 := No_Token_Index;



Lst_Cpos39 := Row_Pos266;
Tmp_List39 := Get_Parse_List (Parser);

loop
   
Defer_Res421 :=
   Param_Spec_Transform_Parse0 (Parser, Lst_Cpos39);
Defer_Pos421 := Parser.Current_Pos;


   exit when Defer_Pos421 = No_Token_Index;

   List_Pos39 := Defer_Pos421;
   Lst_Cpos39 := List_Pos39;

   Tmp_List39.Nodes.Append (Defer_Res421);

      
--  Start tok_code

Token_Res424 := Lst_Cpos39;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res424));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos424 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos39 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos39,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos424 := Lst_Cpos39 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos424 /= No_Token_Index then
          Lst_Cpos39 := Token_Pos424;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List39.Nodes.Length;
begin
   List_Res39 :=
      Allocate_Param_Spec_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos266;
      Token_End := (if Lst_Cpos39 = Row_Pos266
                    then Row_Pos266
                    else Lst_Cpos39 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos266, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res39,
      Kind              => Ada_Param_Spec_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res39,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List39.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res39.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List39);

--  End list_code



Row_Progress30 := 3;

if List_Pos39 /= No_Token_Index then

   Row_Pos266 := List_Pos39;

else
   Row_Pos266 := No_Token_Index;
   goto Exit_Row266_0;

end if;


--  Start tok_code

Token_Res425 := Row_Pos266;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res425));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos425 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos266 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos266,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos425 := Row_Pos266 + 1;
   end if;
end;

--  End tok_code



Row_Progress30 := 4;

if Token_Pos425 /= No_Token_Index then

   Row_Pos266 := Token_Pos425;

else
   Row_Pos266 := No_Token_Index;
   goto Exit_Row266_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row266_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos266 = No_Token_Index and then Nobt34 then

   Row_Pos266 := Parser.Last_Fail.Pos;

   Transform_Has_Failed30 := True;
end if;

if Row_Pos266 /= No_Token_Index then

   Transform_Res196 := Allocate_Params (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res196,
      Kind => Ada_Params,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos266 = Pos
                            then No_Token_Index
                            else Row_Pos266 - 1));

      Initialize_Fields_For_Params
        (Self => Transform_Res196, Params_F_Params => List_Res39);

         if List_Res39 /= null and then Is_Incomplete (List_Res39) then
            Transform_Res196.Last_Attempted_Child := 0;
         elsif List_Res39 /= null and then not Is_Ghost (List_Res39) then
            Transform_Res196.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed30 then
      Transform_Res196.Last_Attempted_Child :=
         Row_Progress30;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <param_specs>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos266 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags196);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Param_Specs_Transform_Parse0_Memo,
      Row_Pos266 /= No_Token_Index,
      Transform_Res196,
      Pos,
      Row_Pos266);


   Parser.Current_Pos := Row_Pos266;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res196;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Param_Specs_Transform_Parse0;

   


function Paren_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Paren_Expr
is
   use Bare_Paren_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos267 :
            Token_Index
               := No_Token_Index;
      Token_Pos426 :
            Token_Index
               := No_Token_Index;
      Token_Res426 :
            Token_Index
               := No_Token_Index;
      Defer_Pos422 :
            Token_Index
               := No_Token_Index;
      Defer_Res422 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos427 :
            Token_Index
               := No_Token_Index;
      Token_Res427 :
            Token_Index
               := No_Token_Index;
      Transform_Res197 :
            Bare_Paren_Expr
               := No_Bare_Ada_Node;
      Transform_Diags197 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Paren_Expr_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res197 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res197;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res197;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags197 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos267 := Pos;



--  Start tok_code

Token_Res426 := Row_Pos267;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res426));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos426 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos267 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos267,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos426 := Row_Pos267 + 1;
   end if;
end;

--  End tok_code




if Token_Pos426 /= No_Token_Index then

   Row_Pos267 := Token_Pos426;

else
   Row_Pos267 := No_Token_Index;
   goto Exit_Row267_0;

end if;


Defer_Res422 :=
   Expr_Or_Parse0 (Parser, Row_Pos267);
Defer_Pos422 := Parser.Current_Pos;




if Defer_Pos422 /= No_Token_Index then

   Row_Pos267 := Defer_Pos422;

else
   Row_Pos267 := No_Token_Index;
   goto Exit_Row267_0;

end if;


--  Start tok_code

Token_Res427 := Row_Pos267;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res427));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos427 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos267 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos267,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos427 := Row_Pos267 + 1;
   end if;
end;

--  End tok_code




if Token_Pos427 /= No_Token_Index then

   Row_Pos267 := Token_Pos427;

else
   Row_Pos267 := No_Token_Index;
   goto Exit_Row267_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row267_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos267 /= No_Token_Index then

   Transform_Res197 := Allocate_Paren_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res197,
      Kind => Ada_Paren_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos267 = Pos
                            then No_Token_Index
                            else Row_Pos267 - 1));

      Initialize_Fields_For_Paren_Expr
        (Self => Transform_Res197, Paren_Expr_F_Expr => Defer_Res422);

         if Defer_Res422 /= null and then Is_Incomplete (Defer_Res422) then
            Transform_Res197.Last_Attempted_Child := 0;
         elsif Defer_Res422 /= null and then not Is_Ghost (Defer_Res422) then
            Transform_Res197.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos267 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags197);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Paren_Expr_Transform_Parse0_Memo,
      Row_Pos267 /= No_Token_Index,
      Transform_Res197,
      Pos,
      Row_Pos267);


   Parser.Current_Pos := Row_Pos267;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res197;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Paren_Expr_Transform_Parse0;

   


function Parent_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Parent_List
is
   use Bare_Parent_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos40 :
            Token_Index
               := No_Token_Index;
      Tmp_List40 :
            Free_Parse_List;
      Defer_Pos423 :
            Token_Index
               := No_Token_Index;
      Defer_Res423 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos428 :
            Token_Index
               := No_Token_Index;
      Token_Res428 :
            Token_Index
               := No_Token_Index;
      List_Pos40 :
            Token_Index
               := No_Token_Index;
      List_Res40 :
            Bare_Parent_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Parent_List_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res40 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res40;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res40;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos40 := No_Token_Index;



Lst_Cpos40 := Pos;
Tmp_List40 := Get_Parse_List (Parser);

loop
   
Defer_Res423 :=
   Static_Name_Or_Parse0 (Parser, Lst_Cpos40);
Defer_Pos423 := Parser.Current_Pos;


   exit when Defer_Pos423 = No_Token_Index;

   List_Pos40 := Defer_Pos423;
   Lst_Cpos40 := List_Pos40;

   Tmp_List40.Nodes.Append (Defer_Res423);

      
--  Start tok_code

Token_Res428 := Lst_Cpos40;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res428));
begin
   if
      T.Kind /= From_Token_Kind (Ada_And)
   then
       Token_Pos428 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos40 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos40,
             Expected_Token_Id => Ada_And,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos428 := Lst_Cpos40 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos428 /= No_Token_Index then
          Lst_Cpos40 := Token_Pos428;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List40.Nodes.Length;
begin
   List_Res40 :=
      Allocate_Parent_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos40 = Pos
                    then Pos
                    else Lst_Cpos40 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res40,
      Kind              => Ada_Parent_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res40,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List40.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res40.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List40);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Parent_List_List_Parse0_Memo,
      List_Pos40 /= No_Token_Index,
      List_Res40,
      Pos,
      List_Pos40);


   Parser.Current_Pos := List_Pos40;

   Exit_Call (Parser, Call_Depth);
   return List_Res40;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Parent_List_List_Parse0;

   


function Pp_Directive_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pp_Directive
is
   use Bare_Pp_Directive_Memos;

   Call_Depth : aliased Natural;

      Nobt35 :
            Boolean
               := False;
      Nobt36 :
            Boolean
               := False;
      Row_Pos268 :
            Token_Index
               := No_Token_Index;
      Token_Pos429 :
            Token_Index
               := No_Token_Index;
      Token_Res429 :
            Token_Index
               := No_Token_Index;
      Defer_Pos424 :
            Token_Index
               := No_Token_Index;
      Defer_Res424 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos425 :
            Token_Index
               := No_Token_Index;
      Defer_Res425 :
            Bare_Pp_Then_Kw
               := No_Bare_Ada_Node;
      Row_Progress31 :
            Integer
               := 0;
      Transform_Res198 :
            Bare_Pp_If_Directive
               := No_Bare_Ada_Node;
      Transform_Has_Failed31 :
            Boolean
               := False;
      Transform_Diags198 :
            Ada.Containers.Count_Type;
      Row_Pos269 :
            Token_Index
               := No_Token_Index;
      Token_Pos430 :
            Token_Index
               := No_Token_Index;
      Token_Res430 :
            Token_Index
               := No_Token_Index;
      Defer_Pos426 :
            Token_Index
               := No_Token_Index;
      Defer_Res426 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos427 :
            Token_Index
               := No_Token_Index;
      Defer_Res427 :
            Bare_Pp_Then_Kw
               := No_Bare_Ada_Node;
      Row_Progress32 :
            Integer
               := 0;
      Transform_Res199 :
            Bare_Pp_Elsif_Directive
               := No_Bare_Ada_Node;
      Transform_Has_Failed32 :
            Boolean
               := False;
      Transform_Diags199 :
            Ada.Containers.Count_Type;
      Row_Pos270 :
            Token_Index
               := No_Token_Index;
      Token_Pos431 :
            Token_Index
               := No_Token_Index;
      Token_Res431 :
            Token_Index
               := No_Token_Index;
      Transform_Res200 :
            Bare_Pp_Else_Directive
               := No_Bare_Ada_Node;
      Transform_Diags200 :
            Ada.Containers.Count_Type;
      Row_Pos271 :
            Token_Index
               := No_Token_Index;
      Token_Pos432 :
            Token_Index
               := No_Token_Index;
      Token_Res432 :
            Token_Index
               := No_Token_Index;
      Token_Pos433 :
            Token_Index
               := No_Token_Index;
      Token_Res433 :
            Token_Index
               := No_Token_Index;
      Token_Pos434 :
            Token_Index
               := No_Token_Index;
      Token_Res434 :
            Token_Index
               := No_Token_Index;
      Transform_Res201 :
            Bare_Pp_End_If_Directive
               := No_Bare_Ada_Node;
      Transform_Diags201 :
            Ada.Containers.Count_Type;
      Or_Pos89 :
            Token_Index
               := No_Token_Index;
      Or_Res89 :
            Bare_Pp_Directive
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Pp_Directive_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res89 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res89;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res89;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos89 := No_Token_Index;
Or_Res89 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags198 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos268 := Pos;



--  Start tok_code

Token_Res429 := Row_Pos268;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res429));
begin
   if
      T.Kind /= From_Token_Kind (Ada_If)
   then
       Token_Pos429 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos268 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos268,
             Expected_Token_Id => Ada_If,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos429 := Row_Pos268 + 1;
   end if;
end;

--  End tok_code



Row_Progress31 := 1;

if Token_Pos429 /= No_Token_Index then

   Row_Pos268 := Token_Pos429;

else
   Row_Pos268 := No_Token_Index;
   goto Exit_Row268_0;

end if;

Nobt35 := True;

   Nobt35 := Nobt35;

Row_Progress31 := 2;

if Row_Pos268 /= No_Token_Index then

   Row_Pos268 := Row_Pos268;

else
   Row_Pos268 := No_Token_Index;
   goto Exit_Row268_0;

end if;


Defer_Res424 :=
   Pp_Expr_Or_Parse0 (Parser, Row_Pos268);
Defer_Pos424 := Parser.Current_Pos;



Row_Progress31 := 3;

if Defer_Pos424 /= No_Token_Index then

   Row_Pos268 := Defer_Pos424;

else
   Row_Pos268 := No_Token_Index;
   goto Exit_Row268_0;

end if;


Defer_Res425 :=
   Pp_Then_Opt_Parse0 (Parser, Row_Pos268);
Defer_Pos425 := Parser.Current_Pos;



Row_Progress31 := 4;

if Defer_Pos425 /= No_Token_Index then

   Row_Pos268 := Defer_Pos425;

else
   Row_Pos268 := No_Token_Index;
   goto Exit_Row268_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row268_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos268 = No_Token_Index and then Nobt35 then

   Row_Pos268 := Parser.Last_Fail.Pos;

   Transform_Has_Failed31 := True;
end if;

if Row_Pos268 /= No_Token_Index then

   Transform_Res198 := Allocate_Pp_If_Directive (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res198,
      Kind => Ada_Pp_If_Directive,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos268 = Pos
                            then No_Token_Index
                            else Row_Pos268 - 1));

      Initialize_Fields_For_Pp_If_Directive
        (Self => Transform_Res198, Pp_If_Directive_F_Expr => Defer_Res424, Pp_If_Directive_F_Then_Kw => Defer_Res425);

         if Defer_Res424 /= null and then Is_Incomplete (Defer_Res424) then
            Transform_Res198.Last_Attempted_Child := 0;
         elsif Defer_Res424 /= null and then not Is_Ghost (Defer_Res424) then
            Transform_Res198.Last_Attempted_Child := -1;
         end if;
         if Defer_Res425 /= null and then Is_Incomplete (Defer_Res425) then
            Transform_Res198.Last_Attempted_Child := 0;
         elsif Defer_Res425 /= null and then not Is_Ghost (Defer_Res425) then
            Transform_Res198.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed31 then
      Transform_Res198.Last_Attempted_Child :=
         Row_Progress31;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <pp_directive>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos268 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags198);
end if;

--  End transform_code

    if Row_Pos268 /= No_Token_Index then
        Or_Pos89 := Row_Pos268;
        Or_Res89 := Transform_Res198;
        goto Exit_Or91;
    end if;
    
--  Start transform_code

Transform_Diags199 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos269 := Pos;



--  Start tok_code

Token_Res430 := Row_Pos269;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res430));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Elsif)
   then
       Token_Pos430 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos269 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos269,
             Expected_Token_Id => Ada_Elsif,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos430 := Row_Pos269 + 1;
   end if;
end;

--  End tok_code



Row_Progress32 := 1;

if Token_Pos430 /= No_Token_Index then

   Row_Pos269 := Token_Pos430;

else
   Row_Pos269 := No_Token_Index;
   goto Exit_Row269_0;

end if;

Nobt36 := True;

   Nobt36 := Nobt36;

Row_Progress32 := 2;

if Row_Pos269 /= No_Token_Index then

   Row_Pos269 := Row_Pos269;

else
   Row_Pos269 := No_Token_Index;
   goto Exit_Row269_0;

end if;


Defer_Res426 :=
   Pp_Expr_Or_Parse0 (Parser, Row_Pos269);
Defer_Pos426 := Parser.Current_Pos;



Row_Progress32 := 3;

if Defer_Pos426 /= No_Token_Index then

   Row_Pos269 := Defer_Pos426;

else
   Row_Pos269 := No_Token_Index;
   goto Exit_Row269_0;

end if;


Defer_Res427 :=
   Pp_Then_Opt_Parse0 (Parser, Row_Pos269);
Defer_Pos427 := Parser.Current_Pos;



Row_Progress32 := 4;

if Defer_Pos427 /= No_Token_Index then

   Row_Pos269 := Defer_Pos427;

else
   Row_Pos269 := No_Token_Index;
   goto Exit_Row269_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row269_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos269 = No_Token_Index and then Nobt36 then

   Row_Pos269 := Parser.Last_Fail.Pos;

   Transform_Has_Failed32 := True;
end if;

if Row_Pos269 /= No_Token_Index then

   Transform_Res199 := Allocate_Pp_Elsif_Directive (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res199,
      Kind => Ada_Pp_Elsif_Directive,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos269 = Pos
                            then No_Token_Index
                            else Row_Pos269 - 1));

      Initialize_Fields_For_Pp_Elsif_Directive
        (Self => Transform_Res199, Pp_Elsif_Directive_F_Expr => Defer_Res426, Pp_Elsif_Directive_F_Then_Kw => Defer_Res427);

         if Defer_Res426 /= null and then Is_Incomplete (Defer_Res426) then
            Transform_Res199.Last_Attempted_Child := 0;
         elsif Defer_Res426 /= null and then not Is_Ghost (Defer_Res426) then
            Transform_Res199.Last_Attempted_Child := -1;
         end if;
         if Defer_Res427 /= null and then Is_Incomplete (Defer_Res427) then
            Transform_Res199.Last_Attempted_Child := 0;
         elsif Defer_Res427 /= null and then not Is_Ghost (Defer_Res427) then
            Transform_Res199.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed32 then
      Transform_Res199.Last_Attempted_Child :=
         Row_Progress32;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <pp_directive>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos269 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags199);
end if;

--  End transform_code

    if Row_Pos269 /= No_Token_Index then
        Or_Pos89 := Row_Pos269;
        Or_Res89 := Transform_Res199;
        goto Exit_Or91;
    end if;
    
--  Start transform_code

Transform_Diags200 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos270 := Pos;



--  Start tok_code

Token_Res431 := Row_Pos270;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res431));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos431 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos270 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos270,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos431 := Row_Pos270 + 1;
   end if;
end;

--  End tok_code




if Token_Pos431 /= No_Token_Index then

   Row_Pos270 := Token_Pos431;

else
   Row_Pos270 := No_Token_Index;
   goto Exit_Row270_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row270_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos270 /= No_Token_Index then

   Transform_Res200 := Allocate_Pp_Else_Directive (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res200,
      Kind => Ada_Pp_Else_Directive,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos270 = Pos
                            then No_Token_Index
                            else Row_Pos270 - 1));




elsif Row_Pos270 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags200);
end if;

--  End transform_code

    if Row_Pos270 /= No_Token_Index then
        Or_Pos89 := Row_Pos270;
        Or_Res89 := Transform_Res200;
        goto Exit_Or91;
    end if;
    
--  Start transform_code

Transform_Diags201 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos271 := Pos;



--  Start tok_code

Token_Res432 := Row_Pos271;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res432));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos432 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos271 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos271,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos432 := Row_Pos271 + 1;
   end if;
end;

--  End tok_code




if Token_Pos432 /= No_Token_Index then

   Row_Pos271 := Token_Pos432;

else
   Row_Pos271 := No_Token_Index;
   goto Exit_Row271_0;

end if;


--  Start tok_code

Token_Res433 := Row_Pos271;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res433));
begin
   if
      T.Kind /= From_Token_Kind (Ada_If)
   then
       Token_Pos433 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos271 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos271,
             Expected_Token_Id => Ada_If,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos433 := Row_Pos271 + 1;
   end if;
end;

--  End tok_code




if Token_Pos433 /= No_Token_Index then

   Row_Pos271 := Token_Pos433;

else
   Row_Pos271 := No_Token_Index;
   goto Exit_Row271_0;

end if;


--  Start tok_code

Token_Res434 := Row_Pos271;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res434));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos434 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos271 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos271,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos434 := Row_Pos271 + 1;
   end if;
end;

--  End tok_code




if Token_Pos434 /= No_Token_Index then

   Row_Pos271 := Token_Pos434;

else
   Row_Pos271 := No_Token_Index;
   goto Exit_Row271_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row271_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos271 /= No_Token_Index then

   Transform_Res201 := Allocate_Pp_End_If_Directive (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res201,
      Kind => Ada_Pp_End_If_Directive,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos271 = Pos
                            then No_Token_Index
                            else Row_Pos271 - 1));




elsif Row_Pos271 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags201);
end if;

--  End transform_code

    if Row_Pos271 /= No_Token_Index then
        Or_Pos89 := Row_Pos271;
        Or_Res89 := Transform_Res201;
        goto Exit_Or91;
    end if;
<<Exit_Or91>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Pp_Directive_Or_Parse0_Memo,
      Or_Pos89 /= No_Token_Index,
      Or_Res89,
      Pos,
      Or_Pos89);


   Parser.Current_Pos := Or_Pos89;

   Exit_Call (Parser, Call_Depth);
   return Or_Res89;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Pp_Directive_Or_Parse0;

   


function Pp_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt37 :
            Boolean
               := False;
      Row_Pos272 :
            Token_Index
               := No_Token_Index;
      Defer_Pos428 :
            Token_Index
               := No_Token_Index;
      Defer_Res428 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos429 :
            Token_Index
               := No_Token_Index;
      Defer_Res429 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos430 :
            Token_Index
               := No_Token_Index;
      Defer_Res430 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress33 :
            Integer
               := 0;
      Transform_Res202 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed33 :
            Boolean
               := False;
      Transform_Diags202 :
            Ada.Containers.Count_Type;
      Defer_Pos431 :
            Token_Index
               := No_Token_Index;
      Defer_Res431 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos90 :
            Token_Index
               := No_Token_Index;
      Or_Res90 :
            Bare_Expr
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Pp_Expr_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res90 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res90;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res90;
   end if;

       Set (Parser.Private_Part.Pp_Expr_Or_Parse0_Memo, False, Or_Res90, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt37 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos90 := No_Token_Index;
Or_Res90 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags202 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos272 := Pos;



Defer_Res428 :=
   Pp_Expr_Or_Parse0 (Parser, Row_Pos272);
Defer_Pos428 := Parser.Current_Pos;



Row_Progress33 := 1;

if Defer_Pos428 /= No_Token_Index then

   Row_Pos272 := Defer_Pos428;

else
   Row_Pos272 := No_Token_Index;
   goto Exit_Row272_0;

end if;


Defer_Res429 :=
   Boolean_Op_Or_Parse0 (Parser, Row_Pos272);
Defer_Pos429 := Parser.Current_Pos;



Row_Progress33 := 2;

if Defer_Pos429 /= No_Token_Index then

   Row_Pos272 := Defer_Pos429;

else
   Row_Pos272 := No_Token_Index;
   goto Exit_Row272_0;

end if;

Nobt37 := True;

   Nobt37 := Nobt37;

Row_Progress33 := 3;

if Row_Pos272 /= No_Token_Index then

   Row_Pos272 := Row_Pos272;

else
   Row_Pos272 := No_Token_Index;
   goto Exit_Row272_0;

end if;


Defer_Res430 :=
   Pp_Term_Or_Parse2 (Parser, Row_Pos272);
Defer_Pos430 := Parser.Current_Pos;



Row_Progress33 := 4;

if Defer_Pos430 /= No_Token_Index then

   Row_Pos272 := Defer_Pos430;

else
   Row_Pos272 := No_Token_Index;
   goto Exit_Row272_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row272_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos272 = No_Token_Index and then Nobt37 then

   Row_Pos272 := Parser.Last_Fail.Pos;

   Transform_Has_Failed33 := True;
end if;

if Row_Pos272 /= No_Token_Index then

   Transform_Res202 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res202,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos272 = Pos
                            then No_Token_Index
                            else Row_Pos272 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res202, Bin_Op_F_Left => Defer_Res428, Bin_Op_F_Op => Defer_Res429, Bin_Op_F_Right => Defer_Res430);

         if Defer_Res428 /= null and then Is_Incomplete (Defer_Res428) then
            Transform_Res202.Last_Attempted_Child := 0;
         elsif Defer_Res428 /= null and then not Is_Ghost (Defer_Res428) then
            Transform_Res202.Last_Attempted_Child := -1;
         end if;
         if Defer_Res429 /= null and then Is_Incomplete (Defer_Res429) then
            Transform_Res202.Last_Attempted_Child := 0;
         elsif Defer_Res429 /= null and then not Is_Ghost (Defer_Res429) then
            Transform_Res202.Last_Attempted_Child := -1;
         end if;
         if Defer_Res430 /= null and then Is_Incomplete (Defer_Res430) then
            Transform_Res202.Last_Attempted_Child := 0;
         elsif Defer_Res430 /= null and then not Is_Ghost (Defer_Res430) then
            Transform_Res202.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed33 then
      Transform_Res202.Last_Attempted_Child :=
         Row_Progress33;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <pp_expr>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos272 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags202);
end if;

--  End transform_code

    if Row_Pos272 /= No_Token_Index then
        Or_Pos90 := Row_Pos272;
        Or_Res90 := Transform_Res202;
        goto Exit_Or92;
    end if;
    
Defer_Res431 :=
   Pp_Term_Or_Parse2 (Parser, Pos);
Defer_Pos431 := Parser.Current_Pos;

    if Defer_Pos431 /= No_Token_Index then
        Or_Pos90 := Defer_Pos431;
        Or_Res90 := Defer_Res431;
        goto Exit_Or92;
    end if;
<<Exit_Or92>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos90 > Mem_Pos then
         Mem_Pos := Or_Pos90;
         Mem_Res := Or_Res90;
         Set
           (Parser.Private_Part.Pp_Expr_Or_Parse0_Memo,
            Or_Pos90 /= No_Token_Index,
            Or_Res90,
            Pos,
            Or_Pos90);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res90 := Mem_Res;
         Or_Pos90 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Pp_Expr_Or_Parse0_Memo,
      Or_Pos90 /= No_Token_Index,
      Or_Res90,
      Pos,
      Or_Pos90);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos90;

   Exit_Call (Parser, Call_Depth);
   return Or_Res90;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Pp_Expr_Or_Parse0;

   


function Pp_Term_Or_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos273 :
            Token_Index
               := No_Token_Index;
      Token_Pos435 :
            Token_Index
               := No_Token_Index;
      Token_Res435 :
            Token_Index
               := No_Token_Index;
      Defer_Pos432 :
            Token_Index
               := No_Token_Index;
      Defer_Res432 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos436 :
            Token_Index
               := No_Token_Index;
      Token_Res436 :
            Token_Index
               := No_Token_Index;
      Transform_Res203 :
            Bare_Paren_Expr
               := No_Bare_Ada_Node;
      Transform_Diags203 :
            Ada.Containers.Count_Type;
      Row_Pos274 :
            Token_Index
               := No_Token_Index;
      Row_Pos275 :
            Token_Index
               := No_Token_Index;
      Token_Pos437 :
            Token_Index
               := No_Token_Index;
      Token_Res437 :
            Token_Index
               := No_Token_Index;
      Transform_Res204 :
            Bare_Op_Not
               := No_Bare_Ada_Node;
      Transform_Diags204 :
            Ada.Containers.Count_Type;
      Defer_Pos433 :
            Token_Index
               := No_Token_Index;
      Defer_Res433 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res205 :
            Bare_Un_Op
               := No_Bare_Ada_Node;
      Transform_Diags205 :
            Ada.Containers.Count_Type;
      Row_Pos276 :
            Token_Index
               := No_Token_Index;
      Defer_Pos434 :
            Token_Index
               := No_Token_Index;
      Defer_Res434 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Row_Pos277 :
            Token_Index
               := No_Token_Index;
      Token_Pos438 :
            Token_Index
               := No_Token_Index;
      Token_Res438 :
            Token_Index
               := No_Token_Index;
      Transform_Res206 :
            Bare_Op_Eq
               := No_Bare_Ada_Node;
      Transform_Diags206 :
            Ada.Containers.Count_Type;
      Row_Pos278 :
            Token_Index
               := No_Token_Index;
      Token_Pos439 :
            Token_Index
               := No_Token_Index;
      Token_Res439 :
            Token_Index
               := No_Token_Index;
      Transform_Res207 :
            Bare_Op_Lt
               := No_Bare_Ada_Node;
      Transform_Diags207 :
            Ada.Containers.Count_Type;
      Row_Pos279 :
            Token_Index
               := No_Token_Index;
      Token_Pos440 :
            Token_Index
               := No_Token_Index;
      Token_Res440 :
            Token_Index
               := No_Token_Index;
      Transform_Res208 :
            Bare_Op_Lte
               := No_Bare_Ada_Node;
      Transform_Diags208 :
            Ada.Containers.Count_Type;
      Row_Pos280 :
            Token_Index
               := No_Token_Index;
      Token_Pos441 :
            Token_Index
               := No_Token_Index;
      Token_Res441 :
            Token_Index
               := No_Token_Index;
      Transform_Res209 :
            Bare_Op_Gt
               := No_Bare_Ada_Node;
      Transform_Diags209 :
            Ada.Containers.Count_Type;
      Row_Pos281 :
            Token_Index
               := No_Token_Index;
      Token_Pos442 :
            Token_Index
               := No_Token_Index;
      Token_Res442 :
            Token_Index
               := No_Token_Index;
      Transform_Res210 :
            Bare_Op_Gte
               := No_Bare_Ada_Node;
      Transform_Diags210 :
            Ada.Containers.Count_Type;
      Or_Pos91 :
            Token_Index
               := No_Token_Index;
      Or_Res91 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos435 :
            Token_Index
               := No_Token_Index;
      Defer_Res435 :
            Bare_String_Literal
               := No_Bare_Ada_Node;
      Defer_Pos436 :
            Token_Index
               := No_Token_Index;
      Defer_Res436 :
            Bare_Int_Literal
               := No_Bare_Ada_Node;
      Defer_Pos437 :
            Token_Index
               := No_Token_Index;
      Defer_Res437 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Or_Pos92 :
            Token_Index
               := No_Token_Index;
      Or_Res92 :
            Bare_Single_Tok_Node
               := No_Bare_Ada_Node;
      Transform_Res211 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Diags211 :
            Ada.Containers.Count_Type;
      Row_Pos282 :
            Token_Index
               := No_Token_Index;
      Defer_Pos438 :
            Token_Index
               := No_Token_Index;
      Defer_Res438 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Token_Pos443 :
            Token_Index
               := No_Token_Index;
      Token_Res443 :
            Token_Index
               := No_Token_Index;
      Defer_Pos439 :
            Token_Index
               := No_Token_Index;
      Defer_Res439 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Null_Res28 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Transform_Res212 :
            Bare_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags212 :
            Ada.Containers.Count_Type;
      Defer_Pos440 :
            Token_Index
               := No_Token_Index;
      Defer_Res440 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Or_Pos93 :
            Token_Index
               := No_Token_Index;
      Or_Res93 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Pp_Term_Or_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res93 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res93;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res93;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos93 := No_Token_Index;
Or_Res93 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags203 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos273 := Pos;



--  Start tok_code

Token_Res435 := Row_Pos273;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res435));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos435 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos273 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos273,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos435 := Row_Pos273 + 1;
   end if;
end;

--  End tok_code




if Token_Pos435 /= No_Token_Index then

   Row_Pos273 := Token_Pos435;

else
   Row_Pos273 := No_Token_Index;
   goto Exit_Row273_0;

end if;


Defer_Res432 :=
   Pp_Expr_Or_Parse0 (Parser, Row_Pos273);
Defer_Pos432 := Parser.Current_Pos;




if Defer_Pos432 /= No_Token_Index then

   Row_Pos273 := Defer_Pos432;

else
   Row_Pos273 := No_Token_Index;
   goto Exit_Row273_0;

end if;


--  Start tok_code

Token_Res436 := Row_Pos273;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res436));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos436 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos273 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos273,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos436 := Row_Pos273 + 1;
   end if;
end;

--  End tok_code




if Token_Pos436 /= No_Token_Index then

   Row_Pos273 := Token_Pos436;

else
   Row_Pos273 := No_Token_Index;
   goto Exit_Row273_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row273_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos273 /= No_Token_Index then

   Transform_Res203 := Allocate_Paren_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res203,
      Kind => Ada_Paren_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos273 = Pos
                            then No_Token_Index
                            else Row_Pos273 - 1));

      Initialize_Fields_For_Paren_Expr
        (Self => Transform_Res203, Paren_Expr_F_Expr => Defer_Res432);

         if Defer_Res432 /= null and then Is_Incomplete (Defer_Res432) then
            Transform_Res203.Last_Attempted_Child := 0;
         elsif Defer_Res432 /= null and then not Is_Ghost (Defer_Res432) then
            Transform_Res203.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos273 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags203);
end if;

--  End transform_code

    if Row_Pos273 /= No_Token_Index then
        Or_Pos93 := Row_Pos273;
        Or_Res93 := Transform_Res203;
        goto Exit_Or93;
    end if;
    
--  Start transform_code

Transform_Diags205 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos274 := Pos;



--  Start transform_code

Transform_Diags204 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos275 := Row_Pos274;



--  Start tok_code

Token_Res437 := Row_Pos275;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res437));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos437 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos275 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos275,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos437 := Row_Pos275 + 1;
   end if;
end;

--  End tok_code




if Token_Pos437 /= No_Token_Index then

   Row_Pos275 := Token_Pos437;

else
   Row_Pos275 := No_Token_Index;
   goto Exit_Row275_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row275_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos275 /= No_Token_Index then

   Transform_Res204 := Allocate_Op_Not (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res204,
      Kind => Ada_Op_Not,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos274,
      Token_End_Index   => (if Row_Pos275 = Row_Pos274
                            then No_Token_Index
                            else Row_Pos275 - 1));

      Initialize_Fields_For_Op_Not
        (Self => Transform_Res204);



elsif Row_Pos275 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags204);
end if;

--  End transform_code




if Row_Pos275 /= No_Token_Index then

   Row_Pos274 := Row_Pos275;

else
   Row_Pos274 := No_Token_Index;
   goto Exit_Row274_0;

end if;


Defer_Res433 :=
   Pp_Expr_Or_Parse0 (Parser, Row_Pos274);
Defer_Pos433 := Parser.Current_Pos;




if Defer_Pos433 /= No_Token_Index then

   Row_Pos274 := Defer_Pos433;

else
   Row_Pos274 := No_Token_Index;
   goto Exit_Row274_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row274_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos274 /= No_Token_Index then

   Transform_Res205 := Allocate_Un_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res205,
      Kind => Ada_Un_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos274 = Pos
                            then No_Token_Index
                            else Row_Pos274 - 1));

      Initialize_Fields_For_Un_Op
        (Self => Transform_Res205, Un_Op_F_Op => Transform_Res204, Un_Op_F_Expr => Defer_Res433);

         if Transform_Res204 /= null and then Is_Incomplete (Transform_Res204) then
            Transform_Res205.Last_Attempted_Child := 0;
         elsif Transform_Res204 /= null and then not Is_Ghost (Transform_Res204) then
            Transform_Res205.Last_Attempted_Child := -1;
         end if;
         if Defer_Res433 /= null and then Is_Incomplete (Defer_Res433) then
            Transform_Res205.Last_Attempted_Child := 0;
         elsif Defer_Res433 /= null and then not Is_Ghost (Defer_Res433) then
            Transform_Res205.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos274 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags205);
end if;

--  End transform_code

    if Row_Pos274 /= No_Token_Index then
        Or_Pos93 := Row_Pos274;
        Or_Res93 := Transform_Res205;
        goto Exit_Or93;
    end if;
    
--  Start transform_code

Transform_Diags211 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos276 := Pos;



Defer_Res434 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos276);
Defer_Pos434 := Parser.Current_Pos;




if Defer_Pos434 /= No_Token_Index then

   Row_Pos276 := Defer_Pos434;

else
   Row_Pos276 := No_Token_Index;
   goto Exit_Row276_0;

end if;


--  Start or_code

Or_Pos91 := No_Token_Index;
Or_Res91 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags206 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos277 := Row_Pos276;



--  Start tok_code

Token_Res438 := Row_Pos277;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res438));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Equal)
   then
       Token_Pos438 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos277 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos277,
             Expected_Token_Id => Ada_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos438 := Row_Pos277 + 1;
   end if;
end;

--  End tok_code




if Token_Pos438 /= No_Token_Index then

   Row_Pos277 := Token_Pos438;

else
   Row_Pos277 := No_Token_Index;
   goto Exit_Row277_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row277_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos277 /= No_Token_Index then

   Transform_Res206 := Allocate_Op_Eq (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res206,
      Kind => Ada_Op_Eq,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos276,
      Token_End_Index   => (if Row_Pos277 = Row_Pos276
                            then No_Token_Index
                            else Row_Pos277 - 1));

      Initialize_Fields_For_Op_Eq
        (Self => Transform_Res206);



elsif Row_Pos277 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags206);
end if;

--  End transform_code

    if Row_Pos277 /= No_Token_Index then
        Or_Pos91 := Row_Pos277;
        Or_Res91 := Transform_Res206;
        goto Exit_Or94;
    end if;
    
--  Start transform_code

Transform_Diags207 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos278 := Row_Pos276;



--  Start tok_code

Token_Res439 := Row_Pos278;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res439));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Lt)
   then
       Token_Pos439 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos278 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos278,
             Expected_Token_Id => Ada_Lt,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos439 := Row_Pos278 + 1;
   end if;
end;

--  End tok_code




if Token_Pos439 /= No_Token_Index then

   Row_Pos278 := Token_Pos439;

else
   Row_Pos278 := No_Token_Index;
   goto Exit_Row278_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row278_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos278 /= No_Token_Index then

   Transform_Res207 := Allocate_Op_Lt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res207,
      Kind => Ada_Op_Lt,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos276,
      Token_End_Index   => (if Row_Pos278 = Row_Pos276
                            then No_Token_Index
                            else Row_Pos278 - 1));

      Initialize_Fields_For_Op_Lt
        (Self => Transform_Res207);



elsif Row_Pos278 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags207);
end if;

--  End transform_code

    if Row_Pos278 /= No_Token_Index then
        Or_Pos91 := Row_Pos278;
        Or_Res91 := Transform_Res207;
        goto Exit_Or94;
    end if;
    
--  Start transform_code

Transform_Diags208 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos279 := Row_Pos276;



--  Start tok_code

Token_Res440 := Row_Pos279;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res440));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Lte)
   then
       Token_Pos440 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos279 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos279,
             Expected_Token_Id => Ada_Lte,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos440 := Row_Pos279 + 1;
   end if;
end;

--  End tok_code




if Token_Pos440 /= No_Token_Index then

   Row_Pos279 := Token_Pos440;

else
   Row_Pos279 := No_Token_Index;
   goto Exit_Row279_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row279_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos279 /= No_Token_Index then

   Transform_Res208 := Allocate_Op_Lte (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res208,
      Kind => Ada_Op_Lte,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos276,
      Token_End_Index   => (if Row_Pos279 = Row_Pos276
                            then No_Token_Index
                            else Row_Pos279 - 1));

      Initialize_Fields_For_Op_Lte
        (Self => Transform_Res208);



elsif Row_Pos279 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags208);
end if;

--  End transform_code

    if Row_Pos279 /= No_Token_Index then
        Or_Pos91 := Row_Pos279;
        Or_Res91 := Transform_Res208;
        goto Exit_Or94;
    end if;
    
--  Start transform_code

Transform_Diags209 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos280 := Row_Pos276;



--  Start tok_code

Token_Res441 := Row_Pos280;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res441));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Gt)
   then
       Token_Pos441 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos280 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos280,
             Expected_Token_Id => Ada_Gt,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos441 := Row_Pos280 + 1;
   end if;
end;

--  End tok_code




if Token_Pos441 /= No_Token_Index then

   Row_Pos280 := Token_Pos441;

else
   Row_Pos280 := No_Token_Index;
   goto Exit_Row280_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row280_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos280 /= No_Token_Index then

   Transform_Res209 := Allocate_Op_Gt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res209,
      Kind => Ada_Op_Gt,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos276,
      Token_End_Index   => (if Row_Pos280 = Row_Pos276
                            then No_Token_Index
                            else Row_Pos280 - 1));

      Initialize_Fields_For_Op_Gt
        (Self => Transform_Res209);



elsif Row_Pos280 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags209);
end if;

--  End transform_code

    if Row_Pos280 /= No_Token_Index then
        Or_Pos91 := Row_Pos280;
        Or_Res91 := Transform_Res209;
        goto Exit_Or94;
    end if;
    
--  Start transform_code

Transform_Diags210 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos281 := Row_Pos276;



--  Start tok_code

Token_Res442 := Row_Pos281;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res442));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Gte)
   then
       Token_Pos442 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos281 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos281,
             Expected_Token_Id => Ada_Gte,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos442 := Row_Pos281 + 1;
   end if;
end;

--  End tok_code




if Token_Pos442 /= No_Token_Index then

   Row_Pos281 := Token_Pos442;

else
   Row_Pos281 := No_Token_Index;
   goto Exit_Row281_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row281_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos281 /= No_Token_Index then

   Transform_Res210 := Allocate_Op_Gte (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res210,
      Kind => Ada_Op_Gte,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos276,
      Token_End_Index   => (if Row_Pos281 = Row_Pos276
                            then No_Token_Index
                            else Row_Pos281 - 1));

      Initialize_Fields_For_Op_Gte
        (Self => Transform_Res210);



elsif Row_Pos281 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags210);
end if;

--  End transform_code

    if Row_Pos281 /= No_Token_Index then
        Or_Pos91 := Row_Pos281;
        Or_Res91 := Transform_Res210;
        goto Exit_Or94;
    end if;
<<Exit_Or94>>

--  End or_code




if Or_Pos91 /= No_Token_Index then

   Row_Pos276 := Or_Pos91;

else
   Row_Pos276 := No_Token_Index;
   goto Exit_Row276_0;

end if;


--  Start or_code

Or_Pos92 := No_Token_Index;
Or_Res92 := No_Bare_Ada_Node;
    
Defer_Res435 :=
   String_Literal_Transform_Parse0 (Parser, Row_Pos276);
Defer_Pos435 := Parser.Current_Pos;

    if Defer_Pos435 /= No_Token_Index then
        Or_Pos92 := Defer_Pos435;
        Or_Res92 := Defer_Res435;
        goto Exit_Or95;
    end if;
    
Defer_Res436 :=
   Int_Literal_Transform_Parse0 (Parser, Row_Pos276);
Defer_Pos436 := Parser.Current_Pos;

    if Defer_Pos436 /= No_Token_Index then
        Or_Pos92 := Defer_Pos436;
        Or_Res92 := Defer_Res436;
        goto Exit_Or95;
    end if;
    
Defer_Res437 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos276);
Defer_Pos437 := Parser.Current_Pos;

    if Defer_Pos437 /= No_Token_Index then
        Or_Pos92 := Defer_Pos437;
        Or_Res92 := Defer_Res437;
        goto Exit_Or95;
    end if;
<<Exit_Or95>>

--  End or_code




if Or_Pos92 /= No_Token_Index then

   Row_Pos276 := Or_Pos92;

else
   Row_Pos276 := No_Token_Index;
   goto Exit_Row276_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row276_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos276 /= No_Token_Index then

   Transform_Res211 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res211,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos276 = Pos
                            then No_Token_Index
                            else Row_Pos276 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res211, Bin_Op_F_Left => Defer_Res434, Bin_Op_F_Op => Or_Res91, Bin_Op_F_Right => Or_Res92);

         if Defer_Res434 /= null and then Is_Incomplete (Defer_Res434) then
            Transform_Res211.Last_Attempted_Child := 0;
         elsif Defer_Res434 /= null and then not Is_Ghost (Defer_Res434) then
            Transform_Res211.Last_Attempted_Child := -1;
         end if;
         if Or_Res91 /= null and then Is_Incomplete (Or_Res91) then
            Transform_Res211.Last_Attempted_Child := 0;
         elsif Or_Res91 /= null and then not Is_Ghost (Or_Res91) then
            Transform_Res211.Last_Attempted_Child := -1;
         end if;
         if Or_Res92 /= null and then Is_Incomplete (Or_Res92) then
            Transform_Res211.Last_Attempted_Child := 0;
         elsif Or_Res92 /= null and then not Is_Ghost (Or_Res92) then
            Transform_Res211.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos276 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags211);
end if;

--  End transform_code

    if Row_Pos276 /= No_Token_Index then
        Or_Pos93 := Row_Pos276;
        Or_Res93 := Transform_Res211;
        goto Exit_Or93;
    end if;
    
--  Start transform_code

Transform_Diags212 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos282 := Pos;



Defer_Res438 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos282);
Defer_Pos438 := Parser.Current_Pos;




if Defer_Pos438 /= No_Token_Index then

   Row_Pos282 := Defer_Pos438;

else
   Row_Pos282 := No_Token_Index;
   goto Exit_Row282_0;

end if;


--  Start tok_code

Token_Res443 := Row_Pos282;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res443));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos443 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos282 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos282,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos443 := Row_Pos282 + 1;
   end if;
end;

--  End tok_code




if Token_Pos443 /= No_Token_Index then

   Row_Pos282 := Token_Pos443;

else
   Row_Pos282 := No_Token_Index;
   goto Exit_Row282_0;

end if;


Defer_Res439 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos282);
Defer_Pos439 := Parser.Current_Pos;




if Defer_Pos439 /= No_Token_Index then

   Row_Pos282 := Defer_Pos439;

else
   Row_Pos282 := No_Token_Index;
   goto Exit_Row282_0;

end if;


   Null_Res28 := Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res28,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos282, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res28,
      Parser => Parser,
      Count  => 0);





if Row_Pos282 /= No_Token_Index then

   Row_Pos282 := Row_Pos282;

else
   Row_Pos282 := No_Token_Index;
   goto Exit_Row282_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row282_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos282 /= No_Token_Index then

   Transform_Res212 := Allocate_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res212,
      Kind => Ada_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos282 = Pos
                            then No_Token_Index
                            else Row_Pos282 - 1));

      Initialize_Fields_For_Attribute_Ref
        (Self => Transform_Res212, Attribute_Ref_F_Prefix => Defer_Res438, Attribute_Ref_F_Attribute => Defer_Res439, Attribute_Ref_F_Args => Null_Res28);

         if Defer_Res438 /= null and then Is_Incomplete (Defer_Res438) then
            Transform_Res212.Last_Attempted_Child := 0;
         elsif Defer_Res438 /= null and then not Is_Ghost (Defer_Res438) then
            Transform_Res212.Last_Attempted_Child := -1;
         end if;
         if Defer_Res439 /= null and then Is_Incomplete (Defer_Res439) then
            Transform_Res212.Last_Attempted_Child := 0;
         elsif Defer_Res439 /= null and then not Is_Ghost (Defer_Res439) then
            Transform_Res212.Last_Attempted_Child := -1;
         end if;
         if Null_Res28 /= null and then Is_Incomplete (Null_Res28) then
            Transform_Res212.Last_Attempted_Child := 0;
         elsif Null_Res28 /= null and then not Is_Ghost (Null_Res28) then
            Transform_Res212.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos282 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags212);
end if;

--  End transform_code

    if Row_Pos282 /= No_Token_Index then
        Or_Pos93 := Row_Pos282;
        Or_Res93 := Transform_Res212;
        goto Exit_Or93;
    end if;
    
Defer_Res440 :=
   Identifier_Transform_Parse0 (Parser, Pos);
Defer_Pos440 := Parser.Current_Pos;

    if Defer_Pos440 /= No_Token_Index then
        Or_Pos93 := Defer_Pos440;
        Or_Res93 := Defer_Res440;
        goto Exit_Or93;
    end if;
<<Exit_Or93>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Pp_Term_Or_Parse2_Memo,
      Or_Pos93 /= No_Token_Index,
      Or_Res93,
      Pos,
      Or_Pos93);


   Parser.Current_Pos := Or_Pos93;

   Exit_Call (Parser, Call_Depth);
   return Or_Res93;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Pp_Term_Or_Parse2;

   


function Pp_Then_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pp_Then_Kw
is
   use Bare_Pp_Then_Kw_Memos;

   Call_Depth : aliased Natural;

      Row_Pos283 :
            Token_Index
               := No_Token_Index;
      Token_Pos444 :
            Token_Index
               := No_Token_Index;
      Token_Res444 :
            Token_Index
               := No_Token_Index;
      Transform_Res213 :
            Bare_Pp_Then_Kw
               := No_Bare_Ada_Node;
      Transform_Diags213 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Pp_Then_Opt_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res213 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res213;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res213;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start opt_code












--  Start transform_code

Transform_Diags213 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos283 := Pos;



--  Start tok_code

Token_Res444 := Row_Pos283;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res444));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos444 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos283 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos283,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos444 := Row_Pos283 + 1;
   end if;
end;

--  End tok_code




if Token_Pos444 /= No_Token_Index then

   Row_Pos283 := Token_Pos444;

else
   Row_Pos283 := No_Token_Index;
   goto Exit_Row283_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row283_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos283 /= No_Token_Index then

   Transform_Res213 := Allocate_Pp_Then_Kw (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res213,
      Kind => Ada_Pp_Then_Kw,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos283 = Pos
                            then No_Token_Index
                            else Row_Pos283 - 1));




elsif Row_Pos283 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags213);
end if;

--  End transform_code


if Row_Pos283 = No_Token_Index then

         
   Transform_Res213 := No_Bare_Ada_Node;



       
   Row_Pos283 := Pos;



end if;

--  End opt_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Pp_Then_Opt_Parse0_Memo,
      Row_Pos283 /= No_Token_Index,
      Transform_Res213,
      Pos,
      Row_Pos283);


   Parser.Current_Pos := Row_Pos283;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res213;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Pp_Then_Opt_Parse0;

   


function Pragma_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pragma_Node
is
   use Bare_Pragma_Node_Memos;

   Call_Depth : aliased Natural;

      Nobt38 :
            Boolean
               := False;
      Nobt39 :
            Boolean
               := False;
      Row_Pos284 :
            Token_Index
               := No_Token_Index;
      Token_Pos445 :
            Token_Index
               := No_Token_Index;
      Token_Res445 :
            Token_Index
               := No_Token_Index;
      Defer_Pos441 :
            Token_Index
               := No_Token_Index;
      Defer_Res441 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Row_Pos285 :
            Token_Index
               := No_Token_Index;
      Token_Pos446 :
            Token_Index
               := No_Token_Index;
      Token_Res446 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos41 :
            Token_Index
               := No_Token_Index;
      Tmp_List41 :
            Free_Parse_List;
      Defer_Pos442 :
            Token_Index
               := No_Token_Index;
      Defer_Res442 :
            Bare_Pragma_Argument_Assoc
               := No_Bare_Ada_Node;
      Defer_Pos443 :
            Token_Index
               := No_Token_Index;
      Defer_Res443 :
            Bare_Contract_Case_Assoc
               := No_Bare_Ada_Node;
      Or_Pos94 :
            Token_Index
               := No_Token_Index;
      Or_Res94 :
            Bare_Base_Assoc
               := No_Bare_Ada_Node;
      Token_Pos447 :
            Token_Index
               := No_Token_Index;
      Token_Res447 :
            Token_Index
               := No_Token_Index;
      List_Pos41 :
            Token_Index
               := No_Token_Index;
      List_Res41 :
            Bare_Base_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos448 :
            Token_Index
               := No_Token_Index;
      Token_Res448 :
            Token_Index
               := No_Token_Index;
      Token_Pos449 :
            Token_Index
               := No_Token_Index;
      Token_Res449 :
            Token_Index
               := No_Token_Index;
      Row_Progress34 :
            Integer
               := 0;
      Transform_Res214 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Transform_Has_Failed34 :
            Boolean
               := False;
      Transform_Diags214 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Pragma_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res214 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res214;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res214;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags214 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos284 := Pos;



--  Start tok_code

Token_Res445 := Row_Pos284;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res445));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Pragma)
   then
       Token_Pos445 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos284 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos284,
             Expected_Token_Id => Ada_Pragma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos445 := Row_Pos284 + 1;
   end if;
end;

--  End tok_code



Row_Progress34 := 1;

if Token_Pos445 /= No_Token_Index then

   Row_Pos284 := Token_Pos445;

else
   Row_Pos284 := No_Token_Index;
   goto Exit_Row284_0;

end if;

Nobt38 := True;

   Nobt38 := Nobt38;

Row_Progress34 := 2;

if Row_Pos284 /= No_Token_Index then

   Row_Pos284 := Row_Pos284;

else
   Row_Pos284 := No_Token_Index;
   goto Exit_Row284_0;

end if;


Defer_Res441 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos284);
Defer_Pos441 := Parser.Current_Pos;



Row_Progress34 := 3;

if Defer_Pos441 /= No_Token_Index then

   Row_Pos284 := Defer_Pos441;

else
   Row_Pos284 := No_Token_Index;
   goto Exit_Row284_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos285 := Row_Pos284;



--  Start tok_code

Token_Res446 := Row_Pos285;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res446));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos446 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos285 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos285,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos446 := Row_Pos285 + 1;
   end if;
end;

--  End tok_code




if Token_Pos446 /= No_Token_Index then

   Row_Pos285 := Token_Pos446;

else
   Row_Pos285 := No_Token_Index;
   goto Exit_Row285_0;

end if;

Nobt39 := True;

   Nobt39 := Nobt39;


if Row_Pos285 /= No_Token_Index then

   Row_Pos285 := Row_Pos285;

else
   Row_Pos285 := No_Token_Index;
   goto Exit_Row285_0;

end if;


--  Start list_code

    List_Pos41 := No_Token_Index;



Lst_Cpos41 := Row_Pos285;
Tmp_List41 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos94 := No_Token_Index;
Or_Res94 := No_Bare_Ada_Node;
    
Defer_Res442 :=
   Pragma_Argument_Transform_Parse1 (Parser, Lst_Cpos41);
Defer_Pos442 := Parser.Current_Pos;

    if Defer_Pos442 /= No_Token_Index then
        Or_Pos94 := Defer_Pos442;
        Or_Res94 := Defer_Res442;
        goto Exit_Or96;
    end if;
    
Defer_Res443 :=
   Contract_Case_Assoc_Transform_Parse0 (Parser, Lst_Cpos41);
Defer_Pos443 := Parser.Current_Pos;

    if Defer_Pos443 /= No_Token_Index then
        Or_Pos94 := Defer_Pos443;
        Or_Res94 := Defer_Res443;
        goto Exit_Or96;
    end if;
<<Exit_Or96>>

--  End or_code


   exit when Or_Pos94 = No_Token_Index;

   List_Pos41 := Or_Pos94;
   Lst_Cpos41 := List_Pos41;

   Tmp_List41.Nodes.Append (Or_Res94);

      
--  Start tok_code

Token_Res447 := Lst_Cpos41;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res447));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos447 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos41 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos41,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos447 := Lst_Cpos41 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos447 /= No_Token_Index then
          Lst_Cpos41 := Token_Pos447;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List41.Nodes.Length;
begin
   List_Res41 :=
      Allocate_Base_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos285;
      Token_End := (if Lst_Cpos41 = Row_Pos285
                    then Row_Pos285
                    else Lst_Cpos41 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos285, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res41,
      Kind              => Ada_Base_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res41,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List41.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res41.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List41);

--  End list_code




if List_Pos41 /= No_Token_Index then

   Row_Pos285 := List_Pos41;

else
   Row_Pos285 := No_Token_Index;
   goto Exit_Row285_0;

end if;


--  Start tok_code

Token_Res448 := Row_Pos285;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res448));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos448 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos285 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos285,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos448 := Row_Pos285 + 1;
   end if;
end;

--  End tok_code




if Token_Pos448 /= No_Token_Index then

   Row_Pos285 := Token_Pos448;

else
   Row_Pos285 := No_Token_Index;
   goto Exit_Row285_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row285_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos285 = No_Token_Index then

         
   if Nobt39 then
      Row_Pos285 := Parser.Last_Fail.Pos;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Row_Pos285)),
              To_Text ("Cannot parse <pragma>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;


         if List_Res41 = No_Bare_Ada_Node then
            
   List_Res41 :=
     Allocate_Base_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => List_Res41,
      Kind              => Ada_Base_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos284 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => List_Res41,
      Parser => Parser,
      Count  => 0);

         end if;


       if not Nobt39 then
          
   Row_Pos285 := Row_Pos284;

       end if;


end if;

--  End opt_code


   Nobt38 := Nobt39;

Row_Progress34 := 4;

if Row_Pos285 /= No_Token_Index then

   Row_Pos284 := Row_Pos285;

else
   Row_Pos284 := No_Token_Index;
   goto Exit_Row284_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res449 := Row_Pos284;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res449));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos449 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos284 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos284,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos449 := Row_Pos284 + 1;
   end if;
end;

--  End tok_code


if Token_Pos449 = No_Token_Index then

         
   Token_Res449 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos284)),
                To_Text ("Missing ';'"));

       
   Token_Pos449 := Row_Pos284;



end if;

--  End opt_code



Row_Progress34 := 5;

if Token_Pos449 /= No_Token_Index then

   Row_Pos284 := Token_Pos449;

else
   Row_Pos284 := No_Token_Index;
   goto Exit_Row284_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row284_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos284 = No_Token_Index and then Nobt38 then

   Row_Pos284 := Parser.Last_Fail.Pos;

   Transform_Has_Failed34 := True;
end if;

if Row_Pos284 /= No_Token_Index then

   Transform_Res214 := Allocate_Pragma_Node (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res214,
      Kind => Ada_Pragma_Node,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos284 = Pos
                            then No_Token_Index
                            else Row_Pos284 - 1));

      Initialize_Fields_For_Pragma_Node
        (Self => Transform_Res214, Pragma_Node_F_Id => Defer_Res441, Pragma_Node_F_Args => List_Res41);

         if Defer_Res441 /= null and then Is_Incomplete (Defer_Res441) then
            Transform_Res214.Last_Attempted_Child := 0;
         elsif Defer_Res441 /= null and then not Is_Ghost (Defer_Res441) then
            Transform_Res214.Last_Attempted_Child := -1;
         end if;
         if List_Res41 /= null and then Is_Incomplete (List_Res41) then
            Transform_Res214.Last_Attempted_Child := 0;
         elsif List_Res41 /= null and then not Is_Ghost (List_Res41) then
            Transform_Res214.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed34 then
      Transform_Res214.Last_Attempted_Child :=
         Row_Progress34;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <pragma>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos284 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags214);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Pragma_Transform_Parse0_Memo,
      Row_Pos284 /= No_Token_Index,
      Transform_Res214,
      Pos,
      Row_Pos284);


   Parser.Current_Pos := Row_Pos284;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res214;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Pragma_Transform_Parse0;

   


function Pragma_Argument_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pragma_Argument_Assoc
is
   use Bare_Pragma_Argument_Assoc_Memos;

   Call_Depth : aliased Natural;

      Row_Pos286 :
            Token_Index
               := No_Token_Index;
      Row_Pos287 :
            Token_Index
               := No_Token_Index;
      Row_Pos288 :
            Token_Index
               := No_Token_Index;
      Defer_Pos444 :
            Token_Index
               := No_Token_Index;
      Defer_Res444 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Token_Pos450 :
            Token_Index
               := No_Token_Index;
      Token_Res450 :
            Token_Index
               := No_Token_Index;
      Defer_Pos445 :
            Token_Index
               := No_Token_Index;
      Defer_Res445 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Null_Res29 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Transform_Res215 :
            Bare_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags215 :
            Ada.Containers.Count_Type;
      Defer_Pos446 :
            Token_Index
               := No_Token_Index;
      Defer_Res446 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Or_Pos95 :
            Token_Index
               := No_Token_Index;
      Or_Res95 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos451 :
            Token_Index
               := No_Token_Index;
      Token_Res451 :
            Token_Index
               := No_Token_Index;
      Defer_Pos447 :
            Token_Index
               := No_Token_Index;
      Defer_Res447 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res216 :
            Bare_Pragma_Argument_Assoc
               := No_Bare_Ada_Node;
      Transform_Diags216 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Pragma_Argument_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res216 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res216;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res216;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags216 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos286 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos287 := Row_Pos286;



--  Start or_code

Or_Pos95 := No_Token_Index;
Or_Res95 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags215 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos288 := Row_Pos287;



Defer_Res444 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos288);
Defer_Pos444 := Parser.Current_Pos;




if Defer_Pos444 /= No_Token_Index then

   Row_Pos288 := Defer_Pos444;

else
   Row_Pos288 := No_Token_Index;
   goto Exit_Row288_0;

end if;


--  Start tok_code

Token_Res450 := Row_Pos288;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res450));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos450 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos288 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos288,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos450 := Row_Pos288 + 1;
   end if;
end;

--  End tok_code




if Token_Pos450 /= No_Token_Index then

   Row_Pos288 := Token_Pos450;

else
   Row_Pos288 := No_Token_Index;
   goto Exit_Row288_0;

end if;


Defer_Res445 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos288);
Defer_Pos445 := Parser.Current_Pos;




if Defer_Pos445 /= No_Token_Index then

   Row_Pos288 := Defer_Pos445;

else
   Row_Pos288 := No_Token_Index;
   goto Exit_Row288_0;

end if;


   Null_Res29 := Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res29,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos288, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res29,
      Parser => Parser,
      Count  => 0);





if Row_Pos288 /= No_Token_Index then

   Row_Pos288 := Row_Pos288;

else
   Row_Pos288 := No_Token_Index;
   goto Exit_Row288_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row288_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos288 /= No_Token_Index then

   Transform_Res215 := Allocate_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res215,
      Kind => Ada_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos287,
      Token_End_Index   => (if Row_Pos288 = Row_Pos287
                            then No_Token_Index
                            else Row_Pos288 - 1));

      Initialize_Fields_For_Attribute_Ref
        (Self => Transform_Res215, Attribute_Ref_F_Prefix => Defer_Res444, Attribute_Ref_F_Attribute => Defer_Res445, Attribute_Ref_F_Args => Null_Res29);

         if Defer_Res444 /= null and then Is_Incomplete (Defer_Res444) then
            Transform_Res215.Last_Attempted_Child := 0;
         elsif Defer_Res444 /= null and then not Is_Ghost (Defer_Res444) then
            Transform_Res215.Last_Attempted_Child := -1;
         end if;
         if Defer_Res445 /= null and then Is_Incomplete (Defer_Res445) then
            Transform_Res215.Last_Attempted_Child := 0;
         elsif Defer_Res445 /= null and then not Is_Ghost (Defer_Res445) then
            Transform_Res215.Last_Attempted_Child := -1;
         end if;
         if Null_Res29 /= null and then Is_Incomplete (Null_Res29) then
            Transform_Res215.Last_Attempted_Child := 0;
         elsif Null_Res29 /= null and then not Is_Ghost (Null_Res29) then
            Transform_Res215.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos288 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags215);
end if;

--  End transform_code

    if Row_Pos288 /= No_Token_Index then
        Or_Pos95 := Row_Pos288;
        Or_Res95 := Transform_Res215;
        goto Exit_Or97;
    end if;
    
Defer_Res446 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos287);
Defer_Pos446 := Parser.Current_Pos;

    if Defer_Pos446 /= No_Token_Index then
        Or_Pos95 := Defer_Pos446;
        Or_Res95 := Defer_Res446;
        goto Exit_Or97;
    end if;
<<Exit_Or97>>

--  End or_code




if Or_Pos95 /= No_Token_Index then

   Row_Pos287 := Or_Pos95;

else
   Row_Pos287 := No_Token_Index;
   goto Exit_Row287_0;

end if;


--  Start tok_code

Token_Res451 := Row_Pos287;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res451));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos451 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos287 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos287,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos451 := Row_Pos287 + 1;
   end if;
end;

--  End tok_code




if Token_Pos451 /= No_Token_Index then

   Row_Pos287 := Token_Pos451;

else
   Row_Pos287 := No_Token_Index;
   goto Exit_Row287_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row287_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos287 = No_Token_Index then

         
   Or_Res95 := No_Bare_Ada_Node;



       
   Row_Pos287 := Row_Pos286;



end if;

--  End opt_code




if Row_Pos287 /= No_Token_Index then

   Row_Pos286 := Row_Pos287;

else
   Row_Pos286 := No_Token_Index;
   goto Exit_Row286_0;

end if;


Defer_Res447 :=
   Expr_Or_Parse0 (Parser, Row_Pos286);
Defer_Pos447 := Parser.Current_Pos;




if Defer_Pos447 /= No_Token_Index then

   Row_Pos286 := Defer_Pos447;

else
   Row_Pos286 := No_Token_Index;
   goto Exit_Row286_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row286_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos286 /= No_Token_Index then

   Transform_Res216 := Allocate_Pragma_Argument_Assoc (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res216,
      Kind => Ada_Pragma_Argument_Assoc,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos286 = Pos
                            then No_Token_Index
                            else Row_Pos286 - 1));

      Initialize_Fields_For_Pragma_Argument_Assoc
        (Self => Transform_Res216, Pragma_Argument_Assoc_F_Name => Or_Res95, Pragma_Argument_Assoc_F_Expr => Defer_Res447);

         if Or_Res95 /= null and then Is_Incomplete (Or_Res95) then
            Transform_Res216.Last_Attempted_Child := 0;
         elsif Or_Res95 /= null and then not Is_Ghost (Or_Res95) then
            Transform_Res216.Last_Attempted_Child := -1;
         end if;
         if Defer_Res447 /= null and then Is_Incomplete (Defer_Res447) then
            Transform_Res216.Last_Attempted_Child := 0;
         elsif Defer_Res447 /= null and then not Is_Ghost (Defer_Res447) then
            Transform_Res216.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos286 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags216);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Pragma_Argument_Transform_Parse1_Memo,
      Row_Pos286 /= No_Token_Index,
      Transform_Res216,
      Pos,
      Row_Pos286);


   Parser.Current_Pos := Row_Pos286;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res216;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Pragma_Argument_Transform_Parse1;

   


function Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos448 :
            Token_Index
               := No_Token_Index;
      Defer_Res448 :
            Bare_Num_Literal
               := No_Bare_Ada_Node;
      Defer_Pos449 :
            Token_Index
               := No_Token_Index;
      Defer_Res449 :
            Bare_Null_Literal
               := No_Bare_Ada_Node;
      Defer_Pos450 :
            Token_Index
               := No_Token_Index;
      Defer_Res450 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos451 :
            Token_Index
               := No_Token_Index;
      Defer_Res451 :
            Bare_Allocator
               := No_Bare_Ada_Node;
      Defer_Pos452 :
            Token_Index
               := No_Token_Index;
      Defer_Res452 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos453 :
            Token_Index
               := No_Token_Index;
      Defer_Res453 :
            Bare_Raise_Expr
               := No_Bare_Ada_Node;
      Defer_Pos454 :
            Token_Index
               := No_Token_Index;
      Defer_Res454 :
            Bare_Paren_Expr
               := No_Bare_Ada_Node;
      Defer_Pos455 :
            Token_Index
               := No_Token_Index;
      Defer_Res455 :
            Bare_Decl_Expr
               := No_Bare_Ada_Node;
      Defer_Pos456 :
            Token_Index
               := No_Token_Index;
      Defer_Res456 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Or_Pos96 :
            Token_Index
               := No_Token_Index;
      Or_Res96 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Primary_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res96 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res96;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res96;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos96 := No_Token_Index;
Or_Res96 := No_Bare_Ada_Node;
    
Defer_Res448 :=
   Num_Literal_Or_Parse0 (Parser, Pos);
Defer_Pos448 := Parser.Current_Pos;

    if Defer_Pos448 /= No_Token_Index then
        Or_Pos96 := Defer_Pos448;
        Or_Res96 := Defer_Res448;
        goto Exit_Or98;
    end if;
    
Defer_Res449 :=
   Null_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos449 := Parser.Current_Pos;

    if Defer_Pos449 /= No_Token_Index then
        Or_Pos96 := Defer_Pos449;
        Or_Res96 := Defer_Res449;
        goto Exit_Or98;
    end if;
    
Defer_Res450 :=
   Name_Or_Parse2 (Parser, Pos);
Defer_Pos450 := Parser.Current_Pos;

    if Defer_Pos450 /= No_Token_Index then
        Or_Pos96 := Defer_Pos450;
        Or_Res96 := Defer_Res450;
        goto Exit_Or98;
    end if;
    
Defer_Res451 :=
   Allocator_Transform_Parse0 (Parser, Pos);
Defer_Pos451 := Parser.Current_Pos;

    if Defer_Pos451 /= No_Token_Index then
        Or_Pos96 := Defer_Pos451;
        Or_Res96 := Defer_Res451;
        goto Exit_Or98;
    end if;
    
Defer_Res452 :=
   Conditional_Expr_Or_Parse0 (Parser, Pos);
Defer_Pos452 := Parser.Current_Pos;

    if Defer_Pos452 /= No_Token_Index then
        Or_Pos96 := Defer_Pos452;
        Or_Res96 := Defer_Res452;
        goto Exit_Or98;
    end if;
    
Defer_Res453 :=
   Raise_Expr_Or_Parse0 (Parser, Pos);
Defer_Pos453 := Parser.Current_Pos;

    if Defer_Pos453 /= No_Token_Index then
        Or_Pos96 := Defer_Pos453;
        Or_Res96 := Defer_Res453;
        goto Exit_Or98;
    end if;
    
Defer_Res454 :=
   Paren_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos454 := Parser.Current_Pos;

    if Defer_Pos454 /= No_Token_Index then
        Or_Pos96 := Defer_Pos454;
        Or_Res96 := Defer_Res454;
        goto Exit_Or98;
    end if;
    
Defer_Res455 :=
   Declare_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos455 := Parser.Current_Pos;

    if Defer_Pos455 /= No_Token_Index then
        Or_Pos96 := Defer_Pos455;
        Or_Res96 := Defer_Res455;
        goto Exit_Or98;
    end if;
    
Defer_Res456 :=
   Aggregate_Or_Parse0 (Parser, Pos);
Defer_Pos456 := Parser.Current_Pos;

    if Defer_Pos456 /= No_Token_Index then
        Or_Pos96 := Defer_Pos456;
        Or_Res96 := Defer_Res456;
        goto Exit_Or98;
    end if;
<<Exit_Or98>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Primary_Or_Parse0_Memo,
      Or_Pos96 /= No_Token_Index,
      Or_Res96,
      Pos,
      Or_Pos96);


   Parser.Current_Pos := Or_Pos96;

   Exit_Call (Parser, Call_Depth);
   return Or_Res96;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Primary_Or_Parse0;

   


function Protected_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Body
is
   use Bare_Protected_Body_Memos;

   Call_Depth : aliased Natural;

      Row_Pos289 :
            Token_Index
               := No_Token_Index;
      Token_Pos452 :
            Token_Index
               := No_Token_Index;
      Token_Res452 :
            Token_Index
               := No_Token_Index;
      Token_Pos453 :
            Token_Index
               := No_Token_Index;
      Token_Res453 :
            Token_Index
               := No_Token_Index;
      Defer_Pos457 :
            Token_Index
               := No_Token_Index;
      Defer_Res457 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos458 :
            Token_Index
               := No_Token_Index;
      Defer_Res458 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos454 :
            Token_Index
               := No_Token_Index;
      Token_Res454 :
            Token_Index
               := No_Token_Index;
      Defer_Pos459 :
            Token_Index
               := No_Token_Index;
      Defer_Res459 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Row_Pos290 :
            Token_Index
               := No_Token_Index;
      Token_Pos455 :
            Token_Index
               := No_Token_Index;
      Token_Res455 :
            Token_Index
               := No_Token_Index;
      Row_Pos291 :
            Token_Index
               := No_Token_Index;
      Defer_Pos460 :
            Token_Index
               := No_Token_Index;
      Defer_Res460 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res217 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags217 :
            Ada.Containers.Count_Type;
      Token_Pos456 :
            Token_Index
               := No_Token_Index;
      Token_Res456 :
            Token_Index
               := No_Token_Index;
      Transform_Res218 :
            Bare_Protected_Body
               := No_Bare_Ada_Node;
      Transform_Diags218 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_Body_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res218 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res218;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res218;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags218 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos289 := Pos;



--  Start tok_code

Token_Res452 := Row_Pos289;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res452));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Protected)
   then
       Token_Pos452 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos289 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos289,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos452 := Row_Pos289 + 1;
   end if;
end;

--  End tok_code




if Token_Pos452 /= No_Token_Index then

   Row_Pos289 := Token_Pos452;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


--  Start tok_code

Token_Res453 := Row_Pos289;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res453));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Body)
   then
       Token_Pos453 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos289 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos289,
             Expected_Token_Id => Ada_Body,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos453 := Row_Pos289 + 1;
   end if;
end;

--  End tok_code




if Token_Pos453 /= No_Token_Index then

   Row_Pos289 := Token_Pos453;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


Defer_Res457 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos289);
Defer_Pos457 := Parser.Current_Pos;




if Defer_Pos457 /= No_Token_Index then

   Row_Pos289 := Defer_Pos457;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


Defer_Res458 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos289);
Defer_Pos458 := Parser.Current_Pos;




if Defer_Pos458 /= No_Token_Index then

   Row_Pos289 := Defer_Pos458;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


--  Start tok_code

Token_Res454 := Row_Pos289;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res454));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos454 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos289 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos289,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos454 := Row_Pos289 + 1;
   end if;
end;

--  End tok_code




if Token_Pos454 /= No_Token_Index then

   Row_Pos289 := Token_Pos454;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Protected_Body0_Extract_Parse0'Access);
        
Defer_Res459 :=
   Decl_Part_Transform_Parse0 (Parser, Row_Pos289);
Defer_Pos459 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos459 /= No_Token_Index then

   Row_Pos289 := Defer_Pos459;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


--  Start row_code

Row_Pos290 := Row_Pos289;



--  Start tok_code

Token_Res455 := Row_Pos290;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res455));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos455 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos290 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos290,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos455 := Row_Pos290 + 1;
   end if;
end;

--  End tok_code




if Token_Pos455 /= No_Token_Index then

   Row_Pos290 := Token_Pos455;

else
   Row_Pos290 := No_Token_Index;
   goto Exit_Row290_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags217 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos291 := Row_Pos290;



Defer_Res460 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos291);
Defer_Pos460 := Parser.Current_Pos;




if Defer_Pos460 /= No_Token_Index then

   Row_Pos291 := Defer_Pos460;

else
   Row_Pos291 := No_Token_Index;
   goto Exit_Row291_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row291_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos291 /= No_Token_Index then

   Transform_Res217 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res217,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos290,
      Token_End_Index   => (if Row_Pos291 = Row_Pos290
                            then No_Token_Index
                            else Row_Pos291 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res217, End_Name_F_Name => Defer_Res460);

         if Defer_Res460 /= null and then Is_Incomplete (Defer_Res460) then
            Transform_Res217.Last_Attempted_Child := 0;
         elsif Defer_Res460 /= null and then not Is_Ghost (Defer_Res460) then
            Transform_Res217.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos291 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags217);
end if;

--  End transform_code


if Row_Pos291 = No_Token_Index then

         
   Transform_Res217 := No_Bare_Ada_Node;



       
   Row_Pos291 := Row_Pos290;



end if;

--  End opt_code




if Row_Pos291 /= No_Token_Index then

   Row_Pos290 := Row_Pos291;

else
   Row_Pos290 := No_Token_Index;
   goto Exit_Row290_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row290_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos290 /= No_Token_Index then

   Row_Pos289 := Row_Pos290;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res456 := Row_Pos289;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res456));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos456 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos289 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos289,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos456 := Row_Pos289 + 1;
   end if;
end;

--  End tok_code


if Token_Pos456 = No_Token_Index then

         
   Token_Res456 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos289)),
                To_Text ("Missing ';'"));

       
   Token_Pos456 := Row_Pos289;



end if;

--  End opt_code




if Token_Pos456 /= No_Token_Index then

   Row_Pos289 := Token_Pos456;

else
   Row_Pos289 := No_Token_Index;
   goto Exit_Row289_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row289_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos289 /= No_Token_Index then

   Transform_Res218 := Allocate_Protected_Body (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res218,
      Kind => Ada_Protected_Body,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos289 = Pos
                            then No_Token_Index
                            else Row_Pos289 - 1));

      Initialize_Fields_For_Protected_Body
        (Self => Transform_Res218, Protected_Body_F_Name => Defer_Res457, Protected_Body_F_Aspects => Defer_Res458, Protected_Body_F_Decls => Defer_Res459, Protected_Body_F_End_Name => Transform_Res217);

         if Defer_Res457 /= null and then Is_Incomplete (Defer_Res457) then
            Transform_Res218.Last_Attempted_Child := 0;
         elsif Defer_Res457 /= null and then not Is_Ghost (Defer_Res457) then
            Transform_Res218.Last_Attempted_Child := -1;
         end if;
         if Defer_Res458 /= null and then Is_Incomplete (Defer_Res458) then
            Transform_Res218.Last_Attempted_Child := 0;
         elsif Defer_Res458 /= null and then not Is_Ghost (Defer_Res458) then
            Transform_Res218.Last_Attempted_Child := -1;
         end if;
         if Defer_Res459 /= null and then Is_Incomplete (Defer_Res459) then
            Transform_Res218.Last_Attempted_Child := 0;
         elsif Defer_Res459 /= null and then not Is_Ghost (Defer_Res459) then
            Transform_Res218.Last_Attempted_Child := -1;
         end if;
         if Transform_Res217 /= null and then Is_Incomplete (Transform_Res217) then
            Transform_Res218.Last_Attempted_Child := 0;
         elsif Transform_Res217 /= null and then not Is_Ghost (Transform_Res217) then
            Transform_Res218.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos289 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags218);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_Body_Transform_Parse1_Memo,
      Row_Pos289 /= No_Token_Index,
      Transform_Res218,
      Pos,
      Row_Pos289);


   Parser.Current_Pos := Row_Pos289;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res218;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_Body_Transform_Parse1;

   


function Protected_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Body_Stub
is
   use Bare_Protected_Body_Stub_Memos;

   Call_Depth : aliased Natural;

      Row_Pos292 :
            Token_Index
               := No_Token_Index;
      Token_Pos457 :
            Token_Index
               := No_Token_Index;
      Token_Res457 :
            Token_Index
               := No_Token_Index;
      Token_Pos458 :
            Token_Index
               := No_Token_Index;
      Token_Res458 :
            Token_Index
               := No_Token_Index;
      Defer_Pos461 :
            Token_Index
               := No_Token_Index;
      Defer_Res461 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos459 :
            Token_Index
               := No_Token_Index;
      Token_Res459 :
            Token_Index
               := No_Token_Index;
      Token_Pos460 :
            Token_Index
               := No_Token_Index;
      Token_Res460 :
            Token_Index
               := No_Token_Index;
      Defer_Pos462 :
            Token_Index
               := No_Token_Index;
      Defer_Res462 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos461 :
            Token_Index
               := No_Token_Index;
      Token_Res461 :
            Token_Index
               := No_Token_Index;
      Transform_Res219 :
            Bare_Protected_Body_Stub
               := No_Bare_Ada_Node;
      Transform_Diags219 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_Body_Stub_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res219 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res219;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res219;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags219 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos292 := Pos;



--  Start tok_code

Token_Res457 := Row_Pos292;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res457));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Protected)
   then
       Token_Pos457 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos292 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos292,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos457 := Row_Pos292 + 1;
   end if;
end;

--  End tok_code




if Token_Pos457 /= No_Token_Index then

   Row_Pos292 := Token_Pos457;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;


--  Start tok_code

Token_Res458 := Row_Pos292;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res458));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Body)
   then
       Token_Pos458 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos292 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos292,
             Expected_Token_Id => Ada_Body,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos458 := Row_Pos292 + 1;
   end if;
end;

--  End tok_code




if Token_Pos458 /= No_Token_Index then

   Row_Pos292 := Token_Pos458;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;


Defer_Res461 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos292);
Defer_Pos461 := Parser.Current_Pos;




if Defer_Pos461 /= No_Token_Index then

   Row_Pos292 := Defer_Pos461;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;


--  Start tok_code

Token_Res459 := Row_Pos292;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res459));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos459 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos292 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos292,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos459 := Row_Pos292 + 1;
   end if;
end;

--  End tok_code




if Token_Pos459 /= No_Token_Index then

   Row_Pos292 := Token_Pos459;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;


--  Start tok_code

Token_Res460 := Row_Pos292;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res460));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Separate)
   then
       Token_Pos460 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos292 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos292,
             Expected_Token_Id => Ada_Separate,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos460 := Row_Pos292 + 1;
   end if;
end;

--  End tok_code




if Token_Pos460 /= No_Token_Index then

   Row_Pos292 := Token_Pos460;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;


Defer_Res462 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos292);
Defer_Pos462 := Parser.Current_Pos;




if Defer_Pos462 /= No_Token_Index then

   Row_Pos292 := Defer_Pos462;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res461 := Row_Pos292;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res461));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos461 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos292 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos292,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos461 := Row_Pos292 + 1;
   end if;
end;

--  End tok_code


if Token_Pos461 = No_Token_Index then

         
   Token_Res461 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos292)),
                To_Text ("Missing ';'"));

       
   Token_Pos461 := Row_Pos292;



end if;

--  End opt_code




if Token_Pos461 /= No_Token_Index then

   Row_Pos292 := Token_Pos461;

else
   Row_Pos292 := No_Token_Index;
   goto Exit_Row292_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row292_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos292 /= No_Token_Index then

   Transform_Res219 := Allocate_Protected_Body_Stub (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res219,
      Kind => Ada_Protected_Body_Stub,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos292 = Pos
                            then No_Token_Index
                            else Row_Pos292 - 1));

      Initialize_Fields_For_Protected_Body_Stub
        (Self => Transform_Res219, Protected_Body_Stub_F_Name => Defer_Res461, Protected_Body_Stub_F_Aspects => Defer_Res462);

         if Defer_Res461 /= null and then Is_Incomplete (Defer_Res461) then
            Transform_Res219.Last_Attempted_Child := 0;
         elsif Defer_Res461 /= null and then not Is_Ghost (Defer_Res461) then
            Transform_Res219.Last_Attempted_Child := -1;
         end if;
         if Defer_Res462 /= null and then Is_Incomplete (Defer_Res462) then
            Transform_Res219.Last_Attempted_Child := 0;
         elsif Defer_Res462 /= null and then not Is_Ghost (Defer_Res462) then
            Transform_Res219.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos292 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags219);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_Body_Stub_Transform_Parse0_Memo,
      Row_Pos292 /= No_Token_Index,
      Transform_Res219,
      Pos,
      Row_Pos292);


   Parser.Current_Pos := Row_Pos292;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res219;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_Body_Stub_Transform_Parse0;

   


function Protected_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Single_Protected_Decl
is
   use Bare_Single_Protected_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos293 :
            Token_Index
               := No_Token_Index;
      Token_Pos462 :
            Token_Index
               := No_Token_Index;
      Token_Res462 :
            Token_Index
               := No_Token_Index;
      Defer_Pos463 :
            Token_Index
               := No_Token_Index;
      Defer_Res463 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos464 :
            Token_Index
               := No_Token_Index;
      Defer_Res464 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos463 :
            Token_Index
               := No_Token_Index;
      Token_Res463 :
            Token_Index
               := No_Token_Index;
      Row_Pos294 :
            Token_Index
               := No_Token_Index;
      Token_Pos464 :
            Token_Index
               := No_Token_Index;
      Token_Res464 :
            Token_Index
               := No_Token_Index;
      Defer_Pos465 :
            Token_Index
               := No_Token_Index;
      Defer_Res465 :
            Bare_Parent_List
               := No_Bare_Ada_Node;
      Token_Pos465 :
            Token_Index
               := No_Token_Index;
      Token_Res465 :
            Token_Index
               := No_Token_Index;
      Defer_Pos466 :
            Token_Index
               := No_Token_Index;
      Defer_Res466 :
            Bare_Protected_Def
               := No_Bare_Ada_Node;
      Token_Pos466 :
            Token_Index
               := No_Token_Index;
      Token_Res466 :
            Token_Index
               := No_Token_Index;
      Transform_Res220 :
            Bare_Single_Protected_Decl
               := No_Bare_Ada_Node;
      Transform_Diags220 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res220 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res220;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res220;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags220 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos293 := Pos;



--  Start tok_code

Token_Res462 := Row_Pos293;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res462));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Protected)
   then
       Token_Pos462 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos293 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos293,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos462 := Row_Pos293 + 1;
   end if;
end;

--  End tok_code




if Token_Pos462 /= No_Token_Index then

   Row_Pos293 := Token_Pos462;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;


Defer_Res463 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos293);
Defer_Pos463 := Parser.Current_Pos;




if Defer_Pos463 /= No_Token_Index then

   Row_Pos293 := Defer_Pos463;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;


Defer_Res464 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos293);
Defer_Pos464 := Parser.Current_Pos;




if Defer_Pos464 /= No_Token_Index then

   Row_Pos293 := Defer_Pos464;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;


--  Start tok_code

Token_Res463 := Row_Pos293;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res463));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos463 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos293 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos293,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos463 := Row_Pos293 + 1;
   end if;
end;

--  End tok_code




if Token_Pos463 /= No_Token_Index then

   Row_Pos293 := Token_Pos463;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos294 := Row_Pos293;



--  Start tok_code

Token_Res464 := Row_Pos294;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res464));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos464 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos294 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos294,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos464 := Row_Pos294 + 1;
   end if;
end;

--  End tok_code




if Token_Pos464 /= No_Token_Index then

   Row_Pos294 := Token_Pos464;

else
   Row_Pos294 := No_Token_Index;
   goto Exit_Row294_0;

end if;


Defer_Res465 :=
   Parent_List_List_Parse0 (Parser, Row_Pos294);
Defer_Pos465 := Parser.Current_Pos;




if Defer_Pos465 /= No_Token_Index then

   Row_Pos294 := Defer_Pos465;

else
   Row_Pos294 := No_Token_Index;
   goto Exit_Row294_0;

end if;


--  Start tok_code

Token_Res465 := Row_Pos294;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res465));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos465 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos294 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos294,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos465 := Row_Pos294 + 1;
   end if;
end;

--  End tok_code




if Token_Pos465 /= No_Token_Index then

   Row_Pos294 := Token_Pos465;

else
   Row_Pos294 := No_Token_Index;
   goto Exit_Row294_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row294_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos294 = No_Token_Index then

         
   Defer_Res465 :=
     Allocate_Parent_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res465,
      Kind              => Ada_Parent_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos293 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res465,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos294 := Row_Pos293;



end if;

--  End opt_code




if Row_Pos294 /= No_Token_Index then

   Row_Pos293 := Row_Pos294;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;


Defer_Res466 :=
   Protected_Def_Transform_Parse3 (Parser, Row_Pos293);
Defer_Pos466 := Parser.Current_Pos;




if Defer_Pos466 /= No_Token_Index then

   Row_Pos293 := Defer_Pos466;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res466 := Row_Pos293;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res466));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos466 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos293 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos293,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos466 := Row_Pos293 + 1;
   end if;
end;

--  End tok_code


if Token_Pos466 = No_Token_Index then

         
   Token_Res466 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos293)),
                To_Text ("Missing ';'"));

       
   Token_Pos466 := Row_Pos293;



end if;

--  End opt_code




if Token_Pos466 /= No_Token_Index then

   Row_Pos293 := Token_Pos466;

else
   Row_Pos293 := No_Token_Index;
   goto Exit_Row293_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row293_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos293 /= No_Token_Index then

   Transform_Res220 := Allocate_Single_Protected_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res220,
      Kind => Ada_Single_Protected_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos293 = Pos
                            then No_Token_Index
                            else Row_Pos293 - 1));

      Initialize_Fields_For_Single_Protected_Decl
        (Self => Transform_Res220, Single_Protected_Decl_F_Name => Defer_Res463, Single_Protected_Decl_F_Aspects => Defer_Res464, Single_Protected_Decl_F_Interfaces => Defer_Res465, Single_Protected_Decl_F_Definition => Defer_Res466);

         if Defer_Res463 /= null and then Is_Incomplete (Defer_Res463) then
            Transform_Res220.Last_Attempted_Child := 0;
         elsif Defer_Res463 /= null and then not Is_Ghost (Defer_Res463) then
            Transform_Res220.Last_Attempted_Child := -1;
         end if;
         if Defer_Res464 /= null and then Is_Incomplete (Defer_Res464) then
            Transform_Res220.Last_Attempted_Child := 0;
         elsif Defer_Res464 /= null and then not Is_Ghost (Defer_Res464) then
            Transform_Res220.Last_Attempted_Child := -1;
         end if;
         if Defer_Res465 /= null and then Is_Incomplete (Defer_Res465) then
            Transform_Res220.Last_Attempted_Child := 0;
         elsif Defer_Res465 /= null and then not Is_Ghost (Defer_Res465) then
            Transform_Res220.Last_Attempted_Child := -1;
         end if;
         if Defer_Res466 /= null and then Is_Incomplete (Defer_Res466) then
            Transform_Res220.Last_Attempted_Child := 0;
         elsif Defer_Res466 /= null and then not Is_Ghost (Defer_Res466) then
            Transform_Res220.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos293 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags220);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_Decl_Transform_Parse0_Memo,
      Row_Pos293 /= No_Token_Index,
      Transform_Res220,
      Pos,
      Row_Pos293);


   Parser.Current_Pos := Row_Pos293;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res220;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_Decl_Transform_Parse0;

   


function Protected_Def_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Def
is
   use Bare_Protected_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos295 :
            Token_Index
               := No_Token_Index;
      Row_Pos296 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos42 :
            Token_Index
               := No_Token_Index;
      Tmp_List42 :
            Free_Parse_List;
      Defer_Pos467 :
            Token_Index
               := No_Token_Index;
      Defer_Res467 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos42 :
            Token_Index
               := No_Token_Index;
      List_Res42 :
            Bare_Decl_List
               := No_Bare_Ada_Node;
      Transform_Res221 :
            Bare_Public_Part
               := No_Bare_Ada_Node;
      Transform_Diags221 :
            Ada.Containers.Count_Type;
      Row_Pos297 :
            Token_Index
               := No_Token_Index;
      Token_Pos467 :
            Token_Index
               := No_Token_Index;
      Token_Res467 :
            Token_Index
               := No_Token_Index;
      Row_Pos298 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos43 :
            Token_Index
               := No_Token_Index;
      Tmp_List43 :
            Free_Parse_List;
      Defer_Pos468 :
            Token_Index
               := No_Token_Index;
      Defer_Res468 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos43 :
            Token_Index
               := No_Token_Index;
      List_Res43 :
            Bare_Decl_List
               := No_Bare_Ada_Node;
      Transform_Res222 :
            Bare_Private_Part
               := No_Bare_Ada_Node;
      Transform_Diags222 :
            Ada.Containers.Count_Type;
      Row_Pos299 :
            Token_Index
               := No_Token_Index;
      Token_Pos468 :
            Token_Index
               := No_Token_Index;
      Token_Res468 :
            Token_Index
               := No_Token_Index;
      Row_Pos300 :
            Token_Index
               := No_Token_Index;
      Defer_Pos469 :
            Token_Index
               := No_Token_Index;
      Defer_Res469 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res223 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags223 :
            Ada.Containers.Count_Type;
      Transform_Res224 :
            Bare_Protected_Def
               := No_Bare_Ada_Node;
      Transform_Diags224 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_Def_Transform_Parse3_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res224 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res224;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res224;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags224 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos295 := Pos;



--  Start transform_code

Transform_Diags221 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos296 := Row_Pos295;



--  Start list_code

    List_Pos42 := Row_Pos296;



Lst_Cpos42 := Row_Pos296;
Tmp_List42 := Get_Parse_List (Parser);

loop
   
Defer_Res467 :=
   Protected_Op_Or_Parse0 (Parser, Lst_Cpos42);
Defer_Pos467 := Parser.Current_Pos;


   exit when Defer_Pos467 = No_Token_Index;

   List_Pos42 := Defer_Pos467;
   Lst_Cpos42 := List_Pos42;

   Tmp_List42.Nodes.Append (Defer_Res467);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List42.Nodes.Length;
begin
   List_Res42 :=
      Allocate_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos296;
      Token_End := (if Lst_Cpos42 = Row_Pos296
                    then Row_Pos296
                    else Lst_Cpos42 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos296, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res42,
      Kind              => Ada_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res42,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List42.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res42.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List42);

--  End list_code




if List_Pos42 /= No_Token_Index then

   Row_Pos296 := List_Pos42;

else
   Row_Pos296 := No_Token_Index;
   goto Exit_Row296_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row296_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos296 /= No_Token_Index then

   Transform_Res221 := Allocate_Public_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res221,
      Kind => Ada_Public_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos295,
      Token_End_Index   => (if Row_Pos296 = Row_Pos295
                            then No_Token_Index
                            else Row_Pos296 - 1));

      Initialize_Fields_For_Public_Part
        (Self => Transform_Res221, Declarative_Part_F_Decls => List_Res42);

         if List_Res42 /= null and then Is_Incomplete (List_Res42) then
            Transform_Res221.Last_Attempted_Child := 0;
         elsif List_Res42 /= null and then not Is_Ghost (List_Res42) then
            Transform_Res221.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos296 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags221);
end if;

--  End transform_code




if Row_Pos296 /= No_Token_Index then

   Row_Pos295 := Row_Pos296;

else
   Row_Pos295 := No_Token_Index;
   goto Exit_Row295_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos297 := Row_Pos295;



--  Start tok_code

Token_Res467 := Row_Pos297;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res467));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos467 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos297 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos297,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos467 := Row_Pos297 + 1;
   end if;
end;

--  End tok_code




if Token_Pos467 /= No_Token_Index then

   Row_Pos297 := Token_Pos467;

else
   Row_Pos297 := No_Token_Index;
   goto Exit_Row297_0;

end if;


--  Start transform_code

Transform_Diags222 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos298 := Row_Pos297;



--  Start list_code

    List_Pos43 := Row_Pos298;



Lst_Cpos43 := Row_Pos298;
Tmp_List43 := Get_Parse_List (Parser);

loop
   
Defer_Res468 :=
   Protected_El_Or_Parse0 (Parser, Lst_Cpos43);
Defer_Pos468 := Parser.Current_Pos;


   exit when Defer_Pos468 = No_Token_Index;

   List_Pos43 := Defer_Pos468;
   Lst_Cpos43 := List_Pos43;

   Tmp_List43.Nodes.Append (Defer_Res468);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List43.Nodes.Length;
begin
   List_Res43 :=
      Allocate_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos298;
      Token_End := (if Lst_Cpos43 = Row_Pos298
                    then Row_Pos298
                    else Lst_Cpos43 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos298, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res43,
      Kind              => Ada_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res43,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List43.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res43.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List43);

--  End list_code




if List_Pos43 /= No_Token_Index then

   Row_Pos298 := List_Pos43;

else
   Row_Pos298 := No_Token_Index;
   goto Exit_Row298_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row298_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos298 /= No_Token_Index then

   Transform_Res222 := Allocate_Private_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res222,
      Kind => Ada_Private_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos297,
      Token_End_Index   => (if Row_Pos298 = Row_Pos297
                            then No_Token_Index
                            else Row_Pos298 - 1));

      Initialize_Fields_For_Private_Part
        (Self => Transform_Res222, Declarative_Part_F_Decls => List_Res43);

         if List_Res43 /= null and then Is_Incomplete (List_Res43) then
            Transform_Res222.Last_Attempted_Child := 0;
         elsif List_Res43 /= null and then not Is_Ghost (List_Res43) then
            Transform_Res222.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos298 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags222);
end if;

--  End transform_code




if Row_Pos298 /= No_Token_Index then

   Row_Pos297 := Row_Pos298;

else
   Row_Pos297 := No_Token_Index;
   goto Exit_Row297_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row297_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos297 = No_Token_Index then

         
   Transform_Res222 := No_Bare_Ada_Node;



       
   Row_Pos297 := Row_Pos295;



end if;

--  End opt_code




if Row_Pos297 /= No_Token_Index then

   Row_Pos295 := Row_Pos297;

else
   Row_Pos295 := No_Token_Index;
   goto Exit_Row295_0;

end if;


--  Start row_code

Row_Pos299 := Row_Pos295;



--  Start tok_code

Token_Res468 := Row_Pos299;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res468));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos468 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos299 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos299,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos468 := Row_Pos299 + 1;
   end if;
end;

--  End tok_code




if Token_Pos468 /= No_Token_Index then

   Row_Pos299 := Token_Pos468;

else
   Row_Pos299 := No_Token_Index;
   goto Exit_Row299_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags223 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos300 := Row_Pos299;



Defer_Res469 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos300);
Defer_Pos469 := Parser.Current_Pos;




if Defer_Pos469 /= No_Token_Index then

   Row_Pos300 := Defer_Pos469;

else
   Row_Pos300 := No_Token_Index;
   goto Exit_Row300_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row300_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos300 /= No_Token_Index then

   Transform_Res223 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res223,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos299,
      Token_End_Index   => (if Row_Pos300 = Row_Pos299
                            then No_Token_Index
                            else Row_Pos300 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res223, End_Name_F_Name => Defer_Res469);

         if Defer_Res469 /= null and then Is_Incomplete (Defer_Res469) then
            Transform_Res223.Last_Attempted_Child := 0;
         elsif Defer_Res469 /= null and then not Is_Ghost (Defer_Res469) then
            Transform_Res223.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos300 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags223);
end if;

--  End transform_code


if Row_Pos300 = No_Token_Index then

         
   Transform_Res223 := No_Bare_Ada_Node;



       
   Row_Pos300 := Row_Pos299;



end if;

--  End opt_code




if Row_Pos300 /= No_Token_Index then

   Row_Pos299 := Row_Pos300;

else
   Row_Pos299 := No_Token_Index;
   goto Exit_Row299_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row299_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos299 /= No_Token_Index then

   Row_Pos295 := Row_Pos299;

else
   Row_Pos295 := No_Token_Index;
   goto Exit_Row295_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row295_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos295 /= No_Token_Index then

   Transform_Res224 := Allocate_Protected_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res224,
      Kind => Ada_Protected_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos295 = Pos
                            then No_Token_Index
                            else Row_Pos295 - 1));

      Initialize_Fields_For_Protected_Def
        (Self => Transform_Res224, Protected_Def_F_Public_Part => Transform_Res221, Protected_Def_F_Private_Part => Transform_Res222, Protected_Def_F_End_Name => Transform_Res223);

         if Transform_Res221 /= null and then Is_Incomplete (Transform_Res221) then
            Transform_Res224.Last_Attempted_Child := 0;
         elsif Transform_Res221 /= null and then not Is_Ghost (Transform_Res221) then
            Transform_Res224.Last_Attempted_Child := -1;
         end if;
         if Transform_Res222 /= null and then Is_Incomplete (Transform_Res222) then
            Transform_Res224.Last_Attempted_Child := 0;
         elsif Transform_Res222 /= null and then not Is_Ghost (Transform_Res222) then
            Transform_Res224.Last_Attempted_Child := -1;
         end if;
         if Transform_Res223 /= null and then Is_Incomplete (Transform_Res223) then
            Transform_Res224.Last_Attempted_Child := 0;
         elsif Transform_Res223 /= null and then not Is_Ghost (Transform_Res223) then
            Transform_Res224.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos295 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags224);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_Def_Transform_Parse3_Memo,
      Row_Pos295 /= No_Token_Index,
      Transform_Res224,
      Pos,
      Row_Pos295);


   Parser.Current_Pos := Row_Pos295;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res224;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_Def_Transform_Parse3;

   


function Protected_El_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos470 :
            Token_Index
               := No_Token_Index;
      Defer_Res470 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Defer_Pos471 :
            Token_Index
               := No_Token_Index;
      Defer_Res471 :
            Bare_Component_Decl
               := No_Bare_Ada_Node;
      Or_Pos97 :
            Token_Index
               := No_Token_Index;
      Or_Res97 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_El_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res97 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res97;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res97;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos97 := No_Token_Index;
Or_Res97 := No_Bare_Ada_Node;
    
Defer_Res470 :=
   Protected_Op_Or_Parse0 (Parser, Pos);
Defer_Pos470 := Parser.Current_Pos;

    if Defer_Pos470 /= No_Token_Index then
        Or_Pos97 := Defer_Pos470;
        Or_Res97 := Defer_Res470;
        goto Exit_Or99;
    end if;
    
Defer_Res471 :=
   Component_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos471 := Parser.Current_Pos;

    if Defer_Pos471 /= No_Token_Index then
        Or_Pos97 := Defer_Pos471;
        Or_Res97 := Defer_Res471;
        goto Exit_Or99;
    end if;
<<Exit_Or99>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_El_Or_Parse0_Memo,
      Or_Pos97 /= No_Token_Index,
      Or_Res97,
      Pos,
      Or_Pos97);


   Parser.Current_Pos := Or_Pos97;

   Exit_Call (Parser, Call_Depth);
   return Or_Res97;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_El_Or_Parse0;

   


function Protected_Op_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos472 :
            Token_Index
               := No_Token_Index;
      Defer_Res472 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;
      Defer_Pos473 :
            Token_Index
               := No_Token_Index;
      Defer_Res473 :
            Bare_Entry_Decl
               := No_Bare_Ada_Node;
      Defer_Pos474 :
            Token_Index
               := No_Token_Index;
      Defer_Res474 :
            Bare_Aspect_Clause
               := No_Bare_Ada_Node;
      Defer_Pos475 :
            Token_Index
               := No_Token_Index;
      Defer_Res475 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos98 :
            Token_Index
               := No_Token_Index;
      Or_Res98 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_Op_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res98 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res98;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res98;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos98 := No_Token_Index;
Or_Res98 := No_Bare_Ada_Node;
    
Defer_Res472 :=
   Subp_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos472 := Parser.Current_Pos;

    if Defer_Pos472 /= No_Token_Index then
        Or_Pos98 := Defer_Pos472;
        Or_Res98 := Defer_Res472;
        goto Exit_Or100;
    end if;
    
Defer_Res473 :=
   Entry_Decl_Transform_Parse1 (Parser, Pos);
Defer_Pos473 := Parser.Current_Pos;

    if Defer_Pos473 /= No_Token_Index then
        Or_Pos98 := Defer_Pos473;
        Or_Res98 := Defer_Res473;
        goto Exit_Or100;
    end if;
    
Defer_Res474 :=
   Aspect_Clause_Or_Parse1 (Parser, Pos);
Defer_Pos474 := Parser.Current_Pos;

    if Defer_Pos474 /= No_Token_Index then
        Or_Pos98 := Defer_Pos474;
        Or_Res98 := Defer_Res474;
        goto Exit_Or100;
    end if;
    
Defer_Res475 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos475 := Parser.Current_Pos;

    if Defer_Pos475 /= No_Token_Index then
        Or_Pos98 := Defer_Pos475;
        Or_Res98 := Defer_Res475;
        goto Exit_Or100;
    end if;
<<Exit_Or100>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_Op_Or_Parse0_Memo,
      Or_Pos98 /= No_Token_Index,
      Or_Res98,
      Pos,
      Or_Pos98);


   Parser.Current_Pos := Or_Pos98;

   Exit_Call (Parser, Call_Depth);
   return Or_Res98;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_Op_Or_Parse0;

   


function Protected_Type_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Protected_Type_Decl
is
   use Bare_Protected_Type_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos301 :
            Token_Index
               := No_Token_Index;
      Token_Pos469 :
            Token_Index
               := No_Token_Index;
      Token_Res469 :
            Token_Index
               := No_Token_Index;
      Token_Pos470 :
            Token_Index
               := No_Token_Index;
      Token_Res470 :
            Token_Index
               := No_Token_Index;
      Defer_Pos476 :
            Token_Index
               := No_Token_Index;
      Defer_Res476 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos477 :
            Token_Index
               := No_Token_Index;
      Defer_Res477 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Defer_Pos478 :
            Token_Index
               := No_Token_Index;
      Defer_Res478 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos471 :
            Token_Index
               := No_Token_Index;
      Token_Res471 :
            Token_Index
               := No_Token_Index;
      Row_Pos302 :
            Token_Index
               := No_Token_Index;
      Token_Pos472 :
            Token_Index
               := No_Token_Index;
      Token_Res472 :
            Token_Index
               := No_Token_Index;
      Defer_Pos479 :
            Token_Index
               := No_Token_Index;
      Defer_Res479 :
            Bare_Parent_List
               := No_Bare_Ada_Node;
      Token_Pos473 :
            Token_Index
               := No_Token_Index;
      Token_Res473 :
            Token_Index
               := No_Token_Index;
      Defer_Pos480 :
            Token_Index
               := No_Token_Index;
      Defer_Res480 :
            Bare_Protected_Def
               := No_Bare_Ada_Node;
      Token_Pos474 :
            Token_Index
               := No_Token_Index;
      Token_Res474 :
            Token_Index
               := No_Token_Index;
      Transform_Res225 :
            Bare_Protected_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags225 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Protected_Type_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res225 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res225;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res225;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags225 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos301 := Pos;



--  Start tok_code

Token_Res469 := Row_Pos301;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res469));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Protected)
   then
       Token_Pos469 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos301 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos301,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos469 := Row_Pos301 + 1;
   end if;
end;

--  End tok_code




if Token_Pos469 /= No_Token_Index then

   Row_Pos301 := Token_Pos469;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


--  Start tok_code

Token_Res470 := Row_Pos301;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res470));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos470 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos301 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos301,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos470 := Row_Pos301 + 1;
   end if;
end;

--  End tok_code




if Token_Pos470 /= No_Token_Index then

   Row_Pos301 := Token_Pos470;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


Defer_Res476 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos301);
Defer_Pos476 := Parser.Current_Pos;




if Defer_Pos476 /= No_Token_Index then

   Row_Pos301 := Defer_Pos476;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


--  Start opt_code












Defer_Res477 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos301);
Defer_Pos477 := Parser.Current_Pos;


if Defer_Pos477 = No_Token_Index then

         
   Defer_Res477 := No_Bare_Ada_Node;



       
   Defer_Pos477 := Row_Pos301;



end if;

--  End opt_code




if Defer_Pos477 /= No_Token_Index then

   Row_Pos301 := Defer_Pos477;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


Defer_Res478 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos301);
Defer_Pos478 := Parser.Current_Pos;




if Defer_Pos478 /= No_Token_Index then

   Row_Pos301 := Defer_Pos478;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


--  Start tok_code

Token_Res471 := Row_Pos301;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res471));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos471 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos301 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos301,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos471 := Row_Pos301 + 1;
   end if;
end;

--  End tok_code




if Token_Pos471 /= No_Token_Index then

   Row_Pos301 := Token_Pos471;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos302 := Row_Pos301;



--  Start tok_code

Token_Res472 := Row_Pos302;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res472));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos472 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos302 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos302,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos472 := Row_Pos302 + 1;
   end if;
end;

--  End tok_code




if Token_Pos472 /= No_Token_Index then

   Row_Pos302 := Token_Pos472;

else
   Row_Pos302 := No_Token_Index;
   goto Exit_Row302_0;

end if;


Defer_Res479 :=
   Parent_List_List_Parse0 (Parser, Row_Pos302);
Defer_Pos479 := Parser.Current_Pos;




if Defer_Pos479 /= No_Token_Index then

   Row_Pos302 := Defer_Pos479;

else
   Row_Pos302 := No_Token_Index;
   goto Exit_Row302_0;

end if;


--  Start tok_code

Token_Res473 := Row_Pos302;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res473));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos473 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos302 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos302,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos473 := Row_Pos302 + 1;
   end if;
end;

--  End tok_code




if Token_Pos473 /= No_Token_Index then

   Row_Pos302 := Token_Pos473;

else
   Row_Pos302 := No_Token_Index;
   goto Exit_Row302_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row302_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos302 = No_Token_Index then

         
   Defer_Res479 :=
     Allocate_Parent_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res479,
      Kind              => Ada_Parent_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos301 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res479,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos302 := Row_Pos301;



end if;

--  End opt_code




if Row_Pos302 /= No_Token_Index then

   Row_Pos301 := Row_Pos302;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


Defer_Res480 :=
   Protected_Def_Transform_Parse3 (Parser, Row_Pos301);
Defer_Pos480 := Parser.Current_Pos;




if Defer_Pos480 /= No_Token_Index then

   Row_Pos301 := Defer_Pos480;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res474 := Row_Pos301;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res474));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos474 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos301 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos301,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos474 := Row_Pos301 + 1;
   end if;
end;

--  End tok_code


if Token_Pos474 = No_Token_Index then

         
   Token_Res474 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos301)),
                To_Text ("Missing ';'"));

       
   Token_Pos474 := Row_Pos301;



end if;

--  End opt_code




if Token_Pos474 /= No_Token_Index then

   Row_Pos301 := Token_Pos474;

else
   Row_Pos301 := No_Token_Index;
   goto Exit_Row301_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row301_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos301 /= No_Token_Index then

   Transform_Res225 := Allocate_Protected_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res225,
      Kind => Ada_Protected_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos301 = Pos
                            then No_Token_Index
                            else Row_Pos301 - 1));

      Initialize_Fields_For_Protected_Type_Decl
        (Self => Transform_Res225, Base_Type_Decl_F_Name => Defer_Res476, Protected_Type_Decl_F_Discriminants => Defer_Res477, Protected_Type_Decl_F_Aspects => Defer_Res478, Protected_Type_Decl_F_Interfaces => Defer_Res479, Protected_Type_Decl_F_Definition => Defer_Res480);

         if Defer_Res476 /= null and then Is_Incomplete (Defer_Res476) then
            Transform_Res225.Last_Attempted_Child := 0;
         elsif Defer_Res476 /= null and then not Is_Ghost (Defer_Res476) then
            Transform_Res225.Last_Attempted_Child := -1;
         end if;
         if Defer_Res477 /= null and then Is_Incomplete (Defer_Res477) then
            Transform_Res225.Last_Attempted_Child := 0;
         elsif Defer_Res477 /= null and then not Is_Ghost (Defer_Res477) then
            Transform_Res225.Last_Attempted_Child := -1;
         end if;
         if Defer_Res478 /= null and then Is_Incomplete (Defer_Res478) then
            Transform_Res225.Last_Attempted_Child := 0;
         elsif Defer_Res478 /= null and then not Is_Ghost (Defer_Res478) then
            Transform_Res225.Last_Attempted_Child := -1;
         end if;
         if Defer_Res479 /= null and then Is_Incomplete (Defer_Res479) then
            Transform_Res225.Last_Attempted_Child := 0;
         elsif Defer_Res479 /= null and then not Is_Ghost (Defer_Res479) then
            Transform_Res225.Last_Attempted_Child := -1;
         end if;
         if Defer_Res480 /= null and then Is_Incomplete (Defer_Res480) then
            Transform_Res225.Last_Attempted_Child := 0;
         elsif Defer_Res480 /= null and then not Is_Ghost (Defer_Res480) then
            Transform_Res225.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos301 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags225);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Protected_Type_Decl_Transform_Parse0_Memo,
      Row_Pos301 /= No_Token_Index,
      Transform_Res225,
      Pos,
      Row_Pos301);


   Parser.Current_Pos := Row_Pos301;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res225;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Protected_Type_Decl_Transform_Parse0;

   


function Qual_Name_Internal_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name
is
   use Bare_Name_Memos;

   Call_Depth : aliased Natural;

      Nobt40 :
            Boolean
               := False;
      Row_Pos303 :
            Token_Index
               := No_Token_Index;
      Defer_Pos481 :
            Token_Index
               := No_Token_Index;
      Defer_Res481 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos475 :
            Token_Index
               := No_Token_Index;
      Token_Res475 :
            Token_Index
               := No_Token_Index;
      Defer_Pos482 :
            Token_Index
               := No_Token_Index;
      Defer_Res482 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Row_Progress35 :
            Integer
               := 0;
      Transform_Res226 :
            Bare_Dotted_Name
               := No_Bare_Ada_Node;
      Transform_Has_Failed35 :
            Boolean
               := False;
      Transform_Diags226 :
            Ada.Containers.Count_Type;
      Row_Pos304 :
            Token_Index
               := No_Token_Index;
      Defer_Pos483 :
            Token_Index
               := No_Token_Index;
      Defer_Res483 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos476 :
            Token_Index
               := No_Token_Index;
      Token_Res476 :
            Token_Index
               := No_Token_Index;
      Defer_Pos484 :
            Token_Index
               := No_Token_Index;
      Defer_Res484 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Null_Res30 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Transform_Res227 :
            Bare_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags227 :
            Ada.Containers.Count_Type;
      Defer_Pos485 :
            Token_Index
               := No_Token_Index;
      Defer_Res485 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Or_Pos99 :
            Token_Index
               := No_Token_Index;
      Or_Res99 :
            Bare_Name
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Qual_Name_Internal_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res99 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res99;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res99;
   end if;

       Set (Parser.Private_Part.Qual_Name_Internal_Or_Parse0_Memo, False, Or_Res99, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt40 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos99 := No_Token_Index;
Or_Res99 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags226 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos303 := Pos;



Defer_Res481 :=
   Qual_Name_Internal_Or_Parse0 (Parser, Row_Pos303);
Defer_Pos481 := Parser.Current_Pos;



Row_Progress35 := 1;

if Defer_Pos481 /= No_Token_Index then

   Row_Pos303 := Defer_Pos481;

else
   Row_Pos303 := No_Token_Index;
   goto Exit_Row303_0;

end if;


--  Start tok_code

Token_Res475 := Row_Pos303;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res475));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Dot)
   then
       Token_Pos475 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos303 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos303,
             Expected_Token_Id => Ada_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos475 := Row_Pos303 + 1;
   end if;
end;

--  End tok_code



Row_Progress35 := 2;

if Token_Pos475 /= No_Token_Index then

   Row_Pos303 := Token_Pos475;

else
   Row_Pos303 := No_Token_Index;
   goto Exit_Row303_0;

end if;

Nobt40 := True;

   Nobt40 := Nobt40;

Row_Progress35 := 3;

if Row_Pos303 /= No_Token_Index then

   Row_Pos303 := Row_Pos303;

else
   Row_Pos303 := No_Token_Index;
   goto Exit_Row303_0;

end if;


Defer_Res482 :=
   Direct_Name_Or_Parse0 (Parser, Row_Pos303);
Defer_Pos482 := Parser.Current_Pos;



Row_Progress35 := 4;

if Defer_Pos482 /= No_Token_Index then

   Row_Pos303 := Defer_Pos482;

else
   Row_Pos303 := No_Token_Index;
   goto Exit_Row303_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row303_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos303 = No_Token_Index and then Nobt40 then

   Row_Pos303 := Parser.Last_Fail.Pos;

   Transform_Has_Failed35 := True;
end if;

if Row_Pos303 /= No_Token_Index then

   Transform_Res226 := Allocate_Dotted_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res226,
      Kind => Ada_Dotted_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos303 = Pos
                            then No_Token_Index
                            else Row_Pos303 - 1));

      Initialize_Fields_For_Dotted_Name
        (Self => Transform_Res226, Dotted_Name_F_Prefix => Defer_Res481, Dotted_Name_F_Suffix => Defer_Res482);

         if Defer_Res481 /= null and then Is_Incomplete (Defer_Res481) then
            Transform_Res226.Last_Attempted_Child := 0;
         elsif Defer_Res481 /= null and then not Is_Ghost (Defer_Res481) then
            Transform_Res226.Last_Attempted_Child := -1;
         end if;
         if Defer_Res482 /= null and then Is_Incomplete (Defer_Res482) then
            Transform_Res226.Last_Attempted_Child := 0;
         elsif Defer_Res482 /= null and then not Is_Ghost (Defer_Res482) then
            Transform_Res226.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed35 then
      Transform_Res226.Last_Attempted_Child :=
         Row_Progress35;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <qual_name_internal>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos303 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags226);
end if;

--  End transform_code

    if Row_Pos303 /= No_Token_Index then
        Or_Pos99 := Row_Pos303;
        Or_Res99 := Transform_Res226;
        goto Exit_Or101;
    end if;
    
--  Start transform_code

Transform_Diags227 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos304 := Pos;



Defer_Res483 :=
   Qual_Name_Internal_Or_Parse0 (Parser, Row_Pos304);
Defer_Pos483 := Parser.Current_Pos;




if Defer_Pos483 /= No_Token_Index then

   Row_Pos304 := Defer_Pos483;

else
   Row_Pos304 := No_Token_Index;
   goto Exit_Row304_0;

end if;


--  Start tok_code

Token_Res476 := Row_Pos304;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res476));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos476 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos304 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos304,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos476 := Row_Pos304 + 1;
   end if;
end;

--  End tok_code




if Token_Pos476 /= No_Token_Index then

   Row_Pos304 := Token_Pos476;

else
   Row_Pos304 := No_Token_Index;
   goto Exit_Row304_0;

end if;


Defer_Res484 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos304);
Defer_Pos484 := Parser.Current_Pos;




if Defer_Pos484 /= No_Token_Index then

   Row_Pos304 := Defer_Pos484;

else
   Row_Pos304 := No_Token_Index;
   goto Exit_Row304_0;

end if;


   Null_Res30 := Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res30,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos304, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res30,
      Parser => Parser,
      Count  => 0);





if Row_Pos304 /= No_Token_Index then

   Row_Pos304 := Row_Pos304;

else
   Row_Pos304 := No_Token_Index;
   goto Exit_Row304_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row304_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos304 /= No_Token_Index then

   Transform_Res227 := Allocate_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res227,
      Kind => Ada_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos304 = Pos
                            then No_Token_Index
                            else Row_Pos304 - 1));

      Initialize_Fields_For_Attribute_Ref
        (Self => Transform_Res227, Attribute_Ref_F_Prefix => Defer_Res483, Attribute_Ref_F_Attribute => Defer_Res484, Attribute_Ref_F_Args => Null_Res30);

         if Defer_Res483 /= null and then Is_Incomplete (Defer_Res483) then
            Transform_Res227.Last_Attempted_Child := 0;
         elsif Defer_Res483 /= null and then not Is_Ghost (Defer_Res483) then
            Transform_Res227.Last_Attempted_Child := -1;
         end if;
         if Defer_Res484 /= null and then Is_Incomplete (Defer_Res484) then
            Transform_Res227.Last_Attempted_Child := 0;
         elsif Defer_Res484 /= null and then not Is_Ghost (Defer_Res484) then
            Transform_Res227.Last_Attempted_Child := -1;
         end if;
         if Null_Res30 /= null and then Is_Incomplete (Null_Res30) then
            Transform_Res227.Last_Attempted_Child := 0;
         elsif Null_Res30 /= null and then not Is_Ghost (Null_Res30) then
            Transform_Res227.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos304 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags227);
end if;

--  End transform_code

    if Row_Pos304 /= No_Token_Index then
        Or_Pos99 := Row_Pos304;
        Or_Res99 := Transform_Res227;
        goto Exit_Or101;
    end if;
    
Defer_Res485 :=
   Direct_Name_Or_Parse0 (Parser, Pos);
Defer_Pos485 := Parser.Current_Pos;

    if Defer_Pos485 /= No_Token_Index then
        Or_Pos99 := Defer_Pos485;
        Or_Res99 := Defer_Res485;
        goto Exit_Or101;
    end if;
<<Exit_Or101>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos99 > Mem_Pos then
         Mem_Pos := Or_Pos99;
         Mem_Res := Or_Res99;
         Set
           (Parser.Private_Part.Qual_Name_Internal_Or_Parse0_Memo,
            Or_Pos99 /= No_Token_Index,
            Or_Res99,
            Pos,
            Or_Pos99);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res99 := Mem_Res;
         Or_Pos99 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Qual_Name_Internal_Or_Parse0_Memo,
      Or_Pos99 /= No_Token_Index,
      Or_Res99,
      Pos,
      Or_Pos99);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos99;

   Exit_Call (Parser, Call_Depth);
   return Or_Res99;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Qual_Name_Internal_Or_Parse0;

   


function Qualified_Name_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Qual_Expr
is
   use Bare_Qual_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos305 :
            Token_Index
               := No_Token_Index;
      Defer_Pos486 :
            Token_Index
               := No_Token_Index;
      Defer_Res486 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos477 :
            Token_Index
               := No_Token_Index;
      Token_Res477 :
            Token_Index
               := No_Token_Index;
      Defer_Pos487 :
            Token_Index
               := No_Token_Index;
      Defer_Res487 :
            Bare_Paren_Expr
               := No_Bare_Ada_Node;
      Defer_Pos488 :
            Token_Index
               := No_Token_Index;
      Defer_Res488 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Or_Pos100 :
            Token_Index
               := No_Token_Index;
      Or_Res100 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res228 :
            Bare_Qual_Expr
               := No_Bare_Ada_Node;
      Transform_Diags228 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Qualified_Name_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res228 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res228;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res228;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags228 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos305 := Pos;



Defer_Res486 :=
   Qual_Name_Internal_Or_Parse0 (Parser, Row_Pos305);
Defer_Pos486 := Parser.Current_Pos;




if Defer_Pos486 /= No_Token_Index then

   Row_Pos305 := Defer_Pos486;

else
   Row_Pos305 := No_Token_Index;
   goto Exit_Row305_0;

end if;


--  Start tok_code

Token_Res477 := Row_Pos305;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res477));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos477 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos305 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos305,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos477 := Row_Pos305 + 1;
   end if;
end;

--  End tok_code




if Token_Pos477 /= No_Token_Index then

   Row_Pos305 := Token_Pos477;

else
   Row_Pos305 := No_Token_Index;
   goto Exit_Row305_0;

end if;


--  Start or_code

Or_Pos100 := No_Token_Index;
Or_Res100 := No_Bare_Ada_Node;
    
Defer_Res487 :=
   Paren_Expr_Transform_Parse0 (Parser, Row_Pos305);
Defer_Pos487 := Parser.Current_Pos;

    if Defer_Pos487 /= No_Token_Index then
        Or_Pos100 := Defer_Pos487;
        Or_Res100 := Defer_Res487;
        goto Exit_Or102;
    end if;
    
Defer_Res488 :=
   Aggregate_Or_Parse0 (Parser, Row_Pos305);
Defer_Pos488 := Parser.Current_Pos;

    if Defer_Pos488 /= No_Token_Index then
        Or_Pos100 := Defer_Pos488;
        Or_Res100 := Defer_Res488;
        goto Exit_Or102;
    end if;
<<Exit_Or102>>

--  End or_code




if Or_Pos100 /= No_Token_Index then

   Row_Pos305 := Or_Pos100;

else
   Row_Pos305 := No_Token_Index;
   goto Exit_Row305_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row305_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos305 /= No_Token_Index then

   Transform_Res228 := Allocate_Qual_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res228,
      Kind => Ada_Qual_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos305 = Pos
                            then No_Token_Index
                            else Row_Pos305 - 1));

      Initialize_Fields_For_Qual_Expr
        (Self => Transform_Res228, Qual_Expr_F_Prefix => Defer_Res486, Qual_Expr_F_Suffix => Or_Res100);

         if Defer_Res486 /= null and then Is_Incomplete (Defer_Res486) then
            Transform_Res228.Last_Attempted_Child := 0;
         elsif Defer_Res486 /= null and then not Is_Ghost (Defer_Res486) then
            Transform_Res228.Last_Attempted_Child := -1;
         end if;
         if Or_Res100 /= null and then Is_Incomplete (Or_Res100) then
            Transform_Res228.Last_Attempted_Child := 0;
         elsif Or_Res100 /= null and then not Is_Ghost (Or_Res100) then
            Transform_Res228.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos305 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags228);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Qualified_Name_Transform_Parse0_Memo,
      Row_Pos305 /= No_Token_Index,
      Transform_Res228,
      Pos,
      Row_Pos305);


   Parser.Current_Pos := Row_Pos305;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res228;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Qualified_Name_Transform_Parse0;

   


function Quantified_Expr_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Quantified_Expr
is
   use Bare_Quantified_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos306 :
            Token_Index
               := No_Token_Index;
      Token_Pos478 :
            Token_Index
               := No_Token_Index;
      Token_Res478 :
            Token_Index
               := No_Token_Index;
      Row_Pos307 :
            Token_Index
               := No_Token_Index;
      Token_Pos479 :
            Token_Index
               := No_Token_Index;
      Token_Res479 :
            Token_Index
               := No_Token_Index;
      Transform_Res229 :
            Bare_Quantifier_All
               := No_Bare_Ada_Node;
      Transform_Diags229 :
            Ada.Containers.Count_Type;
      Row_Pos308 :
            Token_Index
               := No_Token_Index;
      Token_Pos480 :
            Token_Index
               := No_Token_Index;
      Token_Res480 :
            Token_Index
               := No_Token_Index;
      Transform_Res230 :
            Bare_Quantifier_Some
               := No_Bare_Ada_Node;
      Transform_Diags230 :
            Ada.Containers.Count_Type;
      Or_Pos101 :
            Token_Index
               := No_Token_Index;
      Or_Res101 :
            Bare_Quantifier
               := No_Bare_Ada_Node;
      Defer_Pos489 :
            Token_Index
               := No_Token_Index;
      Defer_Res489 :
            Bare_For_Loop_Spec
               := No_Bare_Ada_Node;
      Token_Pos481 :
            Token_Index
               := No_Token_Index;
      Token_Res481 :
            Token_Index
               := No_Token_Index;
      Defer_Pos490 :
            Token_Index
               := No_Token_Index;
      Defer_Res490 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos491 :
            Token_Index
               := No_Token_Index;
      Defer_Res491 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos102 :
            Token_Index
               := No_Token_Index;
      Or_Res102 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res231 :
            Bare_Quantified_Expr
               := No_Bare_Ada_Node;
      Transform_Diags231 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Quantified_Expr_Transform_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res231 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res231;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res231;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags231 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos306 := Pos;



--  Start tok_code

Token_Res478 := Row_Pos306;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res478));
begin
   if
      T.Kind /= From_Token_Kind (Ada_For)
   then
       Token_Pos478 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos306 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos306,
             Expected_Token_Id => Ada_For,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos478 := Row_Pos306 + 1;
   end if;
end;

--  End tok_code




if Token_Pos478 /= No_Token_Index then

   Row_Pos306 := Token_Pos478;

else
   Row_Pos306 := No_Token_Index;
   goto Exit_Row306_0;

end if;


--  Start or_code

Or_Pos101 := No_Token_Index;
Or_Res101 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags229 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos307 := Row_Pos306;



--  Start tok_code

Token_Res479 := Row_Pos307;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res479));
begin
   if
      T.Kind /= From_Token_Kind (Ada_All)
   then
       Token_Pos479 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos307 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos307,
             Expected_Token_Id => Ada_All,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos479 := Row_Pos307 + 1;
   end if;
end;

--  End tok_code




if Token_Pos479 /= No_Token_Index then

   Row_Pos307 := Token_Pos479;

else
   Row_Pos307 := No_Token_Index;
   goto Exit_Row307_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row307_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos307 /= No_Token_Index then

   Transform_Res229 := Allocate_Quantifier_All (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res229,
      Kind => Ada_Quantifier_All,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos306,
      Token_End_Index   => (if Row_Pos307 = Row_Pos306
                            then No_Token_Index
                            else Row_Pos307 - 1));




elsif Row_Pos307 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags229);
end if;

--  End transform_code

    if Row_Pos307 /= No_Token_Index then
        Or_Pos101 := Row_Pos307;
        Or_Res101 := Transform_Res229;
        goto Exit_Or103;
    end if;
    
--  Start transform_code

Transform_Diags230 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos308 := Row_Pos306;



--  Start tok_code

Token_Res480 := Row_Pos308;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res480));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Some)
   then
       Token_Pos480 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos308 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos308,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos480 := Row_Pos308 + 1;
   end if;
end;

--  End tok_code




if Token_Pos480 /= No_Token_Index then

   Row_Pos308 := Token_Pos480;

else
   Row_Pos308 := No_Token_Index;
   goto Exit_Row308_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row308_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos308 /= No_Token_Index then

   Transform_Res230 := Allocate_Quantifier_Some (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res230,
      Kind => Ada_Quantifier_Some,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos306,
      Token_End_Index   => (if Row_Pos308 = Row_Pos306
                            then No_Token_Index
                            else Row_Pos308 - 1));




elsif Row_Pos308 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags230);
end if;

--  End transform_code

    if Row_Pos308 /= No_Token_Index then
        Or_Pos101 := Row_Pos308;
        Or_Res101 := Transform_Res230;
        goto Exit_Or103;
    end if;
<<Exit_Or103>>

--  End or_code




if Or_Pos101 /= No_Token_Index then

   Row_Pos306 := Or_Pos101;

else
   Row_Pos306 := No_Token_Index;
   goto Exit_Row306_0;

end if;


Defer_Res489 :=
   For_Loop_Param_Spec_Transform_Parse3 (Parser, Row_Pos306);
Defer_Pos489 := Parser.Current_Pos;




if Defer_Pos489 /= No_Token_Index then

   Row_Pos306 := Defer_Pos489;

else
   Row_Pos306 := No_Token_Index;
   goto Exit_Row306_0;

end if;


--  Start tok_code

Token_Res481 := Row_Pos306;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res481));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos481 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos306 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos306,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos481 := Row_Pos306 + 1;
   end if;
end;

--  End tok_code




if Token_Pos481 /= No_Token_Index then

   Row_Pos306 := Token_Pos481;

else
   Row_Pos306 := No_Token_Index;
   goto Exit_Row306_0;

end if;


--  Start or_code

Or_Pos102 := No_Token_Index;
Or_Res102 := No_Bare_Ada_Node;
    
Defer_Res490 :=
   Expr_Or_Parse0 (Parser, Row_Pos306);
Defer_Pos490 := Parser.Current_Pos;

    if Defer_Pos490 /= No_Token_Index then
        Or_Pos102 := Defer_Pos490;
        Or_Res102 := Defer_Res490;
        goto Exit_Or104;
    end if;
    
Defer_Res491 :=
   Discrete_Range_Or_Parse0 (Parser, Row_Pos306);
Defer_Pos491 := Parser.Current_Pos;

    if Defer_Pos491 /= No_Token_Index then
        Or_Pos102 := Defer_Pos491;
        Or_Res102 := Defer_Res491;
        goto Exit_Or104;
    end if;
<<Exit_Or104>>

--  End or_code




if Or_Pos102 /= No_Token_Index then

   Row_Pos306 := Or_Pos102;

else
   Row_Pos306 := No_Token_Index;
   goto Exit_Row306_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row306_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos306 /= No_Token_Index then

   Transform_Res231 := Allocate_Quantified_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res231,
      Kind => Ada_Quantified_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos306 = Pos
                            then No_Token_Index
                            else Row_Pos306 - 1));

      Initialize_Fields_For_Quantified_Expr
        (Self => Transform_Res231, Quantified_Expr_F_Quantifier => Or_Res101, Quantified_Expr_F_Loop_Spec => Defer_Res489, Quantified_Expr_F_Expr => Or_Res102);

         if Or_Res101 /= null and then Is_Incomplete (Or_Res101) then
            Transform_Res231.Last_Attempted_Child := 0;
         elsif Or_Res101 /= null and then not Is_Ghost (Or_Res101) then
            Transform_Res231.Last_Attempted_Child := -1;
         end if;
         if Defer_Res489 /= null and then Is_Incomplete (Defer_Res489) then
            Transform_Res231.Last_Attempted_Child := 0;
         elsif Defer_Res489 /= null and then not Is_Ghost (Defer_Res489) then
            Transform_Res231.Last_Attempted_Child := -1;
         end if;
         if Or_Res102 /= null and then Is_Incomplete (Or_Res102) then
            Transform_Res231.Last_Attempted_Child := 0;
         elsif Or_Res102 /= null and then not Is_Ghost (Or_Res102) then
            Transform_Res231.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos306 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags231);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Quantified_Expr_Transform_Parse2_Memo,
      Row_Pos306 /= No_Token_Index,
      Transform_Res231,
      Pos,
      Row_Pos306);


   Parser.Current_Pos := Row_Pos306;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res231;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Quantified_Expr_Transform_Parse2;

   


function Raise_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Expr
is
   use Bare_Raise_Expr_Memos;

   Call_Depth : aliased Natural;

      Row_Pos309 :
            Token_Index
               := No_Token_Index;
      Token_Pos482 :
            Token_Index
               := No_Token_Index;
      Token_Res482 :
            Token_Index
               := No_Token_Index;
      Defer_Pos492 :
            Token_Index
               := No_Token_Index;
      Defer_Res492 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos310 :
            Token_Index
               := No_Token_Index;
      Token_Pos483 :
            Token_Index
               := No_Token_Index;
      Token_Res483 :
            Token_Index
               := No_Token_Index;
      Defer_Pos493 :
            Token_Index
               := No_Token_Index;
      Defer_Res493 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res232 :
            Bare_Raise_Expr
               := No_Bare_Ada_Node;
      Transform_Diags232 :
            Ada.Containers.Count_Type;
      Row_Pos311 :
            Token_Index
               := No_Token_Index;
      Token_Pos484 :
            Token_Index
               := No_Token_Index;
      Token_Res484 :
            Token_Index
               := No_Token_Index;
      Null_Res31 :
            Bare_Name
               := No_Bare_Ada_Node;
      Null_Res32 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res233 :
            Bare_Raise_Expr
               := No_Bare_Ada_Node;
      Transform_Diags233 :
            Ada.Containers.Count_Type;
      Or_Pos103 :
            Token_Index
               := No_Token_Index;
      Or_Res103 :
            Bare_Raise_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Raise_Expr_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res103 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res103;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res103;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos103 := No_Token_Index;
Or_Res103 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags232 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos309 := Pos;



--  Start tok_code

Token_Res482 := Row_Pos309;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res482));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Raise)
   then
       Token_Pos482 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos309 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos309,
             Expected_Token_Id => Ada_Raise,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos482 := Row_Pos309 + 1;
   end if;
end;

--  End tok_code




if Token_Pos482 /= No_Token_Index then

   Row_Pos309 := Token_Pos482;

else
   Row_Pos309 := No_Token_Index;
   goto Exit_Row309_0;

end if;


Defer_Res492 :=
   Name_Or_Parse2 (Parser, Row_Pos309);
Defer_Pos492 := Parser.Current_Pos;




if Defer_Pos492 /= No_Token_Index then

   Row_Pos309 := Defer_Pos492;

else
   Row_Pos309 := No_Token_Index;
   goto Exit_Row309_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos310 := Row_Pos309;



--  Start tok_code

Token_Res483 := Row_Pos310;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res483));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos483 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos310 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos310,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos483 := Row_Pos310 + 1;
   end if;
end;

--  End tok_code




if Token_Pos483 /= No_Token_Index then

   Row_Pos310 := Token_Pos483;

else
   Row_Pos310 := No_Token_Index;
   goto Exit_Row310_0;

end if;


Defer_Res493 :=
   Expr_Or_Parse0 (Parser, Row_Pos310);
Defer_Pos493 := Parser.Current_Pos;




if Defer_Pos493 /= No_Token_Index then

   Row_Pos310 := Defer_Pos493;

else
   Row_Pos310 := No_Token_Index;
   goto Exit_Row310_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row310_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos310 = No_Token_Index then

         
   Defer_Res493 := No_Bare_Ada_Node;



       
   Row_Pos310 := Row_Pos309;



end if;

--  End opt_code




if Row_Pos310 /= No_Token_Index then

   Row_Pos309 := Row_Pos310;

else
   Row_Pos309 := No_Token_Index;
   goto Exit_Row309_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row309_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos309 /= No_Token_Index then

   Transform_Res232 := Allocate_Raise_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res232,
      Kind => Ada_Raise_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos309 = Pos
                            then No_Token_Index
                            else Row_Pos309 - 1));

      Initialize_Fields_For_Raise_Expr
        (Self => Transform_Res232, Raise_Expr_F_Exception_Name => Defer_Res492, Raise_Expr_F_Error_Message => Defer_Res493);

         if Defer_Res492 /= null and then Is_Incomplete (Defer_Res492) then
            Transform_Res232.Last_Attempted_Child := 0;
         elsif Defer_Res492 /= null and then not Is_Ghost (Defer_Res492) then
            Transform_Res232.Last_Attempted_Child := -1;
         end if;
         if Defer_Res493 /= null and then Is_Incomplete (Defer_Res493) then
            Transform_Res232.Last_Attempted_Child := 0;
         elsif Defer_Res493 /= null and then not Is_Ghost (Defer_Res493) then
            Transform_Res232.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos309 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags232);
end if;

--  End transform_code

    if Row_Pos309 /= No_Token_Index then
        Or_Pos103 := Row_Pos309;
        Or_Res103 := Transform_Res232;
        goto Exit_Or105;
    end if;
    
--  Start transform_code

Transform_Diags233 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos311 := Pos;



--  Start tok_code

Token_Res484 := Row_Pos311;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res484));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Raise)
   then
       Token_Pos484 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos311 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos311,
             Expected_Token_Id => Ada_Raise,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos484 := Row_Pos311 + 1;
   end if;
end;

--  End tok_code




if Token_Pos484 /= No_Token_Index then

   Row_Pos311 := Token_Pos484;

else
   Row_Pos311 := No_Token_Index;
   goto Exit_Row311_0;

end if;


   Null_Res31 := No_Bare_Ada_Node;




if Row_Pos311 /= No_Token_Index then

   Row_Pos311 := Row_Pos311;

else
   Row_Pos311 := No_Token_Index;
   goto Exit_Row311_0;

end if;


   Null_Res32 := No_Bare_Ada_Node;




if Row_Pos311 /= No_Token_Index then

   Row_Pos311 := Row_Pos311;

else
   Row_Pos311 := No_Token_Index;
   goto Exit_Row311_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row311_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos311 /= No_Token_Index then

   Transform_Res233 := Allocate_Raise_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res233,
      Kind => Ada_Raise_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos311 = Pos
                            then No_Token_Index
                            else Row_Pos311 - 1));

      Initialize_Fields_For_Raise_Expr
        (Self => Transform_Res233, Raise_Expr_F_Exception_Name => Null_Res31, Raise_Expr_F_Error_Message => Null_Res32);

         if Null_Res31 /= null and then Is_Incomplete (Null_Res31) then
            Transform_Res233.Last_Attempted_Child := 0;
         elsif Null_Res31 /= null and then not Is_Ghost (Null_Res31) then
            Transform_Res233.Last_Attempted_Child := -1;
         end if;
         if Null_Res32 /= null and then Is_Incomplete (Null_Res32) then
            Transform_Res233.Last_Attempted_Child := 0;
         elsif Null_Res32 /= null and then not Is_Ghost (Null_Res32) then
            Transform_Res233.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos311 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags233);
end if;

--  End transform_code

    if Row_Pos311 /= No_Token_Index then
        Or_Pos103 := Row_Pos311;
        Or_Res103 := Transform_Res233;
        goto Exit_Or105;
    end if;
<<Exit_Or105>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Raise_Expr_Or_Parse0_Memo,
      Or_Pos103 /= No_Token_Index,
      Or_Res103,
      Pos,
      Or_Pos103);


   Parser.Current_Pos := Or_Pos103;

   Exit_Call (Parser, Call_Depth);
   return Or_Res103;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Raise_Expr_Or_Parse0;

   


function Raise_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Stmt
is
   use Bare_Raise_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos312 :
            Token_Index
               := No_Token_Index;
      Token_Pos485 :
            Token_Index
               := No_Token_Index;
      Token_Res485 :
            Token_Index
               := No_Token_Index;
      Defer_Pos494 :
            Token_Index
               := No_Token_Index;
      Defer_Res494 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos313 :
            Token_Index
               := No_Token_Index;
      Token_Pos486 :
            Token_Index
               := No_Token_Index;
      Token_Res486 :
            Token_Index
               := No_Token_Index;
      Defer_Pos495 :
            Token_Index
               := No_Token_Index;
      Defer_Res495 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos487 :
            Token_Index
               := No_Token_Index;
      Token_Res487 :
            Token_Index
               := No_Token_Index;
      Transform_Res234 :
            Bare_Raise_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags234 :
            Ada.Containers.Count_Type;
      Row_Pos314 :
            Token_Index
               := No_Token_Index;
      Token_Pos488 :
            Token_Index
               := No_Token_Index;
      Token_Res488 :
            Token_Index
               := No_Token_Index;
      Null_Res33 :
            Bare_Name
               := No_Bare_Ada_Node;
      Null_Res34 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos489 :
            Token_Index
               := No_Token_Index;
      Token_Res489 :
            Token_Index
               := No_Token_Index;
      Transform_Res235 :
            Bare_Raise_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags235 :
            Ada.Containers.Count_Type;
      Or_Pos104 :
            Token_Index
               := No_Token_Index;
      Or_Res104 :
            Bare_Raise_Stmt
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Raise_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res104 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res104;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res104;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos104 := No_Token_Index;
Or_Res104 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags234 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos312 := Pos;



--  Start tok_code

Token_Res485 := Row_Pos312;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res485));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Raise)
   then
       Token_Pos485 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos312 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos312,
             Expected_Token_Id => Ada_Raise,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos485 := Row_Pos312 + 1;
   end if;
end;

--  End tok_code




if Token_Pos485 /= No_Token_Index then

   Row_Pos312 := Token_Pos485;

else
   Row_Pos312 := No_Token_Index;
   goto Exit_Row312_0;

end if;


Defer_Res494 :=
   Name_Or_Parse2 (Parser, Row_Pos312);
Defer_Pos494 := Parser.Current_Pos;




if Defer_Pos494 /= No_Token_Index then

   Row_Pos312 := Defer_Pos494;

else
   Row_Pos312 := No_Token_Index;
   goto Exit_Row312_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos313 := Row_Pos312;



--  Start tok_code

Token_Res486 := Row_Pos313;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res486));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos486 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos313 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos313,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos486 := Row_Pos313 + 1;
   end if;
end;

--  End tok_code




if Token_Pos486 /= No_Token_Index then

   Row_Pos313 := Token_Pos486;

else
   Row_Pos313 := No_Token_Index;
   goto Exit_Row313_0;

end if;


Defer_Res495 :=
   Expr_Or_Parse0 (Parser, Row_Pos313);
Defer_Pos495 := Parser.Current_Pos;




if Defer_Pos495 /= No_Token_Index then

   Row_Pos313 := Defer_Pos495;

else
   Row_Pos313 := No_Token_Index;
   goto Exit_Row313_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row313_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos313 = No_Token_Index then

         
   Defer_Res495 := No_Bare_Ada_Node;



       
   Row_Pos313 := Row_Pos312;



end if;

--  End opt_code




if Row_Pos313 /= No_Token_Index then

   Row_Pos312 := Row_Pos313;

else
   Row_Pos312 := No_Token_Index;
   goto Exit_Row312_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res487 := Row_Pos312;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res487));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos487 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos312 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos312,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos487 := Row_Pos312 + 1;
   end if;
end;

--  End tok_code


if Token_Pos487 = No_Token_Index then

         
   Token_Res487 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos312)),
                To_Text ("Missing ';'"));

       
   Token_Pos487 := Row_Pos312;



end if;

--  End opt_code




if Token_Pos487 /= No_Token_Index then

   Row_Pos312 := Token_Pos487;

else
   Row_Pos312 := No_Token_Index;
   goto Exit_Row312_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row312_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos312 /= No_Token_Index then

   Transform_Res234 := Allocate_Raise_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res234,
      Kind => Ada_Raise_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos312 = Pos
                            then No_Token_Index
                            else Row_Pos312 - 1));

      Initialize_Fields_For_Raise_Stmt
        (Self => Transform_Res234, Raise_Stmt_F_Exception_Name => Defer_Res494, Raise_Stmt_F_Error_Message => Defer_Res495);

         if Defer_Res494 /= null and then Is_Incomplete (Defer_Res494) then
            Transform_Res234.Last_Attempted_Child := 0;
         elsif Defer_Res494 /= null and then not Is_Ghost (Defer_Res494) then
            Transform_Res234.Last_Attempted_Child := -1;
         end if;
         if Defer_Res495 /= null and then Is_Incomplete (Defer_Res495) then
            Transform_Res234.Last_Attempted_Child := 0;
         elsif Defer_Res495 /= null and then not Is_Ghost (Defer_Res495) then
            Transform_Res234.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos312 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags234);
end if;

--  End transform_code

    if Row_Pos312 /= No_Token_Index then
        Or_Pos104 := Row_Pos312;
        Or_Res104 := Transform_Res234;
        goto Exit_Or106;
    end if;
    
--  Start transform_code

Transform_Diags235 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos314 := Pos;



--  Start tok_code

Token_Res488 := Row_Pos314;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res488));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Raise)
   then
       Token_Pos488 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos314 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos314,
             Expected_Token_Id => Ada_Raise,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos488 := Row_Pos314 + 1;
   end if;
end;

--  End tok_code




if Token_Pos488 /= No_Token_Index then

   Row_Pos314 := Token_Pos488;

else
   Row_Pos314 := No_Token_Index;
   goto Exit_Row314_0;

end if;


   Null_Res33 := No_Bare_Ada_Node;




if Row_Pos314 /= No_Token_Index then

   Row_Pos314 := Row_Pos314;

else
   Row_Pos314 := No_Token_Index;
   goto Exit_Row314_0;

end if;


   Null_Res34 := No_Bare_Ada_Node;




if Row_Pos314 /= No_Token_Index then

   Row_Pos314 := Row_Pos314;

else
   Row_Pos314 := No_Token_Index;
   goto Exit_Row314_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res489 := Row_Pos314;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res489));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos489 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos314 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos314,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos489 := Row_Pos314 + 1;
   end if;
end;

--  End tok_code


if Token_Pos489 = No_Token_Index then

         
   Token_Res489 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos314)),
                To_Text ("Missing ';'"));

       
   Token_Pos489 := Row_Pos314;



end if;

--  End opt_code




if Token_Pos489 /= No_Token_Index then

   Row_Pos314 := Token_Pos489;

else
   Row_Pos314 := No_Token_Index;
   goto Exit_Row314_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row314_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos314 /= No_Token_Index then

   Transform_Res235 := Allocate_Raise_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res235,
      Kind => Ada_Raise_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos314 = Pos
                            then No_Token_Index
                            else Row_Pos314 - 1));

      Initialize_Fields_For_Raise_Stmt
        (Self => Transform_Res235, Raise_Stmt_F_Exception_Name => Null_Res33, Raise_Stmt_F_Error_Message => Null_Res34);

         if Null_Res33 /= null and then Is_Incomplete (Null_Res33) then
            Transform_Res235.Last_Attempted_Child := 0;
         elsif Null_Res33 /= null and then not Is_Ghost (Null_Res33) then
            Transform_Res235.Last_Attempted_Child := -1;
         end if;
         if Null_Res34 /= null and then Is_Incomplete (Null_Res34) then
            Transform_Res235.Last_Attempted_Child := 0;
         elsif Null_Res34 /= null and then not Is_Ghost (Null_Res34) then
            Transform_Res235.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos314 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags235);
end if;

--  End transform_code

    if Row_Pos314 /= No_Token_Index then
        Or_Pos104 := Row_Pos314;
        Or_Res104 := Transform_Res235;
        goto Exit_Or106;
    end if;
<<Exit_Or106>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Raise_Stmt_Or_Parse0_Memo,
      Or_Pos104 /= No_Token_Index,
      Or_Res104,
      Pos,
      Or_Pos104);


   Parser.Current_Pos := Or_Pos104;

   Exit_Call (Parser, Call_Depth);
   return Or_Res104;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Raise_Stmt_Or_Parse0;

   


function Range_Constraint_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Range_Constraint
is
   use Bare_Range_Constraint_Memos;

   Call_Depth : aliased Natural;

      Row_Pos315 :
            Token_Index
               := No_Token_Index;
      Row_Pos316 :
            Token_Index
               := No_Token_Index;
      Token_Pos490 :
            Token_Index
               := No_Token_Index;
      Token_Res490 :
            Token_Index
               := No_Token_Index;
      Defer_Pos496 :
            Token_Index
               := No_Token_Index;
      Defer_Res496 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos497 :
            Token_Index
               := No_Token_Index;
      Defer_Res497 :
            Bare_Name
               := No_Bare_Ada_Node;
      Or_Pos105 :
            Token_Index
               := No_Token_Index;
      Or_Res105 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res236 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Diags236 :
            Ada.Containers.Count_Type;
      Transform_Res237 :
            Bare_Range_Constraint
               := No_Bare_Ada_Node;
      Transform_Diags237 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Range_Constraint_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res237 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res237;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res237;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags237 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos315 := Pos;



--  Start transform_code

Transform_Diags236 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos316 := Row_Pos315;



--  Start tok_code

Token_Res490 := Row_Pos316;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res490));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Range)
   then
       Token_Pos490 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos316 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos316,
             Expected_Token_Id => Ada_Range,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos490 := Row_Pos316 + 1;
   end if;
end;

--  End tok_code




if Token_Pos490 /= No_Token_Index then

   Row_Pos316 := Token_Pos490;

else
   Row_Pos316 := No_Token_Index;
   goto Exit_Row316_0;

end if;


--  Start or_code

Or_Pos105 := No_Token_Index;
Or_Res105 := No_Bare_Ada_Node;
    
Defer_Res496 :=
   Discrete_Range_Or_Parse0 (Parser, Row_Pos316);
Defer_Pos496 := Parser.Current_Pos;

    if Defer_Pos496 /= No_Token_Index then
        Or_Pos105 := Defer_Pos496;
        Or_Res105 := Defer_Res496;
        goto Exit_Or107;
    end if;
    
Defer_Res497 :=
   Name_Or_Parse2 (Parser, Row_Pos316);
Defer_Pos497 := Parser.Current_Pos;

    if Defer_Pos497 /= No_Token_Index then
        Or_Pos105 := Defer_Pos497;
        Or_Res105 := Defer_Res497;
        goto Exit_Or107;
    end if;
<<Exit_Or107>>

--  End or_code




if Or_Pos105 /= No_Token_Index then

   Row_Pos316 := Or_Pos105;

else
   Row_Pos316 := No_Token_Index;
   goto Exit_Row316_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row316_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos316 /= No_Token_Index then

   Transform_Res236 := Allocate_Range_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res236,
      Kind => Ada_Range_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos315,
      Token_End_Index   => (if Row_Pos316 = Row_Pos315
                            then No_Token_Index
                            else Row_Pos316 - 1));

      Initialize_Fields_For_Range_Spec
        (Self => Transform_Res236, Range_Spec_F_Range => Or_Res105);

         if Or_Res105 /= null and then Is_Incomplete (Or_Res105) then
            Transform_Res236.Last_Attempted_Child := 0;
         elsif Or_Res105 /= null and then not Is_Ghost (Or_Res105) then
            Transform_Res236.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos316 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags236);
end if;

--  End transform_code




if Row_Pos316 /= No_Token_Index then

   Row_Pos315 := Row_Pos316;

else
   Row_Pos315 := No_Token_Index;
   goto Exit_Row315_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row315_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos315 /= No_Token_Index then

   Transform_Res237 := Allocate_Range_Constraint (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res237,
      Kind => Ada_Range_Constraint,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos315 = Pos
                            then No_Token_Index
                            else Row_Pos315 - 1));

      Initialize_Fields_For_Range_Constraint
        (Self => Transform_Res237, Range_Constraint_F_Range => Transform_Res236);

         if Transform_Res236 /= null and then Is_Incomplete (Transform_Res236) then
            Transform_Res237.Last_Attempted_Child := 0;
         elsif Transform_Res236 /= null and then not Is_Ghost (Transform_Res236) then
            Transform_Res237.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos315 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags237);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Range_Constraint_Transform_Parse1_Memo,
      Row_Pos315 /= No_Token_Index,
      Transform_Res237,
      Pos,
      Row_Pos315);


   Parser.Current_Pos := Row_Pos315;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res237;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Range_Constraint_Transform_Parse1;

   


function Range_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Range_Spec
is
   use Bare_Range_Spec_Memos;

   Call_Depth : aliased Natural;

      Row_Pos317 :
            Token_Index
               := No_Token_Index;
      Token_Pos491 :
            Token_Index
               := No_Token_Index;
      Token_Res491 :
            Token_Index
               := No_Token_Index;
      Defer_Pos498 :
            Token_Index
               := No_Token_Index;
      Defer_Res498 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos499 :
            Token_Index
               := No_Token_Index;
      Defer_Res499 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos500 :
            Token_Index
               := No_Token_Index;
      Defer_Res500 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Or_Pos106 :
            Token_Index
               := No_Token_Index;
      Or_Res106 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res238 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Diags238 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Range_Spec_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res238 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res238;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res238;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags238 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos317 := Pos;



--  Start tok_code

Token_Res491 := Row_Pos317;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res491));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Range)
   then
       Token_Pos491 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos317 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos317,
             Expected_Token_Id => Ada_Range,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos491 := Row_Pos317 + 1;
   end if;
end;

--  End tok_code




if Token_Pos491 /= No_Token_Index then

   Row_Pos317 := Token_Pos491;

else
   Row_Pos317 := No_Token_Index;
   goto Exit_Row317_0;

end if;


--  Start or_code

Or_Pos106 := No_Token_Index;
Or_Res106 := No_Bare_Ada_Node;
    
Defer_Res498 :=
   Discrete_Range_Or_Parse0 (Parser, Row_Pos317);
Defer_Pos498 := Parser.Current_Pos;

    if Defer_Pos498 /= No_Token_Index then
        Or_Pos106 := Defer_Pos498;
        Or_Res106 := Defer_Res498;
        goto Exit_Or108;
    end if;
    
Defer_Res499 :=
   Name_Or_Parse2 (Parser, Row_Pos317);
Defer_Pos499 := Parser.Current_Pos;

    if Defer_Pos499 /= No_Token_Index then
        Or_Pos106 := Defer_Pos499;
        Or_Res106 := Defer_Res499;
        goto Exit_Or108;
    end if;
    
Defer_Res500 :=
   Box_Expr_Transform_Parse0 (Parser, Row_Pos317);
Defer_Pos500 := Parser.Current_Pos;

    if Defer_Pos500 /= No_Token_Index then
        Or_Pos106 := Defer_Pos500;
        Or_Res106 := Defer_Res500;
        goto Exit_Or108;
    end if;
<<Exit_Or108>>

--  End or_code




if Or_Pos106 /= No_Token_Index then

   Row_Pos317 := Or_Pos106;

else
   Row_Pos317 := No_Token_Index;
   goto Exit_Row317_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row317_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos317 /= No_Token_Index then

   Transform_Res238 := Allocate_Range_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res238,
      Kind => Ada_Range_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos317 = Pos
                            then No_Token_Index
                            else Row_Pos317 - 1));

      Initialize_Fields_For_Range_Spec
        (Self => Transform_Res238, Range_Spec_F_Range => Or_Res106);

         if Or_Res106 /= null and then Is_Incomplete (Or_Res106) then
            Transform_Res238.Last_Attempted_Child := 0;
         elsif Or_Res106 /= null and then not Is_Ghost (Or_Res106) then
            Transform_Res238.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos317 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags238);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Range_Spec_Transform_Parse0_Memo,
      Row_Pos317 /= No_Token_Index,
      Transform_Res238,
      Pos,
      Row_Pos317);


   Parser.Current_Pos := Row_Pos317;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res238;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Range_Spec_Transform_Parse0;

   


function Real_Type_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Real_Type_Def
is
   use Bare_Real_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos501 :
            Token_Index
               := No_Token_Index;
      Defer_Res501 :
            Bare_Floating_Point_Def
               := No_Bare_Ada_Node;
      Defer_Pos502 :
            Token_Index
               := No_Token_Index;
      Defer_Res502 :
            Bare_Decimal_Fixed_Point_Def
               := No_Bare_Ada_Node;
      Defer_Pos503 :
            Token_Index
               := No_Token_Index;
      Defer_Res503 :
            Bare_Ordinary_Fixed_Point_Def
               := No_Bare_Ada_Node;
      Or_Pos107 :
            Token_Index
               := No_Token_Index;
      Or_Res107 :
            Bare_Real_Type_Def
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Real_Type_Def_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res107 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res107;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res107;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos107 := No_Token_Index;
Or_Res107 := No_Bare_Ada_Node;
    
Defer_Res501 :=
   Floating_Point_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos501 := Parser.Current_Pos;

    if Defer_Pos501 /= No_Token_Index then
        Or_Pos107 := Defer_Pos501;
        Or_Res107 := Defer_Res501;
        goto Exit_Or109;
    end if;
    
Defer_Res502 :=
   Decimal_Fixed_Point_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos502 := Parser.Current_Pos;

    if Defer_Pos502 /= No_Token_Index then
        Or_Pos107 := Defer_Pos502;
        Or_Res107 := Defer_Res502;
        goto Exit_Or109;
    end if;
    
Defer_Res503 :=
   Ordinary_Fixed_Point_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos503 := Parser.Current_Pos;

    if Defer_Pos503 /= No_Token_Index then
        Or_Pos107 := Defer_Pos503;
        Or_Res107 := Defer_Res503;
        goto Exit_Or109;
    end if;
<<Exit_Or109>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Real_Type_Def_Or_Parse0_Memo,
      Or_Pos107 /= No_Token_Index,
      Or_Res107,
      Pos,
      Or_Pos107);


   Parser.Current_Pos := Or_Pos107;

   Exit_Call (Parser, Call_Depth);
   return Or_Res107;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Real_Type_Def_Or_Parse0;

   


function Record_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Record_Def
is
   use Bare_Base_Record_Def_Memos;

   Call_Depth : aliased Natural;

      Nobt41 :
            Boolean
               := False;
      Row_Pos318 :
            Token_Index
               := No_Token_Index;
      Token_Pos492 :
            Token_Index
               := No_Token_Index;
      Token_Res492 :
            Token_Index
               := No_Token_Index;
      Defer_Pos504 :
            Token_Index
               := No_Token_Index;
      Defer_Res504 :
            Bare_Component_List
               := No_Bare_Ada_Node;
      Token_Pos493 :
            Token_Index
               := No_Token_Index;
      Token_Res493 :
            Token_Index
               := No_Token_Index;
      Token_Pos494 :
            Token_Index
               := No_Token_Index;
      Token_Res494 :
            Token_Index
               := No_Token_Index;
      Row_Progress36 :
            Integer
               := 0;
      Transform_Res239 :
            Bare_Record_Def
               := No_Bare_Ada_Node;
      Transform_Has_Failed36 :
            Boolean
               := False;
      Transform_Diags239 :
            Ada.Containers.Count_Type;
      Row_Pos319 :
            Token_Index
               := No_Token_Index;
      Token_Pos495 :
            Token_Index
               := No_Token_Index;
      Token_Res495 :
            Token_Index
               := No_Token_Index;
      Token_Pos496 :
            Token_Index
               := No_Token_Index;
      Token_Res496 :
            Token_Index
               := No_Token_Index;
      Row_Pos320 :
            Token_Index
               := No_Token_Index;
      Null_Res35 :
            Bare_Ada_Node_List
               := No_Bare_Ada_Node;
      Null_Res36 :
            Bare_Variant_Part
               := No_Bare_Ada_Node;
      Transform_Res240 :
            Bare_Component_List
               := No_Bare_Ada_Node;
      Transform_Diags240 :
            Ada.Containers.Count_Type;
      Transform_Res241 :
            Bare_Null_Record_Def
               := No_Bare_Ada_Node;
      Transform_Diags241 :
            Ada.Containers.Count_Type;
      Or_Pos108 :
            Token_Index
               := No_Token_Index;
      Or_Res108 :
            Bare_Base_Record_Def
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Record_Def_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res108 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res108;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res108;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos108 := No_Token_Index;
Or_Res108 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags239 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos318 := Pos;



--  Start tok_code

Token_Res492 := Row_Pos318;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res492));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Record)
   then
       Token_Pos492 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos318 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos318,
             Expected_Token_Id => Ada_Record,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos492 := Row_Pos318 + 1;
   end if;
end;

--  End tok_code



Row_Progress36 := 1;

if Token_Pos492 /= No_Token_Index then

   Row_Pos318 := Token_Pos492;

else
   Row_Pos318 := No_Token_Index;
   goto Exit_Row318_0;

end if;


Defer_Res504 :=
   Component_List_Transform_Parse0 (Parser, Row_Pos318);
Defer_Pos504 := Parser.Current_Pos;



Row_Progress36 := 2;

if Defer_Pos504 /= No_Token_Index then

   Row_Pos318 := Defer_Pos504;

else
   Row_Pos318 := No_Token_Index;
   goto Exit_Row318_0;

end if;


--  Start tok_code

Token_Res493 := Row_Pos318;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res493));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos493 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos318 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos318,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos493 := Row_Pos318 + 1;
   end if;
end;

--  End tok_code



Row_Progress36 := 3;

if Token_Pos493 /= No_Token_Index then

   Row_Pos318 := Token_Pos493;

else
   Row_Pos318 := No_Token_Index;
   goto Exit_Row318_0;

end if;

Nobt41 := True;

   Nobt41 := Nobt41;

Row_Progress36 := 4;

if Row_Pos318 /= No_Token_Index then

   Row_Pos318 := Row_Pos318;

else
   Row_Pos318 := No_Token_Index;
   goto Exit_Row318_0;

end if;


--  Start tok_code

Token_Res494 := Row_Pos318;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res494));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Record)
   then
       Token_Pos494 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos318 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos318,
             Expected_Token_Id => Ada_Record,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos494 := Row_Pos318 + 1;
   end if;
end;

--  End tok_code



Row_Progress36 := 5;

if Token_Pos494 /= No_Token_Index then

   Row_Pos318 := Token_Pos494;

else
   Row_Pos318 := No_Token_Index;
   goto Exit_Row318_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row318_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos318 = No_Token_Index and then Nobt41 then

   Row_Pos318 := Parser.Last_Fail.Pos;

   Transform_Has_Failed36 := True;
end if;

if Row_Pos318 /= No_Token_Index then

   Transform_Res239 := Allocate_Record_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res239,
      Kind => Ada_Record_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos318 = Pos
                            then No_Token_Index
                            else Row_Pos318 - 1));

      Initialize_Fields_For_Record_Def
        (Self => Transform_Res239, Base_Record_Def_F_Components => Defer_Res504);

         if Defer_Res504 /= null and then Is_Incomplete (Defer_Res504) then
            Transform_Res239.Last_Attempted_Child := 0;
         elsif Defer_Res504 /= null and then not Is_Ghost (Defer_Res504) then
            Transform_Res239.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed36 then
      Transform_Res239.Last_Attempted_Child :=
         Row_Progress36;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <record_def>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos318 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags239);
end if;

--  End transform_code

    if Row_Pos318 /= No_Token_Index then
        Or_Pos108 := Row_Pos318;
        Or_Res108 := Transform_Res239;
        goto Exit_Or110;
    end if;
    
--  Start transform_code

Transform_Diags241 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos319 := Pos;



--  Start tok_code

Token_Res495 := Row_Pos319;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res495));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos495 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos319 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos319,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos495 := Row_Pos319 + 1;
   end if;
end;

--  End tok_code




if Token_Pos495 /= No_Token_Index then

   Row_Pos319 := Token_Pos495;

else
   Row_Pos319 := No_Token_Index;
   goto Exit_Row319_0;

end if;


--  Start tok_code

Token_Res496 := Row_Pos319;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res496));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Record)
   then
       Token_Pos496 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos319 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos319,
             Expected_Token_Id => Ada_Record,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos496 := Row_Pos319 + 1;
   end if;
end;

--  End tok_code




if Token_Pos496 /= No_Token_Index then

   Row_Pos319 := Token_Pos496;

else
   Row_Pos319 := No_Token_Index;
   goto Exit_Row319_0;

end if;


--  Start transform_code

Transform_Diags240 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos320 := Row_Pos319;



   Null_Res35 := Allocate_Ada_Node_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res35,
      Kind              => Ada_Ada_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos320, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res35,
      Parser => Parser,
      Count  => 0);





if Row_Pos320 /= No_Token_Index then

   Row_Pos320 := Row_Pos320;

else
   Row_Pos320 := No_Token_Index;
   goto Exit_Row320_0;

end if;


   Null_Res36 := No_Bare_Ada_Node;




if Row_Pos320 /= No_Token_Index then

   Row_Pos320 := Row_Pos320;

else
   Row_Pos320 := No_Token_Index;
   goto Exit_Row320_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row320_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos320 /= No_Token_Index then

   Transform_Res240 := Allocate_Component_List (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res240,
      Kind => Ada_Component_List,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos319,
      Token_End_Index   => (if Row_Pos320 = Row_Pos319
                            then No_Token_Index
                            else Row_Pos320 - 1));

      Initialize_Fields_For_Component_List
        (Self => Transform_Res240, Component_List_F_Components => Null_Res35, Component_List_F_Variant_Part => Null_Res36);

         if Null_Res35 /= null and then Is_Incomplete (Null_Res35) then
            Transform_Res240.Last_Attempted_Child := 0;
         elsif Null_Res35 /= null and then not Is_Ghost (Null_Res35) then
            Transform_Res240.Last_Attempted_Child := -1;
         end if;
         if Null_Res36 /= null and then Is_Incomplete (Null_Res36) then
            Transform_Res240.Last_Attempted_Child := 0;
         elsif Null_Res36 /= null and then not Is_Ghost (Null_Res36) then
            Transform_Res240.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos320 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags240);
end if;

--  End transform_code




if Row_Pos320 /= No_Token_Index then

   Row_Pos319 := Row_Pos320;

else
   Row_Pos319 := No_Token_Index;
   goto Exit_Row319_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row319_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos319 /= No_Token_Index then

   Transform_Res241 := Allocate_Null_Record_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res241,
      Kind => Ada_Null_Record_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos319 = Pos
                            then No_Token_Index
                            else Row_Pos319 - 1));

      Initialize_Fields_For_Null_Record_Def
        (Self => Transform_Res241, Base_Record_Def_F_Components => Transform_Res240);

         if Transform_Res240 /= null and then Is_Incomplete (Transform_Res240) then
            Transform_Res241.Last_Attempted_Child := 0;
         elsif Transform_Res240 /= null and then not Is_Ghost (Transform_Res240) then
            Transform_Res241.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos319 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags241);
end if;

--  End transform_code

    if Row_Pos319 /= No_Token_Index then
        Or_Pos108 := Row_Pos319;
        Or_Res108 := Transform_Res241;
        goto Exit_Or110;
    end if;
<<Exit_Or110>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Record_Def_Or_Parse0_Memo,
      Or_Pos108 /= No_Token_Index,
      Or_Res108,
      Pos,
      Or_Pos108);


   Parser.Current_Pos := Or_Pos108;

   Exit_Call (Parser, Call_Depth);
   return Or_Res108;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Record_Def_Or_Parse0;

   


function Record_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Record_Type_Def
is
   use Bare_Record_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos321 :
            Token_Index
               := No_Token_Index;
      Token_Pos497 :
            Token_Index
               := No_Token_Index;
      Token_Res497 :
            Token_Index
               := No_Token_Index;
      Opt_Res24 :
            Bare_Abstract_Node
               := No_Bare_Ada_Node;
      Token_Pos498 :
            Token_Index
               := No_Token_Index;
      Token_Res498 :
            Token_Index
               := No_Token_Index;
      Opt_Res25 :
            Bare_Tagged_Node
               := No_Bare_Ada_Node;
      Token_Pos499 :
            Token_Index
               := No_Token_Index;
      Token_Res499 :
            Token_Index
               := No_Token_Index;
      Opt_Res26 :
            Bare_Limited_Node
               := No_Bare_Ada_Node;
      Defer_Pos505 :
            Token_Index
               := No_Token_Index;
      Defer_Res505 :
            Bare_Base_Record_Def
               := No_Bare_Ada_Node;
      Transform_Res242 :
            Bare_Record_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags242 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Record_Type_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res242 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res242;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res242;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags242 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos321 := Pos;



--  Start opt_code












--  Start tok_code

Token_Res497 := Row_Pos321;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res497));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos497 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos321 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos321,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos497 := Row_Pos321 + 1;
   end if;
end;

--  End tok_code


if Token_Pos497 = No_Token_Index then

         Opt_Res24 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res24,
            Kind              => Ada_Abstract_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos321,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos497 := Row_Pos321;


else

      Opt_Res24 := Allocate_Abstract_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res24,
         Kind              => Ada_Abstract_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos321,
         Token_End_Index   => Token_Pos497 - 1);

end if;

--  End opt_code




if Token_Pos497 /= No_Token_Index then

   Row_Pos321 := Token_Pos497;

else
   Row_Pos321 := No_Token_Index;
   goto Exit_Row321_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res498 := Row_Pos321;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res498));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Tagged)
   then
       Token_Pos498 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos321 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos321,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos498 := Row_Pos321 + 1;
   end if;
end;

--  End tok_code


if Token_Pos498 = No_Token_Index then

         Opt_Res25 := Allocate_Tagged_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res25,
            Kind              => Ada_Tagged_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos321,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos498 := Row_Pos321;


else

      Opt_Res25 := Allocate_Tagged_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res25,
         Kind              => Ada_Tagged_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos321,
         Token_End_Index   => Token_Pos498 - 1);

end if;

--  End opt_code




if Token_Pos498 /= No_Token_Index then

   Row_Pos321 := Token_Pos498;

else
   Row_Pos321 := No_Token_Index;
   goto Exit_Row321_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res499 := Row_Pos321;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res499));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Limited)
   then
       Token_Pos499 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos321 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos321,
             Expected_Token_Id => Ada_Limited,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos499 := Row_Pos321 + 1;
   end if;
end;

--  End tok_code


if Token_Pos499 = No_Token_Index then

         Opt_Res26 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res26,
            Kind              => Ada_Limited_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos321,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos499 := Row_Pos321;


else

      Opt_Res26 := Allocate_Limited_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res26,
         Kind              => Ada_Limited_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos321,
         Token_End_Index   => Token_Pos499 - 1);

end if;

--  End opt_code




if Token_Pos499 /= No_Token_Index then

   Row_Pos321 := Token_Pos499;

else
   Row_Pos321 := No_Token_Index;
   goto Exit_Row321_0;

end if;


Defer_Res505 :=
   Record_Def_Or_Parse0 (Parser, Row_Pos321);
Defer_Pos505 := Parser.Current_Pos;




if Defer_Pos505 /= No_Token_Index then

   Row_Pos321 := Defer_Pos505;

else
   Row_Pos321 := No_Token_Index;
   goto Exit_Row321_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row321_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos321 /= No_Token_Index then

   Transform_Res242 := Allocate_Record_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res242,
      Kind => Ada_Record_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos321 = Pos
                            then No_Token_Index
                            else Row_Pos321 - 1));

      Initialize_Fields_For_Record_Type_Def
        (Self => Transform_Res242, Record_Type_Def_F_Has_Abstract => Opt_Res24, Record_Type_Def_F_Has_Tagged => Opt_Res25, Record_Type_Def_F_Has_Limited => Opt_Res26, Record_Type_Def_F_Record_Def => Defer_Res505);

         if Opt_Res24 /= null and then Is_Incomplete (Opt_Res24) then
            Transform_Res242.Last_Attempted_Child := 0;
         elsif Opt_Res24 /= null and then not Is_Ghost (Opt_Res24) then
            Transform_Res242.Last_Attempted_Child := -1;
         end if;
         if Opt_Res25 /= null and then Is_Incomplete (Opt_Res25) then
            Transform_Res242.Last_Attempted_Child := 0;
         elsif Opt_Res25 /= null and then not Is_Ghost (Opt_Res25) then
            Transform_Res242.Last_Attempted_Child := -1;
         end if;
         if Opt_Res26 /= null and then Is_Incomplete (Opt_Res26) then
            Transform_Res242.Last_Attempted_Child := 0;
         elsif Opt_Res26 /= null and then not Is_Ghost (Opt_Res26) then
            Transform_Res242.Last_Attempted_Child := -1;
         end if;
         if Defer_Res505 /= null and then Is_Incomplete (Defer_Res505) then
            Transform_Res242.Last_Attempted_Child := 0;
         elsif Defer_Res505 /= null and then not Is_Ghost (Defer_Res505) then
            Transform_Res242.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos321 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags242);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Record_Type_Def_Transform_Parse0_Memo,
      Row_Pos321 /= No_Token_Index,
      Transform_Res242,
      Pos,
      Row_Pos321);


   Parser.Current_Pos := Row_Pos321;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res242;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Record_Type_Def_Transform_Parse0;

   


function Recov_Decl_Part_Dont_Skip_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Declarative_Part
is
   use Bare_Declarative_Part_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos506 :
            Token_Index
               := No_Token_Index;
      Defer_Res506 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Recov_Decl_Part_Dont_Skip_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Defer_Res506 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Defer_Res506;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Defer_Res506;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Recov_Decl_Part0_Extract_Parse0'Access);
        
Defer_Res506 :=
   Decl_Part_Transform_Parse0 (Parser, Pos);
Defer_Pos506 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        

   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Recov_Decl_Part_Dont_Skip_Parse0_Memo,
      Defer_Pos506 /= No_Token_Index,
      Defer_Res506,
      Pos,
      Defer_Pos506);


   Parser.Current_Pos := Defer_Pos506;

   Exit_Call (Parser, Call_Depth);
   return Defer_Res506;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Recov_Decl_Part_Dont_Skip_Parse0;

   


function Regular_Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate
is
   use Bare_Base_Aggregate_Memos;

   Call_Depth : aliased Natural;

      Nobt42 :
            Boolean
               := False;
      Nobt43 :
            Boolean
               := False;
      Row_Pos322 :
            Token_Index
               := No_Token_Index;
      Token_Pos500 :
            Token_Index
               := No_Token_Index;
      Token_Res500 :
            Token_Index
               := No_Token_Index;
      Row_Pos323 :
            Token_Index
               := No_Token_Index;
      Defer_Pos507 :
            Token_Index
               := No_Token_Index;
      Defer_Res507 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos501 :
            Token_Index
               := No_Token_Index;
      Token_Res501 :
            Token_Index
               := No_Token_Index;
      Token_Pos502 :
            Token_Index
               := No_Token_Index;
      Token_Res502 :
            Token_Index
               := No_Token_Index;
      Token_Pos503 :
            Token_Index
               := No_Token_Index;
      Token_Res503 :
            Token_Index
               := No_Token_Index;
      Null_Res37 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos504 :
            Token_Index
               := No_Token_Index;
      Token_Res504 :
            Token_Index
               := No_Token_Index;
      Transform_Res243 :
            Bare_Null_Record_Aggregate
               := No_Bare_Ada_Node;
      Transform_Diags243 :
            Ada.Containers.Count_Type;
      Row_Pos324 :
            Token_Index
               := No_Token_Index;
      Token_Pos505 :
            Token_Index
               := No_Token_Index;
      Token_Res505 :
            Token_Index
               := No_Token_Index;
      Defer_Pos508 :
            Token_Index
               := No_Token_Index;
      Defer_Res508 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos506 :
            Token_Index
               := No_Token_Index;
      Token_Res506 :
            Token_Index
               := No_Token_Index;
      Token_Pos507 :
            Token_Index
               := No_Token_Index;
      Token_Res507 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos44 :
            Token_Index
               := No_Token_Index;
      Tmp_List44 :
            Free_Parse_List;
      Defer_Pos509 :
            Token_Index
               := No_Token_Index;
      Defer_Res509 :
            Bare_Basic_Assoc
               := No_Bare_Ada_Node;
      Token_Pos508 :
            Token_Index
               := No_Token_Index;
      Token_Res508 :
            Token_Index
               := No_Token_Index;
      List_Pos44 :
            Token_Index
               := No_Token_Index;
      List_Res44 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos509 :
            Token_Index
               := No_Token_Index;
      Token_Res509 :
            Token_Index
               := No_Token_Index;
      Row_Progress37 :
            Integer
               := 0;
      Transform_Res244 :
            Bare_Delta_Aggregate
               := No_Bare_Ada_Node;
      Transform_Has_Failed37 :
            Boolean
               := False;
      Transform_Diags244 :
            Ada.Containers.Count_Type;
      Row_Pos325 :
            Token_Index
               := No_Token_Index;
      Token_Pos510 :
            Token_Index
               := No_Token_Index;
      Token_Res510 :
            Token_Index
               := No_Token_Index;
      Row_Pos326 :
            Token_Index
               := No_Token_Index;
      Defer_Pos510 :
            Token_Index
               := No_Token_Index;
      Defer_Res510 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos511 :
            Token_Index
               := No_Token_Index;
      Token_Res511 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos45 :
            Token_Index
               := No_Token_Index;
      Tmp_List45 :
            Free_Parse_List;
      Defer_Pos511 :
            Token_Index
               := No_Token_Index;
      Defer_Res511 :
            Bare_Basic_Assoc
               := No_Bare_Ada_Node;
      Token_Pos512 :
            Token_Index
               := No_Token_Index;
      Token_Res512 :
            Token_Index
               := No_Token_Index;
      List_Pos45 :
            Token_Index
               := No_Token_Index;
      List_Res45 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos513 :
            Token_Index
               := No_Token_Index;
      Token_Res513 :
            Token_Index
               := No_Token_Index;
      Row_Progress38 :
            Integer
               := 0;
      Transform_Res245 :
            Bare_Aggregate
               := No_Bare_Ada_Node;
      Transform_Has_Failed38 :
            Boolean
               := False;
      Transform_Diags245 :
            Ada.Containers.Count_Type;
      Or_Pos109 :
            Token_Index
               := No_Token_Index;
      Or_Res109 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Regular_Aggregate_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res109 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res109;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res109;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos109 := No_Token_Index;
Or_Res109 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags243 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos322 := Pos;



--  Start tok_code

Token_Res500 := Row_Pos322;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res500));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos500 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos322 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos322,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos500 := Row_Pos322 + 1;
   end if;
end;

--  End tok_code




if Token_Pos500 /= No_Token_Index then

   Row_Pos322 := Token_Pos500;

else
   Row_Pos322 := No_Token_Index;
   goto Exit_Row322_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos323 := Row_Pos322;



Defer_Res507 :=
   Expr_Or_Parse0 (Parser, Row_Pos323);
Defer_Pos507 := Parser.Current_Pos;




if Defer_Pos507 /= No_Token_Index then

   Row_Pos323 := Defer_Pos507;

else
   Row_Pos323 := No_Token_Index;
   goto Exit_Row323_0;

end if;


--  Start tok_code

Token_Res501 := Row_Pos323;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res501));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos501 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos323 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos323,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos501 := Row_Pos323 + 1;
   end if;
end;

--  End tok_code




if Token_Pos501 /= No_Token_Index then

   Row_Pos323 := Token_Pos501;

else
   Row_Pos323 := No_Token_Index;
   goto Exit_Row323_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row323_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos323 = No_Token_Index then

         
   Defer_Res507 := No_Bare_Ada_Node;



       
   Row_Pos323 := Row_Pos322;



end if;

--  End opt_code




if Row_Pos323 /= No_Token_Index then

   Row_Pos322 := Row_Pos323;

else
   Row_Pos322 := No_Token_Index;
   goto Exit_Row322_0;

end if;


--  Start tok_code

Token_Res502 := Row_Pos322;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res502));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos502 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos322 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos322,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos502 := Row_Pos322 + 1;
   end if;
end;

--  End tok_code




if Token_Pos502 /= No_Token_Index then

   Row_Pos322 := Token_Pos502;

else
   Row_Pos322 := No_Token_Index;
   goto Exit_Row322_0;

end if;


--  Start tok_code

Token_Res503 := Row_Pos322;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res503));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Record)
   then
       Token_Pos503 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos322 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos322,
             Expected_Token_Id => Ada_Record,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos503 := Row_Pos322 + 1;
   end if;
end;

--  End tok_code




if Token_Pos503 /= No_Token_Index then

   Row_Pos322 := Token_Pos503;

else
   Row_Pos322 := No_Token_Index;
   goto Exit_Row322_0;

end if;


   Null_Res37 := Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res37,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos322, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res37,
      Parser => Parser,
      Count  => 0);





if Row_Pos322 /= No_Token_Index then

   Row_Pos322 := Row_Pos322;

else
   Row_Pos322 := No_Token_Index;
   goto Exit_Row322_0;

end if;


--  Start tok_code

Token_Res504 := Row_Pos322;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res504));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos504 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos322 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos322,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos504 := Row_Pos322 + 1;
   end if;
end;

--  End tok_code




if Token_Pos504 /= No_Token_Index then

   Row_Pos322 := Token_Pos504;

else
   Row_Pos322 := No_Token_Index;
   goto Exit_Row322_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row322_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos322 /= No_Token_Index then

   Transform_Res243 := Allocate_Null_Record_Aggregate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res243,
      Kind => Ada_Null_Record_Aggregate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos322 = Pos
                            then No_Token_Index
                            else Row_Pos322 - 1));

      Initialize_Fields_For_Null_Record_Aggregate
        (Self => Transform_Res243, Base_Aggregate_F_Ancestor_Expr => Defer_Res507, Base_Aggregate_F_Assocs => Null_Res37);

         if Defer_Res507 /= null and then Is_Incomplete (Defer_Res507) then
            Transform_Res243.Last_Attempted_Child := 0;
         elsif Defer_Res507 /= null and then not Is_Ghost (Defer_Res507) then
            Transform_Res243.Last_Attempted_Child := -1;
         end if;
         if Null_Res37 /= null and then Is_Incomplete (Null_Res37) then
            Transform_Res243.Last_Attempted_Child := 0;
         elsif Null_Res37 /= null and then not Is_Ghost (Null_Res37) then
            Transform_Res243.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos322 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags243);
end if;

--  End transform_code

    if Row_Pos322 /= No_Token_Index then
        Or_Pos109 := Row_Pos322;
        Or_Res109 := Transform_Res243;
        goto Exit_Or111;
    end if;
    
--  Start transform_code

Transform_Diags244 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos324 := Pos;



--  Start tok_code

Token_Res505 := Row_Pos324;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res505));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos505 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos324 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos324,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos505 := Row_Pos324 + 1;
   end if;
end;

--  End tok_code



Row_Progress37 := 1;

if Token_Pos505 /= No_Token_Index then

   Row_Pos324 := Token_Pos505;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;


Defer_Res508 :=
   Expr_Or_Parse0 (Parser, Row_Pos324);
Defer_Pos508 := Parser.Current_Pos;



Row_Progress37 := 2;

if Defer_Pos508 /= No_Token_Index then

   Row_Pos324 := Defer_Pos508;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;


--  Start tok_code

Token_Res506 := Row_Pos324;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res506));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos506 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos324 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos324,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos506 := Row_Pos324 + 1;
   end if;
end;

--  End tok_code



Row_Progress37 := 3;

if Token_Pos506 /= No_Token_Index then

   Row_Pos324 := Token_Pos506;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;


--  Start tok_code

Token_Res507 := Row_Pos324;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res507));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Delta)
   then
       Token_Pos507 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos324 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos324,
             Expected_Token_Id => Ada_Delta,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos507 := Row_Pos324 + 1;
   end if;
end;

--  End tok_code



Row_Progress37 := 4;

if Token_Pos507 /= No_Token_Index then

   Row_Pos324 := Token_Pos507;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;

Nobt42 := True;

   Nobt42 := Nobt42;

Row_Progress37 := 5;

if Row_Pos324 /= No_Token_Index then

   Row_Pos324 := Row_Pos324;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;


--  Start list_code

    List_Pos44 := No_Token_Index;



Lst_Cpos44 := Row_Pos324;
Tmp_List44 := Get_Parse_List (Parser);

loop
   
Defer_Res509 :=
   Aggregate_Assoc_Or_Parse1 (Parser, Lst_Cpos44);
Defer_Pos509 := Parser.Current_Pos;


   exit when Defer_Pos509 = No_Token_Index;

   List_Pos44 := Defer_Pos509;
   Lst_Cpos44 := List_Pos44;

   Tmp_List44.Nodes.Append (Defer_Res509);

      
--  Start tok_code

Token_Res508 := Lst_Cpos44;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res508));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos508 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos44 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos44,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos508 := Lst_Cpos44 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos508 /= No_Token_Index then
          Lst_Cpos44 := Token_Pos508;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List44.Nodes.Length;
begin
   List_Res44 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos324;
      Token_End := (if Lst_Cpos44 = Row_Pos324
                    then Row_Pos324
                    else Lst_Cpos44 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos324, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res44,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res44,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List44.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res44.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List44);

--  End list_code



Row_Progress37 := 6;

if List_Pos44 /= No_Token_Index then

   Row_Pos324 := List_Pos44;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;


--  Start tok_code

Token_Res509 := Row_Pos324;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res509));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos509 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos324 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos324,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos509 := Row_Pos324 + 1;
   end if;
end;

--  End tok_code



Row_Progress37 := 7;

if Token_Pos509 /= No_Token_Index then

   Row_Pos324 := Token_Pos509;

else
   Row_Pos324 := No_Token_Index;
   goto Exit_Row324_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row324_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos324 = No_Token_Index and then Nobt42 then

   Row_Pos324 := Parser.Last_Fail.Pos;

   Transform_Has_Failed37 := True;
end if;

if Row_Pos324 /= No_Token_Index then

   Transform_Res244 := Allocate_Delta_Aggregate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res244,
      Kind => Ada_Delta_Aggregate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos324 = Pos
                            then No_Token_Index
                            else Row_Pos324 - 1));

      Initialize_Fields_For_Delta_Aggregate
        (Self => Transform_Res244, Base_Aggregate_F_Ancestor_Expr => Defer_Res508, Base_Aggregate_F_Assocs => List_Res44);

         if Defer_Res508 /= null and then Is_Incomplete (Defer_Res508) then
            Transform_Res244.Last_Attempted_Child := 0;
         elsif Defer_Res508 /= null and then not Is_Ghost (Defer_Res508) then
            Transform_Res244.Last_Attempted_Child := -1;
         end if;
         if List_Res44 /= null and then Is_Incomplete (List_Res44) then
            Transform_Res244.Last_Attempted_Child := 0;
         elsif List_Res44 /= null and then not Is_Ghost (List_Res44) then
            Transform_Res244.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed37 then
      Transform_Res244.Last_Attempted_Child :=
         Row_Progress37;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <regular_aggregate>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos324 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags244);
end if;

--  End transform_code

    if Row_Pos324 /= No_Token_Index then
        Or_Pos109 := Row_Pos324;
        Or_Res109 := Transform_Res244;
        goto Exit_Or111;
    end if;
    
--  Start transform_code

Transform_Diags245 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos325 := Pos;



--  Start tok_code

Token_Res510 := Row_Pos325;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res510));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos510 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos325 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos325,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos510 := Row_Pos325 + 1;
   end if;
end;

--  End tok_code



Row_Progress38 := 1;

if Token_Pos510 /= No_Token_Index then

   Row_Pos325 := Token_Pos510;

else
   Row_Pos325 := No_Token_Index;
   goto Exit_Row325_0;

end if;

Nobt43 := True;

   Nobt43 := Nobt43;

Row_Progress38 := 2;

if Row_Pos325 /= No_Token_Index then

   Row_Pos325 := Row_Pos325;

else
   Row_Pos325 := No_Token_Index;
   goto Exit_Row325_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos326 := Row_Pos325;



Defer_Res510 :=
   Expr_Or_Parse0 (Parser, Row_Pos326);
Defer_Pos510 := Parser.Current_Pos;




if Defer_Pos510 /= No_Token_Index then

   Row_Pos326 := Defer_Pos510;

else
   Row_Pos326 := No_Token_Index;
   goto Exit_Row326_0;

end if;


--  Start tok_code

Token_Res511 := Row_Pos326;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res511));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos511 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos326 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos326,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos511 := Row_Pos326 + 1;
   end if;
end;

--  End tok_code




if Token_Pos511 /= No_Token_Index then

   Row_Pos326 := Token_Pos511;

else
   Row_Pos326 := No_Token_Index;
   goto Exit_Row326_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row326_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos326 = No_Token_Index then

         
   Defer_Res510 := No_Bare_Ada_Node;



       
   Row_Pos326 := Row_Pos325;



end if;

--  End opt_code



Row_Progress38 := 3;

if Row_Pos326 /= No_Token_Index then

   Row_Pos325 := Row_Pos326;

else
   Row_Pos325 := No_Token_Index;
   goto Exit_Row325_0;

end if;


--  Start list_code

    List_Pos45 := No_Token_Index;



Lst_Cpos45 := Row_Pos325;
Tmp_List45 := Get_Parse_List (Parser);

loop
   
Defer_Res511 :=
   Aggregate_Assoc_Or_Parse1 (Parser, Lst_Cpos45);
Defer_Pos511 := Parser.Current_Pos;


   exit when Defer_Pos511 = No_Token_Index;

   List_Pos45 := Defer_Pos511;
   Lst_Cpos45 := List_Pos45;

   Tmp_List45.Nodes.Append (Defer_Res511);

      
--  Start tok_code

Token_Res512 := Lst_Cpos45;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res512));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos512 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos45 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos45,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos512 := Lst_Cpos45 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos512 /= No_Token_Index then
          Lst_Cpos45 := Token_Pos512;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List45.Nodes.Length;
begin
   List_Res45 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos325;
      Token_End := (if Lst_Cpos45 = Row_Pos325
                    then Row_Pos325
                    else Lst_Cpos45 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos325, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res45,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res45,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List45.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res45.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List45);

--  End list_code



Row_Progress38 := 4;

if List_Pos45 /= No_Token_Index then

   Row_Pos325 := List_Pos45;

else
   Row_Pos325 := No_Token_Index;
   goto Exit_Row325_0;

end if;


--  Start tok_code

Token_Res513 := Row_Pos325;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res513));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos513 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos325 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos325,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos513 := Row_Pos325 + 1;
   end if;
end;

--  End tok_code



Row_Progress38 := 5;

if Token_Pos513 /= No_Token_Index then

   Row_Pos325 := Token_Pos513;

else
   Row_Pos325 := No_Token_Index;
   goto Exit_Row325_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row325_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos325 = No_Token_Index and then Nobt43 then

   Row_Pos325 := Parser.Last_Fail.Pos;

   Transform_Has_Failed38 := True;
end if;

if Row_Pos325 /= No_Token_Index then

   Transform_Res245 := Allocate_Aggregate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res245,
      Kind => Ada_Aggregate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos325 = Pos
                            then No_Token_Index
                            else Row_Pos325 - 1));

      Initialize_Fields_For_Aggregate
        (Self => Transform_Res245, Base_Aggregate_F_Ancestor_Expr => Defer_Res510, Base_Aggregate_F_Assocs => List_Res45);

         if Defer_Res510 /= null and then Is_Incomplete (Defer_Res510) then
            Transform_Res245.Last_Attempted_Child := 0;
         elsif Defer_Res510 /= null and then not Is_Ghost (Defer_Res510) then
            Transform_Res245.Last_Attempted_Child := -1;
         end if;
         if List_Res45 /= null and then Is_Incomplete (List_Res45) then
            Transform_Res245.Last_Attempted_Child := 0;
         elsif List_Res45 /= null and then not Is_Ghost (List_Res45) then
            Transform_Res245.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed38 then
      Transform_Res245.Last_Attempted_Child :=
         Row_Progress38;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <regular_aggregate>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos325 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags245);
end if;

--  End transform_code

    if Row_Pos325 /= No_Token_Index then
        Or_Pos109 := Row_Pos325;
        Or_Res109 := Transform_Res245;
        goto Exit_Or111;
    end if;
<<Exit_Or111>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Regular_Aggregate_Or_Parse0_Memo,
      Or_Pos109 /= No_Token_Index,
      Or_Res109,
      Pos,
      Or_Pos109);


   Parser.Current_Pos := Or_Pos109;

   Exit_Call (Parser, Call_Depth);
   return Or_Res109;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Regular_Aggregate_Or_Parse0;

   


function Rel_Op_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Op
is
   use Bare_Op_Memos;

   Call_Depth : aliased Natural;

      Row_Pos327 :
            Token_Index
               := No_Token_Index;
      Token_Pos514 :
            Token_Index
               := No_Token_Index;
      Token_Res514 :
            Token_Index
               := No_Token_Index;
      Token_Pos515 :
            Token_Index
               := No_Token_Index;
      Token_Res515 :
            Token_Index
               := No_Token_Index;
      Transform_Res246 :
            Bare_Op_Not_In
               := No_Bare_Ada_Node;
      Transform_Diags246 :
            Ada.Containers.Count_Type;
      Row_Pos328 :
            Token_Index
               := No_Token_Index;
      Token_Pos516 :
            Token_Index
               := No_Token_Index;
      Token_Res516 :
            Token_Index
               := No_Token_Index;
      Transform_Res247 :
            Bare_Op_In
               := No_Bare_Ada_Node;
      Transform_Diags247 :
            Ada.Containers.Count_Type;
      Or_Pos110 :
            Token_Index
               := No_Token_Index;
      Or_Res110 :
            Bare_Op
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Rel_Op_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res110 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res110;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res110;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos110 := No_Token_Index;
Or_Res110 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags246 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos327 := Pos;



--  Start tok_code

Token_Res514 := Row_Pos327;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res514));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos514 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos327 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos327,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos514 := Row_Pos327 + 1;
   end if;
end;

--  End tok_code




if Token_Pos514 /= No_Token_Index then

   Row_Pos327 := Token_Pos514;

else
   Row_Pos327 := No_Token_Index;
   goto Exit_Row327_0;

end if;


--  Start tok_code

Token_Res515 := Row_Pos327;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res515));
begin
   if
      T.Kind /= From_Token_Kind (Ada_In)
   then
       Token_Pos515 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos327 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos327,
             Expected_Token_Id => Ada_In,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos515 := Row_Pos327 + 1;
   end if;
end;

--  End tok_code




if Token_Pos515 /= No_Token_Index then

   Row_Pos327 := Token_Pos515;

else
   Row_Pos327 := No_Token_Index;
   goto Exit_Row327_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row327_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos327 /= No_Token_Index then

   Transform_Res246 := Allocate_Op_Not_In (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res246,
      Kind => Ada_Op_Not_In,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos327 = Pos
                            then No_Token_Index
                            else Row_Pos327 - 1));

      Initialize_Fields_For_Op_Not_In
        (Self => Transform_Res246);



elsif Row_Pos327 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags246);
end if;

--  End transform_code

    if Row_Pos327 /= No_Token_Index then
        Or_Pos110 := Row_Pos327;
        Or_Res110 := Transform_Res246;
        goto Exit_Or112;
    end if;
    
--  Start transform_code

Transform_Diags247 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos328 := Pos;



--  Start tok_code

Token_Res516 := Row_Pos328;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res516));
begin
   if
      T.Kind /= From_Token_Kind (Ada_In)
   then
       Token_Pos516 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos328 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos328,
             Expected_Token_Id => Ada_In,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos516 := Row_Pos328 + 1;
   end if;
end;

--  End tok_code




if Token_Pos516 /= No_Token_Index then

   Row_Pos328 := Token_Pos516;

else
   Row_Pos328 := No_Token_Index;
   goto Exit_Row328_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row328_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos328 /= No_Token_Index then

   Transform_Res247 := Allocate_Op_In (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res247,
      Kind => Ada_Op_In,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos328 = Pos
                            then No_Token_Index
                            else Row_Pos328 - 1));

      Initialize_Fields_For_Op_In
        (Self => Transform_Res247);



elsif Row_Pos328 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags247);
end if;

--  End transform_code

    if Row_Pos328 /= No_Token_Index then
        Or_Pos110 := Row_Pos328;
        Or_Res110 := Transform_Res247;
        goto Exit_Or112;
    end if;
<<Exit_Or112>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Rel_Op_Or_Parse0_Memo,
      Or_Pos110 /= No_Token_Index,
      Or_Res110,
      Pos,
      Or_Pos110);


   Parser.Current_Pos := Or_Pos110;

   Exit_Call (Parser, Call_Depth);
   return Or_Res110;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Rel_Op_Or_Parse0;

   


function Relation_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt44 :
            Boolean
               := False;
      Row_Pos329 :
            Token_Index
               := No_Token_Index;
      Defer_Pos512 :
            Token_Index
               := No_Token_Index;
      Defer_Res512 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Pos330 :
            Token_Index
               := No_Token_Index;
      Token_Pos517 :
            Token_Index
               := No_Token_Index;
      Token_Res517 :
            Token_Index
               := No_Token_Index;
      Transform_Res248 :
            Bare_Op_Eq
               := No_Bare_Ada_Node;
      Transform_Diags248 :
            Ada.Containers.Count_Type;
      Row_Pos331 :
            Token_Index
               := No_Token_Index;
      Token_Pos518 :
            Token_Index
               := No_Token_Index;
      Token_Res518 :
            Token_Index
               := No_Token_Index;
      Transform_Res249 :
            Bare_Op_Neq
               := No_Bare_Ada_Node;
      Transform_Diags249 :
            Ada.Containers.Count_Type;
      Row_Pos332 :
            Token_Index
               := No_Token_Index;
      Token_Pos519 :
            Token_Index
               := No_Token_Index;
      Token_Res519 :
            Token_Index
               := No_Token_Index;
      Transform_Res250 :
            Bare_Op_Lt
               := No_Bare_Ada_Node;
      Transform_Diags250 :
            Ada.Containers.Count_Type;
      Row_Pos333 :
            Token_Index
               := No_Token_Index;
      Token_Pos520 :
            Token_Index
               := No_Token_Index;
      Token_Res520 :
            Token_Index
               := No_Token_Index;
      Transform_Res251 :
            Bare_Op_Lte
               := No_Bare_Ada_Node;
      Transform_Diags251 :
            Ada.Containers.Count_Type;
      Row_Pos334 :
            Token_Index
               := No_Token_Index;
      Token_Pos521 :
            Token_Index
               := No_Token_Index;
      Token_Res521 :
            Token_Index
               := No_Token_Index;
      Transform_Res252 :
            Bare_Op_Gt
               := No_Bare_Ada_Node;
      Transform_Diags252 :
            Ada.Containers.Count_Type;
      Row_Pos335 :
            Token_Index
               := No_Token_Index;
      Token_Pos522 :
            Token_Index
               := No_Token_Index;
      Token_Res522 :
            Token_Index
               := No_Token_Index;
      Transform_Res253 :
            Bare_Op_Gte
               := No_Bare_Ada_Node;
      Transform_Diags253 :
            Ada.Containers.Count_Type;
      Or_Pos111 :
            Token_Index
               := No_Token_Index;
      Or_Res111 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos513 :
            Token_Index
               := No_Token_Index;
      Defer_Res513 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress39 :
            Integer
               := 0;
      Transform_Res254 :
            Bare_Relation_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed39 :
            Boolean
               := False;
      Transform_Diags254 :
            Ada.Containers.Count_Type;
      Row_Pos336 :
            Token_Index
               := No_Token_Index;
      Defer_Pos514 :
            Token_Index
               := No_Token_Index;
      Defer_Res514 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos515 :
            Token_Index
               := No_Token_Index;
      Defer_Res515 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos516 :
            Token_Index
               := No_Token_Index;
      Defer_Res516 :
            Bare_Expr_Alternatives_List
               := No_Bare_Ada_Node;
      Transform_Res255 :
            Bare_Membership_Expr
               := No_Bare_Ada_Node;
      Transform_Diags255 :
            Ada.Containers.Count_Type;
      Defer_Pos517 :
            Token_Index
               := No_Token_Index;
      Defer_Res517 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos112 :
            Token_Index
               := No_Token_Index;
      Or_Res112 :
            Bare_Expr
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Relation_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res112 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res112;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res112;
   end if;

       Set (Parser.Private_Part.Relation_Or_Parse1_Memo, False, Or_Res112, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt44 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos112 := No_Token_Index;
Or_Res112 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags254 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos329 := Pos;



Defer_Res512 :=
   Relation_Or_Parse1 (Parser, Row_Pos329);
Defer_Pos512 := Parser.Current_Pos;



Row_Progress39 := 1;

if Defer_Pos512 /= No_Token_Index then

   Row_Pos329 := Defer_Pos512;

else
   Row_Pos329 := No_Token_Index;
   goto Exit_Row329_0;

end if;


--  Start or_code

Or_Pos111 := No_Token_Index;
Or_Res111 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags248 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos330 := Row_Pos329;



--  Start tok_code

Token_Res517 := Row_Pos330;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res517));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Equal)
   then
       Token_Pos517 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos330 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos330,
             Expected_Token_Id => Ada_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos517 := Row_Pos330 + 1;
   end if;
end;

--  End tok_code




if Token_Pos517 /= No_Token_Index then

   Row_Pos330 := Token_Pos517;

else
   Row_Pos330 := No_Token_Index;
   goto Exit_Row330_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row330_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos330 /= No_Token_Index then

   Transform_Res248 := Allocate_Op_Eq (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res248,
      Kind => Ada_Op_Eq,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos329,
      Token_End_Index   => (if Row_Pos330 = Row_Pos329
                            then No_Token_Index
                            else Row_Pos330 - 1));

      Initialize_Fields_For_Op_Eq
        (Self => Transform_Res248);



elsif Row_Pos330 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags248);
end if;

--  End transform_code

    if Row_Pos330 /= No_Token_Index then
        Or_Pos111 := Row_Pos330;
        Or_Res111 := Transform_Res248;
        goto Exit_Or114;
    end if;
    
--  Start transform_code

Transform_Diags249 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos331 := Row_Pos329;



--  Start tok_code

Token_Res518 := Row_Pos331;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res518));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Notequal)
   then
       Token_Pos518 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos331 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos331,
             Expected_Token_Id => Ada_Notequal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos518 := Row_Pos331 + 1;
   end if;
end;

--  End tok_code




if Token_Pos518 /= No_Token_Index then

   Row_Pos331 := Token_Pos518;

else
   Row_Pos331 := No_Token_Index;
   goto Exit_Row331_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row331_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos331 /= No_Token_Index then

   Transform_Res249 := Allocate_Op_Neq (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res249,
      Kind => Ada_Op_Neq,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos329,
      Token_End_Index   => (if Row_Pos331 = Row_Pos329
                            then No_Token_Index
                            else Row_Pos331 - 1));

      Initialize_Fields_For_Op_Neq
        (Self => Transform_Res249);



elsif Row_Pos331 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags249);
end if;

--  End transform_code

    if Row_Pos331 /= No_Token_Index then
        Or_Pos111 := Row_Pos331;
        Or_Res111 := Transform_Res249;
        goto Exit_Or114;
    end if;
    
--  Start transform_code

Transform_Diags250 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos332 := Row_Pos329;



--  Start tok_code

Token_Res519 := Row_Pos332;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res519));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Lt)
   then
       Token_Pos519 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos332 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos332,
             Expected_Token_Id => Ada_Lt,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos519 := Row_Pos332 + 1;
   end if;
end;

--  End tok_code




if Token_Pos519 /= No_Token_Index then

   Row_Pos332 := Token_Pos519;

else
   Row_Pos332 := No_Token_Index;
   goto Exit_Row332_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row332_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos332 /= No_Token_Index then

   Transform_Res250 := Allocate_Op_Lt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res250,
      Kind => Ada_Op_Lt,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos329,
      Token_End_Index   => (if Row_Pos332 = Row_Pos329
                            then No_Token_Index
                            else Row_Pos332 - 1));

      Initialize_Fields_For_Op_Lt
        (Self => Transform_Res250);



elsif Row_Pos332 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags250);
end if;

--  End transform_code

    if Row_Pos332 /= No_Token_Index then
        Or_Pos111 := Row_Pos332;
        Or_Res111 := Transform_Res250;
        goto Exit_Or114;
    end if;
    
--  Start transform_code

Transform_Diags251 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos333 := Row_Pos329;



--  Start tok_code

Token_Res520 := Row_Pos333;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res520));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Lte)
   then
       Token_Pos520 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos333 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos333,
             Expected_Token_Id => Ada_Lte,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos520 := Row_Pos333 + 1;
   end if;
end;

--  End tok_code




if Token_Pos520 /= No_Token_Index then

   Row_Pos333 := Token_Pos520;

else
   Row_Pos333 := No_Token_Index;
   goto Exit_Row333_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row333_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos333 /= No_Token_Index then

   Transform_Res251 := Allocate_Op_Lte (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res251,
      Kind => Ada_Op_Lte,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos329,
      Token_End_Index   => (if Row_Pos333 = Row_Pos329
                            then No_Token_Index
                            else Row_Pos333 - 1));

      Initialize_Fields_For_Op_Lte
        (Self => Transform_Res251);



elsif Row_Pos333 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags251);
end if;

--  End transform_code

    if Row_Pos333 /= No_Token_Index then
        Or_Pos111 := Row_Pos333;
        Or_Res111 := Transform_Res251;
        goto Exit_Or114;
    end if;
    
--  Start transform_code

Transform_Diags252 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos334 := Row_Pos329;



--  Start tok_code

Token_Res521 := Row_Pos334;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res521));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Gt)
   then
       Token_Pos521 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos334 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos334,
             Expected_Token_Id => Ada_Gt,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos521 := Row_Pos334 + 1;
   end if;
end;

--  End tok_code




if Token_Pos521 /= No_Token_Index then

   Row_Pos334 := Token_Pos521;

else
   Row_Pos334 := No_Token_Index;
   goto Exit_Row334_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row334_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos334 /= No_Token_Index then

   Transform_Res252 := Allocate_Op_Gt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res252,
      Kind => Ada_Op_Gt,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos329,
      Token_End_Index   => (if Row_Pos334 = Row_Pos329
                            then No_Token_Index
                            else Row_Pos334 - 1));

      Initialize_Fields_For_Op_Gt
        (Self => Transform_Res252);



elsif Row_Pos334 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags252);
end if;

--  End transform_code

    if Row_Pos334 /= No_Token_Index then
        Or_Pos111 := Row_Pos334;
        Or_Res111 := Transform_Res252;
        goto Exit_Or114;
    end if;
    
--  Start transform_code

Transform_Diags253 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos335 := Row_Pos329;



--  Start tok_code

Token_Res522 := Row_Pos335;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res522));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Gte)
   then
       Token_Pos522 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos335 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos335,
             Expected_Token_Id => Ada_Gte,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos522 := Row_Pos335 + 1;
   end if;
end;

--  End tok_code




if Token_Pos522 /= No_Token_Index then

   Row_Pos335 := Token_Pos522;

else
   Row_Pos335 := No_Token_Index;
   goto Exit_Row335_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row335_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos335 /= No_Token_Index then

   Transform_Res253 := Allocate_Op_Gte (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res253,
      Kind => Ada_Op_Gte,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos329,
      Token_End_Index   => (if Row_Pos335 = Row_Pos329
                            then No_Token_Index
                            else Row_Pos335 - 1));

      Initialize_Fields_For_Op_Gte
        (Self => Transform_Res253);



elsif Row_Pos335 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags253);
end if;

--  End transform_code

    if Row_Pos335 /= No_Token_Index then
        Or_Pos111 := Row_Pos335;
        Or_Res111 := Transform_Res253;
        goto Exit_Or114;
    end if;
<<Exit_Or114>>

--  End or_code



Row_Progress39 := 2;

if Or_Pos111 /= No_Token_Index then

   Row_Pos329 := Or_Pos111;

else
   Row_Pos329 := No_Token_Index;
   goto Exit_Row329_0;

end if;

Nobt44 := True;

   Nobt44 := Nobt44;

Row_Progress39 := 3;

if Row_Pos329 /= No_Token_Index then

   Row_Pos329 := Row_Pos329;

else
   Row_Pos329 := No_Token_Index;
   goto Exit_Row329_0;

end if;


Defer_Res513 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos329);
Defer_Pos513 := Parser.Current_Pos;



Row_Progress39 := 4;

if Defer_Pos513 /= No_Token_Index then

   Row_Pos329 := Defer_Pos513;

else
   Row_Pos329 := No_Token_Index;
   goto Exit_Row329_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row329_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos329 = No_Token_Index and then Nobt44 then

   Row_Pos329 := Parser.Last_Fail.Pos;

   Transform_Has_Failed39 := True;
end if;

if Row_Pos329 /= No_Token_Index then

   Transform_Res254 := Allocate_Relation_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res254,
      Kind => Ada_Relation_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos329 = Pos
                            then No_Token_Index
                            else Row_Pos329 - 1));

      Initialize_Fields_For_Relation_Op
        (Self => Transform_Res254, Bin_Op_F_Left => Defer_Res512, Bin_Op_F_Op => Or_Res111, Bin_Op_F_Right => Defer_Res513);

         if Defer_Res512 /= null and then Is_Incomplete (Defer_Res512) then
            Transform_Res254.Last_Attempted_Child := 0;
         elsif Defer_Res512 /= null and then not Is_Ghost (Defer_Res512) then
            Transform_Res254.Last_Attempted_Child := -1;
         end if;
         if Or_Res111 /= null and then Is_Incomplete (Or_Res111) then
            Transform_Res254.Last_Attempted_Child := 0;
         elsif Or_Res111 /= null and then not Is_Ghost (Or_Res111) then
            Transform_Res254.Last_Attempted_Child := -1;
         end if;
         if Defer_Res513 /= null and then Is_Incomplete (Defer_Res513) then
            Transform_Res254.Last_Attempted_Child := 0;
         elsif Defer_Res513 /= null and then not Is_Ghost (Defer_Res513) then
            Transform_Res254.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed39 then
      Transform_Res254.Last_Attempted_Child :=
         Row_Progress39;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <relation>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos329 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags254);
end if;

--  End transform_code

    if Row_Pos329 /= No_Token_Index then
        Or_Pos112 := Row_Pos329;
        Or_Res112 := Transform_Res254;
        goto Exit_Or113;
    end if;
    
--  Start transform_code

Transform_Diags255 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos336 := Pos;



Defer_Res514 :=
   Relation_Or_Parse1 (Parser, Row_Pos336);
Defer_Pos514 := Parser.Current_Pos;




if Defer_Pos514 /= No_Token_Index then

   Row_Pos336 := Defer_Pos514;

else
   Row_Pos336 := No_Token_Index;
   goto Exit_Row336_0;

end if;


Defer_Res515 :=
   Rel_Op_Or_Parse0 (Parser, Row_Pos336);
Defer_Pos515 := Parser.Current_Pos;




if Defer_Pos515 /= No_Token_Index then

   Row_Pos336 := Defer_Pos515;

else
   Row_Pos336 := No_Token_Index;
   goto Exit_Row336_0;

end if;


Defer_Res516 :=
   Membership_Choice_List_List_Parse0 (Parser, Row_Pos336);
Defer_Pos516 := Parser.Current_Pos;




if Defer_Pos516 /= No_Token_Index then

   Row_Pos336 := Defer_Pos516;

else
   Row_Pos336 := No_Token_Index;
   goto Exit_Row336_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row336_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos336 /= No_Token_Index then

   Transform_Res255 := Allocate_Membership_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res255,
      Kind => Ada_Membership_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos336 = Pos
                            then No_Token_Index
                            else Row_Pos336 - 1));

      Initialize_Fields_For_Membership_Expr
        (Self => Transform_Res255, Membership_Expr_F_Expr => Defer_Res514, Membership_Expr_F_Op => Defer_Res515, Membership_Expr_F_Membership_Exprs => Defer_Res516);

         if Defer_Res514 /= null and then Is_Incomplete (Defer_Res514) then
            Transform_Res255.Last_Attempted_Child := 0;
         elsif Defer_Res514 /= null and then not Is_Ghost (Defer_Res514) then
            Transform_Res255.Last_Attempted_Child := -1;
         end if;
         if Defer_Res515 /= null and then Is_Incomplete (Defer_Res515) then
            Transform_Res255.Last_Attempted_Child := 0;
         elsif Defer_Res515 /= null and then not Is_Ghost (Defer_Res515) then
            Transform_Res255.Last_Attempted_Child := -1;
         end if;
         if Defer_Res516 /= null and then Is_Incomplete (Defer_Res516) then
            Transform_Res255.Last_Attempted_Child := 0;
         elsif Defer_Res516 /= null and then not Is_Ghost (Defer_Res516) then
            Transform_Res255.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos336 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags255);
end if;

--  End transform_code

    if Row_Pos336 /= No_Token_Index then
        Or_Pos112 := Row_Pos336;
        Or_Res112 := Transform_Res255;
        goto Exit_Or113;
    end if;
    
Defer_Res517 :=
   Simple_Expr_Or_Parse1 (Parser, Pos);
Defer_Pos517 := Parser.Current_Pos;

    if Defer_Pos517 /= No_Token_Index then
        Or_Pos112 := Defer_Pos517;
        Or_Res112 := Defer_Res517;
        goto Exit_Or113;
    end if;
<<Exit_Or113>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos112 > Mem_Pos then
         Mem_Pos := Or_Pos112;
         Mem_Res := Or_Res112;
         Set
           (Parser.Private_Part.Relation_Or_Parse1_Memo,
            Or_Pos112 /= No_Token_Index,
            Or_Res112,
            Pos,
            Or_Pos112);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res112 := Mem_Res;
         Or_Pos112 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Relation_Or_Parse1_Memo,
      Or_Pos112 /= No_Token_Index,
      Or_Res112,
      Pos,
      Or_Pos112);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos112;

   Exit_Call (Parser, Call_Depth);
   return Or_Res112;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Relation_Or_Parse1;

   


function Renaming_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Renaming_Clause
is
   use Bare_Renaming_Clause_Memos;

   Call_Depth : aliased Natural;

      Row_Pos337 :
            Token_Index
               := No_Token_Index;
      Token_Pos523 :
            Token_Index
               := No_Token_Index;
      Token_Res523 :
            Token_Index
               := No_Token_Index;
      Defer_Pos518 :
            Token_Index
               := No_Token_Index;
      Defer_Res518 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res256 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Transform_Diags256 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Renaming_Clause_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res256 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res256;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res256;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags256 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos337 := Pos;



--  Start tok_code

Token_Res523 := Row_Pos337;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res523));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Renames)
   then
       Token_Pos523 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos337 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos337,
             Expected_Token_Id => Ada_Renames,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos523 := Row_Pos337 + 1;
   end if;
end;

--  End tok_code




if Token_Pos523 /= No_Token_Index then

   Row_Pos337 := Token_Pos523;

else
   Row_Pos337 := No_Token_Index;
   goto Exit_Row337_0;

end if;


Defer_Res518 :=
   Name_Or_Parse2 (Parser, Row_Pos337);
Defer_Pos518 := Parser.Current_Pos;




if Defer_Pos518 /= No_Token_Index then

   Row_Pos337 := Defer_Pos518;

else
   Row_Pos337 := No_Token_Index;
   goto Exit_Row337_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row337_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos337 /= No_Token_Index then

   Transform_Res256 := Allocate_Renaming_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res256,
      Kind => Ada_Renaming_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos337 = Pos
                            then No_Token_Index
                            else Row_Pos337 - 1));

      Initialize_Fields_For_Renaming_Clause
        (Self => Transform_Res256, Renaming_Clause_F_Renamed_Object => Defer_Res518);

         if Defer_Res518 /= null and then Is_Incomplete (Defer_Res518) then
            Transform_Res256.Last_Attempted_Child := 0;
         elsif Defer_Res518 /= null and then not Is_Ghost (Defer_Res518) then
            Transform_Res256.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos337 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags256);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Renaming_Clause_Transform_Parse0_Memo,
      Row_Pos337 /= No_Token_Index,
      Transform_Res256,
      Pos,
      Row_Pos337);


   Parser.Current_Pos := Row_Pos337;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res256;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Renaming_Clause_Transform_Parse0;

   


function Requeue_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Requeue_Stmt
is
   use Bare_Requeue_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos338 :
            Token_Index
               := No_Token_Index;
      Token_Pos524 :
            Token_Index
               := No_Token_Index;
      Token_Res524 :
            Token_Index
               := No_Token_Index;
      Defer_Pos519 :
            Token_Index
               := No_Token_Index;
      Defer_Res519 :
            Bare_Name
               := No_Bare_Ada_Node;
      Row_Pos339 :
            Token_Index
               := No_Token_Index;
      Token_Pos525 :
            Token_Index
               := No_Token_Index;
      Token_Res525 :
            Token_Index
               := No_Token_Index;
      Token_Pos526 :
            Token_Index
               := No_Token_Index;
      Token_Res526 :
            Token_Index
               := No_Token_Index;
      Opt_Res27 :
            Bare_Abort_Node
               := No_Bare_Ada_Node;
      Token_Pos527 :
            Token_Index
               := No_Token_Index;
      Token_Res527 :
            Token_Index
               := No_Token_Index;
      Transform_Res257 :
            Bare_Requeue_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags257 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Requeue_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res257 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res257;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res257;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags257 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos338 := Pos;



--  Start tok_code

Token_Res524 := Row_Pos338;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res524));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Requeue)
   then
       Token_Pos524 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos338 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos338,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos524 := Row_Pos338 + 1;
   end if;
end;

--  End tok_code




if Token_Pos524 /= No_Token_Index then

   Row_Pos338 := Token_Pos524;

else
   Row_Pos338 := No_Token_Index;
   goto Exit_Row338_0;

end if;


Defer_Res519 :=
   Name_Or_Parse2 (Parser, Row_Pos338);
Defer_Pos519 := Parser.Current_Pos;




if Defer_Pos519 /= No_Token_Index then

   Row_Pos338 := Defer_Pos519;

else
   Row_Pos338 := No_Token_Index;
   goto Exit_Row338_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos339 := Row_Pos338;



--  Start tok_code

Token_Res525 := Row_Pos339;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res525));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos525 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos339 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos339,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos525 := Row_Pos339 + 1;
   end if;
end;

--  End tok_code




if Token_Pos525 /= No_Token_Index then

   Row_Pos339 := Token_Pos525;

else
   Row_Pos339 := No_Token_Index;
   goto Exit_Row339_0;

end if;


--  Start tok_code

Token_Res526 := Row_Pos339;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res526));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Abort)
   then
       Token_Pos526 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos339 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos339,
             Expected_Token_Id => Ada_Abort,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos526 := Row_Pos339 + 1;
   end if;
end;

--  End tok_code




if Token_Pos526 /= No_Token_Index then

   Row_Pos339 := Token_Pos526;

else
   Row_Pos339 := No_Token_Index;
   goto Exit_Row339_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row339_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos339 = No_Token_Index then

         Opt_Res27 := Allocate_Abort_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res27,
            Kind              => Ada_Abort_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos338,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos339 := Row_Pos338;


else

      Opt_Res27 := Allocate_Abort_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res27,
         Kind              => Ada_Abort_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos338,
         Token_End_Index   => Row_Pos339 - 1);

end if;

--  End opt_code




if Row_Pos339 /= No_Token_Index then

   Row_Pos338 := Row_Pos339;

else
   Row_Pos338 := No_Token_Index;
   goto Exit_Row338_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res527 := Row_Pos338;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res527));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos527 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos338 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos338,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos527 := Row_Pos338 + 1;
   end if;
end;

--  End tok_code


if Token_Pos527 = No_Token_Index then

         
   Token_Res527 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos338)),
                To_Text ("Missing ';'"));

       
   Token_Pos527 := Row_Pos338;



end if;

--  End opt_code




if Token_Pos527 /= No_Token_Index then

   Row_Pos338 := Token_Pos527;

else
   Row_Pos338 := No_Token_Index;
   goto Exit_Row338_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row338_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos338 /= No_Token_Index then

   Transform_Res257 := Allocate_Requeue_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res257,
      Kind => Ada_Requeue_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos338 = Pos
                            then No_Token_Index
                            else Row_Pos338 - 1));

      Initialize_Fields_For_Requeue_Stmt
        (Self => Transform_Res257, Requeue_Stmt_F_Call_Name => Defer_Res519, Requeue_Stmt_F_Has_Abort => Opt_Res27);

         if Defer_Res519 /= null and then Is_Incomplete (Defer_Res519) then
            Transform_Res257.Last_Attempted_Child := 0;
         elsif Defer_Res519 /= null and then not Is_Ghost (Defer_Res519) then
            Transform_Res257.Last_Attempted_Child := -1;
         end if;
         if Opt_Res27 /= null and then Is_Incomplete (Opt_Res27) then
            Transform_Res257.Last_Attempted_Child := 0;
         elsif Opt_Res27 /= null and then not Is_Ghost (Opt_Res27) then
            Transform_Res257.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos338 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags257);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Requeue_Stmt_Transform_Parse0_Memo,
      Row_Pos338 /= No_Token_Index,
      Transform_Res257,
      Pos,
      Row_Pos338);


   Parser.Current_Pos := Row_Pos338;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res257;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Requeue_Stmt_Transform_Parse0;

   


function Return_Stmt_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Return_Stmt
is
   use Bare_Return_Stmt_Memos;

   Call_Depth : aliased Natural;

      Row_Pos340 :
            Token_Index
               := No_Token_Index;
      Token_Pos528 :
            Token_Index
               := No_Token_Index;
      Token_Res528 :
            Token_Index
               := No_Token_Index;
      Defer_Pos520 :
            Token_Index
               := No_Token_Index;
      Defer_Res520 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos529 :
            Token_Index
               := No_Token_Index;
      Token_Res529 :
            Token_Index
               := No_Token_Index;
      Transform_Res258 :
            Bare_Return_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags258 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Return_Stmt_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res258 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res258;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res258;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags258 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos340 := Pos;



--  Start tok_code

Token_Res528 := Row_Pos340;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res528));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Return)
   then
       Token_Pos528 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos340 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos340,
             Expected_Token_Id => Ada_Return,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos528 := Row_Pos340 + 1;
   end if;
end;

--  End tok_code




if Token_Pos528 /= No_Token_Index then

   Row_Pos340 := Token_Pos528;

else
   Row_Pos340 := No_Token_Index;
   goto Exit_Row340_0;

end if;


--  Start opt_code












Defer_Res520 :=
   Expr_Or_Parse0 (Parser, Row_Pos340);
Defer_Pos520 := Parser.Current_Pos;


if Defer_Pos520 = No_Token_Index then

         
   Defer_Res520 := No_Bare_Ada_Node;



       
   Defer_Pos520 := Row_Pos340;



end if;

--  End opt_code




if Defer_Pos520 /= No_Token_Index then

   Row_Pos340 := Defer_Pos520;

else
   Row_Pos340 := No_Token_Index;
   goto Exit_Row340_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res529 := Row_Pos340;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res529));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos529 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos340 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos340,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos529 := Row_Pos340 + 1;
   end if;
end;

--  End tok_code


if Token_Pos529 = No_Token_Index then

         
   Token_Res529 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos340)),
                To_Text ("Missing ';'"));

       
   Token_Pos529 := Row_Pos340;



end if;

--  End opt_code




if Token_Pos529 /= No_Token_Index then

   Row_Pos340 := Token_Pos529;

else
   Row_Pos340 := No_Token_Index;
   goto Exit_Row340_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row340_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos340 /= No_Token_Index then

   Transform_Res258 := Allocate_Return_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res258,
      Kind => Ada_Return_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos340 = Pos
                            then No_Token_Index
                            else Row_Pos340 - 1));

      Initialize_Fields_For_Return_Stmt
        (Self => Transform_Res258, Return_Stmt_F_Return_Expr => Defer_Res520);

         if Defer_Res520 /= null and then Is_Incomplete (Defer_Res520) then
            Transform_Res258.Last_Attempted_Child := 0;
         elsif Defer_Res520 /= null and then not Is_Ghost (Defer_Res520) then
            Transform_Res258.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos340 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags258);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Return_Stmt_Transform_Parse0_Memo,
      Row_Pos340 /= No_Token_Index,
      Transform_Res258,
      Pos,
      Row_Pos340);


   Parser.Current_Pos := Row_Pos340;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res258;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Return_Stmt_Transform_Parse0;

   


function Select_Stmt_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Select_Stmt
is
   use Bare_Select_Stmt_Memos;

   Call_Depth : aliased Natural;

      Nobt45 :
            Boolean
               := False;
      Row_Pos341 :
            Token_Index
               := No_Token_Index;
      Token_Pos530 :
            Token_Index
               := No_Token_Index;
      Token_Res530 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos46 :
            Token_Index
               := No_Token_Index;
      Tmp_List46 :
            Free_Parse_List;
      Row_Pos342 :
            Token_Index
               := No_Token_Index;
      Row_Pos343 :
            Token_Index
               := No_Token_Index;
      Token_Pos531 :
            Token_Index
               := No_Token_Index;
      Token_Res531 :
            Token_Index
               := No_Token_Index;
      Defer_Pos521 :
            Token_Index
               := No_Token_Index;
      Defer_Res521 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Token_Pos532 :
            Token_Index
               := No_Token_Index;
      Token_Res532 :
            Token_Index
               := No_Token_Index;
      Defer_Pos522 :
            Token_Index
               := No_Token_Index;
      Defer_Res522 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Transform_Res259 :
            Bare_Select_When_Part
               := No_Bare_Ada_Node;
      Transform_Diags259 :
            Ada.Containers.Count_Type;
      Token_Pos533 :
            Token_Index
               := No_Token_Index;
      Token_Res533 :
            Token_Index
               := No_Token_Index;
      List_Pos46 :
            Token_Index
               := No_Token_Index;
      List_Res46 :
            Bare_Select_When_Part_List
               := No_Bare_Ada_Node;
      Row_Pos344 :
            Token_Index
               := No_Token_Index;
      Token_Pos534 :
            Token_Index
               := No_Token_Index;
      Token_Res534 :
            Token_Index
               := No_Token_Index;
      Defer_Pos523 :
            Token_Index
               := No_Token_Index;
      Defer_Res523 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Row_Pos345 :
            Token_Index
               := No_Token_Index;
      Token_Pos535 :
            Token_Index
               := No_Token_Index;
      Token_Res535 :
            Token_Index
               := No_Token_Index;
      Token_Pos536 :
            Token_Index
               := No_Token_Index;
      Token_Res536 :
            Token_Index
               := No_Token_Index;
      Defer_Pos524 :
            Token_Index
               := No_Token_Index;
      Defer_Res524 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;
      Token_Pos537 :
            Token_Index
               := No_Token_Index;
      Token_Res537 :
            Token_Index
               := No_Token_Index;
      Token_Pos538 :
            Token_Index
               := No_Token_Index;
      Token_Res538 :
            Token_Index
               := No_Token_Index;
      Token_Pos539 :
            Token_Index
               := No_Token_Index;
      Token_Res539 :
            Token_Index
               := No_Token_Index;
      Row_Progress40 :
            Integer
               := 0;
      Transform_Res260 :
            Bare_Select_Stmt
               := No_Bare_Ada_Node;
      Transform_Has_Failed40 :
            Boolean
               := False;
      Transform_Diags260 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Select_Stmt_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res260 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res260;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res260;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags260 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos341 := Pos;



--  Start tok_code

Token_Res530 := Row_Pos341;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res530));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Select)
   then
       Token_Pos530 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos341 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos341,
             Expected_Token_Id => Ada_Select,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos530 := Row_Pos341 + 1;
   end if;
end;

--  End tok_code



Row_Progress40 := 1;

if Token_Pos530 /= No_Token_Index then

   Row_Pos341 := Token_Pos530;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;

Nobt45 := True;

   Nobt45 := Nobt45;

Row_Progress40 := 2;

if Row_Pos341 /= No_Token_Index then

   Row_Pos341 := Row_Pos341;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;


--  Start list_code

    List_Pos46 := No_Token_Index;



Lst_Cpos46 := Row_Pos341;
Tmp_List46 := Get_Parse_List (Parser);

loop
   
--  Start transform_code

Transform_Diags259 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos342 := Lst_Cpos46;



--  Start opt_code












--  Start row_code

Row_Pos343 := Row_Pos342;



--  Start tok_code

Token_Res531 := Row_Pos343;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res531));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos531 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos343 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos343,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos531 := Row_Pos343 + 1;
   end if;
end;

--  End tok_code




if Token_Pos531 /= No_Token_Index then

   Row_Pos343 := Token_Pos531;

else
   Row_Pos343 := No_Token_Index;
   goto Exit_Row343_0;

end if;


Defer_Res521 :=
   Expr_Or_Parse0 (Parser, Row_Pos343);
Defer_Pos521 := Parser.Current_Pos;




if Defer_Pos521 /= No_Token_Index then

   Row_Pos343 := Defer_Pos521;

else
   Row_Pos343 := No_Token_Index;
   goto Exit_Row343_0;

end if;


--  Start tok_code

Token_Res532 := Row_Pos343;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res532));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos532 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos343 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos343,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos532 := Row_Pos343 + 1;
   end if;
end;

--  End tok_code




if Token_Pos532 /= No_Token_Index then

   Row_Pos343 := Token_Pos532;

else
   Row_Pos343 := No_Token_Index;
   goto Exit_Row343_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row343_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos343 = No_Token_Index then

         
   Defer_Res521 := No_Bare_Ada_Node;



       
   Row_Pos343 := Row_Pos342;



end if;

--  End opt_code




if Row_Pos343 /= No_Token_Index then

   Row_Pos342 := Row_Pos343;

else
   Row_Pos342 := No_Token_Index;
   goto Exit_Row342_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Select_Stmt0_Extract_Parse0'Access);
        
Defer_Res522 :=
   Stmts_List_Parse0 (Parser, Row_Pos342);
Defer_Pos522 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos522 /= No_Token_Index then

   Row_Pos342 := Defer_Pos522;

else
   Row_Pos342 := No_Token_Index;
   goto Exit_Row342_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row342_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos342 /= No_Token_Index then

   Transform_Res259 := Allocate_Select_When_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res259,
      Kind => Ada_Select_When_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos46,
      Token_End_Index   => (if Row_Pos342 = Lst_Cpos46
                            then No_Token_Index
                            else Row_Pos342 - 1));

      Initialize_Fields_For_Select_When_Part
        (Self => Transform_Res259, Select_When_Part_F_Cond_Expr => Defer_Res521, Select_When_Part_F_Stmts => Defer_Res522);

         if Defer_Res521 /= null and then Is_Incomplete (Defer_Res521) then
            Transform_Res259.Last_Attempted_Child := 0;
         elsif Defer_Res521 /= null and then not Is_Ghost (Defer_Res521) then
            Transform_Res259.Last_Attempted_Child := -1;
         end if;
         if Defer_Res522 /= null and then Is_Incomplete (Defer_Res522) then
            Transform_Res259.Last_Attempted_Child := 0;
         elsif Defer_Res522 /= null and then not Is_Ghost (Defer_Res522) then
            Transform_Res259.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos342 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags259);
end if;

--  End transform_code


   exit when Row_Pos342 = No_Token_Index;

   List_Pos46 := Row_Pos342;
   Lst_Cpos46 := List_Pos46;

   Tmp_List46.Nodes.Append (Transform_Res259);

      
--  Start tok_code

Token_Res533 := Lst_Cpos46;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res533));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Or)
   then
       Token_Pos533 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos46 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos46,
             Expected_Token_Id => Ada_Or,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos533 := Lst_Cpos46 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos533 /= No_Token_Index then
          Lst_Cpos46 := Token_Pos533;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List46.Nodes.Length;
begin
   List_Res46 :=
      Allocate_Select_When_Part_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos341;
      Token_End := (if Lst_Cpos46 = Row_Pos341
                    then Row_Pos341
                    else Lst_Cpos46 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos341, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res46,
      Kind              => Ada_Select_When_Part_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res46,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List46.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res46.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List46);

--  End list_code



Row_Progress40 := 3;

if List_Pos46 /= No_Token_Index then

   Row_Pos341 := List_Pos46;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos344 := Row_Pos341;



--  Start tok_code

Token_Res534 := Row_Pos344;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res534));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Else)
   then
       Token_Pos534 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos344 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos344,
             Expected_Token_Id => Ada_Else,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos534 := Row_Pos344 + 1;
   end if;
end;

--  End tok_code




if Token_Pos534 /= No_Token_Index then

   Row_Pos344 := Token_Pos534;

else
   Row_Pos344 := No_Token_Index;
   goto Exit_Row344_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Select_Stmt1_Extract_Parse0'Access);
        
Defer_Res523 :=
   Stmts_List_Parse0 (Parser, Row_Pos344);
Defer_Pos523 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos523 /= No_Token_Index then

   Row_Pos344 := Defer_Pos523;

else
   Row_Pos344 := No_Token_Index;
   goto Exit_Row344_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row344_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos344 = No_Token_Index then

         
   Defer_Res523 :=
     Allocate_Stmt_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res523,
      Kind              => Ada_Stmt_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos341 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res523,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos344 := Row_Pos341;



end if;

--  End opt_code



Row_Progress40 := 4;

if Row_Pos344 /= No_Token_Index then

   Row_Pos341 := Row_Pos344;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos345 := Row_Pos341;



--  Start tok_code

Token_Res535 := Row_Pos345;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res535));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Then)
   then
       Token_Pos535 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos345 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos345,
             Expected_Token_Id => Ada_Then,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos535 := Row_Pos345 + 1;
   end if;
end;

--  End tok_code




if Token_Pos535 /= No_Token_Index then

   Row_Pos345 := Token_Pos535;

else
   Row_Pos345 := No_Token_Index;
   goto Exit_Row345_0;

end if;


--  Start tok_code

Token_Res536 := Row_Pos345;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res536));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Abort)
   then
       Token_Pos536 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos345 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos345,
             Expected_Token_Id => Ada_Abort,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos536 := Row_Pos345 + 1;
   end if;
end;

--  End tok_code




if Token_Pos536 /= No_Token_Index then

   Row_Pos345 := Token_Pos536;

else
   Row_Pos345 := No_Token_Index;
   goto Exit_Row345_0;

end if;


        Parser.Private_Part.Dont_Skip.Append
          (Dontskip_Select_Stmt2_Extract_Parse0'Access);
        
Defer_Res524 :=
   Stmts_List_Parse0 (Parser, Row_Pos345);
Defer_Pos524 := Parser.Current_Pos;

        Parser.Private_Part.Dont_Skip.Delete_Last;
        



if Defer_Pos524 /= No_Token_Index then

   Row_Pos345 := Defer_Pos524;

else
   Row_Pos345 := No_Token_Index;
   goto Exit_Row345_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row345_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos345 = No_Token_Index then

         
   Defer_Res524 :=
     Allocate_Stmt_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res524,
      Kind              => Ada_Stmt_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos341 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res524,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos345 := Row_Pos341;



end if;

--  End opt_code



Row_Progress40 := 5;

if Row_Pos345 /= No_Token_Index then

   Row_Pos341 := Row_Pos345;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;


--  Start tok_code

Token_Res537 := Row_Pos341;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res537));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos537 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos341 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos341,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos537 := Row_Pos341 + 1;
   end if;
end;

--  End tok_code



Row_Progress40 := 6;

if Token_Pos537 /= No_Token_Index then

   Row_Pos341 := Token_Pos537;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;


--  Start tok_code

Token_Res538 := Row_Pos341;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res538));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Select)
   then
       Token_Pos538 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos341 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos341,
             Expected_Token_Id => Ada_Select,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos538 := Row_Pos341 + 1;
   end if;
end;

--  End tok_code



Row_Progress40 := 7;

if Token_Pos538 /= No_Token_Index then

   Row_Pos341 := Token_Pos538;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;


--  Start tok_code

Token_Res539 := Row_Pos341;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res539));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos539 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos341 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos341,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos539 := Row_Pos341 + 1;
   end if;
end;

--  End tok_code



Row_Progress40 := 8;

if Token_Pos539 /= No_Token_Index then

   Row_Pos341 := Token_Pos539;

else
   Row_Pos341 := No_Token_Index;
   goto Exit_Row341_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row341_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos341 = No_Token_Index and then Nobt45 then

   Row_Pos341 := Parser.Last_Fail.Pos;

   Transform_Has_Failed40 := True;
end if;

if Row_Pos341 /= No_Token_Index then

   Transform_Res260 := Allocate_Select_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res260,
      Kind => Ada_Select_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos341 = Pos
                            then No_Token_Index
                            else Row_Pos341 - 1));

      Initialize_Fields_For_Select_Stmt
        (Self => Transform_Res260, Select_Stmt_F_Guards => List_Res46, Select_Stmt_F_Else_Stmts => Defer_Res523, Select_Stmt_F_Abort_Stmts => Defer_Res524);

         if List_Res46 /= null and then Is_Incomplete (List_Res46) then
            Transform_Res260.Last_Attempted_Child := 0;
         elsif List_Res46 /= null and then not Is_Ghost (List_Res46) then
            Transform_Res260.Last_Attempted_Child := -1;
         end if;
         if Defer_Res523 /= null and then Is_Incomplete (Defer_Res523) then
            Transform_Res260.Last_Attempted_Child := 0;
         elsif Defer_Res523 /= null and then not Is_Ghost (Defer_Res523) then
            Transform_Res260.Last_Attempted_Child := -1;
         end if;
         if Defer_Res524 /= null and then Is_Incomplete (Defer_Res524) then
            Transform_Res260.Last_Attempted_Child := 0;
         elsif Defer_Res524 /= null and then not Is_Ghost (Defer_Res524) then
            Transform_Res260.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed40 then
      Transform_Res260.Last_Attempted_Child :=
         Row_Progress40;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <select_stmt>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos341 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags260);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Select_Stmt_Transform_Parse1_Memo,
      Row_Pos341 /= No_Token_Index,
      Transform_Res260,
      Pos,
      Row_Pos341);


   Parser.Current_Pos := Row_Pos341;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res260;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Select_Stmt_Transform_Parse1;

   


function Sexpr_Or_Box_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos525 :
            Token_Index
               := No_Token_Index;
      Defer_Res525 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos526 :
            Token_Index
               := No_Token_Index;
      Defer_Res526 :
            Bare_Box_Expr
               := No_Bare_Ada_Node;
      Or_Pos113 :
            Token_Index
               := No_Token_Index;
      Or_Res113 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Sexpr_Or_Box_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res113 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res113;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res113;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos113 := No_Token_Index;
Or_Res113 := No_Bare_Ada_Node;
    
Defer_Res525 :=
   Simple_Expr_Or_Parse1 (Parser, Pos);
Defer_Pos525 := Parser.Current_Pos;

    if Defer_Pos525 /= No_Token_Index then
        Or_Pos113 := Defer_Pos525;
        Or_Res113 := Defer_Res525;
        goto Exit_Or115;
    end if;
    
Defer_Res526 :=
   Box_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos526 := Parser.Current_Pos;

    if Defer_Pos526 /= No_Token_Index then
        Or_Pos113 := Defer_Pos526;
        Or_Res113 := Defer_Res526;
        goto Exit_Or115;
    end if;
<<Exit_Or115>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Sexpr_Or_Box_Or_Parse0_Memo,
      Or_Pos113 /= No_Token_Index,
      Or_Res113,
      Pos,
      Or_Pos113);


   Parser.Current_Pos := Or_Pos113;

   Exit_Call (Parser, Call_Depth);
   return Or_Res113;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Sexpr_Or_Box_Or_Parse0;

   


function Signed_Int_Type_Def_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Signed_Int_Type_Def
is
   use Bare_Signed_Int_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos346 :
            Token_Index
               := No_Token_Index;
      Defer_Pos527 :
            Token_Index
               := No_Token_Index;
      Defer_Res527 :
            Bare_Range_Spec
               := No_Bare_Ada_Node;
      Transform_Res261 :
            Bare_Signed_Int_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags261 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Signed_Int_Type_Def_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res261 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res261;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res261;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags261 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos346 := Pos;



Defer_Res527 :=
   Range_Spec_Transform_Parse0 (Parser, Row_Pos346);
Defer_Pos527 := Parser.Current_Pos;




if Defer_Pos527 /= No_Token_Index then

   Row_Pos346 := Defer_Pos527;

else
   Row_Pos346 := No_Token_Index;
   goto Exit_Row346_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row346_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos346 /= No_Token_Index then

   Transform_Res261 := Allocate_Signed_Int_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res261,
      Kind => Ada_Signed_Int_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos346 = Pos
                            then No_Token_Index
                            else Row_Pos346 - 1));

      Initialize_Fields_For_Signed_Int_Type_Def
        (Self => Transform_Res261, Signed_Int_Type_Def_F_Range => Defer_Res527);

         if Defer_Res527 /= null and then Is_Incomplete (Defer_Res527) then
            Transform_Res261.Last_Attempted_Child := 0;
         elsif Defer_Res527 /= null and then not Is_Ghost (Defer_Res527) then
            Transform_Res261.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos346 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags261);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Signed_Int_Type_Def_Transform_Parse0_Memo,
      Row_Pos346 /= No_Token_Index,
      Transform_Res261,
      Pos,
      Row_Pos346);


   Parser.Current_Pos := Row_Pos346;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res261;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Signed_Int_Type_Def_Transform_Parse0;

   


function Simple_Expr_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt46 :
            Boolean
               := False;
      Row_Pos347 :
            Token_Index
               := No_Token_Index;
      Defer_Pos528 :
            Token_Index
               := No_Token_Index;
      Defer_Res528 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Pos348 :
            Token_Index
               := No_Token_Index;
      Token_Pos540 :
            Token_Index
               := No_Token_Index;
      Token_Res540 :
            Token_Index
               := No_Token_Index;
      Transform_Res262 :
            Bare_Op_Plus
               := No_Bare_Ada_Node;
      Transform_Diags262 :
            Ada.Containers.Count_Type;
      Row_Pos349 :
            Token_Index
               := No_Token_Index;
      Token_Pos541 :
            Token_Index
               := No_Token_Index;
      Token_Res541 :
            Token_Index
               := No_Token_Index;
      Transform_Res263 :
            Bare_Op_Minus
               := No_Bare_Ada_Node;
      Transform_Diags263 :
            Ada.Containers.Count_Type;
      Or_Pos114 :
            Token_Index
               := No_Token_Index;
      Or_Res114 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos529 :
            Token_Index
               := No_Token_Index;
      Defer_Res529 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress41 :
            Integer
               := 0;
      Transform_Res264 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed41 :
            Boolean
               := False;
      Transform_Diags264 :
            Ada.Containers.Count_Type;
      Row_Pos350 :
            Token_Index
               := No_Token_Index;
      Defer_Pos530 :
            Token_Index
               := No_Token_Index;
      Defer_Res530 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Lst_Cpos47 :
            Token_Index
               := No_Token_Index;
      Tmp_List47 :
            Free_Parse_List;
      Row_Pos351 :
            Token_Index
               := No_Token_Index;
      Row_Pos352 :
            Token_Index
               := No_Token_Index;
      Token_Pos542 :
            Token_Index
               := No_Token_Index;
      Token_Res542 :
            Token_Index
               := No_Token_Index;
      Transform_Res265 :
            Bare_Op_Concat
               := No_Bare_Ada_Node;
      Transform_Diags265 :
            Ada.Containers.Count_Type;
      Defer_Pos531 :
            Token_Index
               := No_Token_Index;
      Defer_Res531 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Transform_Res266 :
            Bare_Concat_Operand
               := No_Bare_Ada_Node;
      Transform_Diags266 :
            Ada.Containers.Count_Type;
      List_Pos47 :
            Token_Index
               := No_Token_Index;
      List_Res47 :
            Bare_Concat_Operand_List
               := No_Bare_Ada_Node;
      Transform_Res267 :
            Bare_Concat_Op
               := No_Bare_Ada_Node;
      Transform_Diags267 :
            Ada.Containers.Count_Type;
      Defer_Pos532 :
            Token_Index
               := No_Token_Index;
      Defer_Res532 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos115 :
            Token_Index
               := No_Token_Index;
      Or_Res115 :
            Bare_Expr
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Simple_Expr_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res115 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res115;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res115;
   end if;

       Set (Parser.Private_Part.Simple_Expr_Or_Parse1_Memo, False, Or_Res115, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt46 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos115 := No_Token_Index;
Or_Res115 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags264 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos347 := Pos;



Defer_Res528 :=
   Simple_Expr_Or_Parse1 (Parser, Row_Pos347);
Defer_Pos528 := Parser.Current_Pos;



Row_Progress41 := 1;

if Defer_Pos528 /= No_Token_Index then

   Row_Pos347 := Defer_Pos528;

else
   Row_Pos347 := No_Token_Index;
   goto Exit_Row347_0;

end if;


--  Start or_code

Or_Pos114 := No_Token_Index;
Or_Res114 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags262 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos348 := Row_Pos347;



--  Start tok_code

Token_Res540 := Row_Pos348;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res540));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Plus)
   then
       Token_Pos540 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos348 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos348,
             Expected_Token_Id => Ada_Plus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos540 := Row_Pos348 + 1;
   end if;
end;

--  End tok_code




if Token_Pos540 /= No_Token_Index then

   Row_Pos348 := Token_Pos540;

else
   Row_Pos348 := No_Token_Index;
   goto Exit_Row348_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row348_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos348 /= No_Token_Index then

   Transform_Res262 := Allocate_Op_Plus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res262,
      Kind => Ada_Op_Plus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos347,
      Token_End_Index   => (if Row_Pos348 = Row_Pos347
                            then No_Token_Index
                            else Row_Pos348 - 1));

      Initialize_Fields_For_Op_Plus
        (Self => Transform_Res262);



elsif Row_Pos348 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags262);
end if;

--  End transform_code

    if Row_Pos348 /= No_Token_Index then
        Or_Pos114 := Row_Pos348;
        Or_Res114 := Transform_Res262;
        goto Exit_Or117;
    end if;
    
--  Start transform_code

Transform_Diags263 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos349 := Row_Pos347;



--  Start tok_code

Token_Res541 := Row_Pos349;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res541));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Minus)
   then
       Token_Pos541 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos349 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos349,
             Expected_Token_Id => Ada_Minus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos541 := Row_Pos349 + 1;
   end if;
end;

--  End tok_code




if Token_Pos541 /= No_Token_Index then

   Row_Pos349 := Token_Pos541;

else
   Row_Pos349 := No_Token_Index;
   goto Exit_Row349_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row349_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos349 /= No_Token_Index then

   Transform_Res263 := Allocate_Op_Minus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res263,
      Kind => Ada_Op_Minus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos347,
      Token_End_Index   => (if Row_Pos349 = Row_Pos347
                            then No_Token_Index
                            else Row_Pos349 - 1));

      Initialize_Fields_For_Op_Minus
        (Self => Transform_Res263);



elsif Row_Pos349 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags263);
end if;

--  End transform_code

    if Row_Pos349 /= No_Token_Index then
        Or_Pos114 := Row_Pos349;
        Or_Res114 := Transform_Res263;
        goto Exit_Or117;
    end if;
<<Exit_Or117>>

--  End or_code



Row_Progress41 := 2;

if Or_Pos114 /= No_Token_Index then

   Row_Pos347 := Or_Pos114;

else
   Row_Pos347 := No_Token_Index;
   goto Exit_Row347_0;

end if;

Nobt46 := True;

   Nobt46 := Nobt46;

Row_Progress41 := 3;

if Row_Pos347 /= No_Token_Index then

   Row_Pos347 := Row_Pos347;

else
   Row_Pos347 := No_Token_Index;
   goto Exit_Row347_0;

end if;


Defer_Res529 :=
   Term_Or_Parse1 (Parser, Row_Pos347);
Defer_Pos529 := Parser.Current_Pos;



Row_Progress41 := 4;

if Defer_Pos529 /= No_Token_Index then

   Row_Pos347 := Defer_Pos529;

else
   Row_Pos347 := No_Token_Index;
   goto Exit_Row347_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row347_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos347 = No_Token_Index and then Nobt46 then

   Row_Pos347 := Parser.Last_Fail.Pos;

   Transform_Has_Failed41 := True;
end if;

if Row_Pos347 /= No_Token_Index then

   Transform_Res264 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res264,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos347 = Pos
                            then No_Token_Index
                            else Row_Pos347 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res264, Bin_Op_F_Left => Defer_Res528, Bin_Op_F_Op => Or_Res114, Bin_Op_F_Right => Defer_Res529);

         if Defer_Res528 /= null and then Is_Incomplete (Defer_Res528) then
            Transform_Res264.Last_Attempted_Child := 0;
         elsif Defer_Res528 /= null and then not Is_Ghost (Defer_Res528) then
            Transform_Res264.Last_Attempted_Child := -1;
         end if;
         if Or_Res114 /= null and then Is_Incomplete (Or_Res114) then
            Transform_Res264.Last_Attempted_Child := 0;
         elsif Or_Res114 /= null and then not Is_Ghost (Or_Res114) then
            Transform_Res264.Last_Attempted_Child := -1;
         end if;
         if Defer_Res529 /= null and then Is_Incomplete (Defer_Res529) then
            Transform_Res264.Last_Attempted_Child := 0;
         elsif Defer_Res529 /= null and then not Is_Ghost (Defer_Res529) then
            Transform_Res264.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed41 then
      Transform_Res264.Last_Attempted_Child :=
         Row_Progress41;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <simple_expr>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos347 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags264);
end if;

--  End transform_code

    if Row_Pos347 /= No_Token_Index then
        Or_Pos115 := Row_Pos347;
        Or_Res115 := Transform_Res264;
        goto Exit_Or116;
    end if;
    
--  Start transform_code

Transform_Diags267 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos350 := Pos;



Defer_Res530 :=
   Unop_Term_Or_Parse1 (Parser, Row_Pos350);
Defer_Pos530 := Parser.Current_Pos;




if Defer_Pos530 /= No_Token_Index then

   Row_Pos350 := Defer_Pos530;

else
   Row_Pos350 := No_Token_Index;
   goto Exit_Row350_0;

end if;


--  Start list_code

    List_Pos47 := No_Token_Index;



Lst_Cpos47 := Row_Pos350;
Tmp_List47 := Get_Parse_List (Parser);

loop
   
--  Start transform_code

Transform_Diags266 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos351 := Lst_Cpos47;



--  Start transform_code

Transform_Diags265 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos352 := Row_Pos351;



--  Start tok_code

Token_Res542 := Row_Pos352;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res542));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Amp)
   then
       Token_Pos542 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos352 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos352,
             Expected_Token_Id => Ada_Amp,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos542 := Row_Pos352 + 1;
   end if;
end;

--  End tok_code




if Token_Pos542 /= No_Token_Index then

   Row_Pos352 := Token_Pos542;

else
   Row_Pos352 := No_Token_Index;
   goto Exit_Row352_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row352_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos352 /= No_Token_Index then

   Transform_Res265 := Allocate_Op_Concat (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res265,
      Kind => Ada_Op_Concat,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos351,
      Token_End_Index   => (if Row_Pos352 = Row_Pos351
                            then No_Token_Index
                            else Row_Pos352 - 1));

      Initialize_Fields_For_Op_Concat
        (Self => Transform_Res265);



elsif Row_Pos352 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags265);
end if;

--  End transform_code




if Row_Pos352 /= No_Token_Index then

   Row_Pos351 := Row_Pos352;

else
   Row_Pos351 := No_Token_Index;
   goto Exit_Row351_0;

end if;


Defer_Res531 :=
   Unop_Term_Or_Parse1 (Parser, Row_Pos351);
Defer_Pos531 := Parser.Current_Pos;




if Defer_Pos531 /= No_Token_Index then

   Row_Pos351 := Defer_Pos531;

else
   Row_Pos351 := No_Token_Index;
   goto Exit_Row351_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row351_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos351 /= No_Token_Index then

   Transform_Res266 := Allocate_Concat_Operand (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res266,
      Kind => Ada_Concat_Operand,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos47,
      Token_End_Index   => (if Row_Pos351 = Lst_Cpos47
                            then No_Token_Index
                            else Row_Pos351 - 1));

      Initialize_Fields_For_Concat_Operand
        (Self => Transform_Res266, Concat_Operand_F_Operator => Transform_Res265, Concat_Operand_F_Operand => Defer_Res531);

         if Transform_Res265 /= null and then Is_Incomplete (Transform_Res265) then
            Transform_Res266.Last_Attempted_Child := 0;
         elsif Transform_Res265 /= null and then not Is_Ghost (Transform_Res265) then
            Transform_Res266.Last_Attempted_Child := -1;
         end if;
         if Defer_Res531 /= null and then Is_Incomplete (Defer_Res531) then
            Transform_Res266.Last_Attempted_Child := 0;
         elsif Defer_Res531 /= null and then not Is_Ghost (Defer_Res531) then
            Transform_Res266.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos351 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags266);
end if;

--  End transform_code


   exit when Row_Pos351 = No_Token_Index;

   List_Pos47 := Row_Pos351;
   Lst_Cpos47 := List_Pos47;

   Tmp_List47.Nodes.Append (Transform_Res266);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List47.Nodes.Length;
begin
   List_Res47 :=
      Allocate_Concat_Operand_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos350;
      Token_End := (if Lst_Cpos47 = Row_Pos350
                    then Row_Pos350
                    else Lst_Cpos47 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos350, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res47,
      Kind              => Ada_Concat_Operand_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res47,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List47.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res47.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List47);

--  End list_code




if List_Pos47 /= No_Token_Index then

   Row_Pos350 := List_Pos47;

else
   Row_Pos350 := No_Token_Index;
   goto Exit_Row350_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row350_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos350 /= No_Token_Index then

   Transform_Res267 := Allocate_Concat_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res267,
      Kind => Ada_Concat_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos350 = Pos
                            then No_Token_Index
                            else Row_Pos350 - 1));

      Initialize_Fields_For_Concat_Op
        (Self => Transform_Res267, Concat_Op_F_First_Operand => Defer_Res530, Concat_Op_F_Other_Operands => List_Res47);

         if Defer_Res530 /= null and then Is_Incomplete (Defer_Res530) then
            Transform_Res267.Last_Attempted_Child := 0;
         elsif Defer_Res530 /= null and then not Is_Ghost (Defer_Res530) then
            Transform_Res267.Last_Attempted_Child := -1;
         end if;
         if List_Res47 /= null and then Is_Incomplete (List_Res47) then
            Transform_Res267.Last_Attempted_Child := 0;
         elsif List_Res47 /= null and then not Is_Ghost (List_Res47) then
            Transform_Res267.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos350 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags267);
end if;

--  End transform_code

    if Row_Pos350 /= No_Token_Index then
        Or_Pos115 := Row_Pos350;
        Or_Res115 := Transform_Res267;
        goto Exit_Or116;
    end if;
    
Defer_Res532 :=
   Unop_Term_Or_Parse1 (Parser, Pos);
Defer_Pos532 := Parser.Current_Pos;

    if Defer_Pos532 /= No_Token_Index then
        Or_Pos115 := Defer_Pos532;
        Or_Res115 := Defer_Res532;
        goto Exit_Or116;
    end if;
<<Exit_Or116>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos115 > Mem_Pos then
         Mem_Pos := Or_Pos115;
         Mem_Res := Or_Res115;
         Set
           (Parser.Private_Part.Simple_Expr_Or_Parse1_Memo,
            Or_Pos115 /= No_Token_Index,
            Or_Res115,
            Pos,
            Or_Pos115);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res115 := Mem_Res;
         Or_Pos115 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Simple_Expr_Or_Parse1_Memo,
      Or_Pos115 /= No_Token_Index,
      Or_Res115,
      Pos,
      Or_Pos115);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos115;

   Exit_Call (Parser, Call_Depth);
   return Or_Res115;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Simple_Expr_Or_Parse1;

   


function Simple_Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos533 :
            Token_Index
               := No_Token_Index;
      Defer_Res533 :
            Bare_Null_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos534 :
            Token_Index
               := No_Token_Index;
      Defer_Res534 :
            Bare_Assign_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos535 :
            Token_Index
               := No_Token_Index;
      Defer_Res535 :
            Bare_Goto_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos536 :
            Token_Index
               := No_Token_Index;
      Defer_Res536 :
            Bare_Exit_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos537 :
            Token_Index
               := No_Token_Index;
      Defer_Res537 :
            Bare_Return_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos538 :
            Token_Index
               := No_Token_Index;
      Defer_Res538 :
            Bare_Requeue_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos539 :
            Token_Index
               := No_Token_Index;
      Defer_Res539 :
            Bare_Call_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos540 :
            Token_Index
               := No_Token_Index;
      Defer_Res540 :
            Bare_Abort_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos541 :
            Token_Index
               := No_Token_Index;
      Defer_Res541 :
            Bare_Delay_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos542 :
            Token_Index
               := No_Token_Index;
      Defer_Res542 :
            Bare_Raise_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos543 :
            Token_Index
               := No_Token_Index;
      Defer_Res543 :
            Bare_Terminate_Alternative
               := No_Bare_Ada_Node;
      Defer_Pos544 :
            Token_Index
               := No_Token_Index;
      Defer_Res544 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos116 :
            Token_Index
               := No_Token_Index;
      Or_Res116 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Simple_Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res116 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res116;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res116;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos116 := No_Token_Index;
Or_Res116 := No_Bare_Ada_Node;
    
Defer_Res533 :=
   Null_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos533 := Parser.Current_Pos;

    if Defer_Pos533 /= No_Token_Index then
        Or_Pos116 := Defer_Pos533;
        Or_Res116 := Defer_Res533;
        goto Exit_Or118;
    end if;
    
Defer_Res534 :=
   Assignment_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos534 := Parser.Current_Pos;

    if Defer_Pos534 /= No_Token_Index then
        Or_Pos116 := Defer_Pos534;
        Or_Res116 := Defer_Res534;
        goto Exit_Or118;
    end if;
    
Defer_Res535 :=
   Goto_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos535 := Parser.Current_Pos;

    if Defer_Pos535 /= No_Token_Index then
        Or_Pos116 := Defer_Pos535;
        Or_Res116 := Defer_Res535;
        goto Exit_Or118;
    end if;
    
Defer_Res536 :=
   Exit_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos536 := Parser.Current_Pos;

    if Defer_Pos536 /= No_Token_Index then
        Or_Pos116 := Defer_Pos536;
        Or_Res116 := Defer_Res536;
        goto Exit_Or118;
    end if;
    
Defer_Res537 :=
   Return_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos537 := Parser.Current_Pos;

    if Defer_Pos537 /= No_Token_Index then
        Or_Pos116 := Defer_Pos537;
        Or_Res116 := Defer_Res537;
        goto Exit_Or118;
    end if;
    
Defer_Res538 :=
   Requeue_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos538 := Parser.Current_Pos;

    if Defer_Pos538 /= No_Token_Index then
        Or_Pos116 := Defer_Pos538;
        Or_Res116 := Defer_Res538;
        goto Exit_Or118;
    end if;
    
Defer_Res539 :=
   Call_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos539 := Parser.Current_Pos;

    if Defer_Pos539 /= No_Token_Index then
        Or_Pos116 := Defer_Pos539;
        Or_Res116 := Defer_Res539;
        goto Exit_Or118;
    end if;
    
Defer_Res540 :=
   Abort_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos540 := Parser.Current_Pos;

    if Defer_Pos540 /= No_Token_Index then
        Or_Pos116 := Defer_Pos540;
        Or_Res116 := Defer_Res540;
        goto Exit_Or118;
    end if;
    
Defer_Res541 :=
   Delay_Stmt_Transform_Parse0 (Parser, Pos);
Defer_Pos541 := Parser.Current_Pos;

    if Defer_Pos541 /= No_Token_Index then
        Or_Pos116 := Defer_Pos541;
        Or_Res116 := Defer_Res541;
        goto Exit_Or118;
    end if;
    
Defer_Res542 :=
   Raise_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos542 := Parser.Current_Pos;

    if Defer_Pos542 /= No_Token_Index then
        Or_Pos116 := Defer_Pos542;
        Or_Res116 := Defer_Res542;
        goto Exit_Or118;
    end if;
    
Defer_Res543 :=
   Terminate_Alternative_Transform_Parse0 (Parser, Pos);
Defer_Pos543 := Parser.Current_Pos;

    if Defer_Pos543 /= No_Token_Index then
        Or_Pos116 := Defer_Pos543;
        Or_Res116 := Defer_Res543;
        goto Exit_Or118;
    end if;
    
Defer_Res544 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos544 := Parser.Current_Pos;

    if Defer_Pos544 /= No_Token_Index then
        Or_Pos116 := Defer_Pos544;
        Or_Res116 := Defer_Res544;
        goto Exit_Or118;
    end if;
<<Exit_Or118>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Simple_Stmt_Or_Parse0_Memo,
      Or_Pos116 /= No_Token_Index,
      Or_Res116,
      Pos,
      Or_Pos116);


   Parser.Current_Pos := Or_Pos116;

   Exit_Call (Parser, Call_Depth);
   return Or_Res116;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Simple_Stmt_Or_Parse0;

   


function Simple_Subp_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Decl
is
   use Bare_Subp_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos353 :
            Token_Index
               := No_Token_Index;
      Defer_Pos545 :
            Token_Index
               := No_Token_Index;
      Defer_Res545 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos546 :
            Token_Index
               := No_Token_Index;
      Defer_Res546 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Defer_Pos547 :
            Token_Index
               := No_Token_Index;
      Defer_Res547 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos543 :
            Token_Index
               := No_Token_Index;
      Token_Res543 :
            Token_Index
               := No_Token_Index;
      Transform_Res268 :
            Bare_Subp_Decl
               := No_Bare_Ada_Node;
      Transform_Diags268 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Simple_Subp_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res268 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res268;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res268;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags268 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos353 := Pos;



Defer_Res545 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos353);
Defer_Pos545 := Parser.Current_Pos;




if Defer_Pos545 /= No_Token_Index then

   Row_Pos353 := Defer_Pos545;

else
   Row_Pos353 := No_Token_Index;
   goto Exit_Row353_0;

end if;


Defer_Res546 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos353);
Defer_Pos546 := Parser.Current_Pos;




if Defer_Pos546 /= No_Token_Index then

   Row_Pos353 := Defer_Pos546;

else
   Row_Pos353 := No_Token_Index;
   goto Exit_Row353_0;

end if;


Defer_Res547 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos353);
Defer_Pos547 := Parser.Current_Pos;




if Defer_Pos547 /= No_Token_Index then

   Row_Pos353 := Defer_Pos547;

else
   Row_Pos353 := No_Token_Index;
   goto Exit_Row353_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res543 := Row_Pos353;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res543));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos543 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos353 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos353,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos543 := Row_Pos353 + 1;
   end if;
end;

--  End tok_code


if Token_Pos543 = No_Token_Index then

         
   Token_Res543 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos353)),
                To_Text ("Missing ';'"));

       
   Token_Pos543 := Row_Pos353;



end if;

--  End opt_code




if Token_Pos543 /= No_Token_Index then

   Row_Pos353 := Token_Pos543;

else
   Row_Pos353 := No_Token_Index;
   goto Exit_Row353_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row353_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos353 /= No_Token_Index then

   Transform_Res268 := Allocate_Subp_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res268,
      Kind => Ada_Subp_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos353 = Pos
                            then No_Token_Index
                            else Row_Pos353 - 1));

      Initialize_Fields_For_Subp_Decl
        (Self => Transform_Res268, Classic_Subp_Decl_F_Overriding => Defer_Res545, Classic_Subp_Decl_F_Subp_Spec => Defer_Res546, Subp_Decl_F_Aspects => Defer_Res547);

         if Defer_Res545 /= null and then Is_Incomplete (Defer_Res545) then
            Transform_Res268.Last_Attempted_Child := 0;
         elsif Defer_Res545 /= null and then not Is_Ghost (Defer_Res545) then
            Transform_Res268.Last_Attempted_Child := -1;
         end if;
         if Defer_Res546 /= null and then Is_Incomplete (Defer_Res546) then
            Transform_Res268.Last_Attempted_Child := 0;
         elsif Defer_Res546 /= null and then not Is_Ghost (Defer_Res546) then
            Transform_Res268.Last_Attempted_Child := -1;
         end if;
         if Defer_Res547 /= null and then Is_Incomplete (Defer_Res547) then
            Transform_Res268.Last_Attempted_Child := 0;
         elsif Defer_Res547 /= null and then not Is_Ghost (Defer_Res547) then
            Transform_Res268.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos353 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags268);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Simple_Subp_Decl_Transform_Parse0_Memo,
      Row_Pos353 /= No_Token_Index,
      Transform_Res268,
      Pos,
      Row_Pos353);


   Parser.Current_Pos := Row_Pos353;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res268;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Simple_Subp_Decl_Transform_Parse0;

   


function Single_Task_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Single_Task_Decl
is
   use Bare_Single_Task_Decl_Memos;

   Call_Depth : aliased Natural;

      Nobt47 :
            Boolean
               := False;
      Row_Pos354 :
            Token_Index
               := No_Token_Index;
      Token_Pos544 :
            Token_Index
               := No_Token_Index;
      Token_Res544 :
            Token_Index
               := No_Token_Index;
      Row_Pos355 :
            Token_Index
               := No_Token_Index;
      Defer_Pos548 :
            Token_Index
               := No_Token_Index;
      Defer_Res548 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Null_Res38 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Defer_Pos549 :
            Token_Index
               := No_Token_Index;
      Defer_Res549 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Defer_Pos550 :
            Token_Index
               := No_Token_Index;
      Defer_Res550 :
            Bare_Task_Def
               := No_Bare_Ada_Node;
      Transform_Res269 :
            Bare_Single_Task_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags269 :
            Ada.Containers.Count_Type;
      Token_Pos545 :
            Token_Index
               := No_Token_Index;
      Token_Res545 :
            Token_Index
               := No_Token_Index;
      Row_Progress42 :
            Integer
               := 0;
      Transform_Res270 :
            Bare_Single_Task_Decl
               := No_Bare_Ada_Node;
      Transform_Has_Failed42 :
            Boolean
               := False;
      Transform_Diags270 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Single_Task_Decl_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res270 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res270;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res270;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags270 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos354 := Pos;



--  Start tok_code

Token_Res544 := Row_Pos354;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res544));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Task)
   then
       Token_Pos544 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos354 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos354,
             Expected_Token_Id => Ada_Task,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos544 := Row_Pos354 + 1;
   end if;
end;

--  End tok_code



Row_Progress42 := 1;

if Token_Pos544 /= No_Token_Index then

   Row_Pos354 := Token_Pos544;

else
   Row_Pos354 := No_Token_Index;
   goto Exit_Row354_0;

end if;

Nobt47 := True;

   Nobt47 := Nobt47;

Row_Progress42 := 2;

if Row_Pos354 /= No_Token_Index then

   Row_Pos354 := Row_Pos354;

else
   Row_Pos354 := No_Token_Index;
   goto Exit_Row354_0;

end if;


--  Start transform_code

Transform_Diags269 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos355 := Row_Pos354;



Defer_Res548 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos355);
Defer_Pos548 := Parser.Current_Pos;




if Defer_Pos548 /= No_Token_Index then

   Row_Pos355 := Defer_Pos548;

else
   Row_Pos355 := No_Token_Index;
   goto Exit_Row355_0;

end if;


   Null_Res38 := No_Bare_Ada_Node;




if Row_Pos355 /= No_Token_Index then

   Row_Pos355 := Row_Pos355;

else
   Row_Pos355 := No_Token_Index;
   goto Exit_Row355_0;

end if;


Defer_Res549 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos355);
Defer_Pos549 := Parser.Current_Pos;




if Defer_Pos549 /= No_Token_Index then

   Row_Pos355 := Defer_Pos549;

else
   Row_Pos355 := No_Token_Index;
   goto Exit_Row355_0;

end if;


--  Start opt_code












Defer_Res550 :=
   Task_Def_Transform_Parse3 (Parser, Row_Pos355);
Defer_Pos550 := Parser.Current_Pos;


if Defer_Pos550 = No_Token_Index then

         
   Defer_Res550 := No_Bare_Ada_Node;



       
   Defer_Pos550 := Row_Pos355;



end if;

--  End opt_code




if Defer_Pos550 /= No_Token_Index then

   Row_Pos355 := Defer_Pos550;

else
   Row_Pos355 := No_Token_Index;
   goto Exit_Row355_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row355_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos355 /= No_Token_Index then

   Transform_Res269 := Allocate_Single_Task_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res269,
      Kind => Ada_Single_Task_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos354,
      Token_End_Index   => (if Row_Pos355 = Row_Pos354
                            then No_Token_Index
                            else Row_Pos355 - 1));

      Initialize_Fields_For_Single_Task_Type_Decl
        (Self => Transform_Res269, Base_Type_Decl_F_Name => Defer_Res548, Task_Type_Decl_F_Discriminants => Null_Res38, Task_Type_Decl_F_Aspects => Defer_Res549, Task_Type_Decl_F_Definition => Defer_Res550);

         if Defer_Res548 /= null and then Is_Incomplete (Defer_Res548) then
            Transform_Res269.Last_Attempted_Child := 0;
         elsif Defer_Res548 /= null and then not Is_Ghost (Defer_Res548) then
            Transform_Res269.Last_Attempted_Child := -1;
         end if;
         if Null_Res38 /= null and then Is_Incomplete (Null_Res38) then
            Transform_Res269.Last_Attempted_Child := 0;
         elsif Null_Res38 /= null and then not Is_Ghost (Null_Res38) then
            Transform_Res269.Last_Attempted_Child := -1;
         end if;
         if Defer_Res549 /= null and then Is_Incomplete (Defer_Res549) then
            Transform_Res269.Last_Attempted_Child := 0;
         elsif Defer_Res549 /= null and then not Is_Ghost (Defer_Res549) then
            Transform_Res269.Last_Attempted_Child := -1;
         end if;
         if Defer_Res550 /= null and then Is_Incomplete (Defer_Res550) then
            Transform_Res269.Last_Attempted_Child := 0;
         elsif Defer_Res550 /= null and then not Is_Ghost (Defer_Res550) then
            Transform_Res269.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos355 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags269);
end if;

--  End transform_code



Row_Progress42 := 3;

if Row_Pos355 /= No_Token_Index then

   Row_Pos354 := Row_Pos355;

else
   Row_Pos354 := No_Token_Index;
   goto Exit_Row354_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res545 := Row_Pos354;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res545));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos545 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos354 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos354,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos545 := Row_Pos354 + 1;
   end if;
end;

--  End tok_code


if Token_Pos545 = No_Token_Index then

         
   Token_Res545 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos354)),
                To_Text ("Missing ';'"));

       
   Token_Pos545 := Row_Pos354;



end if;

--  End opt_code



Row_Progress42 := 4;

if Token_Pos545 /= No_Token_Index then

   Row_Pos354 := Token_Pos545;

else
   Row_Pos354 := No_Token_Index;
   goto Exit_Row354_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row354_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos354 = No_Token_Index and then Nobt47 then

   Row_Pos354 := Parser.Last_Fail.Pos;

   Transform_Has_Failed42 := True;
end if;

if Row_Pos354 /= No_Token_Index then

   Transform_Res270 := Allocate_Single_Task_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res270,
      Kind => Ada_Single_Task_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos354 = Pos
                            then No_Token_Index
                            else Row_Pos354 - 1));

      Initialize_Fields_For_Single_Task_Decl
        (Self => Transform_Res270, Single_Task_Decl_F_Task_Type => Transform_Res269);

         if Transform_Res269 /= null and then Is_Incomplete (Transform_Res269) then
            Transform_Res270.Last_Attempted_Child := 0;
         elsif Transform_Res269 /= null and then not Is_Ghost (Transform_Res269) then
            Transform_Res270.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed42 then
      Transform_Res270.Last_Attempted_Child :=
         Row_Progress42;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <single_task_decl>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos354 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags270);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Single_Task_Decl_Transform_Parse1_Memo,
      Row_Pos354 /= No_Token_Index,
      Transform_Res270,
      Pos,
      Row_Pos354);


   Parser.Current_Pos := Row_Pos354;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res270;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Single_Task_Decl_Transform_Parse1;

   


function Static_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name
is
   use Bare_Name_Memos;

   Call_Depth : aliased Natural;

      Nobt48 :
            Boolean
               := False;
      Row_Pos356 :
            Token_Index
               := No_Token_Index;
      Defer_Pos551 :
            Token_Index
               := No_Token_Index;
      Defer_Res551 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos546 :
            Token_Index
               := No_Token_Index;
      Token_Res546 :
            Token_Index
               := No_Token_Index;
      Defer_Pos552 :
            Token_Index
               := No_Token_Index;
      Defer_Res552 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Row_Progress43 :
            Integer
               := 0;
      Transform_Res271 :
            Bare_Dotted_Name
               := No_Bare_Ada_Node;
      Transform_Has_Failed43 :
            Boolean
               := False;
      Transform_Diags271 :
            Ada.Containers.Count_Type;
      Defer_Pos553 :
            Token_Index
               := No_Token_Index;
      Defer_Res553 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Or_Pos117 :
            Token_Index
               := No_Token_Index;
      Or_Res117 :
            Bare_Name
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Static_Name_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res117 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res117;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res117;
   end if;

       Set (Parser.Private_Part.Static_Name_Or_Parse0_Memo, False, Or_Res117, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt48 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos117 := No_Token_Index;
Or_Res117 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags271 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos356 := Pos;



Defer_Res551 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos356);
Defer_Pos551 := Parser.Current_Pos;



Row_Progress43 := 1;

if Defer_Pos551 /= No_Token_Index then

   Row_Pos356 := Defer_Pos551;

else
   Row_Pos356 := No_Token_Index;
   goto Exit_Row356_0;

end if;


--  Start tok_code

Token_Res546 := Row_Pos356;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res546));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Dot)
   then
       Token_Pos546 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos356 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos356,
             Expected_Token_Id => Ada_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos546 := Row_Pos356 + 1;
   end if;
end;

--  End tok_code



Row_Progress43 := 2;

if Token_Pos546 /= No_Token_Index then

   Row_Pos356 := Token_Pos546;

else
   Row_Pos356 := No_Token_Index;
   goto Exit_Row356_0;

end if;

Nobt48 := True;

   Nobt48 := Nobt48;

Row_Progress43 := 3;

if Row_Pos356 /= No_Token_Index then

   Row_Pos356 := Row_Pos356;

else
   Row_Pos356 := No_Token_Index;
   goto Exit_Row356_0;

end if;


Defer_Res552 :=
   Direct_Name_Or_Parse0 (Parser, Row_Pos356);
Defer_Pos552 := Parser.Current_Pos;



Row_Progress43 := 4;

if Defer_Pos552 /= No_Token_Index then

   Row_Pos356 := Defer_Pos552;

else
   Row_Pos356 := No_Token_Index;
   goto Exit_Row356_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row356_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos356 = No_Token_Index and then Nobt48 then

   Row_Pos356 := Parser.Last_Fail.Pos;

   Transform_Has_Failed43 := True;
end if;

if Row_Pos356 /= No_Token_Index then

   Transform_Res271 := Allocate_Dotted_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res271,
      Kind => Ada_Dotted_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos356 = Pos
                            then No_Token_Index
                            else Row_Pos356 - 1));

      Initialize_Fields_For_Dotted_Name
        (Self => Transform_Res271, Dotted_Name_F_Prefix => Defer_Res551, Dotted_Name_F_Suffix => Defer_Res552);

         if Defer_Res551 /= null and then Is_Incomplete (Defer_Res551) then
            Transform_Res271.Last_Attempted_Child := 0;
         elsif Defer_Res551 /= null and then not Is_Ghost (Defer_Res551) then
            Transform_Res271.Last_Attempted_Child := -1;
         end if;
         if Defer_Res552 /= null and then Is_Incomplete (Defer_Res552) then
            Transform_Res271.Last_Attempted_Child := 0;
         elsif Defer_Res552 /= null and then not Is_Ghost (Defer_Res552) then
            Transform_Res271.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed43 then
      Transform_Res271.Last_Attempted_Child :=
         Row_Progress43;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <static_name>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos356 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags271);
end if;

--  End transform_code

    if Row_Pos356 /= No_Token_Index then
        Or_Pos117 := Row_Pos356;
        Or_Res117 := Transform_Res271;
        goto Exit_Or119;
    end if;
    
Defer_Res553 :=
   Direct_Name_Or_Parse0 (Parser, Pos);
Defer_Pos553 := Parser.Current_Pos;

    if Defer_Pos553 /= No_Token_Index then
        Or_Pos117 := Defer_Pos553;
        Or_Res117 := Defer_Res553;
        goto Exit_Or119;
    end if;
<<Exit_Or119>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos117 > Mem_Pos then
         Mem_Pos := Or_Pos117;
         Mem_Res := Or_Res117;
         Set
           (Parser.Private_Part.Static_Name_Or_Parse0_Memo,
            Or_Pos117 /= No_Token_Index,
            Or_Res117,
            Pos,
            Or_Pos117);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res117 := Mem_Res;
         Or_Pos117 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Static_Name_Or_Parse0_Memo,
      Or_Pos117 /= No_Token_Index,
      Or_Res117,
      Pos,
      Or_Pos117);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos117;

   Exit_Call (Parser, Call_Depth);
   return Or_Res117;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Static_Name_Or_Parse0;

   


function Stmt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos554 :
            Token_Index
               := No_Token_Index;
      Defer_Res554 :
            Bare_Composite_Stmt
               := No_Bare_Ada_Node;
      Defer_Pos555 :
            Token_Index
               := No_Token_Index;
      Defer_Res555 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Or_Pos118 :
            Token_Index
               := No_Token_Index;
      Or_Res118 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Stmt_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res118 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res118;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res118;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos118 := No_Token_Index;
Or_Res118 := No_Bare_Ada_Node;
    
Defer_Res554 :=
   Compound_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos554 := Parser.Current_Pos;

    if Defer_Pos554 /= No_Token_Index then
        Or_Pos118 := Defer_Pos554;
        Or_Res118 := Defer_Res554;
        goto Exit_Or120;
    end if;
    
Defer_Res555 :=
   Simple_Stmt_Or_Parse0 (Parser, Pos);
Defer_Pos555 := Parser.Current_Pos;

    if Defer_Pos555 /= No_Token_Index then
        Or_Pos118 := Defer_Pos555;
        Or_Res118 := Defer_Res555;
        goto Exit_Or120;
    end if;
<<Exit_Or120>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Stmt_Or_Parse0_Memo,
      Or_Pos118 /= No_Token_Index,
      Or_Res118,
      Pos,
      Or_Pos118);


   Parser.Current_Pos := Or_Pos118;

   Exit_Call (Parser, Call_Depth);
   return Or_Res118;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Stmt_Or_Parse0;

   


function Stmts_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Stmt_List
is
   use Bare_Stmt_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos48 :
            Token_Index
               := No_Token_Index;
      Tmp_List48 :
            Free_Parse_List;
      Defer_Pos556 :
            Token_Index
               := No_Token_Index;
      Defer_Res556 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Defer_Pos557 :
            Token_Index
               := No_Token_Index;
      Defer_Res557 :
            Bare_Label
               := No_Bare_Ada_Node;
      Row_Pos357 :
            Token_Index
               := No_Token_Index;
      Transform_Res272 :
            Bare_Error_Stmt
               := No_Bare_Ada_Node;
      Transform_Diags272 :
            Ada.Containers.Count_Type;
      Skip_Pos2 :
            Token_Index
               := No_Token_Index;
      Skip_Dummy2 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      Or_Pos119 :
            Token_Index
               := No_Token_Index;
      Or_Res119 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos48 :
            Token_Index
               := No_Token_Index;
      List_Res48 :
            Bare_Stmt_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Stmts_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res48 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res48;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res48;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos48 := Pos;



Lst_Cpos48 := Pos;
Tmp_List48 := Get_Parse_List (Parser);

loop
   
--  Start or_code

Or_Pos119 := No_Token_Index;
Or_Res119 := No_Bare_Ada_Node;
    
Defer_Res556 :=
   Stmt_Or_Parse0 (Parser, Lst_Cpos48);
Defer_Pos556 := Parser.Current_Pos;

    if Defer_Pos556 /= No_Token_Index then
        Or_Pos119 := Defer_Pos556;
        Or_Res119 := Defer_Res556;
        goto Exit_Or121;
    end if;
    
Defer_Res557 :=
   Label_Transform_Parse1 (Parser, Lst_Cpos48);
Defer_Pos557 := Parser.Current_Pos;

    if Defer_Pos557 /= No_Token_Index then
        Or_Pos119 := Defer_Pos557;
        Or_Res119 := Defer_Res557;
        goto Exit_Or121;
    end if;
    
if Get_Token (Parser.TDH.all, Lst_Cpos48).Kind
   = From_Token_Kind (Ada_Termination)
then
   Skip_Pos2 := No_Token_Index;
   goto Exit_Or122;
end if;

for Fn of Parser.Private_Part.Dont_Skip loop
   Skip_Dummy2 := Fn (Parser, Lst_Cpos48);

   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos2 := No_Token_Index;
      goto Exit_Or122;
   end if;
end loop;

Skip_Pos2 := Lst_Cpos48 + 1;

--  Start transform_code

Transform_Diags272 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos357 := Lst_Cpos48;


pragma Warnings (Off, "referenced");
<<Exit_Row357_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos357 /= No_Token_Index then

   Transform_Res272 := Allocate_Error_Stmt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res272,
      Kind => Ada_Error_Stmt,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos48,
      Token_End_Index   => (if Row_Pos357 = Lst_Cpos48
                            then No_Token_Index
                            else Row_Pos357 - 1));




elsif Row_Pos357 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags272);
end if;

--  End transform_code

Transform_Res272.Token_End_Index := Lst_Cpos48;

Append (Parser.Diagnostics,
        Sloc_Range (Parser.TDH.all,
                    Get_Token (Parser.TDH.all, Lst_Cpos48)),
        To_Text ("Skipped token ")
        & Common.Text
            (Wrap_Token_Reference
               (Parser.Unit.Context,
                Parser.TDH,
                (Lst_Cpos48, No_Token_Index))));

<<Exit_Or122>>

    if Skip_Pos2 /= No_Token_Index then
        Or_Pos119 := Skip_Pos2;
        Or_Res119 := Transform_Res272;
        goto Exit_Or121;
    end if;
<<Exit_Or121>>

--  End or_code


   exit when Or_Pos119 = No_Token_Index;

   List_Pos48 := Or_Pos119;
   Lst_Cpos48 := List_Pos48;

   Tmp_List48.Nodes.Append (Or_Res119);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List48.Nodes.Length;
begin
   List_Res48 :=
      Allocate_Stmt_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos48 = Pos
                    then Pos
                    else Lst_Cpos48 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res48,
      Kind              => Ada_Stmt_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res48,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List48.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res48.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List48);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Stmts_List_Parse0_Memo,
      List_Pos48 /= No_Token_Index,
      List_Res48,
      Pos,
      List_Pos48);


   Parser.Current_Pos := List_Pos48;

   Exit_Call (Parser, Call_Depth);
   return List_Res48;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Stmts_List_Parse0;

   


function String_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Literal
is
   use Bare_String_Literal_Memos;

   Call_Depth : aliased Natural;

      Row_Pos358 :
            Token_Index
               := No_Token_Index;
      Token_Pos547 :
            Token_Index
               := No_Token_Index;
      Token_Res547 :
            Token_Index
               := No_Token_Index;
      Transform_Res273 :
            Bare_String_Literal
               := No_Bare_Ada_Node;
      Transform_Diags273 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.String_Literal_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res273 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res273;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res273;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags273 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos358 := Pos;



--  Start tok_code

Token_Res547 := Row_Pos358;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res547));
begin
   if
      T.Kind /= From_Token_Kind (Ada_String)
   then
       Token_Pos547 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos358 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos358,
             Expected_Token_Id => Ada_String,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos547 := Row_Pos358 + 1;
   end if;
end;

--  End tok_code




if Token_Pos547 /= No_Token_Index then

   Row_Pos358 := Token_Pos547;

else
   Row_Pos358 := No_Token_Index;
   goto Exit_Row358_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row358_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos358 /= No_Token_Index then

   Transform_Res273 := Allocate_String_Literal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res273,
      Kind => Ada_String_Literal,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos358 = Pos
                            then No_Token_Index
                            else Row_Pos358 - 1));

      Initialize_Fields_For_String_Literal
        (Self => Transform_Res273);



elsif Row_Pos358 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags273);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.String_Literal_Transform_Parse0_Memo,
      Row_Pos358 /= No_Token_Index,
      Transform_Res273,
      Pos,
      Row_Pos358);


   Parser.Current_Pos := Row_Pos358;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res273;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end String_Literal_Transform_Parse0;

   


function Sub_Object_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Object_Decl
is
   use Bare_Object_Decl_Memos;

   Call_Depth : aliased Natural;

      Nobt49 :
            Boolean
               := False;
      Row_Pos359 :
            Token_Index
               := No_Token_Index;
      Defer_Pos558 :
            Token_Index
               := No_Token_Index;
      Defer_Res558 :
            Bare_Defining_Name_List
               := No_Bare_Ada_Node;
      Token_Pos548 :
            Token_Index
               := No_Token_Index;
      Token_Res548 :
            Token_Index
               := No_Token_Index;
      Token_Pos549 :
            Token_Index
               := No_Token_Index;
      Token_Res549 :
            Token_Index
               := No_Token_Index;
      Opt_Res28 :
            Bare_Aliased_Node
               := No_Bare_Ada_Node;
      Token_Pos550 :
            Token_Index
               := No_Token_Index;
      Token_Res550 :
            Token_Index
               := No_Token_Index;
      Opt_Res29 :
            Bare_Constant_Node
               := No_Bare_Ada_Node;
      Defer_Pos559 :
            Token_Index
               := No_Token_Index;
      Defer_Res559 :
            Bare_Mode
               := No_Bare_Ada_Node;
      Defer_Pos560 :
            Token_Index
               := No_Token_Index;
      Defer_Res560 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Row_Pos360 :
            Token_Index
               := No_Token_Index;
      Token_Pos551 :
            Token_Index
               := No_Token_Index;
      Token_Res551 :
            Token_Index
               := No_Token_Index;
      Defer_Pos561 :
            Token_Index
               := No_Token_Index;
      Defer_Res561 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos562 :
            Token_Index
               := No_Token_Index;
      Defer_Res562 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Defer_Pos563 :
            Token_Index
               := No_Token_Index;
      Defer_Res563 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos552 :
            Token_Index
               := No_Token_Index;
      Token_Res552 :
            Token_Index
               := No_Token_Index;
      Row_Progress44 :
            Integer
               := 0;
      Transform_Res274 :
            Bare_Object_Decl
               := No_Bare_Ada_Node;
      Transform_Has_Failed44 :
            Boolean
               := False;
      Transform_Diags274 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Sub_Object_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res274 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res274;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res274;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags274 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos359 := Pos;



Defer_Res558 :=
   Defining_Id_List_List_Parse0 (Parser, Row_Pos359);
Defer_Pos558 := Parser.Current_Pos;



Row_Progress44 := 1;

if Defer_Pos558 /= No_Token_Index then

   Row_Pos359 := Defer_Pos558;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start tok_code

Token_Res548 := Row_Pos359;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res548));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Colon)
   then
       Token_Pos548 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos359 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos359,
             Expected_Token_Id => Ada_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos548 := Row_Pos359 + 1;
   end if;
end;

--  End tok_code



Row_Progress44 := 2;

if Token_Pos548 /= No_Token_Index then

   Row_Pos359 := Token_Pos548;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res549 := Row_Pos359;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res549));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Aliased)
   then
       Token_Pos549 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos359 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos359,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos549 := Row_Pos359 + 1;
   end if;
end;

--  End tok_code


if Token_Pos549 = No_Token_Index then

         Opt_Res28 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res28,
            Kind              => Ada_Aliased_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos359,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos549 := Row_Pos359;


else

      Opt_Res28 := Allocate_Aliased_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res28,
         Kind              => Ada_Aliased_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos359,
         Token_End_Index   => Token_Pos549 - 1);

end if;

--  End opt_code



Row_Progress44 := 3;

if Token_Pos549 /= No_Token_Index then

   Row_Pos359 := Token_Pos549;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res550 := Row_Pos359;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res550));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Constant)
   then
       Token_Pos550 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos359 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos359,
             Expected_Token_Id => Ada_Constant,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos550 := Row_Pos359 + 1;
   end if;
end;

--  End tok_code


if Token_Pos550 = No_Token_Index then

         Opt_Res29 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res29,
            Kind              => Ada_Constant_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos359,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos550 := Row_Pos359;


else

      Opt_Res29 := Allocate_Constant_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res29,
         Kind              => Ada_Constant_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos359,
         Token_End_Index   => Token_Pos550 - 1);

end if;

--  End opt_code



Row_Progress44 := 4;

if Token_Pos550 /= No_Token_Index then

   Row_Pos359 := Token_Pos550;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start opt_code












Defer_Res559 :=
   Mode_Or_Parse0 (Parser, Row_Pos359);
Defer_Pos559 := Parser.Current_Pos;


if Defer_Pos559 = No_Token_Index then

         
   Defer_Res559 := No_Bare_Ada_Node;



       
   Defer_Pos559 := Row_Pos359;



end if;

--  End opt_code



Row_Progress44 := 5;

if Defer_Pos559 /= No_Token_Index then

   Row_Pos359 := Defer_Pos559;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


Defer_Res560 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos359);
Defer_Pos560 := Parser.Current_Pos;



Row_Progress44 := 6;

if Defer_Pos560 /= No_Token_Index then

   Row_Pos359 := Defer_Pos560;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;

Nobt49 := True;

   Nobt49 := Nobt49;

Row_Progress44 := 7;

if Row_Pos359 /= No_Token_Index then

   Row_Pos359 := Row_Pos359;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos360 := Row_Pos359;



--  Start tok_code

Token_Res551 := Row_Pos360;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res551));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Assign)
   then
       Token_Pos551 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos360 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos360,
             Expected_Token_Id => Ada_Assign,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos551 := Row_Pos360 + 1;
   end if;
end;

--  End tok_code




if Token_Pos551 /= No_Token_Index then

   Row_Pos360 := Token_Pos551;

else
   Row_Pos360 := No_Token_Index;
   goto Exit_Row360_0;

end if;


Defer_Res561 :=
   Expr_Or_Parse0 (Parser, Row_Pos360);
Defer_Pos561 := Parser.Current_Pos;




if Defer_Pos561 /= No_Token_Index then

   Row_Pos360 := Defer_Pos561;

else
   Row_Pos360 := No_Token_Index;
   goto Exit_Row360_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row360_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos360 = No_Token_Index then

         
   Defer_Res561 := No_Bare_Ada_Node;



       
   Row_Pos360 := Row_Pos359;



end if;

--  End opt_code



Row_Progress44 := 8;

if Row_Pos360 /= No_Token_Index then

   Row_Pos359 := Row_Pos360;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start opt_code












Defer_Res562 :=
   Renaming_Clause_Transform_Parse0 (Parser, Row_Pos359);
Defer_Pos562 := Parser.Current_Pos;


if Defer_Pos562 = No_Token_Index then

         
   Defer_Res562 := No_Bare_Ada_Node;



       
   Defer_Pos562 := Row_Pos359;



end if;

--  End opt_code



Row_Progress44 := 9;

if Defer_Pos562 /= No_Token_Index then

   Row_Pos359 := Defer_Pos562;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


Defer_Res563 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos359);
Defer_Pos563 := Parser.Current_Pos;



Row_Progress44 := 10;

if Defer_Pos563 /= No_Token_Index then

   Row_Pos359 := Defer_Pos563;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;


--  Start tok_code

Token_Res552 := Row_Pos359;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res552));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos552 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos359 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos359,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos552 := Row_Pos359 + 1;
   end if;
end;

--  End tok_code



Row_Progress44 := 11;

if Token_Pos552 /= No_Token_Index then

   Row_Pos359 := Token_Pos552;

else
   Row_Pos359 := No_Token_Index;
   goto Exit_Row359_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row359_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos359 = No_Token_Index and then Nobt49 then

   Row_Pos359 := Parser.Last_Fail.Pos;

   Transform_Has_Failed44 := True;
end if;

if Row_Pos359 /= No_Token_Index then

   Transform_Res274 := Allocate_Object_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res274,
      Kind => Ada_Object_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos359 = Pos
                            then No_Token_Index
                            else Row_Pos359 - 1));

      Initialize_Fields_For_Object_Decl
        (Self => Transform_Res274, Object_Decl_F_Ids => Defer_Res558, Object_Decl_F_Has_Aliased => Opt_Res28, Object_Decl_F_Has_Constant => Opt_Res29, Object_Decl_F_Mode => Defer_Res559, Object_Decl_F_Type_Expr => Defer_Res560, Object_Decl_F_Default_Expr => Defer_Res561, Object_Decl_F_Renaming_Clause => Defer_Res562, Object_Decl_F_Aspects => Defer_Res563);

         if Defer_Res558 /= null and then Is_Incomplete (Defer_Res558) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Defer_Res558 /= null and then not Is_Ghost (Defer_Res558) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Opt_Res28 /= null and then Is_Incomplete (Opt_Res28) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Opt_Res28 /= null and then not Is_Ghost (Opt_Res28) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Opt_Res29 /= null and then Is_Incomplete (Opt_Res29) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Opt_Res29 /= null and then not Is_Ghost (Opt_Res29) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Defer_Res559 /= null and then Is_Incomplete (Defer_Res559) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Defer_Res559 /= null and then not Is_Ghost (Defer_Res559) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Defer_Res560 /= null and then Is_Incomplete (Defer_Res560) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Defer_Res560 /= null and then not Is_Ghost (Defer_Res560) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Defer_Res561 /= null and then Is_Incomplete (Defer_Res561) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Defer_Res561 /= null and then not Is_Ghost (Defer_Res561) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Defer_Res562 /= null and then Is_Incomplete (Defer_Res562) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Defer_Res562 /= null and then not Is_Ghost (Defer_Res562) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;
         if Defer_Res563 /= null and then Is_Incomplete (Defer_Res563) then
            Transform_Res274.Last_Attempted_Child := 0;
         elsif Defer_Res563 /= null and then not Is_Ghost (Defer_Res563) then
            Transform_Res274.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed44 then
      Transform_Res274.Last_Attempted_Child :=
         Row_Progress44;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <sub_object_decl>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos359 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags274);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Sub_Object_Decl_Transform_Parse0_Memo,
      Row_Pos359 /= No_Token_Index,
      Transform_Res274,
      Pos,
      Row_Pos359);


   Parser.Current_Pos := Row_Pos359;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res274;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Sub_Object_Decl_Transform_Parse0;

   


function Subp_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Body
is
   use Bare_Subp_Body_Memos;

   Call_Depth : aliased Natural;

      Nobt50 :
            Boolean
               := False;
      Row_Pos361 :
            Token_Index
               := No_Token_Index;
      Defer_Pos564 :
            Token_Index
               := No_Token_Index;
      Defer_Res564 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos565 :
            Token_Index
               := No_Token_Index;
      Defer_Res565 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Defer_Pos566 :
            Token_Index
               := No_Token_Index;
      Defer_Res566 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos553 :
            Token_Index
               := No_Token_Index;
      Token_Res553 :
            Token_Index
               := No_Token_Index;
      Defer_Pos567 :
            Token_Index
               := No_Token_Index;
      Defer_Res567 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Token_Pos554 :
            Token_Index
               := No_Token_Index;
      Token_Res554 :
            Token_Index
               := No_Token_Index;
      Defer_Pos568 :
            Token_Index
               := No_Token_Index;
      Defer_Res568 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos362 :
            Token_Index
               := No_Token_Index;
      Token_Pos555 :
            Token_Index
               := No_Token_Index;
      Token_Res555 :
            Token_Index
               := No_Token_Index;
      Row_Pos363 :
            Token_Index
               := No_Token_Index;
      Defer_Pos569 :
            Token_Index
               := No_Token_Index;
      Defer_Res569 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res275 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags275 :
            Ada.Containers.Count_Type;
      Token_Pos556 :
            Token_Index
               := No_Token_Index;
      Token_Res556 :
            Token_Index
               := No_Token_Index;
      Row_Progress45 :
            Integer
               := 0;
      Transform_Res276 :
            Bare_Subp_Body
               := No_Bare_Ada_Node;
      Transform_Has_Failed45 :
            Boolean
               := False;
      Transform_Diags276 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subp_Body_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res276 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res276;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res276;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags276 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos361 := Pos;



Defer_Res564 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos361);
Defer_Pos564 := Parser.Current_Pos;



Row_Progress45 := 1;

if Defer_Pos564 /= No_Token_Index then

   Row_Pos361 := Defer_Pos564;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


Defer_Res565 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos361);
Defer_Pos565 := Parser.Current_Pos;



Row_Progress45 := 2;

if Defer_Pos565 /= No_Token_Index then

   Row_Pos361 := Defer_Pos565;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


Defer_Res566 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos361);
Defer_Pos566 := Parser.Current_Pos;



Row_Progress45 := 3;

if Defer_Pos566 /= No_Token_Index then

   Row_Pos361 := Defer_Pos566;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


--  Start tok_code

Token_Res553 := Row_Pos361;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res553));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos553 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos361 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos361,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos553 := Row_Pos361 + 1;
   end if;
end;

--  End tok_code



Row_Progress45 := 4;

if Token_Pos553 /= No_Token_Index then

   Row_Pos361 := Token_Pos553;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;

Nobt50 := True;

   Nobt50 := Nobt50;

Row_Progress45 := 5;

if Row_Pos361 /= No_Token_Index then

   Row_Pos361 := Row_Pos361;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


Defer_Res567 :=
   Recov_Decl_Part_Dont_Skip_Parse0 (Parser, Row_Pos361);
Defer_Pos567 := Parser.Current_Pos;



Row_Progress45 := 6;

if Defer_Pos567 /= No_Token_Index then

   Row_Pos361 := Defer_Pos567;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


--  Start tok_code

Token_Res554 := Row_Pos361;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res554));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos554 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos361 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos361,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos554 := Row_Pos361 + 1;
   end if;
end;

--  End tok_code



Row_Progress45 := 7;

if Token_Pos554 /= No_Token_Index then

   Row_Pos361 := Token_Pos554;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


Defer_Res568 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos361);
Defer_Pos568 := Parser.Current_Pos;



Row_Progress45 := 8;

if Defer_Pos568 /= No_Token_Index then

   Row_Pos361 := Defer_Pos568;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


--  Start row_code

Row_Pos362 := Row_Pos361;



--  Start tok_code

Token_Res555 := Row_Pos362;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res555));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos555 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos362 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos362,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos555 := Row_Pos362 + 1;
   end if;
end;

--  End tok_code




if Token_Pos555 /= No_Token_Index then

   Row_Pos362 := Token_Pos555;

else
   Row_Pos362 := No_Token_Index;
   goto Exit_Row362_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags275 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos363 := Row_Pos362;



Defer_Res569 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos363);
Defer_Pos569 := Parser.Current_Pos;




if Defer_Pos569 /= No_Token_Index then

   Row_Pos363 := Defer_Pos569;

else
   Row_Pos363 := No_Token_Index;
   goto Exit_Row363_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row363_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos363 /= No_Token_Index then

   Transform_Res275 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res275,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos362,
      Token_End_Index   => (if Row_Pos363 = Row_Pos362
                            then No_Token_Index
                            else Row_Pos363 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res275, End_Name_F_Name => Defer_Res569);

         if Defer_Res569 /= null and then Is_Incomplete (Defer_Res569) then
            Transform_Res275.Last_Attempted_Child := 0;
         elsif Defer_Res569 /= null and then not Is_Ghost (Defer_Res569) then
            Transform_Res275.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos363 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags275);
end if;

--  End transform_code


if Row_Pos363 = No_Token_Index then

         
   Transform_Res275 := No_Bare_Ada_Node;



       
   Row_Pos363 := Row_Pos362;



end if;

--  End opt_code




if Row_Pos363 /= No_Token_Index then

   Row_Pos362 := Row_Pos363;

else
   Row_Pos362 := No_Token_Index;
   goto Exit_Row362_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row362_0>>
pragma Warnings (On, "referenced");

--  End row_code



Row_Progress45 := 9;

if Row_Pos362 /= No_Token_Index then

   Row_Pos361 := Row_Pos362;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;


--  Start tok_code

Token_Res556 := Row_Pos361;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res556));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos556 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos361 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos361,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos556 := Row_Pos361 + 1;
   end if;
end;

--  End tok_code



Row_Progress45 := 10;

if Token_Pos556 /= No_Token_Index then

   Row_Pos361 := Token_Pos556;

else
   Row_Pos361 := No_Token_Index;
   goto Exit_Row361_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row361_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos361 = No_Token_Index and then Nobt50 then

   Row_Pos361 := Parser.Last_Fail.Pos;

   Transform_Has_Failed45 := True;
end if;

if Row_Pos361 /= No_Token_Index then

   Transform_Res276 := Allocate_Subp_Body (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res276,
      Kind => Ada_Subp_Body,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos361 = Pos
                            then No_Token_Index
                            else Row_Pos361 - 1));

      Initialize_Fields_For_Subp_Body
        (Self => Transform_Res276, Base_Subp_Body_F_Overriding => Defer_Res564, Base_Subp_Body_F_Subp_Spec => Defer_Res565, Subp_Body_F_Aspects => Defer_Res566, Subp_Body_F_Decls => Defer_Res567, Subp_Body_F_Stmts => Defer_Res568, Subp_Body_F_End_Name => Transform_Res275);

         if Defer_Res564 /= null and then Is_Incomplete (Defer_Res564) then
            Transform_Res276.Last_Attempted_Child := 0;
         elsif Defer_Res564 /= null and then not Is_Ghost (Defer_Res564) then
            Transform_Res276.Last_Attempted_Child := -1;
         end if;
         if Defer_Res565 /= null and then Is_Incomplete (Defer_Res565) then
            Transform_Res276.Last_Attempted_Child := 0;
         elsif Defer_Res565 /= null and then not Is_Ghost (Defer_Res565) then
            Transform_Res276.Last_Attempted_Child := -1;
         end if;
         if Defer_Res566 /= null and then Is_Incomplete (Defer_Res566) then
            Transform_Res276.Last_Attempted_Child := 0;
         elsif Defer_Res566 /= null and then not Is_Ghost (Defer_Res566) then
            Transform_Res276.Last_Attempted_Child := -1;
         end if;
         if Defer_Res567 /= null and then Is_Incomplete (Defer_Res567) then
            Transform_Res276.Last_Attempted_Child := 0;
         elsif Defer_Res567 /= null and then not Is_Ghost (Defer_Res567) then
            Transform_Res276.Last_Attempted_Child := -1;
         end if;
         if Defer_Res568 /= null and then Is_Incomplete (Defer_Res568) then
            Transform_Res276.Last_Attempted_Child := 0;
         elsif Defer_Res568 /= null and then not Is_Ghost (Defer_Res568) then
            Transform_Res276.Last_Attempted_Child := -1;
         end if;
         if Transform_Res275 /= null and then Is_Incomplete (Transform_Res275) then
            Transform_Res276.Last_Attempted_Child := 0;
         elsif Transform_Res275 /= null and then not Is_Ghost (Transform_Res275) then
            Transform_Res276.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed45 then
      Transform_Res276.Last_Attempted_Child :=
         Row_Progress45;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <subp_body>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos361 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags276);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subp_Body_Transform_Parse1_Memo,
      Row_Pos361 /= No_Token_Index,
      Transform_Res276,
      Pos,
      Row_Pos361);


   Parser.Current_Pos := Row_Pos361;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res276;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subp_Body_Transform_Parse1;

   


function Subp_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Body_Stub
is
   use Bare_Subp_Body_Stub_Memos;

   Call_Depth : aliased Natural;

      Row_Pos364 :
            Token_Index
               := No_Token_Index;
      Defer_Pos570 :
            Token_Index
               := No_Token_Index;
      Defer_Res570 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos571 :
            Token_Index
               := No_Token_Index;
      Defer_Res571 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Token_Pos557 :
            Token_Index
               := No_Token_Index;
      Token_Res557 :
            Token_Index
               := No_Token_Index;
      Token_Pos558 :
            Token_Index
               := No_Token_Index;
      Token_Res558 :
            Token_Index
               := No_Token_Index;
      Defer_Pos572 :
            Token_Index
               := No_Token_Index;
      Defer_Res572 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos559 :
            Token_Index
               := No_Token_Index;
      Token_Res559 :
            Token_Index
               := No_Token_Index;
      Transform_Res277 :
            Bare_Subp_Body_Stub
               := No_Bare_Ada_Node;
      Transform_Diags277 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subp_Body_Stub_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res277 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res277;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res277;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags277 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos364 := Pos;



Defer_Res570 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos364);
Defer_Pos570 := Parser.Current_Pos;




if Defer_Pos570 /= No_Token_Index then

   Row_Pos364 := Defer_Pos570;

else
   Row_Pos364 := No_Token_Index;
   goto Exit_Row364_0;

end if;


Defer_Res571 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos364);
Defer_Pos571 := Parser.Current_Pos;




if Defer_Pos571 /= No_Token_Index then

   Row_Pos364 := Defer_Pos571;

else
   Row_Pos364 := No_Token_Index;
   goto Exit_Row364_0;

end if;


--  Start tok_code

Token_Res557 := Row_Pos364;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res557));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos557 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos364 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos364,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos557 := Row_Pos364 + 1;
   end if;
end;

--  End tok_code




if Token_Pos557 /= No_Token_Index then

   Row_Pos364 := Token_Pos557;

else
   Row_Pos364 := No_Token_Index;
   goto Exit_Row364_0;

end if;


--  Start tok_code

Token_Res558 := Row_Pos364;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res558));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Separate)
   then
       Token_Pos558 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos364 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos364,
             Expected_Token_Id => Ada_Separate,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos558 := Row_Pos364 + 1;
   end if;
end;

--  End tok_code




if Token_Pos558 /= No_Token_Index then

   Row_Pos364 := Token_Pos558;

else
   Row_Pos364 := No_Token_Index;
   goto Exit_Row364_0;

end if;


Defer_Res572 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos364);
Defer_Pos572 := Parser.Current_Pos;




if Defer_Pos572 /= No_Token_Index then

   Row_Pos364 := Defer_Pos572;

else
   Row_Pos364 := No_Token_Index;
   goto Exit_Row364_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res559 := Row_Pos364;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res559));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos559 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos364 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos364,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos559 := Row_Pos364 + 1;
   end if;
end;

--  End tok_code


if Token_Pos559 = No_Token_Index then

         
   Token_Res559 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos364)),
                To_Text ("Missing ';'"));

       
   Token_Pos559 := Row_Pos364;



end if;

--  End opt_code




if Token_Pos559 /= No_Token_Index then

   Row_Pos364 := Token_Pos559;

else
   Row_Pos364 := No_Token_Index;
   goto Exit_Row364_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row364_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos364 /= No_Token_Index then

   Transform_Res277 := Allocate_Subp_Body_Stub (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res277,
      Kind => Ada_Subp_Body_Stub,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos364 = Pos
                            then No_Token_Index
                            else Row_Pos364 - 1));

      Initialize_Fields_For_Subp_Body_Stub
        (Self => Transform_Res277, Subp_Body_Stub_F_Overriding => Defer_Res570, Subp_Body_Stub_F_Subp_Spec => Defer_Res571, Subp_Body_Stub_F_Aspects => Defer_Res572);

         if Defer_Res570 /= null and then Is_Incomplete (Defer_Res570) then
            Transform_Res277.Last_Attempted_Child := 0;
         elsif Defer_Res570 /= null and then not Is_Ghost (Defer_Res570) then
            Transform_Res277.Last_Attempted_Child := -1;
         end if;
         if Defer_Res571 /= null and then Is_Incomplete (Defer_Res571) then
            Transform_Res277.Last_Attempted_Child := 0;
         elsif Defer_Res571 /= null and then not Is_Ghost (Defer_Res571) then
            Transform_Res277.Last_Attempted_Child := -1;
         end if;
         if Defer_Res572 /= null and then Is_Incomplete (Defer_Res572) then
            Transform_Res277.Last_Attempted_Child := 0;
         elsif Defer_Res572 /= null and then not Is_Ghost (Defer_Res572) then
            Transform_Res277.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos364 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags277);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subp_Body_Stub_Transform_Parse0_Memo,
      Row_Pos364 /= No_Token_Index,
      Transform_Res277,
      Pos,
      Row_Pos364);


   Parser.Current_Pos := Row_Pos364;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res277;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subp_Body_Stub_Transform_Parse0;

   


function Subp_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Basic_Decl
is
   use Bare_Basic_Decl_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos573 :
            Token_Index
               := No_Token_Index;
      Defer_Res573 :
            Bare_Null_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos574 :
            Token_Index
               := No_Token_Index;
      Defer_Res574 :
            Bare_Abstract_Subp_Decl
               := No_Bare_Ada_Node;
      Defer_Pos575 :
            Token_Index
               := No_Token_Index;
      Defer_Res575 :
            Bare_Expr_Function
               := No_Bare_Ada_Node;
      Defer_Pos576 :
            Token_Index
               := No_Token_Index;
      Defer_Res576 :
            Bare_Subp_Renaming_Decl
               := No_Bare_Ada_Node;
      Defer_Pos577 :
            Token_Index
               := No_Token_Index;
      Defer_Res577 :
            Bare_Subp_Decl
               := No_Bare_Ada_Node;
      Or_Pos120 :
            Token_Index
               := No_Token_Index;
      Or_Res120 :
            Bare_Basic_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Subp_Decl_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res120 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res120;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res120;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos120 := No_Token_Index;
Or_Res120 := No_Bare_Ada_Node;
    
Defer_Res573 :=
   Null_Subp_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos573 := Parser.Current_Pos;

    if Defer_Pos573 /= No_Token_Index then
        Or_Pos120 := Defer_Pos573;
        Or_Res120 := Defer_Res573;
        goto Exit_Or123;
    end if;
    
Defer_Res574 :=
   Abstract_Subp_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos574 := Parser.Current_Pos;

    if Defer_Pos574 /= No_Token_Index then
        Or_Pos120 := Defer_Pos574;
        Or_Res120 := Defer_Res574;
        goto Exit_Or123;
    end if;
    
Defer_Res575 :=
   Expr_Fn_Transform_Parse0 (Parser, Pos);
Defer_Pos575 := Parser.Current_Pos;

    if Defer_Pos575 /= No_Token_Index then
        Or_Pos120 := Defer_Pos575;
        Or_Res120 := Defer_Res575;
        goto Exit_Or123;
    end if;
    
Defer_Res576 :=
   Subp_Renaming_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos576 := Parser.Current_Pos;

    if Defer_Pos576 /= No_Token_Index then
        Or_Pos120 := Defer_Pos576;
        Or_Res120 := Defer_Res576;
        goto Exit_Or123;
    end if;
    
Defer_Res577 :=
   Simple_Subp_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos577 := Parser.Current_Pos;

    if Defer_Pos577 /= No_Token_Index then
        Or_Pos120 := Defer_Pos577;
        Or_Res120 := Defer_Res577;
        goto Exit_Or123;
    end if;
<<Exit_Or123>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subp_Decl_Or_Parse0_Memo,
      Or_Pos120 /= No_Token_Index,
      Or_Res120,
      Pos,
      Or_Pos120);


   Parser.Current_Pos := Or_Pos120;

   Exit_Call (Parser, Call_Depth);
   return Or_Res120;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subp_Decl_Or_Parse0;

   


function Subp_Renaming_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Renaming_Decl
is
   use Bare_Subp_Renaming_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos365 :
            Token_Index
               := No_Token_Index;
      Defer_Pos578 :
            Token_Index
               := No_Token_Index;
      Defer_Res578 :
            Bare_Overriding_Node
               := No_Bare_Ada_Node;
      Defer_Pos579 :
            Token_Index
               := No_Token_Index;
      Defer_Res579 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Defer_Pos580 :
            Token_Index
               := No_Token_Index;
      Defer_Res580 :
            Bare_Renaming_Clause
               := No_Bare_Ada_Node;
      Defer_Pos581 :
            Token_Index
               := No_Token_Index;
      Defer_Res581 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos560 :
            Token_Index
               := No_Token_Index;
      Token_Res560 :
            Token_Index
               := No_Token_Index;
      Transform_Res278 :
            Bare_Subp_Renaming_Decl
               := No_Bare_Ada_Node;
      Transform_Diags278 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subp_Renaming_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res278 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res278;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res278;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags278 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos365 := Pos;



Defer_Res578 :=
   Overriding_Indicator_Or_Parse0 (Parser, Row_Pos365);
Defer_Pos578 := Parser.Current_Pos;




if Defer_Pos578 /= No_Token_Index then

   Row_Pos365 := Defer_Pos578;

else
   Row_Pos365 := No_Token_Index;
   goto Exit_Row365_0;

end if;


Defer_Res579 :=
   Subp_Spec_Transform_Parse2 (Parser, Row_Pos365);
Defer_Pos579 := Parser.Current_Pos;




if Defer_Pos579 /= No_Token_Index then

   Row_Pos365 := Defer_Pos579;

else
   Row_Pos365 := No_Token_Index;
   goto Exit_Row365_0;

end if;


Defer_Res580 :=
   Renaming_Clause_Transform_Parse0 (Parser, Row_Pos365);
Defer_Pos580 := Parser.Current_Pos;




if Defer_Pos580 /= No_Token_Index then

   Row_Pos365 := Defer_Pos580;

else
   Row_Pos365 := No_Token_Index;
   goto Exit_Row365_0;

end if;


Defer_Res581 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos365);
Defer_Pos581 := Parser.Current_Pos;




if Defer_Pos581 /= No_Token_Index then

   Row_Pos365 := Defer_Pos581;

else
   Row_Pos365 := No_Token_Index;
   goto Exit_Row365_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res560 := Row_Pos365;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res560));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos560 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos365 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos365,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos560 := Row_Pos365 + 1;
   end if;
end;

--  End tok_code


if Token_Pos560 = No_Token_Index then

         
   Token_Res560 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos365)),
                To_Text ("Missing ';'"));

       
   Token_Pos560 := Row_Pos365;



end if;

--  End opt_code




if Token_Pos560 /= No_Token_Index then

   Row_Pos365 := Token_Pos560;

else
   Row_Pos365 := No_Token_Index;
   goto Exit_Row365_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row365_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos365 /= No_Token_Index then

   Transform_Res278 := Allocate_Subp_Renaming_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res278,
      Kind => Ada_Subp_Renaming_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos365 = Pos
                            then No_Token_Index
                            else Row_Pos365 - 1));

      Initialize_Fields_For_Subp_Renaming_Decl
        (Self => Transform_Res278, Base_Subp_Body_F_Overriding => Defer_Res578, Base_Subp_Body_F_Subp_Spec => Defer_Res579, Subp_Renaming_Decl_F_Renames => Defer_Res580, Subp_Renaming_Decl_F_Aspects => Defer_Res581);

         if Defer_Res578 /= null and then Is_Incomplete (Defer_Res578) then
            Transform_Res278.Last_Attempted_Child := 0;
         elsif Defer_Res578 /= null and then not Is_Ghost (Defer_Res578) then
            Transform_Res278.Last_Attempted_Child := -1;
         end if;
         if Defer_Res579 /= null and then Is_Incomplete (Defer_Res579) then
            Transform_Res278.Last_Attempted_Child := 0;
         elsif Defer_Res579 /= null and then not Is_Ghost (Defer_Res579) then
            Transform_Res278.Last_Attempted_Child := -1;
         end if;
         if Defer_Res580 /= null and then Is_Incomplete (Defer_Res580) then
            Transform_Res278.Last_Attempted_Child := 0;
         elsif Defer_Res580 /= null and then not Is_Ghost (Defer_Res580) then
            Transform_Res278.Last_Attempted_Child := -1;
         end if;
         if Defer_Res581 /= null and then Is_Incomplete (Defer_Res581) then
            Transform_Res278.Last_Attempted_Child := 0;
         elsif Defer_Res581 /= null and then not Is_Ghost (Defer_Res581) then
            Transform_Res278.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos365 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags278);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subp_Renaming_Decl_Transform_Parse0_Memo,
      Row_Pos365 /= No_Token_Index,
      Transform_Res278,
      Pos,
      Row_Pos365);


   Parser.Current_Pos := Row_Pos365;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res278;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subp_Renaming_Decl_Transform_Parse0;

   


function Subp_Spec_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subp_Spec
is
   use Bare_Subp_Spec_Memos;

   Call_Depth : aliased Natural;

      Row_Pos366 :
            Token_Index
               := No_Token_Index;
      Row_Pos367 :
            Token_Index
               := No_Token_Index;
      Token_Pos561 :
            Token_Index
               := No_Token_Index;
      Token_Res561 :
            Token_Index
               := No_Token_Index;
      Transform_Res279 :
            Bare_Subp_Kind_Procedure
               := No_Bare_Ada_Node;
      Transform_Diags279 :
            Ada.Containers.Count_Type;
      Row_Pos368 :
            Token_Index
               := No_Token_Index;
      Token_Pos562 :
            Token_Index
               := No_Token_Index;
      Token_Res562 :
            Token_Index
               := No_Token_Index;
      Transform_Res280 :
            Bare_Subp_Kind_Function
               := No_Bare_Ada_Node;
      Transform_Diags280 :
            Ada.Containers.Count_Type;
      Or_Pos121 :
            Token_Index
               := No_Token_Index;
      Or_Res121 :
            Bare_Subp_Kind
               := No_Bare_Ada_Node;
      Defer_Pos582 :
            Token_Index
               := No_Token_Index;
      Defer_Res582 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos583 :
            Token_Index
               := No_Token_Index;
      Defer_Res583 :
            Bare_Params
               := No_Bare_Ada_Node;
      Row_Pos369 :
            Token_Index
               := No_Token_Index;
      Token_Pos563 :
            Token_Index
               := No_Token_Index;
      Token_Res563 :
            Token_Index
               := No_Token_Index;
      Defer_Pos584 :
            Token_Index
               := No_Token_Index;
      Defer_Res584 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;
      Transform_Res281 :
            Bare_Subp_Spec
               := No_Bare_Ada_Node;
      Transform_Diags281 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subp_Spec_Transform_Parse2_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res281 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res281;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res281;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags281 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos366 := Pos;



--  Start or_code

Or_Pos121 := No_Token_Index;
Or_Res121 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags279 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos367 := Row_Pos366;



--  Start tok_code

Token_Res561 := Row_Pos367;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res561));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Procedure)
   then
       Token_Pos561 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos367 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos367,
             Expected_Token_Id => Ada_Procedure,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos561 := Row_Pos367 + 1;
   end if;
end;

--  End tok_code




if Token_Pos561 /= No_Token_Index then

   Row_Pos367 := Token_Pos561;

else
   Row_Pos367 := No_Token_Index;
   goto Exit_Row367_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row367_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos367 /= No_Token_Index then

   Transform_Res279 := Allocate_Subp_Kind_Procedure (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res279,
      Kind => Ada_Subp_Kind_Procedure,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos366,
      Token_End_Index   => (if Row_Pos367 = Row_Pos366
                            then No_Token_Index
                            else Row_Pos367 - 1));




elsif Row_Pos367 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags279);
end if;

--  End transform_code

    if Row_Pos367 /= No_Token_Index then
        Or_Pos121 := Row_Pos367;
        Or_Res121 := Transform_Res279;
        goto Exit_Or124;
    end if;
    
--  Start transform_code

Transform_Diags280 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos368 := Row_Pos366;



--  Start tok_code

Token_Res562 := Row_Pos368;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res562));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Function)
   then
       Token_Pos562 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos368 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos368,
             Expected_Token_Id => Ada_Function,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos562 := Row_Pos368 + 1;
   end if;
end;

--  End tok_code




if Token_Pos562 /= No_Token_Index then

   Row_Pos368 := Token_Pos562;

else
   Row_Pos368 := No_Token_Index;
   goto Exit_Row368_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row368_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos368 /= No_Token_Index then

   Transform_Res280 := Allocate_Subp_Kind_Function (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res280,
      Kind => Ada_Subp_Kind_Function,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos366,
      Token_End_Index   => (if Row_Pos368 = Row_Pos366
                            then No_Token_Index
                            else Row_Pos368 - 1));




elsif Row_Pos368 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags280);
end if;

--  End transform_code

    if Row_Pos368 /= No_Token_Index then
        Or_Pos121 := Row_Pos368;
        Or_Res121 := Transform_Res280;
        goto Exit_Or124;
    end if;
<<Exit_Or124>>

--  End or_code




if Or_Pos121 /= No_Token_Index then

   Row_Pos366 := Or_Pos121;

else
   Row_Pos366 := No_Token_Index;
   goto Exit_Row366_0;

end if;


--  Start opt_code












Defer_Res582 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos366);
Defer_Pos582 := Parser.Current_Pos;


if Defer_Pos582 = No_Token_Index then

         
   Defer_Res582 := No_Bare_Ada_Node;



       
   Defer_Pos582 := Row_Pos366;



end if;

--  End opt_code




if Defer_Pos582 /= No_Token_Index then

   Row_Pos366 := Defer_Pos582;

else
   Row_Pos366 := No_Token_Index;
   goto Exit_Row366_0;

end if;


--  Start opt_code












Defer_Res583 :=
   Param_Specs_Transform_Parse0 (Parser, Row_Pos366);
Defer_Pos583 := Parser.Current_Pos;


if Defer_Pos583 = No_Token_Index then

         
   Defer_Res583 := No_Bare_Ada_Node;



       
   Defer_Pos583 := Row_Pos366;



end if;

--  End opt_code




if Defer_Pos583 /= No_Token_Index then

   Row_Pos366 := Defer_Pos583;

else
   Row_Pos366 := No_Token_Index;
   goto Exit_Row366_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos369 := Row_Pos366;



--  Start tok_code

Token_Res563 := Row_Pos369;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res563));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Return)
   then
       Token_Pos563 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos369 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos369,
             Expected_Token_Id => Ada_Return,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos563 := Row_Pos369 + 1;
   end if;
end;

--  End tok_code




if Token_Pos563 /= No_Token_Index then

   Row_Pos369 := Token_Pos563;

else
   Row_Pos369 := No_Token_Index;
   goto Exit_Row369_0;

end if;


Defer_Res584 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos369);
Defer_Pos584 := Parser.Current_Pos;




if Defer_Pos584 /= No_Token_Index then

   Row_Pos369 := Defer_Pos584;

else
   Row_Pos369 := No_Token_Index;
   goto Exit_Row369_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row369_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos369 = No_Token_Index then

         
   Defer_Res584 := No_Bare_Ada_Node;



       
   Row_Pos369 := Row_Pos366;



end if;

--  End opt_code




if Row_Pos369 /= No_Token_Index then

   Row_Pos366 := Row_Pos369;

else
   Row_Pos366 := No_Token_Index;
   goto Exit_Row366_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row366_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos366 /= No_Token_Index then

   Transform_Res281 := Allocate_Subp_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res281,
      Kind => Ada_Subp_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos366 = Pos
                            then No_Token_Index
                            else Row_Pos366 - 1));

      Initialize_Fields_For_Subp_Spec
        (Self => Transform_Res281, Subp_Spec_F_Subp_Kind => Or_Res121, Subp_Spec_F_Subp_Name => Defer_Res582, Subp_Spec_F_Subp_Params => Defer_Res583, Subp_Spec_F_Subp_Returns => Defer_Res584);

         if Or_Res121 /= null and then Is_Incomplete (Or_Res121) then
            Transform_Res281.Last_Attempted_Child := 0;
         elsif Or_Res121 /= null and then not Is_Ghost (Or_Res121) then
            Transform_Res281.Last_Attempted_Child := -1;
         end if;
         if Defer_Res582 /= null and then Is_Incomplete (Defer_Res582) then
            Transform_Res281.Last_Attempted_Child := 0;
         elsif Defer_Res582 /= null and then not Is_Ghost (Defer_Res582) then
            Transform_Res281.Last_Attempted_Child := -1;
         end if;
         if Defer_Res583 /= null and then Is_Incomplete (Defer_Res583) then
            Transform_Res281.Last_Attempted_Child := 0;
         elsif Defer_Res583 /= null and then not Is_Ghost (Defer_Res583) then
            Transform_Res281.Last_Attempted_Child := -1;
         end if;
         if Defer_Res584 /= null and then Is_Incomplete (Defer_Res584) then
            Transform_Res281.Last_Attempted_Child := 0;
         elsif Defer_Res584 /= null and then not Is_Ghost (Defer_Res584) then
            Transform_Res281.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos366 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags281);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subp_Spec_Transform_Parse2_Memo,
      Row_Pos366 /= No_Token_Index,
      Transform_Res281,
      Pos,
      Row_Pos366);


   Parser.Current_Pos := Row_Pos366;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res281;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subp_Spec_Transform_Parse2;

   


function Subtype_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subtype_Decl
is
   use Bare_Subtype_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos370 :
            Token_Index
               := No_Token_Index;
      Token_Pos564 :
            Token_Index
               := No_Token_Index;
      Token_Res564 :
            Token_Index
               := No_Token_Index;
      Defer_Pos585 :
            Token_Index
               := No_Token_Index;
      Defer_Res585 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos565 :
            Token_Index
               := No_Token_Index;
      Token_Res565 :
            Token_Index
               := No_Token_Index;
      Defer_Pos586 :
            Token_Index
               := No_Token_Index;
      Defer_Res586 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Defer_Pos587 :
            Token_Index
               := No_Token_Index;
      Defer_Res587 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos566 :
            Token_Index
               := No_Token_Index;
      Token_Res566 :
            Token_Index
               := No_Token_Index;
      Transform_Res282 :
            Bare_Subtype_Decl
               := No_Bare_Ada_Node;
      Transform_Diags282 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subtype_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res282 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res282;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res282;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags282 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos370 := Pos;



--  Start tok_code

Token_Res564 := Row_Pos370;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res564));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Subtype)
   then
       Token_Pos564 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos370 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos370,
             Expected_Token_Id => Ada_Subtype,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos564 := Row_Pos370 + 1;
   end if;
end;

--  End tok_code




if Token_Pos564 /= No_Token_Index then

   Row_Pos370 := Token_Pos564;

else
   Row_Pos370 := No_Token_Index;
   goto Exit_Row370_0;

end if;


Defer_Res585 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos370);
Defer_Pos585 := Parser.Current_Pos;




if Defer_Pos585 /= No_Token_Index then

   Row_Pos370 := Defer_Pos585;

else
   Row_Pos370 := No_Token_Index;
   goto Exit_Row370_0;

end if;


--  Start tok_code

Token_Res565 := Row_Pos370;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res565));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos565 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos370 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos370,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos565 := Row_Pos370 + 1;
   end if;
end;

--  End tok_code




if Token_Pos565 /= No_Token_Index then

   Row_Pos370 := Token_Pos565;

else
   Row_Pos370 := No_Token_Index;
   goto Exit_Row370_0;

end if;


Defer_Res586 :=
   Subtype_Indication_Transform_Parse0 (Parser, Row_Pos370);
Defer_Pos586 := Parser.Current_Pos;




if Defer_Pos586 /= No_Token_Index then

   Row_Pos370 := Defer_Pos586;

else
   Row_Pos370 := No_Token_Index;
   goto Exit_Row370_0;

end if;


Defer_Res587 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos370);
Defer_Pos587 := Parser.Current_Pos;




if Defer_Pos587 /= No_Token_Index then

   Row_Pos370 := Defer_Pos587;

else
   Row_Pos370 := No_Token_Index;
   goto Exit_Row370_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res566 := Row_Pos370;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res566));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos566 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos370 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos370,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos566 := Row_Pos370 + 1;
   end if;
end;

--  End tok_code


if Token_Pos566 = No_Token_Index then

         
   Token_Res566 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos370)),
                To_Text ("Missing ';'"));

       
   Token_Pos566 := Row_Pos370;



end if;

--  End opt_code




if Token_Pos566 /= No_Token_Index then

   Row_Pos370 := Token_Pos566;

else
   Row_Pos370 := No_Token_Index;
   goto Exit_Row370_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row370_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos370 /= No_Token_Index then

   Transform_Res282 := Allocate_Subtype_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res282,
      Kind => Ada_Subtype_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos370 = Pos
                            then No_Token_Index
                            else Row_Pos370 - 1));

      Initialize_Fields_For_Subtype_Decl
        (Self => Transform_Res282, Base_Type_Decl_F_Name => Defer_Res585, Subtype_Decl_F_Subtype => Defer_Res586, Subtype_Decl_F_Aspects => Defer_Res587);

         if Defer_Res585 /= null and then Is_Incomplete (Defer_Res585) then
            Transform_Res282.Last_Attempted_Child := 0;
         elsif Defer_Res585 /= null and then not Is_Ghost (Defer_Res585) then
            Transform_Res282.Last_Attempted_Child := -1;
         end if;
         if Defer_Res586 /= null and then Is_Incomplete (Defer_Res586) then
            Transform_Res282.Last_Attempted_Child := 0;
         elsif Defer_Res586 /= null and then not Is_Ghost (Defer_Res586) then
            Transform_Res282.Last_Attempted_Child := -1;
         end if;
         if Defer_Res587 /= null and then Is_Incomplete (Defer_Res587) then
            Transform_Res282.Last_Attempted_Child := 0;
         elsif Defer_Res587 /= null and then not Is_Ghost (Defer_Res587) then
            Transform_Res282.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos370 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags282);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subtype_Decl_Transform_Parse0_Memo,
      Row_Pos370 /= No_Token_Index,
      Transform_Res282,
      Pos,
      Row_Pos370);


   Parser.Current_Pos := Row_Pos370;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res282;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subtype_Decl_Transform_Parse0;

   


function Subtype_Indication_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subtype_Indication
is
   use Bare_Subtype_Indication_Memos;

   Call_Depth : aliased Natural;

      Row_Pos371 :
            Token_Index
               := No_Token_Index;
      Row_Pos372 :
            Token_Index
               := No_Token_Index;
      Token_Pos567 :
            Token_Index
               := No_Token_Index;
      Token_Res567 :
            Token_Index
               := No_Token_Index;
      Token_Pos568 :
            Token_Index
               := No_Token_Index;
      Token_Res568 :
            Token_Index
               := No_Token_Index;
      Opt_Res30 :
            Bare_Not_Null
               := No_Bare_Ada_Node;
      Defer_Pos588 :
            Token_Index
               := No_Token_Index;
      Defer_Res588 :
            Bare_Name
               := No_Bare_Ada_Node;
      Defer_Pos589 :
            Token_Index
               := No_Token_Index;
      Defer_Res589 :
            Bare_Constraint
               := No_Bare_Ada_Node;
      Transform_Res283 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Transform_Diags283 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subtype_Indication_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res283 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res283;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res283;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags283 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos371 := Pos;



--  Start opt_code












--  Start row_code

Row_Pos372 := Row_Pos371;



--  Start tok_code

Token_Res567 := Row_Pos372;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res567));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Not)
   then
       Token_Pos567 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos372 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos372,
             Expected_Token_Id => Ada_Not,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos567 := Row_Pos372 + 1;
   end if;
end;

--  End tok_code




if Token_Pos567 /= No_Token_Index then

   Row_Pos372 := Token_Pos567;

else
   Row_Pos372 := No_Token_Index;
   goto Exit_Row372_0;

end if;


--  Start tok_code

Token_Res568 := Row_Pos372;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res568));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Null)
   then
       Token_Pos568 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos372 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos372,
             Expected_Token_Id => Ada_Null,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos568 := Row_Pos372 + 1;
   end if;
end;

--  End tok_code




if Token_Pos568 /= No_Token_Index then

   Row_Pos372 := Token_Pos568;

else
   Row_Pos372 := No_Token_Index;
   goto Exit_Row372_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row372_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos372 = No_Token_Index then

         Opt_Res30 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res30,
            Kind              => Ada_Not_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos371,
            Token_End_Index   => No_Token_Index);


       
   Row_Pos372 := Row_Pos371;


else

      Opt_Res30 := Allocate_Not_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res30,
         Kind              => Ada_Not_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos371,
         Token_End_Index   => Row_Pos372 - 1);

end if;

--  End opt_code




if Row_Pos372 /= No_Token_Index then

   Row_Pos371 := Row_Pos372;

else
   Row_Pos371 := No_Token_Index;
   goto Exit_Row371_0;

end if;


Defer_Res588 :=
   Subtype_Name_Or_Parse0 (Parser, Row_Pos371);
Defer_Pos588 := Parser.Current_Pos;




if Defer_Pos588 /= No_Token_Index then

   Row_Pos371 := Defer_Pos588;

else
   Row_Pos371 := No_Token_Index;
   goto Exit_Row371_0;

end if;


--  Start opt_code












Defer_Res589 :=
   Constraint_Or_Parse0 (Parser, Row_Pos371);
Defer_Pos589 := Parser.Current_Pos;


if Defer_Pos589 = No_Token_Index then

         
   Defer_Res589 := No_Bare_Ada_Node;



       
   Defer_Pos589 := Row_Pos371;



end if;

--  End opt_code




if Defer_Pos589 /= No_Token_Index then

   Row_Pos371 := Defer_Pos589;

else
   Row_Pos371 := No_Token_Index;
   goto Exit_Row371_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row371_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos371 /= No_Token_Index then

   Transform_Res283 := Allocate_Subtype_Indication (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res283,
      Kind => Ada_Subtype_Indication,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos371 = Pos
                            then No_Token_Index
                            else Row_Pos371 - 1));

      Initialize_Fields_For_Subtype_Indication
        (Self => Transform_Res283, Subtype_Indication_F_Has_Not_Null => Opt_Res30, Subtype_Indication_F_Name => Defer_Res588, Subtype_Indication_F_Constraint => Defer_Res589);

         if Opt_Res30 /= null and then Is_Incomplete (Opt_Res30) then
            Transform_Res283.Last_Attempted_Child := 0;
         elsif Opt_Res30 /= null and then not Is_Ghost (Opt_Res30) then
            Transform_Res283.Last_Attempted_Child := -1;
         end if;
         if Defer_Res588 /= null and then Is_Incomplete (Defer_Res588) then
            Transform_Res283.Last_Attempted_Child := 0;
         elsif Defer_Res588 /= null and then not Is_Ghost (Defer_Res588) then
            Transform_Res283.Last_Attempted_Child := -1;
         end if;
         if Defer_Res589 /= null and then Is_Incomplete (Defer_Res589) then
            Transform_Res283.Last_Attempted_Child := 0;
         elsif Defer_Res589 /= null and then not Is_Ghost (Defer_Res589) then
            Transform_Res283.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos371 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags283);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subtype_Indication_Transform_Parse0_Memo,
      Row_Pos371 /= No_Token_Index,
      Transform_Res283,
      Pos,
      Row_Pos371);


   Parser.Current_Pos := Row_Pos371;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res283;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subtype_Indication_Transform_Parse0;

   


function Subtype_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Name
is
   use Bare_Name_Memos;

   Call_Depth : aliased Natural;

      Nobt51 :
            Boolean
               := False;
      Row_Pos373 :
            Token_Index
               := No_Token_Index;
      Defer_Pos590 :
            Token_Index
               := No_Token_Index;
      Defer_Res590 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos569 :
            Token_Index
               := No_Token_Index;
      Token_Res569 :
            Token_Index
               := No_Token_Index;
      Defer_Pos591 :
            Token_Index
               := No_Token_Index;
      Defer_Res591 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Row_Progress46 :
            Integer
               := 0;
      Transform_Res284 :
            Bare_Dotted_Name
               := No_Bare_Ada_Node;
      Transform_Has_Failed46 :
            Boolean
               := False;
      Transform_Diags284 :
            Ada.Containers.Count_Type;
      Row_Pos374 :
            Token_Index
               := No_Token_Index;
      Defer_Pos592 :
            Token_Index
               := No_Token_Index;
      Defer_Res592 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos570 :
            Token_Index
               := No_Token_Index;
      Token_Res570 :
            Token_Index
               := No_Token_Index;
      Defer_Pos593 :
            Token_Index
               := No_Token_Index;
      Defer_Res593 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Row_Pos375 :
            Token_Index
               := No_Token_Index;
      Token_Pos571 :
            Token_Index
               := No_Token_Index;
      Token_Res571 :
            Token_Index
               := No_Token_Index;
      Defer_Pos594 :
            Token_Index
               := No_Token_Index;
      Defer_Res594 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos572 :
            Token_Index
               := No_Token_Index;
      Token_Res572 :
            Token_Index
               := No_Token_Index;
      Transform_Res285 :
            Bare_Attribute_Ref
               := No_Bare_Ada_Node;
      Transform_Diags285 :
            Ada.Containers.Count_Type;
      Defer_Pos595 :
            Token_Index
               := No_Token_Index;
      Defer_Res595 :
            Bare_Base_Id
               := No_Bare_Ada_Node;
      Or_Pos122 :
            Token_Index
               := No_Token_Index;
      Or_Res122 :
            Bare_Name
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Subtype_Name_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res122 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res122;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res122;
   end if;

       Set (Parser.Private_Part.Subtype_Name_Or_Parse0_Memo, False, Or_Res122, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt51 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos122 := No_Token_Index;
Or_Res122 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags284 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos373 := Pos;



Defer_Res590 :=
   Subtype_Name_Or_Parse0 (Parser, Row_Pos373);
Defer_Pos590 := Parser.Current_Pos;



Row_Progress46 := 1;

if Defer_Pos590 /= No_Token_Index then

   Row_Pos373 := Defer_Pos590;

else
   Row_Pos373 := No_Token_Index;
   goto Exit_Row373_0;

end if;


--  Start tok_code

Token_Res569 := Row_Pos373;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res569));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Dot)
   then
       Token_Pos569 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos373 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos373,
             Expected_Token_Id => Ada_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos569 := Row_Pos373 + 1;
   end if;
end;

--  End tok_code



Row_Progress46 := 2;

if Token_Pos569 /= No_Token_Index then

   Row_Pos373 := Token_Pos569;

else
   Row_Pos373 := No_Token_Index;
   goto Exit_Row373_0;

end if;

Nobt51 := True;

   Nobt51 := Nobt51;

Row_Progress46 := 3;

if Row_Pos373 /= No_Token_Index then

   Row_Pos373 := Row_Pos373;

else
   Row_Pos373 := No_Token_Index;
   goto Exit_Row373_0;

end if;


Defer_Res591 :=
   Direct_Name_Or_Parse0 (Parser, Row_Pos373);
Defer_Pos591 := Parser.Current_Pos;



Row_Progress46 := 4;

if Defer_Pos591 /= No_Token_Index then

   Row_Pos373 := Defer_Pos591;

else
   Row_Pos373 := No_Token_Index;
   goto Exit_Row373_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row373_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos373 = No_Token_Index and then Nobt51 then

   Row_Pos373 := Parser.Last_Fail.Pos;

   Transform_Has_Failed46 := True;
end if;

if Row_Pos373 /= No_Token_Index then

   Transform_Res284 := Allocate_Dotted_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res284,
      Kind => Ada_Dotted_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos373 = Pos
                            then No_Token_Index
                            else Row_Pos373 - 1));

      Initialize_Fields_For_Dotted_Name
        (Self => Transform_Res284, Dotted_Name_F_Prefix => Defer_Res590, Dotted_Name_F_Suffix => Defer_Res591);

         if Defer_Res590 /= null and then Is_Incomplete (Defer_Res590) then
            Transform_Res284.Last_Attempted_Child := 0;
         elsif Defer_Res590 /= null and then not Is_Ghost (Defer_Res590) then
            Transform_Res284.Last_Attempted_Child := -1;
         end if;
         if Defer_Res591 /= null and then Is_Incomplete (Defer_Res591) then
            Transform_Res284.Last_Attempted_Child := 0;
         elsif Defer_Res591 /= null and then not Is_Ghost (Defer_Res591) then
            Transform_Res284.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed46 then
      Transform_Res284.Last_Attempted_Child :=
         Row_Progress46;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <subtype_name>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos373 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags284);
end if;

--  End transform_code

    if Row_Pos373 /= No_Token_Index then
        Or_Pos122 := Row_Pos373;
        Or_Res122 := Transform_Res284;
        goto Exit_Or125;
    end if;
    
--  Start transform_code

Transform_Diags285 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos374 := Pos;



Defer_Res592 :=
   Subtype_Name_Or_Parse0 (Parser, Row_Pos374);
Defer_Pos592 := Parser.Current_Pos;




if Defer_Pos592 /= No_Token_Index then

   Row_Pos374 := Defer_Pos592;

else
   Row_Pos374 := No_Token_Index;
   goto Exit_Row374_0;

end if;


--  Start tok_code

Token_Res570 := Row_Pos374;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res570));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Tick)
   then
       Token_Pos570 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos374 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos374,
             Expected_Token_Id => Ada_Tick,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos570 := Row_Pos374 + 1;
   end if;
end;

--  End tok_code




if Token_Pos570 /= No_Token_Index then

   Row_Pos374 := Token_Pos570;

else
   Row_Pos374 := No_Token_Index;
   goto Exit_Row374_0;

end if;


Defer_Res593 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos374);
Defer_Pos593 := Parser.Current_Pos;




if Defer_Pos593 /= No_Token_Index then

   Row_Pos374 := Defer_Pos593;

else
   Row_Pos374 := No_Token_Index;
   goto Exit_Row374_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos375 := Row_Pos374;



--  Start tok_code

Token_Res571 := Row_Pos375;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res571));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos571 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos375 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos375,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos571 := Row_Pos375 + 1;
   end if;
end;

--  End tok_code




if Token_Pos571 /= No_Token_Index then

   Row_Pos375 := Token_Pos571;

else
   Row_Pos375 := No_Token_Index;
   goto Exit_Row375_0;

end if;


Defer_Res594 :=
   Attr_Suffix_List_Parse0 (Parser, Row_Pos375);
Defer_Pos594 := Parser.Current_Pos;




if Defer_Pos594 /= No_Token_Index then

   Row_Pos375 := Defer_Pos594;

else
   Row_Pos375 := No_Token_Index;
   goto Exit_Row375_0;

end if;


--  Start tok_code

Token_Res572 := Row_Pos375;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res572));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos572 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos375 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos375,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos572 := Row_Pos375 + 1;
   end if;
end;

--  End tok_code




if Token_Pos572 /= No_Token_Index then

   Row_Pos375 := Token_Pos572;

else
   Row_Pos375 := No_Token_Index;
   goto Exit_Row375_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row375_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos375 = No_Token_Index then

         
   Defer_Res594 :=
     Allocate_Assoc_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res594,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos374 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res594,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos375 := Row_Pos374;



end if;

--  End opt_code




if Row_Pos375 /= No_Token_Index then

   Row_Pos374 := Row_Pos375;

else
   Row_Pos374 := No_Token_Index;
   goto Exit_Row374_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row374_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos374 /= No_Token_Index then

   Transform_Res285 := Allocate_Attribute_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res285,
      Kind => Ada_Attribute_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos374 = Pos
                            then No_Token_Index
                            else Row_Pos374 - 1));

      Initialize_Fields_For_Attribute_Ref
        (Self => Transform_Res285, Attribute_Ref_F_Prefix => Defer_Res592, Attribute_Ref_F_Attribute => Defer_Res593, Attribute_Ref_F_Args => Defer_Res594);

         if Defer_Res592 /= null and then Is_Incomplete (Defer_Res592) then
            Transform_Res285.Last_Attempted_Child := 0;
         elsif Defer_Res592 /= null and then not Is_Ghost (Defer_Res592) then
            Transform_Res285.Last_Attempted_Child := -1;
         end if;
         if Defer_Res593 /= null and then Is_Incomplete (Defer_Res593) then
            Transform_Res285.Last_Attempted_Child := 0;
         elsif Defer_Res593 /= null and then not Is_Ghost (Defer_Res593) then
            Transform_Res285.Last_Attempted_Child := -1;
         end if;
         if Defer_Res594 /= null and then Is_Incomplete (Defer_Res594) then
            Transform_Res285.Last_Attempted_Child := 0;
         elsif Defer_Res594 /= null and then not Is_Ghost (Defer_Res594) then
            Transform_Res285.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos374 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags285);
end if;

--  End transform_code

    if Row_Pos374 /= No_Token_Index then
        Or_Pos122 := Row_Pos374;
        Or_Res122 := Transform_Res285;
        goto Exit_Or125;
    end if;
    
Defer_Res595 :=
   Direct_Name_Or_Parse0 (Parser, Pos);
Defer_Pos595 := Parser.Current_Pos;

    if Defer_Pos595 /= No_Token_Index then
        Or_Pos122 := Defer_Pos595;
        Or_Res122 := Defer_Res595;
        goto Exit_Or125;
    end if;
<<Exit_Or125>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos122 > Mem_Pos then
         Mem_Pos := Or_Pos122;
         Mem_Res := Or_Res122;
         Set
           (Parser.Private_Part.Subtype_Name_Or_Parse0_Memo,
            Or_Pos122 /= No_Token_Index,
            Or_Res122,
            Pos,
            Or_Pos122);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res122 := Mem_Res;
         Or_Pos122 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Subtype_Name_Or_Parse0_Memo,
      Or_Pos122 /= No_Token_Index,
      Or_Res122,
      Pos,
      Or_Pos122);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos122;

   Exit_Call (Parser, Call_Depth);
   return Or_Res122;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subtype_Name_Or_Parse0;

   


function Subunit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Subunit
is
   use Bare_Subunit_Memos;

   Call_Depth : aliased Natural;

      Row_Pos376 :
            Token_Index
               := No_Token_Index;
      Token_Pos573 :
            Token_Index
               := No_Token_Index;
      Token_Res573 :
            Token_Index
               := No_Token_Index;
      Token_Pos574 :
            Token_Index
               := No_Token_Index;
      Token_Res574 :
            Token_Index
               := No_Token_Index;
      Defer_Pos596 :
            Token_Index
               := No_Token_Index;
      Defer_Res596 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos575 :
            Token_Index
               := No_Token_Index;
      Token_Res575 :
            Token_Index
               := No_Token_Index;
      Defer_Pos597 :
            Token_Index
               := No_Token_Index;
      Defer_Res597 :
            Bare_Subp_Body
               := No_Bare_Ada_Node;
      Defer_Pos598 :
            Token_Index
               := No_Token_Index;
      Defer_Res598 :
            Bare_Package_Body
               := No_Bare_Ada_Node;
      Defer_Pos599 :
            Token_Index
               := No_Token_Index;
      Defer_Res599 :
            Bare_Task_Body
               := No_Bare_Ada_Node;
      Defer_Pos600 :
            Token_Index
               := No_Token_Index;
      Defer_Res600 :
            Bare_Protected_Body
               := No_Bare_Ada_Node;
      Or_Pos123 :
            Token_Index
               := No_Token_Index;
      Or_Res123 :
            Bare_Body_Node
               := No_Bare_Ada_Node;
      Transform_Res286 :
            Bare_Subunit
               := No_Bare_Ada_Node;
      Transform_Diags286 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Subunit_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res286 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res286;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res286;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags286 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos376 := Pos;



--  Start tok_code

Token_Res573 := Row_Pos376;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res573));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Separate)
   then
       Token_Pos573 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos376 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos376,
             Expected_Token_Id => Ada_Separate,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos573 := Row_Pos376 + 1;
   end if;
end;

--  End tok_code




if Token_Pos573 /= No_Token_Index then

   Row_Pos376 := Token_Pos573;

else
   Row_Pos376 := No_Token_Index;
   goto Exit_Row376_0;

end if;


--  Start tok_code

Token_Res574 := Row_Pos376;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res574));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos574 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos376 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos376,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos574 := Row_Pos376 + 1;
   end if;
end;

--  End tok_code




if Token_Pos574 /= No_Token_Index then

   Row_Pos376 := Token_Pos574;

else
   Row_Pos376 := No_Token_Index;
   goto Exit_Row376_0;

end if;


Defer_Res596 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos376);
Defer_Pos596 := Parser.Current_Pos;




if Defer_Pos596 /= No_Token_Index then

   Row_Pos376 := Defer_Pos596;

else
   Row_Pos376 := No_Token_Index;
   goto Exit_Row376_0;

end if;


--  Start tok_code

Token_Res575 := Row_Pos376;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res575));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos575 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos376 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos376,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos575 := Row_Pos376 + 1;
   end if;
end;

--  End tok_code




if Token_Pos575 /= No_Token_Index then

   Row_Pos376 := Token_Pos575;

else
   Row_Pos376 := No_Token_Index;
   goto Exit_Row376_0;

end if;


--  Start or_code

Or_Pos123 := No_Token_Index;
Or_Res123 := No_Bare_Ada_Node;
    
Defer_Res597 :=
   Subp_Body_Transform_Parse1 (Parser, Row_Pos376);
Defer_Pos597 := Parser.Current_Pos;

    if Defer_Pos597 /= No_Token_Index then
        Or_Pos123 := Defer_Pos597;
        Or_Res123 := Defer_Res597;
        goto Exit_Or126;
    end if;
    
Defer_Res598 :=
   Package_Body_Transform_Parse1 (Parser, Row_Pos376);
Defer_Pos598 := Parser.Current_Pos;

    if Defer_Pos598 /= No_Token_Index then
        Or_Pos123 := Defer_Pos598;
        Or_Res123 := Defer_Res598;
        goto Exit_Or126;
    end if;
    
Defer_Res599 :=
   Task_Body_Transform_Parse1 (Parser, Row_Pos376);
Defer_Pos599 := Parser.Current_Pos;

    if Defer_Pos599 /= No_Token_Index then
        Or_Pos123 := Defer_Pos599;
        Or_Res123 := Defer_Res599;
        goto Exit_Or126;
    end if;
    
Defer_Res600 :=
   Protected_Body_Transform_Parse1 (Parser, Row_Pos376);
Defer_Pos600 := Parser.Current_Pos;

    if Defer_Pos600 /= No_Token_Index then
        Or_Pos123 := Defer_Pos600;
        Or_Res123 := Defer_Res600;
        goto Exit_Or126;
    end if;
<<Exit_Or126>>

--  End or_code




if Or_Pos123 /= No_Token_Index then

   Row_Pos376 := Or_Pos123;

else
   Row_Pos376 := No_Token_Index;
   goto Exit_Row376_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row376_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos376 /= No_Token_Index then

   Transform_Res286 := Allocate_Subunit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res286,
      Kind => Ada_Subunit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos376 = Pos
                            then No_Token_Index
                            else Row_Pos376 - 1));

      Initialize_Fields_For_Subunit
        (Self => Transform_Res286, Subunit_F_Name => Defer_Res596, Subunit_F_Body => Or_Res123);

         if Defer_Res596 /= null and then Is_Incomplete (Defer_Res596) then
            Transform_Res286.Last_Attempted_Child := 0;
         elsif Defer_Res596 /= null and then not Is_Ghost (Defer_Res596) then
            Transform_Res286.Last_Attempted_Child := -1;
         end if;
         if Or_Res123 /= null and then Is_Incomplete (Or_Res123) then
            Transform_Res286.Last_Attempted_Child := 0;
         elsif Or_Res123 /= null and then not Is_Ghost (Or_Res123) then
            Transform_Res286.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos376 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags286);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Subunit_Transform_Parse0_Memo,
      Row_Pos376 /= No_Token_Index,
      Transform_Res286,
      Pos,
      Row_Pos376);


   Parser.Current_Pos := Row_Pos376;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res286;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Subunit_Transform_Parse0;

   


function Target_Name_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Target_Name
is
   use Bare_Target_Name_Memos;

   Call_Depth : aliased Natural;

      Row_Pos377 :
            Token_Index
               := No_Token_Index;
      Token_Pos576 :
            Token_Index
               := No_Token_Index;
      Token_Res576 :
            Token_Index
               := No_Token_Index;
      Transform_Res287 :
            Bare_Target_Name
               := No_Bare_Ada_Node;
      Transform_Diags287 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Target_Name_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res287 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res287;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res287;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags287 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos377 := Pos;



--  Start tok_code

Token_Res576 := Row_Pos377;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res576));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Target)
   then
       Token_Pos576 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos377 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos377,
             Expected_Token_Id => Ada_Target,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos576 := Row_Pos377 + 1;
   end if;
end;

--  End tok_code




if Token_Pos576 /= No_Token_Index then

   Row_Pos377 := Token_Pos576;

else
   Row_Pos377 := No_Token_Index;
   goto Exit_Row377_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row377_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos377 /= No_Token_Index then

   Transform_Res287 := Allocate_Target_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res287,
      Kind => Ada_Target_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos377 = Pos
                            then No_Token_Index
                            else Row_Pos377 - 1));

      Initialize_Fields_For_Target_Name
        (Self => Transform_Res287);



elsif Row_Pos377 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags287);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Target_Name_Transform_Parse0_Memo,
      Row_Pos377 /= No_Token_Index,
      Transform_Res287,
      Pos,
      Row_Pos377);


   Parser.Current_Pos := Row_Pos377;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res287;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Target_Name_Transform_Parse0;

   


function Task_Body_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Body
is
   use Bare_Task_Body_Memos;

   Call_Depth : aliased Natural;

      Nobt52 :
            Boolean
               := False;
      Row_Pos378 :
            Token_Index
               := No_Token_Index;
      Token_Pos577 :
            Token_Index
               := No_Token_Index;
      Token_Res577 :
            Token_Index
               := No_Token_Index;
      Token_Pos578 :
            Token_Index
               := No_Token_Index;
      Token_Res578 :
            Token_Index
               := No_Token_Index;
      Defer_Pos601 :
            Token_Index
               := No_Token_Index;
      Defer_Res601 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos602 :
            Token_Index
               := No_Token_Index;
      Defer_Res602 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos579 :
            Token_Index
               := No_Token_Index;
      Token_Res579 :
            Token_Index
               := No_Token_Index;
      Defer_Pos603 :
            Token_Index
               := No_Token_Index;
      Defer_Res603 :
            Bare_Declarative_Part
               := No_Bare_Ada_Node;
      Token_Pos580 :
            Token_Index
               := No_Token_Index;
      Token_Res580 :
            Token_Index
               := No_Token_Index;
      Defer_Pos604 :
            Token_Index
               := No_Token_Index;
      Defer_Res604 :
            Bare_Handled_Stmts
               := No_Bare_Ada_Node;
      Row_Pos379 :
            Token_Index
               := No_Token_Index;
      Token_Pos581 :
            Token_Index
               := No_Token_Index;
      Token_Res581 :
            Token_Index
               := No_Token_Index;
      Row_Pos380 :
            Token_Index
               := No_Token_Index;
      Defer_Pos605 :
            Token_Index
               := No_Token_Index;
      Defer_Res605 :
            Bare_Name
               := No_Bare_Ada_Node;
      Transform_Res288 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags288 :
            Ada.Containers.Count_Type;
      Token_Pos582 :
            Token_Index
               := No_Token_Index;
      Token_Res582 :
            Token_Index
               := No_Token_Index;
      Row_Progress47 :
            Integer
               := 0;
      Transform_Res289 :
            Bare_Task_Body
               := No_Bare_Ada_Node;
      Transform_Has_Failed47 :
            Boolean
               := False;
      Transform_Diags289 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Task_Body_Transform_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res289 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res289;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res289;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags289 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos378 := Pos;



--  Start tok_code

Token_Res577 := Row_Pos378;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res577));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Task)
   then
       Token_Pos577 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos378 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos378,
             Expected_Token_Id => Ada_Task,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos577 := Row_Pos378 + 1;
   end if;
end;

--  End tok_code



Row_Progress47 := 1;

if Token_Pos577 /= No_Token_Index then

   Row_Pos378 := Token_Pos577;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


--  Start tok_code

Token_Res578 := Row_Pos378;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res578));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Body)
   then
       Token_Pos578 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos378 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos378,
             Expected_Token_Id => Ada_Body,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos578 := Row_Pos378 + 1;
   end if;
end;

--  End tok_code



Row_Progress47 := 2;

if Token_Pos578 /= No_Token_Index then

   Row_Pos378 := Token_Pos578;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


Defer_Res601 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos378);
Defer_Pos601 := Parser.Current_Pos;



Row_Progress47 := 3;

if Defer_Pos601 /= No_Token_Index then

   Row_Pos378 := Defer_Pos601;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


Defer_Res602 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos378);
Defer_Pos602 := Parser.Current_Pos;



Row_Progress47 := 4;

if Defer_Pos602 /= No_Token_Index then

   Row_Pos378 := Defer_Pos602;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


--  Start tok_code

Token_Res579 := Row_Pos378;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res579));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos579 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos378 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos378,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos579 := Row_Pos378 + 1;
   end if;
end;

--  End tok_code



Row_Progress47 := 5;

if Token_Pos579 /= No_Token_Index then

   Row_Pos378 := Token_Pos579;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;

Nobt52 := True;

   Nobt52 := Nobt52;

Row_Progress47 := 6;

if Row_Pos378 /= No_Token_Index then

   Row_Pos378 := Row_Pos378;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


Defer_Res603 :=
   Recov_Decl_Part_Dont_Skip_Parse0 (Parser, Row_Pos378);
Defer_Pos603 := Parser.Current_Pos;



Row_Progress47 := 7;

if Defer_Pos603 /= No_Token_Index then

   Row_Pos378 := Defer_Pos603;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


--  Start tok_code

Token_Res580 := Row_Pos378;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res580));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Begin)
   then
       Token_Pos580 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos378 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos378,
             Expected_Token_Id => Ada_Begin,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos580 := Row_Pos378 + 1;
   end if;
end;

--  End tok_code



Row_Progress47 := 8;

if Token_Pos580 /= No_Token_Index then

   Row_Pos378 := Token_Pos580;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


Defer_Res604 :=
   Handled_Stmts_Transform_Parse0 (Parser, Row_Pos378);
Defer_Pos604 := Parser.Current_Pos;



Row_Progress47 := 9;

if Defer_Pos604 /= No_Token_Index then

   Row_Pos378 := Defer_Pos604;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


--  Start row_code

Row_Pos379 := Row_Pos378;



--  Start tok_code

Token_Res581 := Row_Pos379;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res581));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos581 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos379 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos379,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos581 := Row_Pos379 + 1;
   end if;
end;

--  End tok_code




if Token_Pos581 /= No_Token_Index then

   Row_Pos379 := Token_Pos581;

else
   Row_Pos379 := No_Token_Index;
   goto Exit_Row379_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags288 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos380 := Row_Pos379;



Defer_Res605 :=
   Static_Name_Or_Parse0 (Parser, Row_Pos380);
Defer_Pos605 := Parser.Current_Pos;




if Defer_Pos605 /= No_Token_Index then

   Row_Pos380 := Defer_Pos605;

else
   Row_Pos380 := No_Token_Index;
   goto Exit_Row380_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row380_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos380 /= No_Token_Index then

   Transform_Res288 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res288,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos379,
      Token_End_Index   => (if Row_Pos380 = Row_Pos379
                            then No_Token_Index
                            else Row_Pos380 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res288, End_Name_F_Name => Defer_Res605);

         if Defer_Res605 /= null and then Is_Incomplete (Defer_Res605) then
            Transform_Res288.Last_Attempted_Child := 0;
         elsif Defer_Res605 /= null and then not Is_Ghost (Defer_Res605) then
            Transform_Res288.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos380 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags288);
end if;

--  End transform_code


if Row_Pos380 = No_Token_Index then

         
   Transform_Res288 := No_Bare_Ada_Node;



       
   Row_Pos380 := Row_Pos379;



end if;

--  End opt_code




if Row_Pos380 /= No_Token_Index then

   Row_Pos379 := Row_Pos380;

else
   Row_Pos379 := No_Token_Index;
   goto Exit_Row379_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row379_0>>
pragma Warnings (On, "referenced");

--  End row_code



Row_Progress47 := 10;

if Row_Pos379 /= No_Token_Index then

   Row_Pos378 := Row_Pos379;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res582 := Row_Pos378;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res582));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos582 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos378 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos378,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos582 := Row_Pos378 + 1;
   end if;
end;

--  End tok_code


if Token_Pos582 = No_Token_Index then

         
   Token_Res582 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos378)),
                To_Text ("Missing ';'"));

       
   Token_Pos582 := Row_Pos378;



end if;

--  End opt_code



Row_Progress47 := 11;

if Token_Pos582 /= No_Token_Index then

   Row_Pos378 := Token_Pos582;

else
   Row_Pos378 := No_Token_Index;
   goto Exit_Row378_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row378_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos378 = No_Token_Index and then Nobt52 then

   Row_Pos378 := Parser.Last_Fail.Pos;

   Transform_Has_Failed47 := True;
end if;

if Row_Pos378 /= No_Token_Index then

   Transform_Res289 := Allocate_Task_Body (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res289,
      Kind => Ada_Task_Body,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos378 = Pos
                            then No_Token_Index
                            else Row_Pos378 - 1));

      Initialize_Fields_For_Task_Body
        (Self => Transform_Res289, Task_Body_F_Name => Defer_Res601, Task_Body_F_Aspects => Defer_Res602, Task_Body_F_Decls => Defer_Res603, Task_Body_F_Stmts => Defer_Res604, Task_Body_F_End_Name => Transform_Res288);

         if Defer_Res601 /= null and then Is_Incomplete (Defer_Res601) then
            Transform_Res289.Last_Attempted_Child := 0;
         elsif Defer_Res601 /= null and then not Is_Ghost (Defer_Res601) then
            Transform_Res289.Last_Attempted_Child := -1;
         end if;
         if Defer_Res602 /= null and then Is_Incomplete (Defer_Res602) then
            Transform_Res289.Last_Attempted_Child := 0;
         elsif Defer_Res602 /= null and then not Is_Ghost (Defer_Res602) then
            Transform_Res289.Last_Attempted_Child := -1;
         end if;
         if Defer_Res603 /= null and then Is_Incomplete (Defer_Res603) then
            Transform_Res289.Last_Attempted_Child := 0;
         elsif Defer_Res603 /= null and then not Is_Ghost (Defer_Res603) then
            Transform_Res289.Last_Attempted_Child := -1;
         end if;
         if Defer_Res604 /= null and then Is_Incomplete (Defer_Res604) then
            Transform_Res289.Last_Attempted_Child := 0;
         elsif Defer_Res604 /= null and then not Is_Ghost (Defer_Res604) then
            Transform_Res289.Last_Attempted_Child := -1;
         end if;
         if Transform_Res288 /= null and then Is_Incomplete (Transform_Res288) then
            Transform_Res289.Last_Attempted_Child := 0;
         elsif Transform_Res288 /= null and then not Is_Ghost (Transform_Res288) then
            Transform_Res289.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed47 then
      Transform_Res289.Last_Attempted_Child :=
         Row_Progress47;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <task_body>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos378 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags289);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Task_Body_Transform_Parse1_Memo,
      Row_Pos378 /= No_Token_Index,
      Transform_Res289,
      Pos,
      Row_Pos378);


   Parser.Current_Pos := Row_Pos378;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res289;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Task_Body_Transform_Parse1;

   


function Task_Body_Stub_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Body_Stub
is
   use Bare_Task_Body_Stub_Memos;

   Call_Depth : aliased Natural;

      Row_Pos381 :
            Token_Index
               := No_Token_Index;
      Token_Pos583 :
            Token_Index
               := No_Token_Index;
      Token_Res583 :
            Token_Index
               := No_Token_Index;
      Token_Pos584 :
            Token_Index
               := No_Token_Index;
      Token_Res584 :
            Token_Index
               := No_Token_Index;
      Defer_Pos606 :
            Token_Index
               := No_Token_Index;
      Defer_Res606 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Token_Pos585 :
            Token_Index
               := No_Token_Index;
      Token_Res585 :
            Token_Index
               := No_Token_Index;
      Token_Pos586 :
            Token_Index
               := No_Token_Index;
      Token_Res586 :
            Token_Index
               := No_Token_Index;
      Defer_Pos607 :
            Token_Index
               := No_Token_Index;
      Defer_Res607 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos587 :
            Token_Index
               := No_Token_Index;
      Token_Res587 :
            Token_Index
               := No_Token_Index;
      Transform_Res290 :
            Bare_Task_Body_Stub
               := No_Bare_Ada_Node;
      Transform_Diags290 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Task_Body_Stub_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res290 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res290;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res290;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags290 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos381 := Pos;



--  Start tok_code

Token_Res583 := Row_Pos381;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res583));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Task)
   then
       Token_Pos583 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos381 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos381,
             Expected_Token_Id => Ada_Task,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos583 := Row_Pos381 + 1;
   end if;
end;

--  End tok_code




if Token_Pos583 /= No_Token_Index then

   Row_Pos381 := Token_Pos583;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;


--  Start tok_code

Token_Res584 := Row_Pos381;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res584));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Body)
   then
       Token_Pos584 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos381 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos381,
             Expected_Token_Id => Ada_Body,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos584 := Row_Pos381 + 1;
   end if;
end;

--  End tok_code




if Token_Pos584 /= No_Token_Index then

   Row_Pos381 := Token_Pos584;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;


Defer_Res606 :=
   Defining_Name_Transform_Parse0 (Parser, Row_Pos381);
Defer_Pos606 := Parser.Current_Pos;




if Defer_Pos606 /= No_Token_Index then

   Row_Pos381 := Defer_Pos606;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;


--  Start tok_code

Token_Res585 := Row_Pos381;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res585));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos585 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos381 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos381,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos585 := Row_Pos381 + 1;
   end if;
end;

--  End tok_code




if Token_Pos585 /= No_Token_Index then

   Row_Pos381 := Token_Pos585;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;


--  Start tok_code

Token_Res586 := Row_Pos381;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res586));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Separate)
   then
       Token_Pos586 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos381 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos381,
             Expected_Token_Id => Ada_Separate,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos586 := Row_Pos381 + 1;
   end if;
end;

--  End tok_code




if Token_Pos586 /= No_Token_Index then

   Row_Pos381 := Token_Pos586;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;


Defer_Res607 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos381);
Defer_Pos607 := Parser.Current_Pos;




if Defer_Pos607 /= No_Token_Index then

   Row_Pos381 := Defer_Pos607;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res587 := Row_Pos381;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res587));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos587 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos381 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos381,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos587 := Row_Pos381 + 1;
   end if;
end;

--  End tok_code


if Token_Pos587 = No_Token_Index then

         
   Token_Res587 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos381)),
                To_Text ("Missing ';'"));

       
   Token_Pos587 := Row_Pos381;



end if;

--  End opt_code




if Token_Pos587 /= No_Token_Index then

   Row_Pos381 := Token_Pos587;

else
   Row_Pos381 := No_Token_Index;
   goto Exit_Row381_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row381_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos381 /= No_Token_Index then

   Transform_Res290 := Allocate_Task_Body_Stub (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res290,
      Kind => Ada_Task_Body_Stub,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos381 = Pos
                            then No_Token_Index
                            else Row_Pos381 - 1));

      Initialize_Fields_For_Task_Body_Stub
        (Self => Transform_Res290, Task_Body_Stub_F_Name => Defer_Res606, Task_Body_Stub_F_Aspects => Defer_Res607);

         if Defer_Res606 /= null and then Is_Incomplete (Defer_Res606) then
            Transform_Res290.Last_Attempted_Child := 0;
         elsif Defer_Res606 /= null and then not Is_Ghost (Defer_Res606) then
            Transform_Res290.Last_Attempted_Child := -1;
         end if;
         if Defer_Res607 /= null and then Is_Incomplete (Defer_Res607) then
            Transform_Res290.Last_Attempted_Child := 0;
         elsif Defer_Res607 /= null and then not Is_Ghost (Defer_Res607) then
            Transform_Res290.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos381 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags290);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Task_Body_Stub_Transform_Parse0_Memo,
      Row_Pos381 /= No_Token_Index,
      Transform_Res290,
      Pos,
      Row_Pos381);


   Parser.Current_Pos := Row_Pos381;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res290;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Task_Body_Stub_Transform_Parse0;

   


function Task_Def_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Def
is
   use Bare_Task_Def_Memos;

   Call_Depth : aliased Natural;

      Row_Pos382 :
            Token_Index
               := No_Token_Index;
      Token_Pos588 :
            Token_Index
               := No_Token_Index;
      Token_Res588 :
            Token_Index
               := No_Token_Index;
      Row_Pos383 :
            Token_Index
               := No_Token_Index;
      Token_Pos589 :
            Token_Index
               := No_Token_Index;
      Token_Res589 :
            Token_Index
               := No_Token_Index;
      Defer_Pos608 :
            Token_Index
               := No_Token_Index;
      Defer_Res608 :
            Bare_Parent_List
               := No_Bare_Ada_Node;
      Token_Pos590 :
            Token_Index
               := No_Token_Index;
      Token_Res590 :
            Token_Index
               := No_Token_Index;
      Row_Pos384 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos49 :
            Token_Index
               := No_Token_Index;
      Tmp_List49 :
            Free_Parse_List;
      Defer_Pos609 :
            Token_Index
               := No_Token_Index;
      Defer_Res609 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos49 :
            Token_Index
               := No_Token_Index;
      List_Res49 :
            Bare_Decl_List
               := No_Bare_Ada_Node;
      Transform_Res291 :
            Bare_Public_Part
               := No_Bare_Ada_Node;
      Transform_Diags291 :
            Ada.Containers.Count_Type;
      Row_Pos385 :
            Token_Index
               := No_Token_Index;
      Token_Pos591 :
            Token_Index
               := No_Token_Index;
      Token_Res591 :
            Token_Index
               := No_Token_Index;
      Row_Pos386 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos50 :
            Token_Index
               := No_Token_Index;
      Tmp_List50 :
            Free_Parse_List;
      Defer_Pos610 :
            Token_Index
               := No_Token_Index;
      Defer_Res610 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;
      List_Pos50 :
            Token_Index
               := No_Token_Index;
      List_Res50 :
            Bare_Decl_List
               := No_Bare_Ada_Node;
      Transform_Res292 :
            Bare_Private_Part
               := No_Bare_Ada_Node;
      Transform_Diags292 :
            Ada.Containers.Count_Type;
      Row_Pos387 :
            Token_Index
               := No_Token_Index;
      Token_Pos592 :
            Token_Index
               := No_Token_Index;
      Token_Res592 :
            Token_Index
               := No_Token_Index;
      Row_Pos388 :
            Token_Index
               := No_Token_Index;
      Defer_Pos611 :
            Token_Index
               := No_Token_Index;
      Defer_Res611 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Transform_Res293 :
            Bare_End_Name
               := No_Bare_Ada_Node;
      Transform_Diags293 :
            Ada.Containers.Count_Type;
      Transform_Res294 :
            Bare_Task_Def
               := No_Bare_Ada_Node;
      Transform_Diags294 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Task_Def_Transform_Parse3_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res294 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res294;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res294;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags294 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos382 := Pos;



--  Start tok_code

Token_Res588 := Row_Pos382;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res588));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos588 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos382 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos382,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos588 := Row_Pos382 + 1;
   end if;
end;

--  End tok_code




if Token_Pos588 /= No_Token_Index then

   Row_Pos382 := Token_Pos588;

else
   Row_Pos382 := No_Token_Index;
   goto Exit_Row382_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos383 := Row_Pos382;



--  Start tok_code

Token_Res589 := Row_Pos383;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res589));
begin
   if
      T.Kind /= From_Token_Kind (Ada_New)
   then
       Token_Pos589 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos383 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos383,
             Expected_Token_Id => Ada_New,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos589 := Row_Pos383 + 1;
   end if;
end;

--  End tok_code




if Token_Pos589 /= No_Token_Index then

   Row_Pos383 := Token_Pos589;

else
   Row_Pos383 := No_Token_Index;
   goto Exit_Row383_0;

end if;


Defer_Res608 :=
   Parent_List_List_Parse0 (Parser, Row_Pos383);
Defer_Pos608 := Parser.Current_Pos;




if Defer_Pos608 /= No_Token_Index then

   Row_Pos383 := Defer_Pos608;

else
   Row_Pos383 := No_Token_Index;
   goto Exit_Row383_0;

end if;


--  Start tok_code

Token_Res590 := Row_Pos383;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res590));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos590 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos383 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos383,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos590 := Row_Pos383 + 1;
   end if;
end;

--  End tok_code




if Token_Pos590 /= No_Token_Index then

   Row_Pos383 := Token_Pos590;

else
   Row_Pos383 := No_Token_Index;
   goto Exit_Row383_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row383_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos383 = No_Token_Index then

         
   Defer_Res608 :=
     Allocate_Parent_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res608,
      Kind              => Ada_Parent_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos382 - 1,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res608,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos383 := Row_Pos382;



end if;

--  End opt_code




if Row_Pos383 /= No_Token_Index then

   Row_Pos382 := Row_Pos383;

else
   Row_Pos382 := No_Token_Index;
   goto Exit_Row382_0;

end if;


--  Start transform_code

Transform_Diags291 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos384 := Row_Pos382;



--  Start list_code

    List_Pos49 := Row_Pos384;



Lst_Cpos49 := Row_Pos384;
Tmp_List49 := Get_Parse_List (Parser);

loop
   
Defer_Res609 :=
   Task_Item_Or_Parse0 (Parser, Lst_Cpos49);
Defer_Pos609 := Parser.Current_Pos;


   exit when Defer_Pos609 = No_Token_Index;

   List_Pos49 := Defer_Pos609;
   Lst_Cpos49 := List_Pos49;

   Tmp_List49.Nodes.Append (Defer_Res609);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List49.Nodes.Length;
begin
   List_Res49 :=
      Allocate_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos384;
      Token_End := (if Lst_Cpos49 = Row_Pos384
                    then Row_Pos384
                    else Lst_Cpos49 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos384, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res49,
      Kind              => Ada_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res49,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List49.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res49.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List49);

--  End list_code




if List_Pos49 /= No_Token_Index then

   Row_Pos384 := List_Pos49;

else
   Row_Pos384 := No_Token_Index;
   goto Exit_Row384_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row384_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos384 /= No_Token_Index then

   Transform_Res291 := Allocate_Public_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res291,
      Kind => Ada_Public_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos382,
      Token_End_Index   => (if Row_Pos384 = Row_Pos382
                            then No_Token_Index
                            else Row_Pos384 - 1));

      Initialize_Fields_For_Public_Part
        (Self => Transform_Res291, Declarative_Part_F_Decls => List_Res49);

         if List_Res49 /= null and then Is_Incomplete (List_Res49) then
            Transform_Res291.Last_Attempted_Child := 0;
         elsif List_Res49 /= null and then not Is_Ghost (List_Res49) then
            Transform_Res291.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos384 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags291);
end if;

--  End transform_code




if Row_Pos384 /= No_Token_Index then

   Row_Pos382 := Row_Pos384;

else
   Row_Pos382 := No_Token_Index;
   goto Exit_Row382_0;

end if;


--  Start opt_code












--  Start row_code

Row_Pos385 := Row_Pos382;



--  Start tok_code

Token_Res591 := Row_Pos385;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res591));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos591 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos385 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos385,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos591 := Row_Pos385 + 1;
   end if;
end;

--  End tok_code




if Token_Pos591 /= No_Token_Index then

   Row_Pos385 := Token_Pos591;

else
   Row_Pos385 := No_Token_Index;
   goto Exit_Row385_0;

end if;


--  Start transform_code

Transform_Diags292 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos386 := Row_Pos385;



--  Start list_code

    List_Pos50 := Row_Pos386;



Lst_Cpos50 := Row_Pos386;
Tmp_List50 := Get_Parse_List (Parser);

loop
   
Defer_Res610 :=
   Task_Item_Or_Parse0 (Parser, Lst_Cpos50);
Defer_Pos610 := Parser.Current_Pos;


   exit when Defer_Pos610 = No_Token_Index;

   List_Pos50 := Defer_Pos610;
   Lst_Cpos50 := List_Pos50;

   Tmp_List50.Nodes.Append (Defer_Res610);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List50.Nodes.Length;
begin
   List_Res50 :=
      Allocate_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos386;
      Token_End := (if Lst_Cpos50 = Row_Pos386
                    then Row_Pos386
                    else Lst_Cpos50 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos386, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res50,
      Kind              => Ada_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res50,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List50.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res50.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List50);

--  End list_code




if List_Pos50 /= No_Token_Index then

   Row_Pos386 := List_Pos50;

else
   Row_Pos386 := No_Token_Index;
   goto Exit_Row386_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row386_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos386 /= No_Token_Index then

   Transform_Res292 := Allocate_Private_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res292,
      Kind => Ada_Private_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos385,
      Token_End_Index   => (if Row_Pos386 = Row_Pos385
                            then No_Token_Index
                            else Row_Pos386 - 1));

      Initialize_Fields_For_Private_Part
        (Self => Transform_Res292, Declarative_Part_F_Decls => List_Res50);

         if List_Res50 /= null and then Is_Incomplete (List_Res50) then
            Transform_Res292.Last_Attempted_Child := 0;
         elsif List_Res50 /= null and then not Is_Ghost (List_Res50) then
            Transform_Res292.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos386 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags292);
end if;

--  End transform_code




if Row_Pos386 /= No_Token_Index then

   Row_Pos385 := Row_Pos386;

else
   Row_Pos385 := No_Token_Index;
   goto Exit_Row385_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row385_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos385 = No_Token_Index then

         
   Transform_Res292 := No_Bare_Ada_Node;



       
   Row_Pos385 := Row_Pos382;



end if;

--  End opt_code




if Row_Pos385 /= No_Token_Index then

   Row_Pos382 := Row_Pos385;

else
   Row_Pos382 := No_Token_Index;
   goto Exit_Row382_0;

end if;


--  Start row_code

Row_Pos387 := Row_Pos382;



--  Start tok_code

Token_Res592 := Row_Pos387;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res592));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos592 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos387 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos387,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos592 := Row_Pos387 + 1;
   end if;
end;

--  End tok_code




if Token_Pos592 /= No_Token_Index then

   Row_Pos387 := Token_Pos592;

else
   Row_Pos387 := No_Token_Index;
   goto Exit_Row387_0;

end if;


--  Start opt_code












--  Start transform_code

Transform_Diags293 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos388 := Row_Pos387;



Defer_Res611 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos388);
Defer_Pos611 := Parser.Current_Pos;




if Defer_Pos611 /= No_Token_Index then

   Row_Pos388 := Defer_Pos611;

else
   Row_Pos388 := No_Token_Index;
   goto Exit_Row388_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row388_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos388 /= No_Token_Index then

   Transform_Res293 := Allocate_End_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res293,
      Kind => Ada_End_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos387,
      Token_End_Index   => (if Row_Pos388 = Row_Pos387
                            then No_Token_Index
                            else Row_Pos388 - 1));

      Initialize_Fields_For_End_Name
        (Self => Transform_Res293, End_Name_F_Name => Defer_Res611);

         if Defer_Res611 /= null and then Is_Incomplete (Defer_Res611) then
            Transform_Res293.Last_Attempted_Child := 0;
         elsif Defer_Res611 /= null and then not Is_Ghost (Defer_Res611) then
            Transform_Res293.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos388 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags293);
end if;

--  End transform_code


if Row_Pos388 = No_Token_Index then

         
   Transform_Res293 := No_Bare_Ada_Node;



       
   Row_Pos388 := Row_Pos387;



end if;

--  End opt_code




if Row_Pos388 /= No_Token_Index then

   Row_Pos387 := Row_Pos388;

else
   Row_Pos387 := No_Token_Index;
   goto Exit_Row387_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row387_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos387 /= No_Token_Index then

   Row_Pos382 := Row_Pos387;

else
   Row_Pos382 := No_Token_Index;
   goto Exit_Row382_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row382_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos382 /= No_Token_Index then

   Transform_Res294 := Allocate_Task_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res294,
      Kind => Ada_Task_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos382 = Pos
                            then No_Token_Index
                            else Row_Pos382 - 1));

      Initialize_Fields_For_Task_Def
        (Self => Transform_Res294, Task_Def_F_Interfaces => Defer_Res608, Task_Def_F_Public_Part => Transform_Res291, Task_Def_F_Private_Part => Transform_Res292, Task_Def_F_End_Name => Transform_Res293);

         if Defer_Res608 /= null and then Is_Incomplete (Defer_Res608) then
            Transform_Res294.Last_Attempted_Child := 0;
         elsif Defer_Res608 /= null and then not Is_Ghost (Defer_Res608) then
            Transform_Res294.Last_Attempted_Child := -1;
         end if;
         if Transform_Res291 /= null and then Is_Incomplete (Transform_Res291) then
            Transform_Res294.Last_Attempted_Child := 0;
         elsif Transform_Res291 /= null and then not Is_Ghost (Transform_Res291) then
            Transform_Res294.Last_Attempted_Child := -1;
         end if;
         if Transform_Res292 /= null and then Is_Incomplete (Transform_Res292) then
            Transform_Res294.Last_Attempted_Child := 0;
         elsif Transform_Res292 /= null and then not Is_Ghost (Transform_Res292) then
            Transform_Res294.Last_Attempted_Child := -1;
         end if;
         if Transform_Res293 /= null and then Is_Incomplete (Transform_Res293) then
            Transform_Res294.Last_Attempted_Child := 0;
         elsif Transform_Res293 /= null and then not Is_Ghost (Transform_Res293) then
            Transform_Res294.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos382 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags294);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Task_Def_Transform_Parse3_Memo,
      Row_Pos382 /= No_Token_Index,
      Transform_Res294,
      Pos,
      Row_Pos382);


   Parser.Current_Pos := Row_Pos382;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res294;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Task_Def_Transform_Parse3;

   


function Task_Item_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ada_Node
is
   use Bare_Ada_Node_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos612 :
            Token_Index
               := No_Token_Index;
      Defer_Res612 :
            Bare_Entry_Decl
               := No_Bare_Ada_Node;
      Defer_Pos613 :
            Token_Index
               := No_Token_Index;
      Defer_Res613 :
            Bare_Aspect_Clause
               := No_Bare_Ada_Node;
      Defer_Pos614 :
            Token_Index
               := No_Token_Index;
      Defer_Res614 :
            Bare_Pragma_Node
               := No_Bare_Ada_Node;
      Or_Pos124 :
            Token_Index
               := No_Token_Index;
      Or_Res124 :
            Bare_Ada_Node
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Task_Item_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res124 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res124;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res124;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos124 := No_Token_Index;
Or_Res124 := No_Bare_Ada_Node;
    
Defer_Res612 :=
   Entry_Decl_Transform_Parse1 (Parser, Pos);
Defer_Pos612 := Parser.Current_Pos;

    if Defer_Pos612 /= No_Token_Index then
        Or_Pos124 := Defer_Pos612;
        Or_Res124 := Defer_Res612;
        goto Exit_Or127;
    end if;
    
Defer_Res613 :=
   Aspect_Clause_Or_Parse1 (Parser, Pos);
Defer_Pos613 := Parser.Current_Pos;

    if Defer_Pos613 /= No_Token_Index then
        Or_Pos124 := Defer_Pos613;
        Or_Res124 := Defer_Res613;
        goto Exit_Or127;
    end if;
    
Defer_Res614 :=
   Pragma_Transform_Parse0 (Parser, Pos);
Defer_Pos614 := Parser.Current_Pos;

    if Defer_Pos614 /= No_Token_Index then
        Or_Pos124 := Defer_Pos614;
        Or_Res124 := Defer_Res614;
        goto Exit_Or127;
    end if;
<<Exit_Or127>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Task_Item_Or_Parse0_Memo,
      Or_Pos124 /= No_Token_Index,
      Or_Res124,
      Pos,
      Or_Pos124);


   Parser.Current_Pos := Or_Pos124;

   Exit_Call (Parser, Call_Depth);
   return Or_Res124;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Task_Item_Or_Parse0;

   


function Task_Type_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Task_Type_Decl
is
   use Bare_Task_Type_Decl_Memos;

   Call_Depth : aliased Natural;

      Nobt53 :
            Boolean
               := False;
      Row_Pos389 :
            Token_Index
               := No_Token_Index;
      Token_Pos593 :
            Token_Index
               := No_Token_Index;
      Token_Res593 :
            Token_Index
               := No_Token_Index;
      Token_Pos594 :
            Token_Index
               := No_Token_Index;
      Token_Res594 :
            Token_Index
               := No_Token_Index;
      Defer_Pos615 :
            Token_Index
               := No_Token_Index;
      Defer_Res615 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos616 :
            Token_Index
               := No_Token_Index;
      Defer_Res616 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Defer_Pos617 :
            Token_Index
               := No_Token_Index;
      Defer_Res617 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Defer_Pos618 :
            Token_Index
               := No_Token_Index;
      Defer_Res618 :
            Bare_Task_Def
               := No_Bare_Ada_Node;
      Token_Pos595 :
            Token_Index
               := No_Token_Index;
      Token_Res595 :
            Token_Index
               := No_Token_Index;
      Row_Progress48 :
            Integer
               := 0;
      Transform_Res295 :
            Bare_Task_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Has_Failed48 :
            Boolean
               := False;
      Transform_Diags295 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Task_Type_Decl_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res295 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res295;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res295;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags295 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos389 := Pos;



--  Start tok_code

Token_Res593 := Row_Pos389;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res593));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Task)
   then
       Token_Pos593 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos389 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos389,
             Expected_Token_Id => Ada_Task,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos593 := Row_Pos389 + 1;
   end if;
end;

--  End tok_code



Row_Progress48 := 1;

if Token_Pos593 /= No_Token_Index then

   Row_Pos389 := Token_Pos593;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;


--  Start tok_code

Token_Res594 := Row_Pos389;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res594));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos594 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos389 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos389,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos594 := Row_Pos389 + 1;
   end if;
end;

--  End tok_code



Row_Progress48 := 2;

if Token_Pos594 /= No_Token_Index then

   Row_Pos389 := Token_Pos594;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;

Nobt53 := True;

   Nobt53 := Nobt53;

Row_Progress48 := 3;

if Row_Pos389 /= No_Token_Index then

   Row_Pos389 := Row_Pos389;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;


Defer_Res615 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos389);
Defer_Pos615 := Parser.Current_Pos;



Row_Progress48 := 4;

if Defer_Pos615 /= No_Token_Index then

   Row_Pos389 := Defer_Pos615;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;


--  Start opt_code












Defer_Res616 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos389);
Defer_Pos616 := Parser.Current_Pos;


if Defer_Pos616 = No_Token_Index then

         
   Defer_Res616 := No_Bare_Ada_Node;



       
   Defer_Pos616 := Row_Pos389;



end if;

--  End opt_code



Row_Progress48 := 5;

if Defer_Pos616 /= No_Token_Index then

   Row_Pos389 := Defer_Pos616;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;


Defer_Res617 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos389);
Defer_Pos617 := Parser.Current_Pos;



Row_Progress48 := 6;

if Defer_Pos617 /= No_Token_Index then

   Row_Pos389 := Defer_Pos617;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;


--  Start opt_code












Defer_Res618 :=
   Task_Def_Transform_Parse3 (Parser, Row_Pos389);
Defer_Pos618 := Parser.Current_Pos;


if Defer_Pos618 = No_Token_Index then

         
   Defer_Res618 := No_Bare_Ada_Node;



       
   Defer_Pos618 := Row_Pos389;



end if;

--  End opt_code



Row_Progress48 := 7;

if Defer_Pos618 /= No_Token_Index then

   Row_Pos389 := Defer_Pos618;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res595 := Row_Pos389;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res595));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos595 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos389 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos389,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos595 := Row_Pos389 + 1;
   end if;
end;

--  End tok_code


if Token_Pos595 = No_Token_Index then

         
   Token_Res595 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos389)),
                To_Text ("Missing ';'"));

       
   Token_Pos595 := Row_Pos389;



end if;

--  End opt_code



Row_Progress48 := 8;

if Token_Pos595 /= No_Token_Index then

   Row_Pos389 := Token_Pos595;

else
   Row_Pos389 := No_Token_Index;
   goto Exit_Row389_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row389_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos389 = No_Token_Index and then Nobt53 then

   Row_Pos389 := Parser.Last_Fail.Pos;

   Transform_Has_Failed48 := True;
end if;

if Row_Pos389 /= No_Token_Index then

   Transform_Res295 := Allocate_Task_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res295,
      Kind => Ada_Task_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos389 = Pos
                            then No_Token_Index
                            else Row_Pos389 - 1));

      Initialize_Fields_For_Task_Type_Decl
        (Self => Transform_Res295, Base_Type_Decl_F_Name => Defer_Res615, Task_Type_Decl_F_Discriminants => Defer_Res616, Task_Type_Decl_F_Aspects => Defer_Res617, Task_Type_Decl_F_Definition => Defer_Res618);

         if Defer_Res615 /= null and then Is_Incomplete (Defer_Res615) then
            Transform_Res295.Last_Attempted_Child := 0;
         elsif Defer_Res615 /= null and then not Is_Ghost (Defer_Res615) then
            Transform_Res295.Last_Attempted_Child := -1;
         end if;
         if Defer_Res616 /= null and then Is_Incomplete (Defer_Res616) then
            Transform_Res295.Last_Attempted_Child := 0;
         elsif Defer_Res616 /= null and then not Is_Ghost (Defer_Res616) then
            Transform_Res295.Last_Attempted_Child := -1;
         end if;
         if Defer_Res617 /= null and then Is_Incomplete (Defer_Res617) then
            Transform_Res295.Last_Attempted_Child := 0;
         elsif Defer_Res617 /= null and then not Is_Ghost (Defer_Res617) then
            Transform_Res295.Last_Attempted_Child := -1;
         end if;
         if Defer_Res618 /= null and then Is_Incomplete (Defer_Res618) then
            Transform_Res295.Last_Attempted_Child := 0;
         elsif Defer_Res618 /= null and then not Is_Ghost (Defer_Res618) then
            Transform_Res295.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed48 then
      Transform_Res295.Last_Attempted_Child :=
         Row_Progress48;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <task_type_decl>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos389 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags295);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Task_Type_Decl_Transform_Parse0_Memo,
      Row_Pos389 /= No_Token_Index,
      Transform_Res295,
      Pos,
      Row_Pos389);


   Parser.Current_Pos := Row_Pos389;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res295;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Task_Type_Decl_Transform_Parse0;

   


function Term_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt54 :
            Boolean
               := False;
      Row_Pos390 :
            Token_Index
               := No_Token_Index;
      Defer_Pos619 :
            Token_Index
               := No_Token_Index;
      Defer_Res619 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Pos391 :
            Token_Index
               := No_Token_Index;
      Token_Pos596 :
            Token_Index
               := No_Token_Index;
      Token_Res596 :
            Token_Index
               := No_Token_Index;
      Transform_Res296 :
            Bare_Op_Mult
               := No_Bare_Ada_Node;
      Transform_Diags296 :
            Ada.Containers.Count_Type;
      Row_Pos392 :
            Token_Index
               := No_Token_Index;
      Token_Pos597 :
            Token_Index
               := No_Token_Index;
      Token_Res597 :
            Token_Index
               := No_Token_Index;
      Transform_Res297 :
            Bare_Op_Div
               := No_Bare_Ada_Node;
      Transform_Diags297 :
            Ada.Containers.Count_Type;
      Row_Pos393 :
            Token_Index
               := No_Token_Index;
      Token_Pos598 :
            Token_Index
               := No_Token_Index;
      Token_Res598 :
            Token_Index
               := No_Token_Index;
      Transform_Res298 :
            Bare_Op_Mod
               := No_Bare_Ada_Node;
      Transform_Diags298 :
            Ada.Containers.Count_Type;
      Row_Pos394 :
            Token_Index
               := No_Token_Index;
      Token_Pos599 :
            Token_Index
               := No_Token_Index;
      Token_Res599 :
            Token_Index
               := No_Token_Index;
      Transform_Res299 :
            Bare_Op_Rem
               := No_Bare_Ada_Node;
      Transform_Diags299 :
            Ada.Containers.Count_Type;
      Or_Pos125 :
            Token_Index
               := No_Token_Index;
      Or_Res125 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos620 :
            Token_Index
               := No_Token_Index;
      Defer_Res620 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress49 :
            Integer
               := 0;
      Transform_Res300 :
            Bare_Bin_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed49 :
            Boolean
               := False;
      Transform_Diags300 :
            Ada.Containers.Count_Type;
      Defer_Pos621 :
            Token_Index
               := No_Token_Index;
      Defer_Res621 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos126 :
            Token_Index
               := No_Token_Index;
      Or_Res126 :
            Bare_Expr
               := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Ada_Node;

   M : Memo_Entry := Get (Parser.Private_Part.Term_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res126 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res126;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res126;
   end if;

       Set (Parser.Private_Part.Term_Or_Parse1_Memo, False, Or_Res126, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt54 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos126 := No_Token_Index;
Or_Res126 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags300 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos390 := Pos;



Defer_Res619 :=
   Term_Or_Parse1 (Parser, Row_Pos390);
Defer_Pos619 := Parser.Current_Pos;



Row_Progress49 := 1;

if Defer_Pos619 /= No_Token_Index then

   Row_Pos390 := Defer_Pos619;

else
   Row_Pos390 := No_Token_Index;
   goto Exit_Row390_0;

end if;


--  Start or_code

Or_Pos125 := No_Token_Index;
Or_Res125 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags296 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos391 := Row_Pos390;



--  Start tok_code

Token_Res596 := Row_Pos391;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res596));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Mult)
   then
       Token_Pos596 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos391 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos391,
             Expected_Token_Id => Ada_Mult,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos596 := Row_Pos391 + 1;
   end if;
end;

--  End tok_code




if Token_Pos596 /= No_Token_Index then

   Row_Pos391 := Token_Pos596;

else
   Row_Pos391 := No_Token_Index;
   goto Exit_Row391_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row391_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos391 /= No_Token_Index then

   Transform_Res296 := Allocate_Op_Mult (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res296,
      Kind => Ada_Op_Mult,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos390,
      Token_End_Index   => (if Row_Pos391 = Row_Pos390
                            then No_Token_Index
                            else Row_Pos391 - 1));

      Initialize_Fields_For_Op_Mult
        (Self => Transform_Res296);



elsif Row_Pos391 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags296);
end if;

--  End transform_code

    if Row_Pos391 /= No_Token_Index then
        Or_Pos125 := Row_Pos391;
        Or_Res125 := Transform_Res296;
        goto Exit_Or129;
    end if;
    
--  Start transform_code

Transform_Diags297 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos392 := Row_Pos390;



--  Start tok_code

Token_Res597 := Row_Pos392;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res597));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Divide)
   then
       Token_Pos597 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos392 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos392,
             Expected_Token_Id => Ada_Divide,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos597 := Row_Pos392 + 1;
   end if;
end;

--  End tok_code




if Token_Pos597 /= No_Token_Index then

   Row_Pos392 := Token_Pos597;

else
   Row_Pos392 := No_Token_Index;
   goto Exit_Row392_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row392_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos392 /= No_Token_Index then

   Transform_Res297 := Allocate_Op_Div (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res297,
      Kind => Ada_Op_Div,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos390,
      Token_End_Index   => (if Row_Pos392 = Row_Pos390
                            then No_Token_Index
                            else Row_Pos392 - 1));

      Initialize_Fields_For_Op_Div
        (Self => Transform_Res297);



elsif Row_Pos392 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags297);
end if;

--  End transform_code

    if Row_Pos392 /= No_Token_Index then
        Or_Pos125 := Row_Pos392;
        Or_Res125 := Transform_Res297;
        goto Exit_Or129;
    end if;
    
--  Start transform_code

Transform_Diags298 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos393 := Row_Pos390;



--  Start tok_code

Token_Res598 := Row_Pos393;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res598));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Mod)
   then
       Token_Pos598 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos393 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos393,
             Expected_Token_Id => Ada_Mod,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos598 := Row_Pos393 + 1;
   end if;
end;

--  End tok_code




if Token_Pos598 /= No_Token_Index then

   Row_Pos393 := Token_Pos598;

else
   Row_Pos393 := No_Token_Index;
   goto Exit_Row393_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row393_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos393 /= No_Token_Index then

   Transform_Res298 := Allocate_Op_Mod (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res298,
      Kind => Ada_Op_Mod,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos390,
      Token_End_Index   => (if Row_Pos393 = Row_Pos390
                            then No_Token_Index
                            else Row_Pos393 - 1));

      Initialize_Fields_For_Op_Mod
        (Self => Transform_Res298);



elsif Row_Pos393 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags298);
end if;

--  End transform_code

    if Row_Pos393 /= No_Token_Index then
        Or_Pos125 := Row_Pos393;
        Or_Res125 := Transform_Res298;
        goto Exit_Or129;
    end if;
    
--  Start transform_code

Transform_Diags299 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos394 := Row_Pos390;



--  Start tok_code

Token_Res599 := Row_Pos394;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res599));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Rem)
   then
       Token_Pos599 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos394 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos394,
             Expected_Token_Id => Ada_Rem,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos599 := Row_Pos394 + 1;
   end if;
end;

--  End tok_code




if Token_Pos599 /= No_Token_Index then

   Row_Pos394 := Token_Pos599;

else
   Row_Pos394 := No_Token_Index;
   goto Exit_Row394_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row394_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos394 /= No_Token_Index then

   Transform_Res299 := Allocate_Op_Rem (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res299,
      Kind => Ada_Op_Rem,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos390,
      Token_End_Index   => (if Row_Pos394 = Row_Pos390
                            then No_Token_Index
                            else Row_Pos394 - 1));

      Initialize_Fields_For_Op_Rem
        (Self => Transform_Res299);



elsif Row_Pos394 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags299);
end if;

--  End transform_code

    if Row_Pos394 /= No_Token_Index then
        Or_Pos125 := Row_Pos394;
        Or_Res125 := Transform_Res299;
        goto Exit_Or129;
    end if;
<<Exit_Or129>>

--  End or_code



Row_Progress49 := 2;

if Or_Pos125 /= No_Token_Index then

   Row_Pos390 := Or_Pos125;

else
   Row_Pos390 := No_Token_Index;
   goto Exit_Row390_0;

end if;

Nobt54 := True;

   Nobt54 := Nobt54;

Row_Progress49 := 3;

if Row_Pos390 /= No_Token_Index then

   Row_Pos390 := Row_Pos390;

else
   Row_Pos390 := No_Token_Index;
   goto Exit_Row390_0;

end if;


Defer_Res620 :=
   Factor_Or_Parse1 (Parser, Row_Pos390);
Defer_Pos620 := Parser.Current_Pos;



Row_Progress49 := 4;

if Defer_Pos620 /= No_Token_Index then

   Row_Pos390 := Defer_Pos620;

else
   Row_Pos390 := No_Token_Index;
   goto Exit_Row390_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row390_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos390 = No_Token_Index and then Nobt54 then

   Row_Pos390 := Parser.Last_Fail.Pos;

   Transform_Has_Failed49 := True;
end if;

if Row_Pos390 /= No_Token_Index then

   Transform_Res300 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res300,
      Kind => Ada_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos390 = Pos
                            then No_Token_Index
                            else Row_Pos390 - 1));

      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res300, Bin_Op_F_Left => Defer_Res619, Bin_Op_F_Op => Or_Res125, Bin_Op_F_Right => Defer_Res620);

         if Defer_Res619 /= null and then Is_Incomplete (Defer_Res619) then
            Transform_Res300.Last_Attempted_Child := 0;
         elsif Defer_Res619 /= null and then not Is_Ghost (Defer_Res619) then
            Transform_Res300.Last_Attempted_Child := -1;
         end if;
         if Or_Res125 /= null and then Is_Incomplete (Or_Res125) then
            Transform_Res300.Last_Attempted_Child := 0;
         elsif Or_Res125 /= null and then not Is_Ghost (Or_Res125) then
            Transform_Res300.Last_Attempted_Child := -1;
         end if;
         if Defer_Res620 /= null and then Is_Incomplete (Defer_Res620) then
            Transform_Res300.Last_Attempted_Child := 0;
         elsif Defer_Res620 /= null and then not Is_Ghost (Defer_Res620) then
            Transform_Res300.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed49 then
      Transform_Res300.Last_Attempted_Child :=
         Row_Progress49;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <term>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos390 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags300);
end if;

--  End transform_code

    if Row_Pos390 /= No_Token_Index then
        Or_Pos126 := Row_Pos390;
        Or_Res126 := Transform_Res300;
        goto Exit_Or128;
    end if;
    
Defer_Res621 :=
   Factor_Or_Parse1 (Parser, Pos);
Defer_Pos621 := Parser.Current_Pos;

    if Defer_Pos621 /= No_Token_Index then
        Or_Pos126 := Defer_Pos621;
        Or_Res126 := Defer_Res621;
        goto Exit_Or128;
    end if;
<<Exit_Or128>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos126 > Mem_Pos then
         Mem_Pos := Or_Pos126;
         Mem_Res := Or_Res126;
         Set
           (Parser.Private_Part.Term_Or_Parse1_Memo,
            Or_Pos126 /= No_Token_Index,
            Or_Res126,
            Pos,
            Or_Pos126);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res126 := Mem_Res;
         Or_Pos126 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (Parser.Private_Part.Term_Or_Parse1_Memo,
      Or_Pos126 /= No_Token_Index,
      Or_Res126,
      Pos,
      Or_Pos126);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos126;

   Exit_Call (Parser, Call_Depth);
   return Or_Res126;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Term_Or_Parse1;

   


function Terminate_Alternative_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Terminate_Alternative
is
   use Bare_Terminate_Alternative_Memos;

   Call_Depth : aliased Natural;

      Row_Pos395 :
            Token_Index
               := No_Token_Index;
      Token_Pos600 :
            Token_Index
               := No_Token_Index;
      Token_Res600 :
            Token_Index
               := No_Token_Index;
      Token_Pos601 :
            Token_Index
               := No_Token_Index;
      Token_Res601 :
            Token_Index
               := No_Token_Index;
      Transform_Res301 :
            Bare_Terminate_Alternative
               := No_Bare_Ada_Node;
      Transform_Diags301 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Terminate_Alternative_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res301 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res301;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res301;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags301 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos395 := Pos;



--  Start tok_code

Token_Res600 := Row_Pos395;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res600));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Terminate)
   then
       Token_Pos600 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos395 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos395,
             Expected_Token_Id => Ada_Terminate,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos600 := Row_Pos395 + 1;
   end if;
end;

--  End tok_code




if Token_Pos600 /= No_Token_Index then

   Row_Pos395 := Token_Pos600;

else
   Row_Pos395 := No_Token_Index;
   goto Exit_Row395_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res601 := Row_Pos395;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res601));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos601 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos395 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos395,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos601 := Row_Pos395 + 1;
   end if;
end;

--  End tok_code


if Token_Pos601 = No_Token_Index then

         
   Token_Res601 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos395)),
                To_Text ("Missing ';'"));

       
   Token_Pos601 := Row_Pos395;



end if;

--  End opt_code




if Token_Pos601 /= No_Token_Index then

   Row_Pos395 := Token_Pos601;

else
   Row_Pos395 := No_Token_Index;
   goto Exit_Row395_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row395_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos395 /= No_Token_Index then

   Transform_Res301 := Allocate_Terminate_Alternative (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res301,
      Kind => Ada_Terminate_Alternative,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos395 = Pos
                            then No_Token_Index
                            else Row_Pos395 - 1));




elsif Row_Pos395 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags301);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Terminate_Alternative_Transform_Parse0_Memo,
      Row_Pos395 /= No_Token_Index,
      Transform_Res301,
      Pos,
      Row_Pos395);


   Parser.Current_Pos := Row_Pos395;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res301;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Terminate_Alternative_Transform_Parse0;

   


function Type_Decl_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Type_Decl
is
   use Bare_Base_Type_Decl_Memos;

   Call_Depth : aliased Natural;

      Row_Pos396 :
            Token_Index
               := No_Token_Index;
      Token_Pos602 :
            Token_Index
               := No_Token_Index;
      Token_Res602 :
            Token_Index
               := No_Token_Index;
      Defer_Pos622 :
            Token_Index
               := No_Token_Index;
      Defer_Res622 :
            Bare_Defining_Name
               := No_Bare_Ada_Node;
      Defer_Pos623 :
            Token_Index
               := No_Token_Index;
      Defer_Res623 :
            Bare_Discriminant_Part
               := No_Bare_Ada_Node;
      Token_Pos603 :
            Token_Index
               := No_Token_Index;
      Token_Res603 :
            Token_Index
               := No_Token_Index;
      Defer_Pos624 :
            Token_Index
               := No_Token_Index;
      Defer_Res624 :
            Bare_Type_Def
               := No_Bare_Ada_Node;
      Row_Pos397 :
            Token_Index
               := No_Token_Index;
      Token_Pos604 :
            Token_Index
               := No_Token_Index;
      Token_Res604 :
            Token_Index
               := No_Token_Index;
      Opt_Res31 :
            Bare_Abstract_Node
               := No_Bare_Ada_Node;
      Token_Pos605 :
            Token_Index
               := No_Token_Index;
      Token_Res605 :
            Token_Index
               := No_Token_Index;
      Opt_Res32 :
            Bare_Tagged_Node
               := No_Bare_Ada_Node;
      Token_Pos606 :
            Token_Index
               := No_Token_Index;
      Token_Res606 :
            Token_Index
               := No_Token_Index;
      Opt_Res33 :
            Bare_Limited_Node
               := No_Bare_Ada_Node;
      Token_Pos607 :
            Token_Index
               := No_Token_Index;
      Token_Res607 :
            Token_Index
               := No_Token_Index;
      Transform_Res302 :
            Bare_Private_Type_Def
               := No_Bare_Ada_Node;
      Transform_Diags302 :
            Ada.Containers.Count_Type;
      Or_Pos127 :
            Token_Index
               := No_Token_Index;
      Or_Res127 :
            Bare_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos625 :
            Token_Index
               := No_Token_Index;
      Defer_Res625 :
            Bare_Aspect_Spec
               := No_Bare_Ada_Node;
      Token_Pos608 :
            Token_Index
               := No_Token_Index;
      Token_Res608 :
            Token_Index
               := No_Token_Index;
      Transform_Res303 :
            Bare_Concrete_Type_Decl
               := No_Bare_Ada_Node;
      Transform_Diags303 :
            Ada.Containers.Count_Type;
      Defer_Pos626 :
            Token_Index
               := No_Token_Index;
      Defer_Res626 :
            Bare_Incomplete_Type_Decl
               := No_Bare_Ada_Node;
      Or_Pos128 :
            Token_Index
               := No_Token_Index;
      Or_Res128 :
            Bare_Base_Type_Decl
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Type_Decl_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res128 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res128;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res128;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos128 := No_Token_Index;
Or_Res128 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags303 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos396 := Pos;



--  Start tok_code

Token_Res602 := Row_Pos396;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res602));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos602 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos396 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos396,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos602 := Row_Pos396 + 1;
   end if;
end;

--  End tok_code




if Token_Pos602 /= No_Token_Index then

   Row_Pos396 := Token_Pos602;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;


Defer_Res622 :=
   Defining_Id_Transform_Parse0 (Parser, Row_Pos396);
Defer_Pos622 := Parser.Current_Pos;




if Defer_Pos622 /= No_Token_Index then

   Row_Pos396 := Defer_Pos622;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;


--  Start opt_code












Defer_Res623 :=
   Discriminant_Part_Or_Parse0 (Parser, Row_Pos396);
Defer_Pos623 := Parser.Current_Pos;


if Defer_Pos623 = No_Token_Index then

         
   Defer_Res623 := No_Bare_Ada_Node;



       
   Defer_Pos623 := Row_Pos396;



end if;

--  End opt_code




if Defer_Pos623 /= No_Token_Index then

   Row_Pos396 := Defer_Pos623;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;


--  Start tok_code

Token_Res603 := Row_Pos396;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res603));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos603 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos396 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos396,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos603 := Row_Pos396 + 1;
   end if;
end;

--  End tok_code




if Token_Pos603 /= No_Token_Index then

   Row_Pos396 := Token_Pos603;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;


--  Start or_code

Or_Pos127 := No_Token_Index;
Or_Res127 := No_Bare_Ada_Node;
    
Defer_Res624 :=
   Type_Def_Or_Parse0 (Parser, Row_Pos396);
Defer_Pos624 := Parser.Current_Pos;

    if Defer_Pos624 /= No_Token_Index then
        Or_Pos127 := Defer_Pos624;
        Or_Res127 := Defer_Res624;
        goto Exit_Or131;
    end if;
    
--  Start transform_code

Transform_Diags302 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos397 := Row_Pos396;



--  Start opt_code












--  Start tok_code

Token_Res604 := Row_Pos397;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res604));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Abstract)
   then
       Token_Pos604 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos397 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos397,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos604 := Row_Pos397 + 1;
   end if;
end;

--  End tok_code


if Token_Pos604 = No_Token_Index then

         Opt_Res31 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res31,
            Kind              => Ada_Abstract_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos397,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos604 := Row_Pos397;


else

      Opt_Res31 := Allocate_Abstract_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res31,
         Kind              => Ada_Abstract_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos397,
         Token_End_Index   => Token_Pos604 - 1);

end if;

--  End opt_code




if Token_Pos604 /= No_Token_Index then

   Row_Pos397 := Token_Pos604;

else
   Row_Pos397 := No_Token_Index;
   goto Exit_Row397_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res605 := Row_Pos397;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res605));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Tagged)
   then
       Token_Pos605 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos397 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos397,
             Expected_Token_Id => Ada_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos605 := Row_Pos397 + 1;
   end if;
end;

--  End tok_code


if Token_Pos605 = No_Token_Index then

         Opt_Res32 := Allocate_Tagged_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res32,
            Kind              => Ada_Tagged_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos397,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos605 := Row_Pos397;


else

      Opt_Res32 := Allocate_Tagged_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res32,
         Kind              => Ada_Tagged_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos397,
         Token_End_Index   => Token_Pos605 - 1);

end if;

--  End opt_code




if Token_Pos605 /= No_Token_Index then

   Row_Pos397 := Token_Pos605;

else
   Row_Pos397 := No_Token_Index;
   goto Exit_Row397_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res606 := Row_Pos397;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res606));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Limited)
   then
       Token_Pos606 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos397 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos397,
             Expected_Token_Id => Ada_Limited,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos606 := Row_Pos397 + 1;
   end if;
end;

--  End tok_code


if Token_Pos606 = No_Token_Index then

         Opt_Res33 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res33,
            Kind              => Ada_Limited_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos397,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos606 := Row_Pos397;


else

      Opt_Res33 := Allocate_Limited_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res33,
         Kind              => Ada_Limited_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos397,
         Token_End_Index   => Token_Pos606 - 1);

end if;

--  End opt_code




if Token_Pos606 /= No_Token_Index then

   Row_Pos397 := Token_Pos606;

else
   Row_Pos397 := No_Token_Index;
   goto Exit_Row397_0;

end if;


--  Start tok_code

Token_Res607 := Row_Pos397;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res607));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos607 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos397 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos397,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos607 := Row_Pos397 + 1;
   end if;
end;

--  End tok_code




if Token_Pos607 /= No_Token_Index then

   Row_Pos397 := Token_Pos607;

else
   Row_Pos397 := No_Token_Index;
   goto Exit_Row397_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row397_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos397 /= No_Token_Index then

   Transform_Res302 := Allocate_Private_Type_Def (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res302,
      Kind => Ada_Private_Type_Def,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos396,
      Token_End_Index   => (if Row_Pos397 = Row_Pos396
                            then No_Token_Index
                            else Row_Pos397 - 1));

      Initialize_Fields_For_Private_Type_Def
        (Self => Transform_Res302, Private_Type_Def_F_Has_Abstract => Opt_Res31, Private_Type_Def_F_Has_Tagged => Opt_Res32, Private_Type_Def_F_Has_Limited => Opt_Res33);

         if Opt_Res31 /= null and then Is_Incomplete (Opt_Res31) then
            Transform_Res302.Last_Attempted_Child := 0;
         elsif Opt_Res31 /= null and then not Is_Ghost (Opt_Res31) then
            Transform_Res302.Last_Attempted_Child := -1;
         end if;
         if Opt_Res32 /= null and then Is_Incomplete (Opt_Res32) then
            Transform_Res302.Last_Attempted_Child := 0;
         elsif Opt_Res32 /= null and then not Is_Ghost (Opt_Res32) then
            Transform_Res302.Last_Attempted_Child := -1;
         end if;
         if Opt_Res33 /= null and then Is_Incomplete (Opt_Res33) then
            Transform_Res302.Last_Attempted_Child := 0;
         elsif Opt_Res33 /= null and then not Is_Ghost (Opt_Res33) then
            Transform_Res302.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos397 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags302);
end if;

--  End transform_code

    if Row_Pos397 /= No_Token_Index then
        Or_Pos127 := Row_Pos397;
        Or_Res127 := Transform_Res302;
        goto Exit_Or131;
    end if;
<<Exit_Or131>>

--  End or_code




if Or_Pos127 /= No_Token_Index then

   Row_Pos396 := Or_Pos127;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;


Defer_Res625 :=
   Aspect_Spec_Opt_Parse0 (Parser, Row_Pos396);
Defer_Pos625 := Parser.Current_Pos;




if Defer_Pos625 /= No_Token_Index then

   Row_Pos396 := Defer_Pos625;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res608 := Row_Pos396;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res608));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos608 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos396 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos396,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos608 := Row_Pos396 + 1;
   end if;
end;

--  End tok_code


if Token_Pos608 = No_Token_Index then

         
   Token_Res608 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos396)),
                To_Text ("Missing ';'"));

       
   Token_Pos608 := Row_Pos396;



end if;

--  End opt_code




if Token_Pos608 /= No_Token_Index then

   Row_Pos396 := Token_Pos608;

else
   Row_Pos396 := No_Token_Index;
   goto Exit_Row396_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row396_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos396 /= No_Token_Index then

   Transform_Res303 := Allocate_Concrete_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res303,
      Kind => Ada_Concrete_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos396 = Pos
                            then No_Token_Index
                            else Row_Pos396 - 1));

      Initialize_Fields_For_Concrete_Type_Decl
        (Self => Transform_Res303, Base_Type_Decl_F_Name => Defer_Res622, Type_Decl_F_Discriminants => Defer_Res623, Type_Decl_F_Type_Def => Or_Res127, Concrete_Type_Decl_F_Aspects => Defer_Res625);

         if Defer_Res622 /= null and then Is_Incomplete (Defer_Res622) then
            Transform_Res303.Last_Attempted_Child := 0;
         elsif Defer_Res622 /= null and then not Is_Ghost (Defer_Res622) then
            Transform_Res303.Last_Attempted_Child := -1;
         end if;
         if Defer_Res623 /= null and then Is_Incomplete (Defer_Res623) then
            Transform_Res303.Last_Attempted_Child := 0;
         elsif Defer_Res623 /= null and then not Is_Ghost (Defer_Res623) then
            Transform_Res303.Last_Attempted_Child := -1;
         end if;
         if Or_Res127 /= null and then Is_Incomplete (Or_Res127) then
            Transform_Res303.Last_Attempted_Child := 0;
         elsif Or_Res127 /= null and then not Is_Ghost (Or_Res127) then
            Transform_Res303.Last_Attempted_Child := -1;
         end if;
         if Defer_Res625 /= null and then Is_Incomplete (Defer_Res625) then
            Transform_Res303.Last_Attempted_Child := 0;
         elsif Defer_Res625 /= null and then not Is_Ghost (Defer_Res625) then
            Transform_Res303.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos396 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags303);
end if;

--  End transform_code

    if Row_Pos396 /= No_Token_Index then
        Or_Pos128 := Row_Pos396;
        Or_Res128 := Transform_Res303;
        goto Exit_Or130;
    end if;
    
Defer_Res626 :=
   Incomplete_Type_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos626 := Parser.Current_Pos;

    if Defer_Pos626 /= No_Token_Index then
        Or_Pos128 := Defer_Pos626;
        Or_Res128 := Defer_Res626;
        goto Exit_Or130;
    end if;
<<Exit_Or130>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Type_Decl_Or_Parse1_Memo,
      Or_Pos128 /= No_Token_Index,
      Or_Res128,
      Pos,
      Or_Pos128);


   Parser.Current_Pos := Or_Pos128;

   Exit_Call (Parser, Call_Depth);
   return Or_Res128;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Type_Decl_Or_Parse1;

   


function Type_Def_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Def
is
   use Bare_Type_Def_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos627 :
            Token_Index
               := No_Token_Index;
      Defer_Res627 :
            Bare_Record_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos628 :
            Token_Index
               := No_Token_Index;
      Defer_Res628 :
            Bare_Real_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos629 :
            Token_Index
               := No_Token_Index;
      Defer_Res629 :
            Bare_Derived_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos630 :
            Token_Index
               := No_Token_Index;
      Defer_Res630 :
            Bare_Signed_Int_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos631 :
            Token_Index
               := No_Token_Index;
      Defer_Res631 :
            Bare_Mod_Int_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos632 :
            Token_Index
               := No_Token_Index;
      Defer_Res632 :
            Bare_Array_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos633 :
            Token_Index
               := No_Token_Index;
      Defer_Res633 :
            Bare_Interface_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos634 :
            Token_Index
               := No_Token_Index;
      Defer_Res634 :
            Bare_Access_Def
               := No_Bare_Ada_Node;
      Defer_Pos635 :
            Token_Index
               := No_Token_Index;
      Defer_Res635 :
            Bare_Formal_Discrete_Type_Def
               := No_Bare_Ada_Node;
      Defer_Pos636 :
            Token_Index
               := No_Token_Index;
      Defer_Res636 :
            Bare_Enum_Type_Def
               := No_Bare_Ada_Node;
      Or_Pos129 :
            Token_Index
               := No_Token_Index;
      Or_Res129 :
            Bare_Type_Def
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Type_Def_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res129 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res129;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res129;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos129 := No_Token_Index;
Or_Res129 := No_Bare_Ada_Node;
    
Defer_Res627 :=
   Record_Type_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos627 := Parser.Current_Pos;

    if Defer_Pos627 /= No_Token_Index then
        Or_Pos129 := Defer_Pos627;
        Or_Res129 := Defer_Res627;
        goto Exit_Or132;
    end if;
    
Defer_Res628 :=
   Real_Type_Def_Or_Parse0 (Parser, Pos);
Defer_Pos628 := Parser.Current_Pos;

    if Defer_Pos628 /= No_Token_Index then
        Or_Pos129 := Defer_Pos628;
        Or_Res129 := Defer_Res628;
        goto Exit_Or132;
    end if;
    
Defer_Res629 :=
   Derived_Type_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos629 := Parser.Current_Pos;

    if Defer_Pos629 /= No_Token_Index then
        Or_Pos129 := Defer_Pos629;
        Or_Res129 := Defer_Res629;
        goto Exit_Or132;
    end if;
    
Defer_Res630 :=
   Signed_Int_Type_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos630 := Parser.Current_Pos;

    if Defer_Pos630 /= No_Token_Index then
        Or_Pos129 := Defer_Pos630;
        Or_Res129 := Defer_Res630;
        goto Exit_Or132;
    end if;
    
Defer_Res631 :=
   Mod_Int_Type_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos631 := Parser.Current_Pos;

    if Defer_Pos631 /= No_Token_Index then
        Or_Pos129 := Defer_Pos631;
        Or_Res129 := Defer_Res631;
        goto Exit_Or132;
    end if;
    
Defer_Res632 :=
   Array_Type_Def_Transform_Parse2 (Parser, Pos);
Defer_Pos632 := Parser.Current_Pos;

    if Defer_Pos632 /= No_Token_Index then
        Or_Pos129 := Defer_Pos632;
        Or_Res129 := Defer_Res632;
        goto Exit_Or132;
    end if;
    
Defer_Res633 :=
   Interface_Type_Def_Transform_Parse4 (Parser, Pos);
Defer_Pos633 := Parser.Current_Pos;

    if Defer_Pos633 /= No_Token_Index then
        Or_Pos129 := Defer_Pos633;
        Or_Res129 := Defer_Res633;
        goto Exit_Or132;
    end if;
    
Defer_Res634 :=
   Access_Def_Or_Parse0 (Parser, Pos);
Defer_Pos634 := Parser.Current_Pos;

    if Defer_Pos634 /= No_Token_Index then
        Or_Pos129 := Defer_Pos634;
        Or_Res129 := Defer_Res634;
        goto Exit_Or132;
    end if;
    
Defer_Res635 :=
   Formal_Discrete_Type_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos635 := Parser.Current_Pos;

    if Defer_Pos635 /= No_Token_Index then
        Or_Pos129 := Defer_Pos635;
        Or_Res129 := Defer_Res635;
        goto Exit_Or132;
    end if;
    
Defer_Res636 :=
   Enum_Type_Def_Transform_Parse0 (Parser, Pos);
Defer_Pos636 := Parser.Current_Pos;

    if Defer_Pos636 /= No_Token_Index then
        Or_Pos129 := Defer_Pos636;
        Or_Res129 := Defer_Res636;
        goto Exit_Or132;
    end if;
<<Exit_Or132>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Type_Def_Or_Parse0_Memo,
      Or_Pos129 /= No_Token_Index,
      Or_Res129,
      Pos,
      Or_Pos129);


   Parser.Current_Pos := Or_Pos129;

   Exit_Call (Parser, Call_Depth);
   return Or_Res129;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Type_Def_Or_Parse0;

   


function Type_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Expr
is
   use Bare_Type_Expr_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos637 :
            Token_Index
               := No_Token_Index;
      Defer_Res637 :
            Bare_Anonymous_Type
               := No_Bare_Ada_Node;
      Defer_Pos638 :
            Token_Index
               := No_Token_Index;
      Defer_Res638 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Or_Pos130 :
            Token_Index
               := No_Token_Index;
      Or_Res130 :
            Bare_Type_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Type_Expr_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res130 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res130;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res130;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos130 := No_Token_Index;
Or_Res130 := No_Bare_Ada_Node;
    
Defer_Res637 :=
   Anonymous_Type_Transform_Parse0 (Parser, Pos);
Defer_Pos637 := Parser.Current_Pos;

    if Defer_Pos637 /= No_Token_Index then
        Or_Pos130 := Defer_Pos637;
        Or_Res130 := Defer_Res637;
        goto Exit_Or133;
    end if;
    
Defer_Res638 :=
   Subtype_Indication_Transform_Parse0 (Parser, Pos);
Defer_Pos638 := Parser.Current_Pos;

    if Defer_Pos638 /= No_Token_Index then
        Or_Pos130 := Defer_Pos638;
        Or_Res130 := Defer_Res638;
        goto Exit_Or133;
    end if;
<<Exit_Or133>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Type_Expr_Or_Parse0_Memo,
      Or_Pos130 /= No_Token_Index,
      Or_Res130,
      Pos,
      Or_Pos130);


   Parser.Current_Pos := Or_Pos130;

   Exit_Call (Parser, Call_Depth);
   return Or_Res130;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Type_Expr_Or_Parse0;

   


function Unconstrained_Index_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Unconstrained_Array_Index
is
   use Bare_Unconstrained_Array_Index_Memos;

   Call_Depth : aliased Natural;

      Row_Pos398 :
            Token_Index
               := No_Token_Index;
      Defer_Pos639 :
            Token_Index
               := No_Token_Index;
      Defer_Res639 :
            Bare_Subtype_Indication
               := No_Bare_Ada_Node;
      Token_Pos609 :
            Token_Index
               := No_Token_Index;
      Token_Res609 :
            Token_Index
               := No_Token_Index;
      Token_Pos610 :
            Token_Index
               := No_Token_Index;
      Token_Res610 :
            Token_Index
               := No_Token_Index;
      Transform_Res304 :
            Bare_Unconstrained_Array_Index
               := No_Bare_Ada_Node;
      Transform_Diags304 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Unconstrained_Index_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res304 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res304;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res304;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags304 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos398 := Pos;



Defer_Res639 :=
   Subtype_Indication_Transform_Parse0 (Parser, Row_Pos398);
Defer_Pos639 := Parser.Current_Pos;




if Defer_Pos639 /= No_Token_Index then

   Row_Pos398 := Defer_Pos639;

else
   Row_Pos398 := No_Token_Index;
   goto Exit_Row398_0;

end if;


--  Start tok_code

Token_Res609 := Row_Pos398;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res609));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Range)
   then
       Token_Pos609 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos398 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos398,
             Expected_Token_Id => Ada_Range,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos609 := Row_Pos398 + 1;
   end if;
end;

--  End tok_code




if Token_Pos609 /= No_Token_Index then

   Row_Pos398 := Token_Pos609;

else
   Row_Pos398 := No_Token_Index;
   goto Exit_Row398_0;

end if;


--  Start tok_code

Token_Res610 := Row_Pos398;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res610));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Diamond)
   then
       Token_Pos610 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos398 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos398,
             Expected_Token_Id => Ada_Diamond,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos610 := Row_Pos398 + 1;
   end if;
end;

--  End tok_code




if Token_Pos610 /= No_Token_Index then

   Row_Pos398 := Token_Pos610;

else
   Row_Pos398 := No_Token_Index;
   goto Exit_Row398_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row398_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos398 /= No_Token_Index then

   Transform_Res304 := Allocate_Unconstrained_Array_Index (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res304,
      Kind => Ada_Unconstrained_Array_Index,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos398 = Pos
                            then No_Token_Index
                            else Row_Pos398 - 1));

      Initialize_Fields_For_Unconstrained_Array_Index
        (Self => Transform_Res304, Unconstrained_Array_Index_F_Subtype_Indication => Defer_Res639);

         if Defer_Res639 /= null and then Is_Incomplete (Defer_Res639) then
            Transform_Res304.Last_Attempted_Child := 0;
         elsif Defer_Res639 /= null and then not Is_Ghost (Defer_Res639) then
            Transform_Res304.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos398 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags304);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Unconstrained_Index_Transform_Parse0_Memo,
      Row_Pos398 /= No_Token_Index,
      Transform_Res304,
      Pos,
      Row_Pos398);


   Parser.Current_Pos := Row_Pos398;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res304;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Unconstrained_Index_Transform_Parse0;

   


function Unop_Term_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

   Call_Depth : aliased Natural;

      Nobt55 :
            Boolean
               := False;
      Row_Pos399 :
            Token_Index
               := No_Token_Index;
      Row_Pos400 :
            Token_Index
               := No_Token_Index;
      Token_Pos611 :
            Token_Index
               := No_Token_Index;
      Token_Res611 :
            Token_Index
               := No_Token_Index;
      Transform_Res305 :
            Bare_Op_Plus
               := No_Bare_Ada_Node;
      Transform_Diags305 :
            Ada.Containers.Count_Type;
      Row_Pos401 :
            Token_Index
               := No_Token_Index;
      Token_Pos612 :
            Token_Index
               := No_Token_Index;
      Token_Res612 :
            Token_Index
               := No_Token_Index;
      Transform_Res306 :
            Bare_Op_Minus
               := No_Bare_Ada_Node;
      Transform_Diags306 :
            Ada.Containers.Count_Type;
      Or_Pos131 :
            Token_Index
               := No_Token_Index;
      Or_Res131 :
            Bare_Op
               := No_Bare_Ada_Node;
      Defer_Pos640 :
            Token_Index
               := No_Token_Index;
      Defer_Res640 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress50 :
            Integer
               := 0;
      Transform_Res307 :
            Bare_Un_Op
               := No_Bare_Ada_Node;
      Transform_Has_Failed50 :
            Boolean
               := False;
      Transform_Diags307 :
            Ada.Containers.Count_Type;
      Defer_Pos641 :
            Token_Index
               := No_Token_Index;
      Defer_Res641 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Or_Pos132 :
            Token_Index
               := No_Token_Index;
      Or_Res132 :
            Bare_Expr
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Unop_Term_Or_Parse1_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res132 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res132;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res132;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos132 := No_Token_Index;
Or_Res132 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags307 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos399 := Pos;



--  Start or_code

Or_Pos131 := No_Token_Index;
Or_Res131 := No_Bare_Ada_Node;
    
--  Start transform_code

Transform_Diags305 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos400 := Row_Pos399;



--  Start tok_code

Token_Res611 := Row_Pos400;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res611));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Plus)
   then
       Token_Pos611 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos400 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos400,
             Expected_Token_Id => Ada_Plus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos611 := Row_Pos400 + 1;
   end if;
end;

--  End tok_code




if Token_Pos611 /= No_Token_Index then

   Row_Pos400 := Token_Pos611;

else
   Row_Pos400 := No_Token_Index;
   goto Exit_Row400_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row400_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos400 /= No_Token_Index then

   Transform_Res305 := Allocate_Op_Plus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res305,
      Kind => Ada_Op_Plus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos399,
      Token_End_Index   => (if Row_Pos400 = Row_Pos399
                            then No_Token_Index
                            else Row_Pos400 - 1));

      Initialize_Fields_For_Op_Plus
        (Self => Transform_Res305);



elsif Row_Pos400 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags305);
end if;

--  End transform_code

    if Row_Pos400 /= No_Token_Index then
        Or_Pos131 := Row_Pos400;
        Or_Res131 := Transform_Res305;
        goto Exit_Or135;
    end if;
    
--  Start transform_code

Transform_Diags306 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos401 := Row_Pos399;



--  Start tok_code

Token_Res612 := Row_Pos401;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res612));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Minus)
   then
       Token_Pos612 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos401 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos401,
             Expected_Token_Id => Ada_Minus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos612 := Row_Pos401 + 1;
   end if;
end;

--  End tok_code




if Token_Pos612 /= No_Token_Index then

   Row_Pos401 := Token_Pos612;

else
   Row_Pos401 := No_Token_Index;
   goto Exit_Row401_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row401_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos401 /= No_Token_Index then

   Transform_Res306 := Allocate_Op_Minus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res306,
      Kind => Ada_Op_Minus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos399,
      Token_End_Index   => (if Row_Pos401 = Row_Pos399
                            then No_Token_Index
                            else Row_Pos401 - 1));

      Initialize_Fields_For_Op_Minus
        (Self => Transform_Res306);



elsif Row_Pos401 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags306);
end if;

--  End transform_code

    if Row_Pos401 /= No_Token_Index then
        Or_Pos131 := Row_Pos401;
        Or_Res131 := Transform_Res306;
        goto Exit_Or135;
    end if;
<<Exit_Or135>>

--  End or_code



Row_Progress50 := 1;

if Or_Pos131 /= No_Token_Index then

   Row_Pos399 := Or_Pos131;

else
   Row_Pos399 := No_Token_Index;
   goto Exit_Row399_0;

end if;

Nobt55 := True;

   Nobt55 := Nobt55;

Row_Progress50 := 2;

if Row_Pos399 /= No_Token_Index then

   Row_Pos399 := Row_Pos399;

else
   Row_Pos399 := No_Token_Index;
   goto Exit_Row399_0;

end if;


Defer_Res640 :=
   Term_Or_Parse1 (Parser, Row_Pos399);
Defer_Pos640 := Parser.Current_Pos;



Row_Progress50 := 3;

if Defer_Pos640 /= No_Token_Index then

   Row_Pos399 := Defer_Pos640;

else
   Row_Pos399 := No_Token_Index;
   goto Exit_Row399_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row399_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos399 = No_Token_Index and then Nobt55 then

   Row_Pos399 := Parser.Last_Fail.Pos;

   Transform_Has_Failed50 := True;
end if;

if Row_Pos399 /= No_Token_Index then

   Transform_Res307 := Allocate_Un_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res307,
      Kind => Ada_Un_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos399 = Pos
                            then No_Token_Index
                            else Row_Pos399 - 1));

      Initialize_Fields_For_Un_Op
        (Self => Transform_Res307, Un_Op_F_Op => Or_Res131, Un_Op_F_Expr => Defer_Res640);

         if Or_Res131 /= null and then Is_Incomplete (Or_Res131) then
            Transform_Res307.Last_Attempted_Child := 0;
         elsif Or_Res131 /= null and then not Is_Ghost (Or_Res131) then
            Transform_Res307.Last_Attempted_Child := -1;
         end if;
         if Defer_Res640 /= null and then Is_Incomplete (Defer_Res640) then
            Transform_Res307.Last_Attempted_Child := 0;
         elsif Defer_Res640 /= null and then not Is_Ghost (Defer_Res640) then
            Transform_Res307.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed50 then
      Transform_Res307.Last_Attempted_Child :=
         Row_Progress50;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <unop_term>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos399 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags307);
end if;

--  End transform_code

    if Row_Pos399 /= No_Token_Index then
        Or_Pos132 := Row_Pos399;
        Or_Res132 := Transform_Res307;
        goto Exit_Or134;
    end if;
    
Defer_Res641 :=
   Term_Or_Parse1 (Parser, Pos);
Defer_Pos641 := Parser.Current_Pos;

    if Defer_Pos641 /= No_Token_Index then
        Or_Pos132 := Defer_Pos641;
        Or_Res132 := Defer_Res641;
        goto Exit_Or134;
    end if;
<<Exit_Or134>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Unop_Term_Or_Parse1_Memo,
      Or_Pos132 /= No_Token_Index,
      Or_Res132,
      Pos,
      Or_Pos132);


   Parser.Current_Pos := Or_Pos132;

   Exit_Call (Parser, Call_Depth);
   return Or_Res132;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Unop_Term_Or_Parse1;

   


function Update_Attr_Aggregate_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Aggregate
is
   use Bare_Base_Aggregate_Memos;

   Call_Depth : aliased Natural;

      Nobt56 :
            Boolean
               := False;
      Defer_Pos642 :
            Token_Index
               := No_Token_Index;
      Defer_Res642 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;
      Row_Pos402 :
            Token_Index
               := No_Token_Index;
      Token_Pos613 :
            Token_Index
               := No_Token_Index;
      Token_Res613 :
            Token_Index
               := No_Token_Index;
      Null_Res39 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Defer_Pos643 :
            Token_Index
               := No_Token_Index;
      Defer_Res643 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;
      Token_Pos614 :
            Token_Index
               := No_Token_Index;
      Token_Res614 :
            Token_Index
               := No_Token_Index;
      Row_Progress51 :
            Integer
               := 0;
      Transform_Res308 :
            Bare_Aggregate
               := No_Bare_Ada_Node;
      Transform_Has_Failed51 :
            Boolean
               := False;
      Transform_Diags308 :
            Ada.Containers.Count_Type;
      Or_Pos133 :
            Token_Index
               := No_Token_Index;
      Or_Res133 :
            Bare_Base_Aggregate
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Update_Attr_Aggregate_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res133 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res133;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res133;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos133 := No_Token_Index;
Or_Res133 := No_Bare_Ada_Node;
    
Defer_Res642 :=
   Regular_Aggregate_Or_Parse0 (Parser, Pos);
Defer_Pos642 := Parser.Current_Pos;

    if Defer_Pos642 /= No_Token_Index then
        Or_Pos133 := Defer_Pos642;
        Or_Res133 := Defer_Res642;
        goto Exit_Or136;
    end if;
    
--  Start transform_code

Transform_Diags308 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos402 := Pos;



--  Start tok_code

Token_Res613 := Row_Pos402;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res613));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Open)
   then
       Token_Pos613 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos402 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos402,
             Expected_Token_Id => Ada_Par_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos613 := Row_Pos402 + 1;
   end if;
end;

--  End tok_code



Row_Progress51 := 1;

if Token_Pos613 /= No_Token_Index then

   Row_Pos402 := Token_Pos613;

else
   Row_Pos402 := No_Token_Index;
   goto Exit_Row402_0;

end if;

Nobt56 := True;

   Nobt56 := Nobt56;

Row_Progress51 := 2;

if Row_Pos402 /= No_Token_Index then

   Row_Pos402 := Row_Pos402;

else
   Row_Pos402 := No_Token_Index;
   goto Exit_Row402_0;

end if;


   Null_Res39 := No_Bare_Ada_Node;



Row_Progress51 := 3;

if Row_Pos402 /= No_Token_Index then

   Row_Pos402 := Row_Pos402;

else
   Row_Pos402 := No_Token_Index;
   goto Exit_Row402_0;

end if;


Defer_Res643 :=
   Update_Attr_Content_List_Parse0 (Parser, Row_Pos402);
Defer_Pos643 := Parser.Current_Pos;



Row_Progress51 := 4;

if Defer_Pos643 /= No_Token_Index then

   Row_Pos402 := Defer_Pos643;

else
   Row_Pos402 := No_Token_Index;
   goto Exit_Row402_0;

end if;


--  Start tok_code

Token_Res614 := Row_Pos402;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res614));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Par_Close)
   then
       Token_Pos614 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos402 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos402,
             Expected_Token_Id => Ada_Par_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos614 := Row_Pos402 + 1;
   end if;
end;

--  End tok_code



Row_Progress51 := 5;

if Token_Pos614 /= No_Token_Index then

   Row_Pos402 := Token_Pos614;

else
   Row_Pos402 := No_Token_Index;
   goto Exit_Row402_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row402_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos402 = No_Token_Index and then Nobt56 then

   Row_Pos402 := Parser.Last_Fail.Pos;

   Transform_Has_Failed51 := True;
end if;

if Row_Pos402 /= No_Token_Index then

   Transform_Res308 := Allocate_Aggregate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res308,
      Kind => Ada_Aggregate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos402 = Pos
                            then No_Token_Index
                            else Row_Pos402 - 1));

      Initialize_Fields_For_Aggregate
        (Self => Transform_Res308, Base_Aggregate_F_Ancestor_Expr => Null_Res39, Base_Aggregate_F_Assocs => Defer_Res643);

         if Null_Res39 /= null and then Is_Incomplete (Null_Res39) then
            Transform_Res308.Last_Attempted_Child := 0;
         elsif Null_Res39 /= null and then not Is_Ghost (Null_Res39) then
            Transform_Res308.Last_Attempted_Child := -1;
         end if;
         if Defer_Res643 /= null and then Is_Incomplete (Defer_Res643) then
            Transform_Res308.Last_Attempted_Child := 0;
         elsif Defer_Res643 /= null and then not Is_Ghost (Defer_Res643) then
            Transform_Res308.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed51 then
      Transform_Res308.Last_Attempted_Child :=
         Row_Progress51;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <update_attr_aggregate>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos402 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags308);
end if;

--  End transform_code

    if Row_Pos402 /= No_Token_Index then
        Or_Pos133 := Row_Pos402;
        Or_Res133 := Transform_Res308;
        goto Exit_Or136;
    end if;
<<Exit_Or136>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Update_Attr_Aggregate_Or_Parse0_Memo,
      Or_Pos133 /= No_Token_Index,
      Or_Res133,
      Pos,
      Or_Pos133);


   Parser.Current_Pos := Or_Pos133;

   Exit_Call (Parser, Call_Depth);
   return Or_Res133;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Update_Attr_Aggregate_Or_Parse0;

   


function Update_Attr_Content_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Assoc_List
is
   use Bare_Assoc_List_Memos;

   Call_Depth : aliased Natural;

      Lst_Cpos51 :
            Token_Index
               := No_Token_Index;
      Tmp_List51 :
            Free_Parse_List;
      Defer_Pos644 :
            Token_Index
               := No_Token_Index;
      Defer_Res644 :
            Bare_Multi_Dim_Array_Assoc
               := No_Bare_Ada_Node;
      Token_Pos615 :
            Token_Index
               := No_Token_Index;
      Token_Res615 :
            Token_Index
               := No_Token_Index;
      List_Pos51 :
            Token_Index
               := No_Token_Index;
      List_Res51 :
            Bare_Assoc_List
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Update_Attr_Content_List_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res51 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return List_Res51;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return List_Res51;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos51 := No_Token_Index;



Lst_Cpos51 := Pos;
Tmp_List51 := Get_Parse_List (Parser);

loop
   
Defer_Res644 :=
   Multidim_Array_Assoc_Transform_Parse0 (Parser, Lst_Cpos51);
Defer_Pos644 := Parser.Current_Pos;


   exit when Defer_Pos644 = No_Token_Index;

   List_Pos51 := Defer_Pos644;
   Lst_Cpos51 := List_Pos51;

   Tmp_List51.Nodes.Append (Defer_Res644);

      
--  Start tok_code

Token_Res615 := Lst_Cpos51;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res615));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos615 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos51 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos51,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos615 := Lst_Cpos51 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos615 /= No_Token_Index then
          Lst_Cpos51 := Token_Pos615;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List51.Nodes.Length;
begin
   List_Res51 :=
      Allocate_Assoc_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos51 = Pos
                    then Pos
                    else Lst_Cpos51 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res51,
      Kind              => Ada_Assoc_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res51,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List51.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res51.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List51);

--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Update_Attr_Content_List_Parse0_Memo,
      List_Pos51 /= No_Token_Index,
      List_Res51,
      Pos,
      List_Pos51);


   Parser.Current_Pos := List_Pos51;

   Exit_Call (Parser, Call_Depth);
   return List_Res51;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Update_Attr_Content_List_Parse0;

   


function Use_Clause_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Use_Clause
is
   use Bare_Use_Clause_Memos;

   Call_Depth : aliased Natural;

      Defer_Pos645 :
            Token_Index
               := No_Token_Index;
      Defer_Res645 :
            Bare_Use_Package_Clause
               := No_Bare_Ada_Node;
      Defer_Pos646 :
            Token_Index
               := No_Token_Index;
      Defer_Res646 :
            Bare_Use_Type_Clause
               := No_Bare_Ada_Node;
      Or_Pos134 :
            Token_Index
               := No_Token_Index;
      Or_Res134 :
            Bare_Use_Clause
               := No_Bare_Ada_Node;


   M : Memo_Entry := Get (Parser.Private_Part.Use_Clause_Or_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res134 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Or_Res134;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Or_Res134;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos134 := No_Token_Index;
Or_Res134 := No_Bare_Ada_Node;
    
Defer_Res645 :=
   Use_Package_Clause_Transform_Parse0 (Parser, Pos);
Defer_Pos645 := Parser.Current_Pos;

    if Defer_Pos645 /= No_Token_Index then
        Or_Pos134 := Defer_Pos645;
        Or_Res134 := Defer_Res645;
        goto Exit_Or137;
    end if;
    
Defer_Res646 :=
   Use_Type_Clause_Transform_Parse0 (Parser, Pos);
Defer_Pos646 := Parser.Current_Pos;

    if Defer_Pos646 /= No_Token_Index then
        Or_Pos134 := Defer_Pos646;
        Or_Res134 := Defer_Res646;
        goto Exit_Or137;
    end if;
<<Exit_Or137>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Use_Clause_Or_Parse0_Memo,
      Or_Pos134 /= No_Token_Index,
      Or_Res134,
      Pos,
      Or_Pos134);


   Parser.Current_Pos := Or_Pos134;

   Exit_Call (Parser, Call_Depth);
   return Or_Res134;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Use_Clause_Or_Parse0;

   


function Use_Package_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Use_Package_Clause
is
   use Bare_Use_Package_Clause_Memos;

   Call_Depth : aliased Natural;

      Row_Pos403 :
            Token_Index
               := No_Token_Index;
      Token_Pos616 :
            Token_Index
               := No_Token_Index;
      Token_Res616 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos52 :
            Token_Index
               := No_Token_Index;
      Tmp_List52 :
            Free_Parse_List;
      Defer_Pos647 :
            Token_Index
               := No_Token_Index;
      Defer_Res647 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos617 :
            Token_Index
               := No_Token_Index;
      Token_Res617 :
            Token_Index
               := No_Token_Index;
      List_Pos52 :
            Token_Index
               := No_Token_Index;
      List_Res52 :
            Bare_Name_List
               := No_Bare_Ada_Node;
      Token_Pos618 :
            Token_Index
               := No_Token_Index;
      Token_Res618 :
            Token_Index
               := No_Token_Index;
      Transform_Res309 :
            Bare_Use_Package_Clause
               := No_Bare_Ada_Node;
      Transform_Diags309 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Use_Package_Clause_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res309 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res309;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res309;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags309 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos403 := Pos;



--  Start tok_code

Token_Res616 := Row_Pos403;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res616));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos616 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos403 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos403,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos616 := Row_Pos403 + 1;
   end if;
end;

--  End tok_code




if Token_Pos616 /= No_Token_Index then

   Row_Pos403 := Token_Pos616;

else
   Row_Pos403 := No_Token_Index;
   goto Exit_Row403_0;

end if;


--  Start list_code

    List_Pos52 := No_Token_Index;



Lst_Cpos52 := Row_Pos403;
Tmp_List52 := Get_Parse_List (Parser);

loop
   
Defer_Res647 :=
   Static_Name_Or_Parse0 (Parser, Lst_Cpos52);
Defer_Pos647 := Parser.Current_Pos;


   exit when Defer_Pos647 = No_Token_Index;

   List_Pos52 := Defer_Pos647;
   Lst_Cpos52 := List_Pos52;

   Tmp_List52.Nodes.Append (Defer_Res647);

      
--  Start tok_code

Token_Res617 := Lst_Cpos52;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res617));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos617 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos52 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos52,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos617 := Lst_Cpos52 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos617 /= No_Token_Index then
          Lst_Cpos52 := Token_Pos617;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List52.Nodes.Length;
begin
   List_Res52 :=
      Allocate_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos403;
      Token_End := (if Lst_Cpos52 = Row_Pos403
                    then Row_Pos403
                    else Lst_Cpos52 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos403, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res52,
      Kind              => Ada_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res52,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List52.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res52.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List52);

--  End list_code




if List_Pos52 /= No_Token_Index then

   Row_Pos403 := List_Pos52;

else
   Row_Pos403 := No_Token_Index;
   goto Exit_Row403_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res618 := Row_Pos403;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res618));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos618 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos403 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos403,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos618 := Row_Pos403 + 1;
   end if;
end;

--  End tok_code


if Token_Pos618 = No_Token_Index then

         
   Token_Res618 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos403)),
                To_Text ("Missing ';'"));

       
   Token_Pos618 := Row_Pos403;



end if;

--  End opt_code




if Token_Pos618 /= No_Token_Index then

   Row_Pos403 := Token_Pos618;

else
   Row_Pos403 := No_Token_Index;
   goto Exit_Row403_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row403_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos403 /= No_Token_Index then

   Transform_Res309 := Allocate_Use_Package_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res309,
      Kind => Ada_Use_Package_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos403 = Pos
                            then No_Token_Index
                            else Row_Pos403 - 1));

      Initialize_Fields_For_Use_Package_Clause
        (Self => Transform_Res309, Use_Package_Clause_F_Packages => List_Res52);

         if List_Res52 /= null and then Is_Incomplete (List_Res52) then
            Transform_Res309.Last_Attempted_Child := 0;
         elsif List_Res52 /= null and then not Is_Ghost (List_Res52) then
            Transform_Res309.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos403 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags309);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Use_Package_Clause_Transform_Parse0_Memo,
      Row_Pos403 /= No_Token_Index,
      Transform_Res309,
      Pos,
      Row_Pos403);


   Parser.Current_Pos := Row_Pos403;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res309;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Use_Package_Clause_Transform_Parse0;

   


function Use_Type_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Use_Type_Clause
is
   use Bare_Use_Type_Clause_Memos;

   Call_Depth : aliased Natural;

      Row_Pos404 :
            Token_Index
               := No_Token_Index;
      Token_Pos619 :
            Token_Index
               := No_Token_Index;
      Token_Res619 :
            Token_Index
               := No_Token_Index;
      Token_Pos620 :
            Token_Index
               := No_Token_Index;
      Token_Res620 :
            Token_Index
               := No_Token_Index;
      Opt_Res34 :
            Bare_All_Node
               := No_Bare_Ada_Node;
      Token_Pos621 :
            Token_Index
               := No_Token_Index;
      Token_Res621 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos53 :
            Token_Index
               := No_Token_Index;
      Tmp_List53 :
            Free_Parse_List;
      Defer_Pos648 :
            Token_Index
               := No_Token_Index;
      Defer_Res648 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos622 :
            Token_Index
               := No_Token_Index;
      Token_Res622 :
            Token_Index
               := No_Token_Index;
      List_Pos53 :
            Token_Index
               := No_Token_Index;
      List_Res53 :
            Bare_Name_List
               := No_Bare_Ada_Node;
      Token_Pos623 :
            Token_Index
               := No_Token_Index;
      Token_Res623 :
            Token_Index
               := No_Token_Index;
      Transform_Res310 :
            Bare_Use_Type_Clause
               := No_Bare_Ada_Node;
      Transform_Diags310 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Use_Type_Clause_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res310 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res310;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res310;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags310 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos404 := Pos;



--  Start tok_code

Token_Res619 := Row_Pos404;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res619));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Use)
   then
       Token_Pos619 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos404 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos404,
             Expected_Token_Id => Ada_Use,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos619 := Row_Pos404 + 1;
   end if;
end;

--  End tok_code




if Token_Pos619 /= No_Token_Index then

   Row_Pos404 := Token_Pos619;

else
   Row_Pos404 := No_Token_Index;
   goto Exit_Row404_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res620 := Row_Pos404;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res620));
begin
   if
      T.Kind /= From_Token_Kind (Ada_All)
   then
       Token_Pos620 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos404 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos404,
             Expected_Token_Id => Ada_All,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos620 := Row_Pos404 + 1;
   end if;
end;

--  End tok_code


if Token_Pos620 = No_Token_Index then

         Opt_Res34 := Allocate_All_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res34,
            Kind              => Ada_All_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos404,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos620 := Row_Pos404;


else

      Opt_Res34 := Allocate_All_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res34,
         Kind              => Ada_All_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos404,
         Token_End_Index   => Token_Pos620 - 1);

end if;

--  End opt_code




if Token_Pos620 /= No_Token_Index then

   Row_Pos404 := Token_Pos620;

else
   Row_Pos404 := No_Token_Index;
   goto Exit_Row404_0;

end if;


--  Start tok_code

Token_Res621 := Row_Pos404;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res621));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Type)
   then
       Token_Pos621 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos404 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos404,
             Expected_Token_Id => Ada_Type,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos621 := Row_Pos404 + 1;
   end if;
end;

--  End tok_code




if Token_Pos621 /= No_Token_Index then

   Row_Pos404 := Token_Pos621;

else
   Row_Pos404 := No_Token_Index;
   goto Exit_Row404_0;

end if;


--  Start list_code

    List_Pos53 := No_Token_Index;



Lst_Cpos53 := Row_Pos404;
Tmp_List53 := Get_Parse_List (Parser);

loop
   
Defer_Res648 :=
   Name_Or_Parse2 (Parser, Lst_Cpos53);
Defer_Pos648 := Parser.Current_Pos;


   exit when Defer_Pos648 = No_Token_Index;

   List_Pos53 := Defer_Pos648;
   Lst_Cpos53 := List_Pos53;

   Tmp_List53.Nodes.Append (Defer_Res648);

      
--  Start tok_code

Token_Res622 := Lst_Cpos53;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res622));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos622 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos53 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos53,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos622 := Lst_Cpos53 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos622 /= No_Token_Index then
          Lst_Cpos53 := Token_Pos622;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List53.Nodes.Length;
begin
   List_Res53 :=
      Allocate_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos404;
      Token_End := (if Lst_Cpos53 = Row_Pos404
                    then Row_Pos404
                    else Lst_Cpos53 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos404, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res53,
      Kind              => Ada_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res53,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List53.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res53.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List53);

--  End list_code




if List_Pos53 /= No_Token_Index then

   Row_Pos404 := List_Pos53;

else
   Row_Pos404 := No_Token_Index;
   goto Exit_Row404_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res623 := Row_Pos404;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res623));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos623 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos404 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos404,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos623 := Row_Pos404 + 1;
   end if;
end;

--  End tok_code


if Token_Pos623 = No_Token_Index then

         
   Token_Res623 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos404)),
                To_Text ("Missing ';'"));

       
   Token_Pos623 := Row_Pos404;



end if;

--  End opt_code




if Token_Pos623 /= No_Token_Index then

   Row_Pos404 := Token_Pos623;

else
   Row_Pos404 := No_Token_Index;
   goto Exit_Row404_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row404_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos404 /= No_Token_Index then

   Transform_Res310 := Allocate_Use_Type_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res310,
      Kind => Ada_Use_Type_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos404 = Pos
                            then No_Token_Index
                            else Row_Pos404 - 1));

      Initialize_Fields_For_Use_Type_Clause
        (Self => Transform_Res310, Use_Type_Clause_F_Has_All => Opt_Res34, Use_Type_Clause_F_Types => List_Res53);

         if Opt_Res34 /= null and then Is_Incomplete (Opt_Res34) then
            Transform_Res310.Last_Attempted_Child := 0;
         elsif Opt_Res34 /= null and then not Is_Ghost (Opt_Res34) then
            Transform_Res310.Last_Attempted_Child := -1;
         end if;
         if List_Res53 /= null and then Is_Incomplete (List_Res53) then
            Transform_Res310.Last_Attempted_Child := 0;
         elsif List_Res53 /= null and then not Is_Ghost (List_Res53) then
            Transform_Res310.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos404 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags310);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Use_Type_Clause_Transform_Parse0_Memo,
      Row_Pos404 /= No_Token_Index,
      Transform_Res310,
      Pos,
      Row_Pos404);


   Parser.Current_Pos := Row_Pos404;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res310;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Use_Type_Clause_Transform_Parse0;

   


function Value_Sequence_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Value_Sequence
is
   use Bare_Value_Sequence_Memos;

   Call_Depth : aliased Natural;

      Row_Pos405 :
            Token_Index
               := No_Token_Index;
      Token_Pos624 :
            Token_Index
               := No_Token_Index;
      Token_Res624 :
            Token_Index
               := No_Token_Index;
      Defer_Pos649 :
            Token_Index
               := No_Token_Index;
      Defer_Res649 :
            Bare_Iterated_Assoc
               := No_Bare_Ada_Node;
      Token_Pos625 :
            Token_Index
               := No_Token_Index;
      Token_Res625 :
            Token_Index
               := No_Token_Index;
      Transform_Res311 :
            Bare_Value_Sequence
               := No_Bare_Ada_Node;
      Transform_Diags311 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Value_Sequence_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res311 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res311;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res311;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags311 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos405 := Pos;



--  Start tok_code

Token_Res624 := Row_Pos405;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res624));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Brack_Open)
   then
       Token_Pos624 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos405 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos405,
             Expected_Token_Id => Ada_Brack_Open,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos624 := Row_Pos405 + 1;
   end if;
end;

--  End tok_code




if Token_Pos624 /= No_Token_Index then

   Row_Pos405 := Token_Pos624;

else
   Row_Pos405 := No_Token_Index;
   goto Exit_Row405_0;

end if;


Defer_Res649 :=
   Iterated_Assoc_Transform_Parse0 (Parser, Row_Pos405);
Defer_Pos649 := Parser.Current_Pos;




if Defer_Pos649 /= No_Token_Index then

   Row_Pos405 := Defer_Pos649;

else
   Row_Pos405 := No_Token_Index;
   goto Exit_Row405_0;

end if;


--  Start tok_code

Token_Res625 := Row_Pos405;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res625));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Brack_Close)
   then
       Token_Pos625 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos405 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos405,
             Expected_Token_Id => Ada_Brack_Close,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos625 := Row_Pos405 + 1;
   end if;
end;

--  End tok_code




if Token_Pos625 /= No_Token_Index then

   Row_Pos405 := Token_Pos625;

else
   Row_Pos405 := No_Token_Index;
   goto Exit_Row405_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row405_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos405 /= No_Token_Index then

   Transform_Res311 := Allocate_Value_Sequence (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res311,
      Kind => Ada_Value_Sequence,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos405 = Pos
                            then No_Token_Index
                            else Row_Pos405 - 1));

      Initialize_Fields_For_Value_Sequence
        (Self => Transform_Res311, Value_Sequence_F_Iter_Assoc => Defer_Res649);

         if Defer_Res649 /= null and then Is_Incomplete (Defer_Res649) then
            Transform_Res311.Last_Attempted_Child := 0;
         elsif Defer_Res649 /= null and then not Is_Ghost (Defer_Res649) then
            Transform_Res311.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos405 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags311);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Value_Sequence_Transform_Parse0_Memo,
      Row_Pos405 /= No_Token_Index,
      Transform_Res311,
      Pos,
      Row_Pos405);


   Parser.Current_Pos := Row_Pos405;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res311;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Value_Sequence_Transform_Parse0;

   


function Variant_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Variant
is
   use Bare_Variant_Memos;

   Call_Depth : aliased Natural;

      Row_Pos406 :
            Token_Index
               := No_Token_Index;
      Token_Pos626 :
            Token_Index
               := No_Token_Index;
      Token_Res626 :
            Token_Index
               := No_Token_Index;
      Defer_Pos650 :
            Token_Index
               := No_Token_Index;
      Defer_Res650 :
            Bare_Alternatives_List
               := No_Bare_Ada_Node;
      Token_Pos627 :
            Token_Index
               := No_Token_Index;
      Token_Res627 :
            Token_Index
               := No_Token_Index;
      Defer_Pos651 :
            Token_Index
               := No_Token_Index;
      Defer_Res651 :
            Bare_Component_List
               := No_Bare_Ada_Node;
      Transform_Res312 :
            Bare_Variant
               := No_Bare_Ada_Node;
      Transform_Diags312 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Variant_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res312 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res312;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res312;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags312 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos406 := Pos;



--  Start tok_code

Token_Res626 := Row_Pos406;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res626));
begin
   if
      T.Kind /= From_Token_Kind (Ada_When)
   then
       Token_Pos626 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos406 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos406,
             Expected_Token_Id => Ada_When,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos626 := Row_Pos406 + 1;
   end if;
end;

--  End tok_code




if Token_Pos626 /= No_Token_Index then

   Row_Pos406 := Token_Pos626;

else
   Row_Pos406 := No_Token_Index;
   goto Exit_Row406_0;

end if;


Defer_Res650 :=
   Choice_List_List_Parse0 (Parser, Row_Pos406);
Defer_Pos650 := Parser.Current_Pos;




if Defer_Pos650 /= No_Token_Index then

   Row_Pos406 := Defer_Pos650;

else
   Row_Pos406 := No_Token_Index;
   goto Exit_Row406_0;

end if;


--  Start tok_code

Token_Res627 := Row_Pos406;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res627));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Arrow)
   then
       Token_Pos627 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos406 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos406,
             Expected_Token_Id => Ada_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos627 := Row_Pos406 + 1;
   end if;
end;

--  End tok_code




if Token_Pos627 /= No_Token_Index then

   Row_Pos406 := Token_Pos627;

else
   Row_Pos406 := No_Token_Index;
   goto Exit_Row406_0;

end if;


Defer_Res651 :=
   Component_List_Transform_Parse0 (Parser, Row_Pos406);
Defer_Pos651 := Parser.Current_Pos;




if Defer_Pos651 /= No_Token_Index then

   Row_Pos406 := Defer_Pos651;

else
   Row_Pos406 := No_Token_Index;
   goto Exit_Row406_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row406_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos406 /= No_Token_Index then

   Transform_Res312 := Allocate_Variant (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res312,
      Kind => Ada_Variant,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos406 = Pos
                            then No_Token_Index
                            else Row_Pos406 - 1));

      Initialize_Fields_For_Variant
        (Self => Transform_Res312, Variant_F_Choices => Defer_Res650, Variant_F_Components => Defer_Res651);

         if Defer_Res650 /= null and then Is_Incomplete (Defer_Res650) then
            Transform_Res312.Last_Attempted_Child := 0;
         elsif Defer_Res650 /= null and then not Is_Ghost (Defer_Res650) then
            Transform_Res312.Last_Attempted_Child := -1;
         end if;
         if Defer_Res651 /= null and then Is_Incomplete (Defer_Res651) then
            Transform_Res312.Last_Attempted_Child := 0;
         elsif Defer_Res651 /= null and then not Is_Ghost (Defer_Res651) then
            Transform_Res312.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos406 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags312);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Variant_Transform_Parse0_Memo,
      Row_Pos406 /= No_Token_Index,
      Transform_Res312,
      Pos,
      Row_Pos406);


   Parser.Current_Pos := Row_Pos406;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res312;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Variant_Transform_Parse0;

   


function Variant_Part_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Variant_Part
is
   use Bare_Variant_Part_Memos;

   Call_Depth : aliased Natural;

      Nobt57 :
            Boolean
               := False;
      Row_Pos407 :
            Token_Index
               := No_Token_Index;
      Token_Pos628 :
            Token_Index
               := No_Token_Index;
      Token_Res628 :
            Token_Index
               := No_Token_Index;
      Defer_Pos652 :
            Token_Index
               := No_Token_Index;
      Defer_Res652 :
            Bare_Identifier
               := No_Bare_Ada_Node;
      Token_Pos629 :
            Token_Index
               := No_Token_Index;
      Token_Res629 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos54 :
            Token_Index
               := No_Token_Index;
      Tmp_List54 :
            Free_Parse_List;
      Defer_Pos653 :
            Token_Index
               := No_Token_Index;
      Defer_Res653 :
            Bare_Variant
               := No_Bare_Ada_Node;
      List_Pos54 :
            Token_Index
               := No_Token_Index;
      List_Res54 :
            Bare_Variant_List
               := No_Bare_Ada_Node;
      Token_Pos630 :
            Token_Index
               := No_Token_Index;
      Token_Res630 :
            Token_Index
               := No_Token_Index;
      Token_Pos631 :
            Token_Index
               := No_Token_Index;
      Token_Res631 :
            Token_Index
               := No_Token_Index;
      Token_Pos632 :
            Token_Index
               := No_Token_Index;
      Token_Res632 :
            Token_Index
               := No_Token_Index;
      Row_Progress52 :
            Integer
               := 0;
      Transform_Res313 :
            Bare_Variant_Part
               := No_Bare_Ada_Node;
      Transform_Has_Failed52 :
            Boolean
               := False;
      Transform_Diags313 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.Variant_Part_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res313 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res313;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res313;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags313 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos407 := Pos;



--  Start tok_code

Token_Res628 := Row_Pos407;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res628));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Case)
   then
       Token_Pos628 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos407 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos407,
             Expected_Token_Id => Ada_Case,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos628 := Row_Pos407 + 1;
   end if;
end;

--  End tok_code



Row_Progress52 := 1;

if Token_Pos628 /= No_Token_Index then

   Row_Pos407 := Token_Pos628;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;

Nobt57 := True;

   Nobt57 := Nobt57;

Row_Progress52 := 2;

if Row_Pos407 /= No_Token_Index then

   Row_Pos407 := Row_Pos407;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;


Defer_Res652 :=
   Identifier_Transform_Parse0 (Parser, Row_Pos407);
Defer_Pos652 := Parser.Current_Pos;



Row_Progress52 := 3;

if Defer_Pos652 /= No_Token_Index then

   Row_Pos407 := Defer_Pos652;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;


--  Start tok_code

Token_Res629 := Row_Pos407;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res629));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Is)
   then
       Token_Pos629 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos407 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos407,
             Expected_Token_Id => Ada_Is,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos629 := Row_Pos407 + 1;
   end if;
end;

--  End tok_code



Row_Progress52 := 4;

if Token_Pos629 /= No_Token_Index then

   Row_Pos407 := Token_Pos629;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;


--  Start list_code

    List_Pos54 := No_Token_Index;



Lst_Cpos54 := Row_Pos407;
Tmp_List54 := Get_Parse_List (Parser);

loop
   
Defer_Res653 :=
   Variant_Transform_Parse0 (Parser, Lst_Cpos54);
Defer_Pos653 := Parser.Current_Pos;


   exit when Defer_Pos653 = No_Token_Index;

   List_Pos54 := Defer_Pos653;
   Lst_Cpos54 := List_Pos54;

   Tmp_List54.Nodes.Append (Defer_Res653);


end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List54.Nodes.Length;
begin
   List_Res54 :=
      Allocate_Variant_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos407;
      Token_End := (if Lst_Cpos54 = Row_Pos407
                    then Row_Pos407
                    else Lst_Cpos54 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos407, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res54,
      Kind              => Ada_Variant_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res54,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List54.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res54.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List54);

--  End list_code



Row_Progress52 := 5;

if List_Pos54 /= No_Token_Index then

   Row_Pos407 := List_Pos54;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;


--  Start tok_code

Token_Res630 := Row_Pos407;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res630));
begin
   if
      T.Kind /= From_Token_Kind (Ada_End)
   then
       Token_Pos630 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos407 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos407,
             Expected_Token_Id => Ada_End,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos630 := Row_Pos407 + 1;
   end if;
end;

--  End tok_code



Row_Progress52 := 6;

if Token_Pos630 /= No_Token_Index then

   Row_Pos407 := Token_Pos630;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;


--  Start tok_code

Token_Res631 := Row_Pos407;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res631));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Case)
   then
       Token_Pos631 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos407 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos407,
             Expected_Token_Id => Ada_Case,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos631 := Row_Pos407 + 1;
   end if;
end;

--  End tok_code



Row_Progress52 := 7;

if Token_Pos631 /= No_Token_Index then

   Row_Pos407 := Token_Pos631;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res632 := Row_Pos407;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res632));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos632 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos407 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos407,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos632 := Row_Pos407 + 1;
   end if;
end;

--  End tok_code


if Token_Pos632 = No_Token_Index then

         
   Token_Res632 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos407)),
                To_Text ("Missing ';'"));

       
   Token_Pos632 := Row_Pos407;



end if;

--  End opt_code



Row_Progress52 := 8;

if Token_Pos632 /= No_Token_Index then

   Row_Pos407 := Token_Pos632;

else
   Row_Pos407 := No_Token_Index;
   goto Exit_Row407_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row407_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos407 = No_Token_Index and then Nobt57 then

   Row_Pos407 := Parser.Last_Fail.Pos;

   Transform_Has_Failed52 := True;
end if;

if Row_Pos407 /= No_Token_Index then

   Transform_Res313 := Allocate_Variant_Part (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res313,
      Kind => Ada_Variant_Part,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos407 = Pos
                            then No_Token_Index
                            else Row_Pos407 - 1));

      Initialize_Fields_For_Variant_Part
        (Self => Transform_Res313, Variant_Part_F_Discr_Name => Defer_Res652, Variant_Part_F_Variant => List_Res54);

         if Defer_Res652 /= null and then Is_Incomplete (Defer_Res652) then
            Transform_Res313.Last_Attempted_Child := 0;
         elsif Defer_Res652 /= null and then not Is_Ghost (Defer_Res652) then
            Transform_Res313.Last_Attempted_Child := -1;
         end if;
         if List_Res54 /= null and then Is_Incomplete (List_Res54) then
            Transform_Res313.Last_Attempted_Child := 0;
         elsif List_Res54 /= null and then not Is_Ghost (List_Res54) then
            Transform_Res313.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed52 then
      Transform_Res313.Last_Attempted_Child :=
         Row_Progress52;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <variant_part>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos407 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags313);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.Variant_Part_Transform_Parse0_Memo,
      Row_Pos407 /= No_Token_Index,
      Transform_Res313,
      Pos,
      Row_Pos407);


   Parser.Current_Pos := Row_Pos407;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res313;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end Variant_Part_Transform_Parse0;

   


function While_Loop_Spec_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_While_Loop_Spec
is
   use Bare_While_Loop_Spec_Memos;

   Call_Depth : aliased Natural;

      Nobt58 :
            Boolean
               := False;
      Row_Pos408 :
            Token_Index
               := No_Token_Index;
      Token_Pos633 :
            Token_Index
               := No_Token_Index;
      Token_Res633 :
            Token_Index
               := No_Token_Index;
      Defer_Pos654 :
            Token_Index
               := No_Token_Index;
      Defer_Res654 :
            Bare_Expr
               := No_Bare_Ada_Node;
      Row_Progress53 :
            Integer
               := 0;
      Transform_Res314 :
            Bare_While_Loop_Spec
               := No_Bare_Ada_Node;
      Transform_Has_Failed53 :
            Boolean
               := False;
      Transform_Diags314 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.While_Loop_Spec_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res314 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res314;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res314;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags314 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos408 := Pos;



--  Start tok_code

Token_Res633 := Row_Pos408;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res633));
begin
   if
      T.Kind /= From_Token_Kind (Ada_While)
   then
       Token_Pos633 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos408 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos408,
             Expected_Token_Id => Ada_While,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos633 := Row_Pos408 + 1;
   end if;
end;

--  End tok_code



Row_Progress53 := 1;

if Token_Pos633 /= No_Token_Index then

   Row_Pos408 := Token_Pos633;

else
   Row_Pos408 := No_Token_Index;
   goto Exit_Row408_0;

end if;

Nobt58 := True;

   Nobt58 := Nobt58;

Row_Progress53 := 2;

if Row_Pos408 /= No_Token_Index then

   Row_Pos408 := Row_Pos408;

else
   Row_Pos408 := No_Token_Index;
   goto Exit_Row408_0;

end if;


Defer_Res654 :=
   Expr_Or_Parse0 (Parser, Row_Pos408);
Defer_Pos654 := Parser.Current_Pos;



Row_Progress53 := 3;

if Defer_Pos654 /= No_Token_Index then

   Row_Pos408 := Defer_Pos654;

else
   Row_Pos408 := No_Token_Index;
   goto Exit_Row408_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row408_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos408 = No_Token_Index and then Nobt58 then

   Row_Pos408 := Parser.Last_Fail.Pos;

   Transform_Has_Failed53 := True;
end if;

if Row_Pos408 /= No_Token_Index then

   Transform_Res314 := Allocate_While_Loop_Spec (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res314,
      Kind => Ada_While_Loop_Spec,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos408 = Pos
                            then No_Token_Index
                            else Row_Pos408 - 1));

      Initialize_Fields_For_While_Loop_Spec
        (Self => Transform_Res314, While_Loop_Spec_F_Expr => Defer_Res654);

         if Defer_Res654 /= null and then Is_Incomplete (Defer_Res654) then
            Transform_Res314.Last_Attempted_Child := 0;
         elsif Defer_Res654 /= null and then not Is_Ghost (Defer_Res654) then
            Transform_Res314.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed53 then
      Transform_Res314.Last_Attempted_Child :=
         Row_Progress53;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <while_loop_spec>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos408 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags314);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.While_Loop_Spec_Transform_Parse0_Memo,
      Row_Pos408 /= No_Token_Index,
      Transform_Res314,
      Pos,
      Row_Pos408);


   Parser.Current_Pos := Row_Pos408;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res314;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end While_Loop_Spec_Transform_Parse0;

   


function With_Clause_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_With_Clause
is
   use Bare_With_Clause_Memos;

   Call_Depth : aliased Natural;

      Row_Pos409 :
            Token_Index
               := No_Token_Index;
      Token_Pos634 :
            Token_Index
               := No_Token_Index;
      Token_Res634 :
            Token_Index
               := No_Token_Index;
      Opt_Res35 :
            Bare_Limited_Node
               := No_Bare_Ada_Node;
      Token_Pos635 :
            Token_Index
               := No_Token_Index;
      Token_Res635 :
            Token_Index
               := No_Token_Index;
      Opt_Res36 :
            Bare_Private_Node
               := No_Bare_Ada_Node;
      Token_Pos636 :
            Token_Index
               := No_Token_Index;
      Token_Res636 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos55 :
            Token_Index
               := No_Token_Index;
      Tmp_List55 :
            Free_Parse_List;
      Defer_Pos655 :
            Token_Index
               := No_Token_Index;
      Defer_Res655 :
            Bare_Name
               := No_Bare_Ada_Node;
      Token_Pos637 :
            Token_Index
               := No_Token_Index;
      Token_Res637 :
            Token_Index
               := No_Token_Index;
      List_Pos55 :
            Token_Index
               := No_Token_Index;
      List_Res55 :
            Bare_Name_List
               := No_Bare_Ada_Node;
      Token_Pos638 :
            Token_Index
               := No_Token_Index;
      Token_Res638 :
            Token_Index
               := No_Token_Index;
      Transform_Res315 :
            Bare_With_Clause
               := No_Bare_Ada_Node;
      Transform_Diags315 :
            Ada.Containers.Count_Type;


   M : Memo_Entry := Get (Parser.Private_Part.With_Clause_Transform_Parse0_Memo, Pos);

begin
   Enter_Call (Parser, Call_Depth'Access);

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res315 := M.Instance;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res315;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Exit_Call (Parser, Call_Depth);
      return Transform_Res315;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code

Transform_Diags315 := Parser.Diagnostics.Length;


--  Start row_code

Row_Pos409 := Pos;



--  Start opt_code












--  Start tok_code

Token_Res634 := Row_Pos409;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res634));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Limited)
   then
       Token_Pos634 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos409 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos409,
             Expected_Token_Id => Ada_Limited,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos634 := Row_Pos409 + 1;
   end if;
end;

--  End tok_code


if Token_Pos634 = No_Token_Index then

         Opt_Res35 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res35,
            Kind              => Ada_Limited_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos409,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos634 := Row_Pos409;


else

      Opt_Res35 := Allocate_Limited_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res35,
         Kind              => Ada_Limited_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos409,
         Token_End_Index   => Token_Pos634 - 1);

end if;

--  End opt_code




if Token_Pos634 /= No_Token_Index then

   Row_Pos409 := Token_Pos634;

else
   Row_Pos409 := No_Token_Index;
   goto Exit_Row409_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res635 := Row_Pos409;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res635));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Private)
   then
       Token_Pos635 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos409 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos409,
             Expected_Token_Id => Ada_Private,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos635 := Row_Pos409 + 1;
   end if;
end;

--  End tok_code


if Token_Pos635 = No_Token_Index then

         Opt_Res36 := Allocate_Private_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res36,
            Kind              => Ada_Private_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos409,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos635 := Row_Pos409;


else

      Opt_Res36 := Allocate_Private_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res36,
         Kind              => Ada_Private_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos409,
         Token_End_Index   => Token_Pos635 - 1);

end if;

--  End opt_code




if Token_Pos635 /= No_Token_Index then

   Row_Pos409 := Token_Pos635;

else
   Row_Pos409 := No_Token_Index;
   goto Exit_Row409_0;

end if;


--  Start tok_code

Token_Res636 := Row_Pos409;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res636));
begin
   if
      T.Kind /= From_Token_Kind (Ada_With)
   then
       Token_Pos636 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos409 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos409,
             Expected_Token_Id => Ada_With,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos636 := Row_Pos409 + 1;
   end if;
end;

--  End tok_code




if Token_Pos636 /= No_Token_Index then

   Row_Pos409 := Token_Pos636;

else
   Row_Pos409 := No_Token_Index;
   goto Exit_Row409_0;

end if;


--  Start list_code

    List_Pos55 := No_Token_Index;



Lst_Cpos55 := Row_Pos409;
Tmp_List55 := Get_Parse_List (Parser);

loop
   
Defer_Res655 :=
   Static_Name_Or_Parse0 (Parser, Lst_Cpos55);
Defer_Pos655 := Parser.Current_Pos;


   exit when Defer_Pos655 = No_Token_Index;

   List_Pos55 := Defer_Pos655;
   Lst_Cpos55 := List_Pos55;

   Tmp_List55.Nodes.Append (Defer_Res655);

      
--  Start tok_code

Token_Res637 := Lst_Cpos55;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res637));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Comma)
   then
       Token_Pos637 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos55 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos55,
             Expected_Token_Id => Ada_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos637 := Lst_Cpos55 + 1;
   end if;
end;

--  End tok_code

      if Token_Pos637 /= No_Token_Index then
          Lst_Cpos55 := Token_Pos637;
      else
         exit;
      end if;

end loop;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List55.Nodes.Length;
begin
   List_Res55 :=
      Allocate_Name_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos409;
      Token_End := (if Lst_Cpos55 = Row_Pos409
                    then Row_Pos409
                    else Lst_Cpos55 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos409, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res55,
      Kind              => Ada_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res55,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Ada_Node_Vectors.Vector renames
         Tmp_List55.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res55.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List55);

--  End list_code




if List_Pos55 /= No_Token_Index then

   Row_Pos409 := List_Pos55;

else
   Row_Pos409 := No_Token_Index;
   goto Exit_Row409_0;

end if;


--  Start opt_code












--  Start tok_code

Token_Res638 := Row_Pos409;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res638));
begin
   if
      T.Kind /= From_Token_Kind (Ada_Semicolon)
   then
       Token_Pos638 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos409 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos409,
             Expected_Token_Id => Ada_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos638 := Row_Pos409 + 1;
   end if;
end;

--  End tok_code


if Token_Pos638 = No_Token_Index then

         
   Token_Res638 := No_Token_Index;


        Append (Parser.Diagnostics,
                Sloc_Range (Parser.TDH.all,
                            Get_Token (Parser.TDH.all, Row_Pos409)),
                To_Text ("Missing ';'"));

       
   Token_Pos638 := Row_Pos409;



end if;

--  End opt_code




if Token_Pos638 /= No_Token_Index then

   Row_Pos409 := Token_Pos638;

else
   Row_Pos409 := No_Token_Index;
   goto Exit_Row409_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row409_0>>
pragma Warnings (On, "referenced");

--  End row_code



if Row_Pos409 /= No_Token_Index then

   Transform_Res315 := Allocate_With_Clause (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res315,
      Kind => Ada_With_Clause,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos409 = Pos
                            then No_Token_Index
                            else Row_Pos409 - 1));

      Initialize_Fields_For_With_Clause
        (Self => Transform_Res315, With_Clause_F_Has_Limited => Opt_Res35, With_Clause_F_Has_Private => Opt_Res36, With_Clause_F_Packages => List_Res55);

         if Opt_Res35 /= null and then Is_Incomplete (Opt_Res35) then
            Transform_Res315.Last_Attempted_Child := 0;
         elsif Opt_Res35 /= null and then not Is_Ghost (Opt_Res35) then
            Transform_Res315.Last_Attempted_Child := -1;
         end if;
         if Opt_Res36 /= null and then Is_Incomplete (Opt_Res36) then
            Transform_Res315.Last_Attempted_Child := 0;
         elsif Opt_Res36 /= null and then not Is_Ghost (Opt_Res36) then
            Transform_Res315.Last_Attempted_Child := -1;
         end if;
         if List_Res55 /= null and then Is_Incomplete (List_Res55) then
            Transform_Res315.Last_Attempted_Child := 0;
         elsif List_Res55 /= null and then not Is_Ghost (List_Res55) then
            Transform_Res315.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos409 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags315);
end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (Parser.Private_Part.With_Clause_Transform_Parse0_Memo,
      Row_Pos409 /= No_Token_Index,
      Transform_Res315,
      Pos,
      Row_Pos409);


   Parser.Current_Pos := Row_Pos409;

   Exit_Call (Parser, Call_Depth);
   return Transform_Res315;

exception
   when others =>
      Exit_Call (Parser, Call_Depth);
      raise;
end With_Clause_Transform_Parse0;


   -----------
   -- Reset --
   -----------

   procedure Reset (Parser : in out Parser_Type) is
      New_Parser : Parser_Type;
      --  We create this new parser instance to leverage creation of default
      --  values, so as to not repeat them.
   begin
      --  We just keep the private part, to not have to reallocate it
      New_Parser.Private_Part := Parser.Private_Part;

      --  And then reset everything else
      Parser := New_Parser;

      --  Reset the memo tables in the private part
         Bare_Abort_Stmt_Memos.Clear
           (Parser.Private_Part.Abort_Stmt_Transform_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Abstract_State_Decl_Or_Parse0_Memo);
         Bare_Abstract_Subp_Decl_Memos.Clear
           (Parser.Private_Part.Abstract_Subp_Decl_Transform_Parse0_Memo);
         Bare_Accept_Stmt_Memos.Clear
           (Parser.Private_Part.Accept_Stmt_Or_Parse0_Memo);
         Bare_Access_Def_Memos.Clear
           (Parser.Private_Part.Access_Def_Or_Parse0_Memo);
         Bare_Basic_Assoc_Memos.Clear
           (Parser.Private_Part.Aggregate_Assoc_Or_Parse1_Memo);
         Bare_Base_Aggregate_Memos.Clear
           (Parser.Private_Part.Aggregate_Or_Parse0_Memo);
         Bare_Allocator_Memos.Clear
           (Parser.Private_Part.Allocator_Transform_Parse0_Memo);
         Bare_Anonymous_Type_Decl_Memos.Clear
           (Parser.Private_Part.Anonymous_Type_Decl_Transform_Parse0_Memo);
         Bare_Anonymous_Type_Memos.Clear
           (Parser.Private_Part.Anonymous_Type_Transform_Parse0_Memo);
         Bare_Array_Type_Def_Memos.Clear
           (Parser.Private_Part.Array_Type_Def_Transform_Parse2_Memo);
         Bare_Aspect_Assoc_Memos.Clear
           (Parser.Private_Part.Aspect_Assoc_Or_Parse2_Memo);
         Bare_Aspect_Clause_Memos.Clear
           (Parser.Private_Part.Aspect_Clause_Or_Parse1_Memo);
         Bare_Aspect_Spec_Memos.Clear
           (Parser.Private_Part.Aspect_Spec_Opt_Parse0_Memo);
         Bare_Assign_Stmt_Memos.Clear
           (Parser.Private_Part.Assignment_Stmt_Transform_Parse0_Memo);
         Bare_Assoc_List_Memos.Clear
           (Parser.Private_Part.Attr_Suffix_List_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Basic_Decl_Or_Parse0_Memo);
         Bare_Ada_Node_List_Memos.Clear
           (Parser.Private_Part.Basic_Decls_List_Parse0_Memo);
         Bare_Composite_Stmt_Memos.Clear
           (Parser.Private_Part.Block_Stmt_Or_Parse0_Memo);
         Bare_Body_Node_Memos.Clear
           (Parser.Private_Part.Body_Or_Parse0_Memo);
         Bare_Body_Stub_Memos.Clear
           (Parser.Private_Part.Body_Stub_Or_Parse0_Memo);
         Bare_Op_Memos.Clear
           (Parser.Private_Part.Boolean_Op_Or_Parse0_Memo);
         Bare_Box_Expr_Memos.Clear
           (Parser.Private_Part.Box_Expr_Transform_Parse0_Memo);
         Bare_Base_Aggregate_Memos.Clear
           (Parser.Private_Part.Bracket_Aggregate_Or_Parse0_Memo);
         Bare_Call_Stmt_Memos.Clear
           (Parser.Private_Part.Call_Stmt_Transform_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Call_Suffix_Or_Parse0_Memo);
         Bare_Case_Stmt_Alternative_Memos.Clear
           (Parser.Private_Part.Case_Alt_Transform_Parse0_Memo);
         Bare_Case_Expr_Alternative_Memos.Clear
           (Parser.Private_Part.Case_Expr_Alt_Transform_Parse0_Memo);
         Bare_Case_Expr_Memos.Clear
           (Parser.Private_Part.Case_Expr_Transform_Parse0_Memo);
         Bare_Case_Stmt_Memos.Clear
           (Parser.Private_Part.Case_Stmt_Transform_Parse0_Memo);
         Bare_Char_Literal_Memos.Clear
           (Parser.Private_Part.Char_Literal_Transform_Parse0_Memo);
         Bare_Alternatives_List_Memos.Clear
           (Parser.Private_Part.Choice_List_List_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Choice_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Compilation_Or_Parse0_Memo);
         Bare_Compilation_Unit_Memos.Clear
           (Parser.Private_Part.Compilation_Unit_Transform_Parse0_Memo);
         Bare_Component_Clause_Memos.Clear
           (Parser.Private_Part.Component_Clause_Transform_Parse0_Memo);
         Bare_Component_Decl_Memos.Clear
           (Parser.Private_Part.Component_Decl_Transform_Parse0_Memo);
         Bare_Component_Def_Memos.Clear
           (Parser.Private_Part.Component_Def_Transform_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Component_Item_Or_Parse0_Memo);
         Bare_Component_List_Memos.Clear
           (Parser.Private_Part.Component_List_Transform_Parse0_Memo);
         Bare_Composite_Constraint_Assoc_Memos.Clear
           (Parser.Private_Part.Composite_Constraint_Assoc_Transform_Parse0_Memo);
         Bare_Composite_Constraint_Memos.Clear
           (Parser.Private_Part.Composite_Constraint_Transform_Parse0_Memo);
         Bare_Composite_Stmt_Memos.Clear
           (Parser.Private_Part.Compound_Stmt_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Conditional_Expr_Or_Parse0_Memo);
         Bare_Constrained_Subtype_Indication_Memos.Clear
           (Parser.Private_Part.Constrained_Subtype_Indication_Transform_Parse0_Memo);
         Bare_Constraint_List_Memos.Clear
           (Parser.Private_Part.Constraint_List_List_Parse0_Memo);
         Bare_Constraint_Memos.Clear
           (Parser.Private_Part.Constraint_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Context_Item_Or_Parse0_Memo);
         Bare_Contract_Case_Assoc_Memos.Clear
           (Parser.Private_Part.Contract_Case_Assoc_Transform_Parse0_Memo);
         Bare_Contract_Cases_Memos.Clear
           (Parser.Private_Part.Contract_Cases_Expr_Transform_Parse0_Memo);
         Bare_Real_Literal_Memos.Clear
           (Parser.Private_Part.Dec_Literal_Transform_Parse0_Memo);
         Bare_Decimal_Fixed_Point_Def_Memos.Clear
           (Parser.Private_Part.Decimal_Fixed_Point_Def_Transform_Parse0_Memo);
         Bare_Declarative_Part_Memos.Clear
           (Parser.Private_Part.Decl_Part_Transform_Parse0_Memo);
         Bare_Decl_Expr_Memos.Clear
           (Parser.Private_Part.Declare_Expr_Transform_Parse0_Memo);
         Bare_Defining_Name_List_Memos.Clear
           (Parser.Private_Part.Defining_Id_List_List_Parse0_Memo);
         Bare_Defining_Name_Memos.Clear
           (Parser.Private_Part.Defining_Id_Transform_Parse0_Memo);
         Bare_Defining_Name_Memos.Clear
           (Parser.Private_Part.Defining_Name_Transform_Parse0_Memo);
         Bare_Delay_Stmt_Memos.Clear
           (Parser.Private_Part.Delay_Stmt_Transform_Parse0_Memo);
         Bare_Delta_Constraint_Memos.Clear
           (Parser.Private_Part.Delta_Constraint_Transform_Parse0_Memo);
         Bare_Derived_Type_Def_Memos.Clear
           (Parser.Private_Part.Derived_Type_Def_Transform_Parse0_Memo);
         Bare_Digits_Constraint_Memos.Clear
           (Parser.Private_Part.Digits_Constraint_Transform_Parse0_Memo);
         Bare_Base_Id_Memos.Clear
           (Parser.Private_Part.Direct_Name_Or_Parse0_Memo);
         Bare_Name_Memos.Clear
           (Parser.Private_Part.Direct_Name_Or_Target_Name_Or_Parse0_Memo);
         Bare_Discriminant_Spec_List_Memos.Clear
           (Parser.Private_Part.Discr_Spec_List_List_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Discrete_Range_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Discrete_Subtype_Definition_Or_Parse0_Memo);
         Bare_Discrete_Subtype_Indication_Memos.Clear
           (Parser.Private_Part.Discrete_Subtype_Indication_Transform_Parse0_Memo);
         Bare_Discriminant_Part_Memos.Clear
           (Parser.Private_Part.Discriminant_Part_Or_Parse0_Memo);
         Bare_Discriminant_Spec_Memos.Clear
           (Parser.Private_Part.Discriminant_Spec_Transform_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Case_Alt0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Elsif_Part0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Exception_Handler0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Generic_Decl0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Generic_Decl1_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Handled_Stmts0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_If_Stmt0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_If_Stmt1_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Iloop_Stmt0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Iloop_Stmt1_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Iloop_Stmt2_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Package_Body0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Package_Decl0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Package_Decl1_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Protected_Body0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Recov_Decl_Part0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Select_Stmt0_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Select_Stmt1_Extract_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Dontskip_Select_Stmt2_Extract_Parse0_Memo);
         Bare_Elsif_Stmt_Part_Memos.Clear
           (Parser.Private_Part.Elsif_Part_Transform_Parse0_Memo);
         Bare_Entry_Body_Memos.Clear
           (Parser.Private_Part.Entry_Body_Transform_Parse3_Memo);
         Bare_Entry_Decl_Memos.Clear
           (Parser.Private_Part.Entry_Decl_Transform_Parse1_Memo);
         Bare_Enum_Literal_Decl_Memos.Clear
           (Parser.Private_Part.Enum_Literal_Decl_Transform_Parse1_Memo);
         Bare_Enum_Type_Def_Memos.Clear
           (Parser.Private_Part.Enum_Type_Def_Transform_Parse0_Memo);
         Bare_Exception_Decl_Memos.Clear
           (Parser.Private_Part.Exception_Decl_Transform_Parse0_Memo);
         Bare_Exception_Handler_Memos.Clear
           (Parser.Private_Part.Exception_Handler_Transform_Parse0_Memo);
         Bare_Exit_Stmt_Memos.Clear
           (Parser.Private_Part.Exit_Stmt_Transform_Parse0_Memo);
         Bare_Expr_Function_Memos.Clear
           (Parser.Private_Part.Expr_Fn_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Expr_Or_Parse0_Memo);
         Bare_Extended_Return_Stmt_Object_Decl_Memos.Clear
           (Parser.Private_Part.Ext_Ret_Stmt_Object_Decl_Transform_Parse0_Memo);
         Bare_Extended_Return_Stmt_Memos.Clear
           (Parser.Private_Part.Ext_Return_Stmt_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Factor_Or_Parse1_Memo);
         Bare_Floating_Point_Def_Memos.Clear
           (Parser.Private_Part.Floating_Point_Def_Transform_Parse0_Memo);
         Bare_For_Loop_Spec_Memos.Clear
           (Parser.Private_Part.For_Loop_Param_Spec_Transform_Parse3_Memo);
         Bare_Formal_Discrete_Type_Def_Memos.Clear
           (Parser.Private_Part.Formal_Discrete_Type_Def_Transform_Parse0_Memo);
         Bare_Formal_Subp_Decl_Memos.Clear
           (Parser.Private_Part.Formal_Subp_Decl_Or_Parse2_Memo);
         Bare_Base_Type_Decl_Memos.Clear
           (Parser.Private_Part.Formal_Type_Decl_Or_Parse1_Memo);
         Bare_Generic_Decl_Memos.Clear
           (Parser.Private_Part.Generic_Decl_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Generic_Formal_Decl_Or_Parse0_Memo);
         Bare_Generic_Formal_Part_Memos.Clear
           (Parser.Private_Part.Generic_Formal_Part_Transform_Parse0_Memo);
         Bare_Generic_Instantiation_Memos.Clear
           (Parser.Private_Part.Generic_Instantiation_Or_Parse1_Memo);
         Bare_Generic_Renaming_Decl_Memos.Clear
           (Parser.Private_Part.Generic_Renaming_Decl_Or_Parse1_Memo);
         Bare_Goto_Stmt_Memos.Clear
           (Parser.Private_Part.Goto_Stmt_Transform_Parse0_Memo);
         Bare_Handled_Stmts_Memos.Clear
           (Parser.Private_Part.Handled_Stmts_Transform_Parse0_Memo);
         Bare_Block_Stmt_Memos.Clear
           (Parser.Private_Part.Iblock_Stmt_Or_Parse0_Memo);
         Bare_Identifier_Memos.Clear
           (Parser.Private_Part.Identifier_Transform_Parse0_Memo);
         Bare_If_Expr_Memos.Clear
           (Parser.Private_Part.If_Expr_Transform_Parse1_Memo);
         Bare_If_Stmt_Memos.Clear
           (Parser.Private_Part.If_Stmt_Transform_Parse0_Memo);
         Bare_Base_Loop_Stmt_Memos.Clear
           (Parser.Private_Part.Iloop_Stmt_Or_Parse0_Memo);
         Bare_Incomplete_Type_Decl_Memos.Clear
           (Parser.Private_Part.Incomplete_Type_Decl_Or_Parse0_Memo);
         Bare_Int_Literal_Memos.Clear
           (Parser.Private_Part.Int_Literal_Transform_Parse0_Memo);
         Bare_Interface_Type_Def_Memos.Clear
           (Parser.Private_Part.Interface_Type_Def_Transform_Parse4_Memo);
         Bare_Iterated_Assoc_Memos.Clear
           (Parser.Private_Part.Iterated_Assoc_Transform_Parse0_Memo);
         Bare_Label_Memos.Clear
           (Parser.Private_Part.Label_Transform_Parse1_Memo);
         Bare_Library_Item_Memos.Clear
           (Parser.Private_Part.Library_Item_Transform_Parse1_Memo);
         Bare_Body_Node_Memos.Clear
           (Parser.Private_Part.Library_Unit_Body_Or_Parse0_Memo);
         Bare_Basic_Decl_Memos.Clear
           (Parser.Private_Part.Library_Unit_Renaming_Decl_Or_Parse0_Memo);
         Bare_Composite_Stmt_Memos.Clear
           (Parser.Private_Part.Loop_Stmt_Or_Parse0_Memo);
         Bare_Expr_Alternatives_List_Memos.Clear
           (Parser.Private_Part.Membership_Choice_List_List_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Membership_Choice_Or_Parse0_Memo);
         Bare_Mod_Int_Type_Def_Memos.Clear
           (Parser.Private_Part.Mod_Int_Type_Def_Transform_Parse0_Memo);
         Bare_Mode_Memos.Clear
           (Parser.Private_Part.Mode_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Multi_Abstract_State_Decl_Or_Parse0_Memo);
         Bare_Multi_Dim_Array_Assoc_Memos.Clear
           (Parser.Private_Part.Multidim_Array_Assoc_Transform_Parse0_Memo);
         Bare_Name_Memos.Clear
           (Parser.Private_Part.Name_Or_Parse2_Memo);
         Bare_No_Type_Object_Renaming_Decl_Memos.Clear
           (Parser.Private_Part.No_Type_Object_Renaming_Decl_Transform_Parse0_Memo);
         Bare_Null_Literal_Memos.Clear
           (Parser.Private_Part.Null_Literal_Transform_Parse0_Memo);
         Bare_Null_Stmt_Memos.Clear
           (Parser.Private_Part.Null_Stmt_Transform_Parse0_Memo);
         Bare_Null_Subp_Decl_Memos.Clear
           (Parser.Private_Part.Null_Subp_Decl_Transform_Parse0_Memo);
         Bare_Num_Literal_Memos.Clear
           (Parser.Private_Part.Num_Literal_Or_Parse0_Memo);
         Bare_Number_Decl_Memos.Clear
           (Parser.Private_Part.Number_Decl_Transform_Parse0_Memo);
         Bare_Basic_Decl_Memos.Clear
           (Parser.Private_Part.Object_Decl_Or_Parse0_Memo);
         Bare_Ordinary_Fixed_Point_Def_Memos.Clear
           (Parser.Private_Part.Ordinary_Fixed_Point_Def_Transform_Parse0_Memo);
         Bare_Others_Designator_Memos.Clear
           (Parser.Private_Part.Others_Designator_Transform_Parse0_Memo);
         Bare_Overriding_Node_Memos.Clear
           (Parser.Private_Part.Overriding_Indicator_Or_Parse0_Memo);
         Bare_Package_Body_Stub_Memos.Clear
           (Parser.Private_Part.Package_Body_Stub_Transform_Parse0_Memo);
         Bare_Package_Body_Memos.Clear
           (Parser.Private_Part.Package_Body_Transform_Parse1_Memo);
         Bare_Package_Decl_Memos.Clear
           (Parser.Private_Part.Package_Decl_Transform_Parse3_Memo);
         Bare_Package_Renaming_Decl_Memos.Clear
           (Parser.Private_Part.Package_Renaming_Decl_Transform_Parse0_Memo);
         Bare_Param_Assoc_Memos.Clear
           (Parser.Private_Part.Param_Assoc_Transform_Parse0_Memo);
         Bare_Param_Spec_Memos.Clear
           (Parser.Private_Part.Param_Spec_Transform_Parse0_Memo);
         Bare_Params_Memos.Clear
           (Parser.Private_Part.Param_Specs_Transform_Parse0_Memo);
         Bare_Paren_Expr_Memos.Clear
           (Parser.Private_Part.Paren_Expr_Transform_Parse0_Memo);
         Bare_Parent_List_Memos.Clear
           (Parser.Private_Part.Parent_List_List_Parse0_Memo);
         Bare_Pp_Directive_Memos.Clear
           (Parser.Private_Part.Pp_Directive_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Pp_Expr_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Pp_Term_Or_Parse2_Memo);
         Bare_Pp_Then_Kw_Memos.Clear
           (Parser.Private_Part.Pp_Then_Opt_Parse0_Memo);
         Bare_Pragma_Argument_Assoc_Memos.Clear
           (Parser.Private_Part.Pragma_Argument_Transform_Parse1_Memo);
         Bare_Pragma_Node_Memos.Clear
           (Parser.Private_Part.Pragma_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Primary_Or_Parse0_Memo);
         Bare_Protected_Body_Stub_Memos.Clear
           (Parser.Private_Part.Protected_Body_Stub_Transform_Parse0_Memo);
         Bare_Protected_Body_Memos.Clear
           (Parser.Private_Part.Protected_Body_Transform_Parse1_Memo);
         Bare_Single_Protected_Decl_Memos.Clear
           (Parser.Private_Part.Protected_Decl_Transform_Parse0_Memo);
         Bare_Protected_Def_Memos.Clear
           (Parser.Private_Part.Protected_Def_Transform_Parse3_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Protected_El_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Protected_Op_Or_Parse0_Memo);
         Bare_Protected_Type_Decl_Memos.Clear
           (Parser.Private_Part.Protected_Type_Decl_Transform_Parse0_Memo);
         Bare_Name_Memos.Clear
           (Parser.Private_Part.Qual_Name_Internal_Or_Parse0_Memo);
         Bare_Qual_Expr_Memos.Clear
           (Parser.Private_Part.Qualified_Name_Transform_Parse0_Memo);
         Bare_Quantified_Expr_Memos.Clear
           (Parser.Private_Part.Quantified_Expr_Transform_Parse2_Memo);
         Bare_Raise_Expr_Memos.Clear
           (Parser.Private_Part.Raise_Expr_Or_Parse0_Memo);
         Bare_Raise_Stmt_Memos.Clear
           (Parser.Private_Part.Raise_Stmt_Or_Parse0_Memo);
         Bare_Range_Constraint_Memos.Clear
           (Parser.Private_Part.Range_Constraint_Transform_Parse1_Memo);
         Bare_Range_Spec_Memos.Clear
           (Parser.Private_Part.Range_Spec_Transform_Parse0_Memo);
         Bare_Real_Type_Def_Memos.Clear
           (Parser.Private_Part.Real_Type_Def_Or_Parse0_Memo);
         Bare_Base_Record_Def_Memos.Clear
           (Parser.Private_Part.Record_Def_Or_Parse0_Memo);
         Bare_Record_Type_Def_Memos.Clear
           (Parser.Private_Part.Record_Type_Def_Transform_Parse0_Memo);
         Bare_Declarative_Part_Memos.Clear
           (Parser.Private_Part.Recov_Decl_Part_Dont_Skip_Parse0_Memo);
         Bare_Base_Aggregate_Memos.Clear
           (Parser.Private_Part.Regular_Aggregate_Or_Parse0_Memo);
         Bare_Op_Memos.Clear
           (Parser.Private_Part.Rel_Op_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Relation_Or_Parse1_Memo);
         Bare_Renaming_Clause_Memos.Clear
           (Parser.Private_Part.Renaming_Clause_Transform_Parse0_Memo);
         Bare_Requeue_Stmt_Memos.Clear
           (Parser.Private_Part.Requeue_Stmt_Transform_Parse0_Memo);
         Bare_Return_Stmt_Memos.Clear
           (Parser.Private_Part.Return_Stmt_Transform_Parse0_Memo);
         Bare_Select_Stmt_Memos.Clear
           (Parser.Private_Part.Select_Stmt_Transform_Parse1_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Sexpr_Or_Box_Or_Parse0_Memo);
         Bare_Signed_Int_Type_Def_Memos.Clear
           (Parser.Private_Part.Signed_Int_Type_Def_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Simple_Expr_Or_Parse1_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Simple_Stmt_Or_Parse0_Memo);
         Bare_Subp_Decl_Memos.Clear
           (Parser.Private_Part.Simple_Subp_Decl_Transform_Parse0_Memo);
         Bare_Single_Task_Decl_Memos.Clear
           (Parser.Private_Part.Single_Task_Decl_Transform_Parse1_Memo);
         Bare_Name_Memos.Clear
           (Parser.Private_Part.Static_Name_Or_Parse0_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Stmt_Or_Parse0_Memo);
         Bare_Stmt_List_Memos.Clear
           (Parser.Private_Part.Stmts_List_Parse0_Memo);
         Bare_String_Literal_Memos.Clear
           (Parser.Private_Part.String_Literal_Transform_Parse0_Memo);
         Bare_Object_Decl_Memos.Clear
           (Parser.Private_Part.Sub_Object_Decl_Transform_Parse0_Memo);
         Bare_Subp_Body_Stub_Memos.Clear
           (Parser.Private_Part.Subp_Body_Stub_Transform_Parse0_Memo);
         Bare_Subp_Body_Memos.Clear
           (Parser.Private_Part.Subp_Body_Transform_Parse1_Memo);
         Bare_Basic_Decl_Memos.Clear
           (Parser.Private_Part.Subp_Decl_Or_Parse0_Memo);
         Bare_Subp_Renaming_Decl_Memos.Clear
           (Parser.Private_Part.Subp_Renaming_Decl_Transform_Parse0_Memo);
         Bare_Subp_Spec_Memos.Clear
           (Parser.Private_Part.Subp_Spec_Transform_Parse2_Memo);
         Bare_Subtype_Decl_Memos.Clear
           (Parser.Private_Part.Subtype_Decl_Transform_Parse0_Memo);
         Bare_Subtype_Indication_Memos.Clear
           (Parser.Private_Part.Subtype_Indication_Transform_Parse0_Memo);
         Bare_Name_Memos.Clear
           (Parser.Private_Part.Subtype_Name_Or_Parse0_Memo);
         Bare_Subunit_Memos.Clear
           (Parser.Private_Part.Subunit_Transform_Parse0_Memo);
         Bare_Target_Name_Memos.Clear
           (Parser.Private_Part.Target_Name_Transform_Parse0_Memo);
         Bare_Task_Body_Stub_Memos.Clear
           (Parser.Private_Part.Task_Body_Stub_Transform_Parse0_Memo);
         Bare_Task_Body_Memos.Clear
           (Parser.Private_Part.Task_Body_Transform_Parse1_Memo);
         Bare_Task_Def_Memos.Clear
           (Parser.Private_Part.Task_Def_Transform_Parse3_Memo);
         Bare_Ada_Node_Memos.Clear
           (Parser.Private_Part.Task_Item_Or_Parse0_Memo);
         Bare_Task_Type_Decl_Memos.Clear
           (Parser.Private_Part.Task_Type_Decl_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Term_Or_Parse1_Memo);
         Bare_Terminate_Alternative_Memos.Clear
           (Parser.Private_Part.Terminate_Alternative_Transform_Parse0_Memo);
         Bare_Base_Type_Decl_Memos.Clear
           (Parser.Private_Part.Type_Decl_Or_Parse1_Memo);
         Bare_Type_Def_Memos.Clear
           (Parser.Private_Part.Type_Def_Or_Parse0_Memo);
         Bare_Type_Expr_Memos.Clear
           (Parser.Private_Part.Type_Expr_Or_Parse0_Memo);
         Bare_Unconstrained_Array_Index_Memos.Clear
           (Parser.Private_Part.Unconstrained_Index_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear
           (Parser.Private_Part.Unop_Term_Or_Parse1_Memo);
         Bare_Base_Aggregate_Memos.Clear
           (Parser.Private_Part.Update_Attr_Aggregate_Or_Parse0_Memo);
         Bare_Assoc_List_Memos.Clear
           (Parser.Private_Part.Update_Attr_Content_List_Parse0_Memo);
         Bare_Use_Clause_Memos.Clear
           (Parser.Private_Part.Use_Clause_Or_Parse0_Memo);
         Bare_Use_Package_Clause_Memos.Clear
           (Parser.Private_Part.Use_Package_Clause_Transform_Parse0_Memo);
         Bare_Use_Type_Clause_Memos.Clear
           (Parser.Private_Part.Use_Type_Clause_Transform_Parse0_Memo);
         Bare_Value_Sequence_Memos.Clear
           (Parser.Private_Part.Value_Sequence_Transform_Parse0_Memo);
         Bare_Variant_Part_Memos.Clear
           (Parser.Private_Part.Variant_Part_Transform_Parse0_Memo);
         Bare_Variant_Memos.Clear
           (Parser.Private_Part.Variant_Transform_Parse0_Memo);
         Bare_While_Loop_Spec_Memos.Clear
           (Parser.Private_Part.While_Loop_Spec_Transform_Parse0_Memo);
         Bare_With_Clause_Memos.Clear
           (Parser.Private_Part.With_Clause_Transform_Parse0_Memo);
   end Reset;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Parser : in out Parser_Type) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Parser_Private_Part_Type, Parser_Private_Part);
      procedure Free is new Ada.Unchecked_Deallocation
        (Free_Parse_List_Record, Free_Parse_List);

      Cur : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
   begin
      while Cur /= null loop
         declare
            Next : constant Free_Parse_List := Cur.Next;
         begin
            Cur.Nodes.Destroy;
            Free (Cur);
            Cur := Next;
         end;
      end loop;
      Free (Parser.Private_Part);
   end Destroy;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize (Parser : in out Parser_Type) is
   begin
      Parser.Private_Part := new Parser_Private_Part_Type'(others => <>);
   end Initialize;

   --------------------
   -- Get_Parse_List --
   --------------------

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List is
      Lists  : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
      Result : Free_Parse_List;
   begin
      if Lists = null then
         Result := new Free_Parse_List_Record;

      else
         Result := Lists;
         Lists := Lists.Next;
      end if;

      return Result;
   end Get_Parse_List;

   ------------------------
   -- Release_Parse_List --
   ------------------------

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List)
   is
      Lists  : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
   begin
      List.Nodes.Clear;
      List.Next := Lists;
      Lists := List;
      List := null;
   end Release_Parse_List;

   ----------------
   -- Enter_Call --
   ----------------

   procedure Enter_Call (Parser : Parser_Type; Call_Depth : access Natural) is
   begin
      Enter_Call (Parser.Unit.Context, Call_Depth);
   end Enter_Call;

   ---------------
   -- Exit_Call --
   ---------------

   procedure Exit_Call (Parser : Parser_Type; Call_Depth : Natural) is
   begin
      Exit_Call (Parser.Unit.Context, Call_Depth);
   end Exit_Call;

end Libadalang.Parsers;
